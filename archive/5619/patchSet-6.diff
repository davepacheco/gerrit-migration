From a5f68dc6218ed63e77b0cd5175c9cecd1c3ed3e1 Mon Sep 17 00:00:00 2001
From: Josh Wilsdon <jwilsdon@joyent.com>
Date: Wed, 6 Mar 2019 10:58:21 -0800
Subject: [PATCH] TRITON-1217 "sysinfo-refresh" doesn't need to worry about
 NICs and aggregations anymore

---
 Makefile                             |    1 -
 docs/index.md                        |    8 +-
 docs/static.md                       |    1 -
 lib/app.js                           |  912 ++-------------
 lib/endpoints/allocations.js         |   59 +-
 lib/endpoints/images.js              |    3 +-
 lib/endpoints/index.js               |   43 +-
 lib/endpoints/nics.js                |    7 +-
 lib/endpoints/servers.js             |  657 ++++++-----
 lib/endpoints/ur.js                  |    1 -
 lib/endpoints/vms.js                 |   48 +-
 lib/endpoints/waitlist.js            |    3 +-
 lib/endpoints/zfs.js                 |    3 +-
 lib/models/image.js                  |    3 +-
 lib/models/server.js                 | 1530 ++++++++++++++------------
 lib/models/vm.js                     |   16 +-
 lib/ur.js                            |  104 +-
 lib/workflows/server-setup.js        |   11 +-
 lib/workflows/server-sysinfo.js      |  640 -----------
 package.json                         |    4 +-
 share/inspect-server.sh              |   81 --
 test/lib/mock.js                     |   25 +-
 test/model/test-model-platform.js    |    2 +-
 test/model/test-model-server.js      |  200 ++--
 test/test-servers.js                 |   11 +-
 test/test-workflow-server-sysinfo.js |  525 ---------
 tools/jsl.node.conf                  |    1 +
 27 files changed, 1464 insertions(+), 3435 deletions(-)
 delete mode 100644 lib/workflows/server-sysinfo.js
 delete mode 100644 share/inspect-server.sh
 delete mode 100644 test/test-workflow-server-sysinfo.js

diff --git a/Makefile b/Makefile
index 13afdd3..4cad77c 100644
--- a/Makefile
+++ b/Makefile
@@ -128,7 +128,6 @@ release: all deps docs $(SMF_MANIFESTS)
 		$(ROOT)/sapi_manifests \
 		$(ROOT)/smf \
 		$(ROOT)/test \
-		$(ROOT)/share \
 		$(ROOT)/tools \
 		$(RELSTAGEDIR)/root/opt/smartdc/cnapi/
 	mkdir -p $(RELSTAGEDIR)/root/opt/smartdc/boot
diff --git a/docs/index.md b/docs/index.md
index 07a2880..ba1c6db 100644
--- a/docs/index.md
+++ b/docs/index.md
@@ -601,7 +601,6 @@ A CNAPI server record looks like the following
 | **memory_available_bytes**           |                  |
 | **memory_provisionable_bytes**       |                  |
 | **memory_total_bytes**               |                  |
-| **overprovision_ratio**              |                  |
 | **overprovision_ratios**             |                  |
 | **rack_identifier**                  |                  |
 | **ram**                              | *Number*         | Amount of ram                                                              |
@@ -1303,7 +1302,12 @@ use will not be supported and may break in the future.
 | 500  | None | Error while processing request |
 
 
-## ServerSysinfoRefresh (POST /servers/:server_uuid/sysinfo-refresh)
+## ServerSysinfoRefresh (deprecated) (POST /servers/:server_uuid/sysinfo-refresh)
+
+*IMPORTANT: This endpoint is deprecated and will be removed in a future
+release. It exists only for backward compatibility and should not be used for
+any new development. As of version 2.9.0, cn-agent will keep the sysinfo
+up-to-date, so there's no need to call this.*
 
 Fetch a given server's sysinfo values and store them in the server object.
 
diff --git a/docs/static.md b/docs/static.md
index 5271d94..d5c0674 100644
--- a/docs/static.md
+++ b/docs/static.md
@@ -568,7 +568,6 @@ A CNAPI server record looks like the following
 | **memory_available_bytes**           |                  |
 | **memory_provisionable_bytes**       |                  |
 | **memory_total_bytes**               |                  |
-| **overprovision_ratio**              |                  |
 | **overprovision_ratios**             |                  |
 | **rack_identifier**                  |                  |
 | **ram**                              | *Number*         | Amount of ram                                                              |
diff --git a/lib/app.js b/lib/app.js
index 5d28bff..564e574 100644
--- a/lib/app.js
+++ b/lib/app.js
@@ -12,19 +12,13 @@
  * This is where the core of CNAPI abstractions and logic is defined.
  */
 
-
 var assert = require('assert-plus');
 var async = require('async');
 var crypto = require('crypto');
-var deepEqual = require('deep-equal');
 var execFile = require('child_process').execFile;
-var fs = require('fs');
 var http = require('http');
 var https = require('https');
 var VError = require('verror');
-var Logger = require('bunyan');
-var restify = require('restify');
-var sdcClients = require('sdc-clients');
 var sprintf = require('sprintf').sprintf;
 var util = require('util');
 var once = require('once');
@@ -50,7 +44,7 @@ var Workflow = require('./apis/workflow');
 
 var TASK_CLEANUP_MAX_AGE = 30 * 24 * 60 * 60;
 var TASK_CLEANUP_PERIOD = 60 * 60;
-var SYSINFO_PERIOD = 60;
+var UNSETUP_UR_SYSINFO_TIMEOUT_SECONDS = 90;
 
 
 
@@ -64,13 +58,10 @@ function App(config, opts) {
     self.config = config;
     self.log = opts.log;
 
-    self.serversNeedSysinfo = {};
-
     self.cnapi_instance = os.hostname();
 
     self.log.info({ config: config }, 'cnapi config');
     self.config.log = self.log;
-    self.collectedGlobalSysinfo = false;
     self.metricsManager = opts.metricsManager;
     self.taskCallbacks = {};
 
@@ -87,6 +78,9 @@ function App(config, opts) {
         cb();
     });
 
+    // Will store info about unsetup servers so we know when they are running.
+    self.unsetupServers = {};
+
     ModelBase.init(self);
     ModelImage.init(self);
     ModelPlatform.init(self);
@@ -129,9 +123,7 @@ function App(config, opts) {
  * - setup workflows
  * - broadcast request for information from all servers
  *
- * Once connected to all of the above we may:
- * - Begin listening for heartbeats
- * - Request sysinfo for compute nodes via Ur
+ * Once connected to all of the above we begin listening for heartbeats.
  */
 
 App.prototype.start = function () {
@@ -200,44 +192,6 @@ App.prototype.start = function () {
 };
 
 
-
-App.prototype.startSysinfoChecker = function () {
-    var self = this;
-
-    setInterval(function () {
-        var uuid;
-        for (uuid in self.serversNeedSysinfo) {
-            updateSysinfo(uuid);
-        }
-        self.serversNeedSysinfo = {};
-    }, 60000);
-
-    function updateSysinfo(uuid) {
-        ModelServer.getUr().serverSysinfo(
-            uuid,
-            { timeoutSeconds: 10 },
-            function (sysinfoerror, sysinfo) {
-                if (sysinfoerror) {
-                    self.log.error({ err: sysinfoerror },
-                        'error fetching sysinfo');
-                    return;
-                }
-
-                self.log.info({ sysinfo: sysinfo }, 'received sysinfo');
-
-                self.refreshServerFromSysinfo(sysinfo, function (error) {
-                    if (error) {
-                        self.log.error({ err: error },
-                            'refreshing server sysinfo');
-                        return;
-                    }
-                    self.log.info('Successfully modified sysinfo in moray');
-                });
-        });
-    }
-};
-
-
 App.prototype.startTaskCleaner = function (uuid) {
     var self = this;
 
@@ -272,14 +226,6 @@ App.prototype.startTaskCleaner = function (uuid) {
     }
 };
 
-/**
- * Mark a server as needing to have sysinfo looked up
- */
-
-App.prototype.needSysinfoFromServer = function (uuid) {
-    var self = this;
-    self.serversNeedSysinfo[uuid] = true;
-};
 
 /**
  * This will start our HTTP service and allow us to respond to HTTP requests.
@@ -317,7 +263,6 @@ App.prototype.initializeConnections = function (callback) {
     self.setupServerHeartbeatReconciler();
 
     self.setupAmqpClient();
-    self.startSysinfoChecker();
     self.startTaskCleaner();
 
     callback();
@@ -408,10 +353,6 @@ App.prototype.setupAmqpClient = function () {
 
             self.ur.useConnection(self.amqpConnection);
             self.ur.bindQueues();
-
-            self.collectGlobalSysinfo(function () {
-                self.collectedGlobalSysinfo = true;
-            });
         });
     });
 
@@ -437,7 +378,6 @@ App.prototype.setupWorkflowClient = function () {
         workflows: [
             'server-setup',
             'server-factory-reset',
-            'server-sysinfo',
             'server-reboot',
             'server-update-nics'
         ],
@@ -490,788 +430,122 @@ App.prototype.setupMorayClient = function () {
 };
 
 
-App.prototype.onVmsUpdate = function (uuid, vmsUpdate, callback) {
-    var self = this;
-
-    self.log.trace(vmsUpdate, 'vms update');
-    if (!callback) {
-        callback = function () {};
-    }
-
-    if (! vmsUpdate.vms) {
-        vmsUpdate.vms = [];
-    }
-
-    self.log.trace('VMs update (%s) received -- %d zones.',
-        uuid, Object.keys(vmsUpdate.vms).length);
-
-    if (!self.moray.connected) {
-        self.log.warn(
-            'cannot refresh server from VMs update: cannot reach moray');
-        callback();
-        return;
-    }
-
-    ModelServer.get(uuid, function (err, server, serverobj) {
-        if (err) {
-            self.log.error({ err: err, uuid: uuid },
-              'could not look up server in moray');
-            callback();
-            return;
-        }
-
-        if ((!serverobj || !serverobj.sysinfo) &&
-            !self.collectedGlobalSysinfo)
-        {
-            callback();
-            return;
-        }
-
-        server.updateFromVmsUpdate(
-            vmsUpdate,
-            function (updateError) {
-                if (updateError) {
-                    self.log.error(
-                        new VError(
-                        updateError,
-                        'updating server record with VMs update'));
-                    return;
-                }
-
-                callback();
-            });
-    });
-};
-
-
-
-
-App.prototype.haveSysinfoNicsChanged = function (sysinfo, fullNapiList) {
+App.prototype.onStatusUpdate = function onStatusUpdate(opts, callback) {
     var self = this;
 
-    self.log.trace(
-        { nics: fullNapiList }, 'full napi list');
-
-    var existingNics = [];
-    var macs = [];
-    var i, n;
-    var napiNics = {};
-    var nics = [];
-    var nicsByMAC = {};
-    var sysinfoNics = {};
-    var toAddNics = [];
-    var toUpdateNics = [];
-    var uuid = sysinfo['UUID'];
-    var adminTag = 'admin';
-    var sysAdminTag = sysinfo['Admin NIC Tag'];
-
-    if (sysAdminTag) {
-        adminTag = sysAdminTag;
-    }
-
-    for (n in sysinfo['Network Interfaces']) {
-        sysinfoNics[n] = sysinfo['Network Interfaces'][n];
-        macs.push(sysinfo['Network Interfaces'][n]['MAC Address']);
-    }
-    for (n in sysinfo['Virtual Network Interfaces']) {
-        sysinfoNics[n] = sysinfo['Virtual Network Interfaces'][n];
-        macs.push(sysinfo['Virtual Network Interfaces'][n]['MAC Address']);
-    }
-
-    for (n in fullNapiList) {
-        // Equivalent of getNics(sysinfo['UUID'])
-        if (fullNapiList[n].belongs_to_uuid === sysinfo['UUID']) {
-            nics.push(fullNapiList[n]);
-        }
-
-        // Used to get existing nics
-        nicsByMAC[fullNapiList[n].mac] = fullNapiList[n];
-    }
-
-    // Determine the existing nics
-    for (i = 0; i < macs.length; i++) {
-        var mac = macs[i];
-        var nic = nicsByMAC[mac];
-
-        if (nic) {
-            existingNics.push(nic);
-        }
-    }
-
-    self.log.trace(
-        { nics: nics }, 'filtered nics');
-
-    // Now that we have the current nics, go through and figure out
-    // if they're adds, deletes, updates, or no change.
-    for (n in nics) {
-        napiNics[nics[n].mac] = nics[n];
-    }
-    for (n in existingNics) {
-        napiNics[existingNics[n].mac]
-        = existingNics[n];
-    }
-
-    self.log.trace(
-        { napiNics: napiNics }, 'NAPI nics');
-
-    for (n in sysinfoNics) {
-        var sysinfoNic = sysinfoNics[n];
-        var napiNic = napiNics[sysinfoNic['MAC Address']];
-        var newNic = {};
-
-        self.log.trace(
-            { sysinfoNic: sysinfoNic, napiNic: napiNic },
-            'Checking nic for changes: ' + sysinfoNic['MAC Address']);
-
-        if (!napiNic) {
-            newNic = {
-                mac: sysinfoNic['MAC Address'],
-                belongs_to_uuid: uuid,
-                belongs_to_type: 'server',
-                owner_uuid: ModelServer.getConfig().adminUuid
-            };
-
-            if (sysinfoNic.ip4addr) {
-                newNic.ip = sysinfoNic.ip4addr;
-            }
-
-            if (sysinfoNic.hasOwnProperty('NIC Names')) {
-                newNic.nic_tags_provided = sysinfoNic['NIC Names'];
-            }
-
-            /*
-             * Only the admin nic should be on the PHYS datalink and have
-             * an IP (and thus no VLAN id).
-             */
-            if (!sysinfoNic.hasOwnProperty('VLAN') && sysinfoNic.ip4addr) {
-                newNic.nic_tag = adminTag;
-                newNic.vlan_id = 0;
-            }
-
-            if (sysinfoNic.hasOwnProperty('VLAN')) {
-                newNic.nic_tag = n.replace(/\d+/, '');
-                newNic.vlan_id = Number(sysinfoNic['VLAN']);
-            }
-
-            toAddNics.push(newNic);
-            continue;
-        }
-
-        if (sysinfoNic.ip4addr && (napiNic.ip != sysinfoNic.ip4addr)) {
-            newNic.ip = sysinfoNic.ip4addr;
-        }
-
-        if (napiNic.belongs_to_uuid != uuid) {
-            newNic.belongs_to_uuid = uuid;
-        }
-
-        if (napiNic.belongs_to_type != 'server') {
-            newNic.belongs_to_type = 'server';
-        }
-
-        function listEqual(a, b) {
-            if (!a && !b) {
-                return true;
-            }
-
-            if (!a || !b || (a.length != b.length)) {
-                return false;
-            }
-
-            a.sort();
-            b.sort();
-
-            for (i = 0; i < a.length; i++) {
-                if (a[i] != b[i]) {
-                    return false;
-                }
-            }
-
-            return true;
-        }
-
-        var equal =
-            listEqual(sysinfoNic['NIC Names'],
-                      napiNic.hasOwnProperty('nic_tags_provided')
-                      ? napiNic.nic_tags_provided : []);
-
-
-
-        if (sysinfoNic.hasOwnProperty('NIC Names') && !equal) {
-            newNic.nic_tags_provided = sysinfoNic['NIC Names'];
-        }
+    assert.object(opts, 'opts');
+    assert.object(opts.params, 'opts.params');
+    assert.object(opts.serverModel, 'opts.serverModel');
+    assert.func(callback, 'callback');
 
-        if (Object.keys(newNic).length !== 0) {
-            newNic.mac = sysinfoNic['MAC Address'];
-            toUpdateNics.push(newNic);
-        }
+    var serverModel = opts.serverModel;
+    var statusUpdate = opts.params;
 
-        delete napiNics[sysinfoNic['MAC Address']];
+    self.log.trace(statusUpdate, 'Status update');
+    if (!callback) {
+        callback = function () {};
     }
 
-    var updateNics = toUpdateNics;
-    var addNics = toAddNics;
-    var deleteNics =
-        Object.keys(napiNics).map(function (x) { return napiNics[x]; });
-    var changed = updateNics.length || addNics.length || deleteNics.length;
-
-    if (changed) {
-        self.log.info({
-            updateNics: updateNics,
-            addNics: addNics,
-            deleteNics: deleteNics,
-            napiNics: nics,
-            changed: changed
-        },
-        'Server %s had NIC changes; will execute sysinfo workflow',
-        sysinfo['UUID']);
-
-        return true;
+    if (! statusUpdate.vms) {
+        statusUpdate.vms = {};
     }
-    return false;
-};
-
 
-App.prototype.collectGlobalSysinfo = function (callback) {
-    var self = this;
-
-    var napi = new sdcClients.NAPI({
-        url: self.config.napi.url,
-        connectTimeout: 5000
-    });
+    self.log.trace('Status update (%s) received -- %d zones.',
+        serverModel.uuid, Object.keys(statusUpdate.vms).length);
 
-    var nics;
-
-    listNics();
-
-    function listNics(waitSecs) {
-        self.log.info('Fetching NIC list from NAPI');
-        waitSecs = waitSecs || 1;
-
-        napi.listNics({ belongs_to_type: 'server' }, function (error, list) {
-            if (error) {
-                self.log.warn(error, 'Error fetching server NICs from NAPI');
-
-                setTimeout(function () {
-                    listNics(waitSecs * 2);
-                }, waitSecs * 1000);
-                return;
+    serverModel.updateFromStatusUpdate(
+        statusUpdate,
+        function (updateError) {
+            if (updateError) {
+                self.log.error(new VError(updateError,
+                    'Updating server record from status update'));
+                // Note: we don't fail here or return an error since these
+                // messages are sent every 60 seconds so if one fails, we'll
+                // get the updated state next time.
             }
 
-            nics = list;
-
-            requestSysinfo();
-        });
-    }
-
-    function requestSysinfo() {
-        self.log.info('Broadcasting request for server sysinfo');
-        self.ur.broadcastSysinfo(function (error, sysinfoCollection) {
-            if (error) {
-                self.log.error(error, 'Error broadcasting sysinfo request');
-                return;
-            }
-
-            async.forEach(
-                sysinfoCollection,
-                function (sysinfo, cb) {
-                    if (self.haveSysinfoNicsChanged(sysinfo, nics)) {
-                        self.log.warn('nics for %s have changed',
-                                      sysinfo.UUID);
-                        ModelServer.beginSysinfoWorkflow(sysinfo);
-                    }
-
-                    self.refreshServerFromSysinfo(sysinfo, cb);
-                },
-                function (err) {
-                    if (err) {
-                        self.log.error(
-                            'Error updating server record from global'
-                            + ' broadcast: %s',
-                            err.message);
-                    }
-
-                    callback();
-                });
+            callback();
         });
-    }
 };
 
 
-/**
- * Given a sysinfo object, this function will check if the server exists in
- * Moray. Because the sysinfo message is sent only on start-up, if the server
- * does exist in Moray, we will update the record with the most recent
- * information.
- * If the server does not exist, it will be created in Moray.
- */
-
-App.prototype.refreshServerFromSysinfo =
-function (sysinfo, refreshcb) {
-    var self = this;
-
-    if (!refreshcb) {
-        refreshcb = function () {};
-    }
-
-    if (!self.moray.connected) {
-        self.log.warn(
-            'Cannot refresh server from sysinfo: cannot reach moray');
-        refreshcb();
-        return;
-    }
-
-    var uuid = sysinfo['UUID'];
-
-    var sysinfoCarryOverParams = [
-        'Zpool', 'Zpool Creation', 'Zpool Disks',
-        'Zpool Profile', 'Zpool Size in GiB'];
-
-    var lastboot, created;
-
-    if (sysinfo['Boot Time']) {
-        lastboot = new Date(Number(
-            sysinfo['Boot Time']) * 1000).toISOString();
-    }
-
-    if (sysinfo['Zpool Creation']) {
-        created = new Date(Number(
-            sysinfo['Zpool Creation']) * 1000).toISOString();
-    }
-
-    var shouldInspectServer = false;
-
-    var server, serverModel;
-
-    async.waterfall([
-        function (cb) {
-            ModelServer.get(uuid, function (err, s, so) {
-                if (err) {
-                    self.log.error(
-                        err, 'Error fetching server %s from Moray', uuid);
-                    cb(err);
-                    return;
-                }
-
-                serverModel = s;
-                server = so;
-                cb();
-            });
-        },
-        function (cb) {
-            if (server) {
-                onServerExists(cb);
-            } else {
-                onServerDoesNotExist(cb);
-            }
-        }
-    ],
-    function (error) {
-        self.log.debug('Finished processing server (%s) sysinfo', uuid);
-        refreshcb();
-    });
-
-
-    function onServerExists(callback) {
-        // These parameters, if they exist in the currently stored sysinfo must
-        // be copied from the current sysinfo into the new one.
-        for (var keyIdx in sysinfoCarryOverParams) {
-            var key = sysinfoCarryOverParams[keyIdx];
-
-            if (server.hasOwnProperty('sysinfo') &&
-                    server.sysinfo.hasOwnProperty(key))
-            {
-                sysinfo[key] = server.sysinfo[key];
-            }
-        }
-
-        ModelServer.updateServerPropertiesFromSysinfo({
-            sysinfo: sysinfo,
-            server: server
-        });
-
-        if (lastboot) {
-            server.last_boot = lastboot;
-        }
-
-        if (!server.created) {
-            if (created) {
-                server.created = created;
-            } else {
-                server.created = (new Date()).toISOString();
-            }
-        }
-
-        // Update the hostname only if the server's sysinfo boot time is
-        // different than that which we have stored in moray. This is to
-        // prevent the situation where we set a hostname during the setup
-        // workflow, and we get a periodic sysinfo message which causes the
-        // hostname value in moray to get overridden.
-
-        if (server.sysinfo &&
-            (server.sysinfo['Boot Time'] !== sysinfo['Boot Time']))
-        {
-            server.hostname = sysinfo['Hostname'];
-        }
-
-        server.current_platform = sysinfo['Live Image'];
-        server.transitional_status = '';
-
-        self.log.debug({sysinfo: sysinfo}, 'Server %s existed in moray', uuid);
-
-        async.waterfall([
-            function (cb) {
-                if (!server.setup && !sysinfo.hasOwnProperty('Setup')) {
-                    shouldInspectServer = true;
-                }
-
-                if (sysinfo['SDC Version'] !== '7.0' &&
-                       (!server.sysinfo ||
-                        !server.sysinfo.hasOwnProperty('Zpool') ||
-                        !sysinfo.hasOwnProperty('Zpool') ||
-                        !sysinfo.hasOwnProperty('Zpool Creation')))
-                {
-                    shouldInspectServer = true;
-                }
-
-                cb();
-            },
-            function (cb) {
-                if (shouldInspectServer) {
-                    inspectServer(function (error, values) {
-                        if (error) {
-                            self.log.error(error);
-                        }
-
-                        lastboot = (
-                            new Date(values.boot_time * 1000))
-                            .toISOString();
-
-                        created = (
-                            new Date(values.zpool_creation * 1000))
-                            .toISOString();
-
-                        var setup = server.setup ||
-                            (server.sysinfo['Setup'] == 'true' ? true : false);
-
-                        if (values.zpool) {
-                            server.sysinfo['Zpool'] = values.zpool;
-                            server.sysinfo['Zpool Disks'] = values.zpool_disks;
-                            server.sysinfo['Zpool Creation']
-                                = values.zpool_creation;
-                            server.sysinfo['Zpool Profile']
-                                = values.zpool_profile;
-                            server.sysinfo['Zpool Size in GiB']
-                                = values.zpool_size;
-                            setup = true;
-                        }
-
-                        server.setup = setup;
-
-                        cb();
-                    });
-                } else if (sysinfo.hasOwnProperty('Setup')) {
-                    self.log.debug('Server %s has \'Setup\' sysinfo'
-                            + ' property, set to \'%s\'', sysinfo['UUID'],
-                            sysinfo['Setup']);
-                    if (sysinfo['Setup'] === false ||
-                            sysinfo['Setup'] === 'false')
-                    {
-                        server.setup = false;
-                    } else if (sysinfo['Setup'] === true ||
-                            sysinfo['Setup'] === 'true')
-                    {
-                        server.setup = true;
-                    }
-                    cb();
-                } else {
-                    cb();
-                }
-            }
-        ],
-        function (error) {
-            modify(callback);
-        });
-    }
-
-    function onServerDoesNotExist(callback) {
-        if (!sysinfo['Setup'] && sysinfo['SDC Version'] !== '7.0') {
-            self.log.info('New server %s missing sysinfo.Setup', uuid);
-            shouldInspectServer = true;
-        }
-
-        if (!sysinfo['Zpool'] && sysinfo['SDC Version'] !== '7.0') {
-            self.log.info('New server %s missing sysinfo.Zpool', uuid);
-            shouldInspectServer = true;
-        }
-
-        if (!sysinfo['Zpool Creation'] && sysinfo['SDC Version'] !== '7.0') {
-            self.log.info(
-                'New server %s missing sysinfo["Zpool Creation"]', uuid);
-            shouldInspectServer = true;
-        }
-
-        if (shouldInspectServer) {
-            inspectServer(function (error, values) {
-                if (error) {
-                    self.log.error(error);
-                }
-                lastboot = (
-                    new Date(values.boot_time * 1000))
-                    .toISOString();
-
-                created = (
-                    new Date(values.zpool_creation * 1000))
-                    .toISOString();
-
-                if (values.zpool) {
-                    create({ setup: true, inspect: values }, callback);
-                } else {
-                    create({ setup: false, inspect: values }, callback);
-                }
-            });
-        } else {
-            var setup = false;
-            if (sysinfo['Boot Parameters']['headnode'] === 'true' ||
-                sysinfo['Setup'] === true ||
-                sysinfo['Setup'] === 'true')
-            {
-                setup = true;
-            } else if (sysinfo['Setup'] === false ||
-                sysinfo['Setup'] === 'false')
-            {
-                setup = false;
-            }
-            create({ setup: setup }, callback);
-            return;
-        }
-    }
-
-
-    function inspectServer(cb) {
-        self.log.info(
-            'Looking up zpools, boot_time on server (%s) via Ur', uuid);
-
-        fs.readFile(
-            __dirname + '/../share/inspect-server.sh',
-        function (readerror, script) {
-            if (readerror) {
-                cb(readerror);
-                return;
-            }
-
-            serverModel.invokeUrScript(
-                script.toString(),
-                { uuid: uuid },
-                function (error, stdout, stderr) {
-                    if (error) {
-                        self.log.error(
-                            'Error fetching list of pools from server %s:' +
-                            ' %s', uuid, stderr);
-                        cb(error);
-                        return;
-                    }
-                    var values;
-                    try {
-                        values = JSON.parse(stdout.toString());
-                    } catch (e) {
-                        cb(new Error(
-                            'Error: parsing inspect payload from server'));
-                        return;
-                    }
-
-                    cb(null, values);
-                });
-        });
-    }
-
-
-    function create(opts, callback) {
-        ModelServer.getBootParamsDefault(
-            function (error, params) {
-                if (opts.inspect) {
-                    // These parameters, if they exist in the currently stored
-                    // sysinfo must be copied from the current sysinfo into the
-                    // new one.
-
-                    if (opts.inspect.zpool) {
-                        sysinfo['Zpool'] = opts.inspect.zpool;
-                        sysinfo['Zpool Disks'] = opts.inspect.zpool_disks;
-                        sysinfo['Zpool Profile']
-                            = opts.inspect.zpool_profile;
-                        sysinfo['Zpool Size in GiB']
-                            = opts.inspect.zpool_size;
-                        opts.setup = true;
-                    }
-                }
-                serverModel.create(
-                    {
-                        boot_params: params,
-                        setup: opts.setup,
-                        sysinfo: sysinfo,
-                        last_boot: lastboot,
-                        created: created,
-                        status: 'running'
-                    },
-                    function (err, s) {
-                        if (err) {
-                            self.log.error(err,
-                                'Error getting default parameters');
-                            callback(err);
-                            return;
-                        }
-                        callback();
-                    });
-            });
-    }
-
-
-    function modify(cb) {
-        if (lastboot) {
-            server.last_boot = lastboot;
-        }
-        if (created) {
-            server.created = created;
-        }
-        server.status = 'running';
-        serverModel.modify(
-            server,
-            function (modifyError) {
-                if (modifyError) {
-                    self.log.error(
-                        modifyError,
-                        serverModel.errorFmt(
-                            'modifying server record'),
-                        uuid);
-                    return;
-                }
-                self.log.debug('Modified server record');
-                cb();
-                return;
-            });
-    }
-};
-
 App.prototype.onSysinfoReceivedUr =
 function onSysinfoReceivedUr(message, routingKey) {
     var self = this;
-    var serverUuid = routingKey.split('.')[2];
-
-    return self.onSysinfoReceived(serverUuid, message);
-};
-
-/**
- * Compute nodes which are not in the 'setup' state, will periodically
- * broadcast their sysinfo payloads. On receipt of these messages, we will
- * check if we have any records of this server in moray. If it is found there,
- * ignore message. If it's not found in Moray, we need to add it.
- */
-
-App.prototype.onSysinfoReceived =
-function onSysinfoReceived(serverUuid, newSysinfo, callback) {
-    var self = this;
-
-    var sysinfoTimeoutSeconds = 90;
-    self.log.info('new sysinfo received for %s', serverUuid);
-    self.log.debug({sysinfo: newSysinfo}, 'sysinfo for %s', serverUuid);
 
-    var serverValues;
+    var serverUuid = routingKey.split('.')[2];
+    var sysinfo = message;
+
+    assert.equal(serverUuid, sysinfo['UUID'],
+        'Ur routing key must match sysinfo.UUID');
+
+    // When a server is unsetup and therefore does not have a cn-agent running
+    // and sending heartbeats, we currently handle updating its status based on
+    // the sysinfo messages that are emitted by Ur every 60 seconds. When we see
+    // a sysinfo from an unsetup server we:
+    //
+    //  * clear existing timers
+    //  * ensure the server record is created/updated
+    //  * ensure the server record has status=running (it's alive!)
+    //  * set a timer so that in 90 seconds if we haven't seen another sysinfo,
+    //    we mark the status=unknown.
+    //
+    // This code should all be able to be removed (we can ignore all ur.sysinfo
+    // messages) once cn-agent is automatically running on new servers.
+
+    if (self.unsetupServers.hasOwnProperty(serverUuid)) {
+        clearTimeout(self.unsetupServers[serverUuid].sysinfoTimer);
+        if (sysinfo['Setup'].toString() === 'true') {
+            // no longer unsetup!
+            delete self.unsetupServers[serverUuid];
+        }
+    }
 
-    async.waterfall([
-        function (next) {
-            // If server exists and is not setup, clear and set a timeout to
-            // set status to unknown. This way will need to periodically send
-            // out sysinfo messages or it will be marked as status = 'unknown'.
-            ModelServer.get(serverUuid, function (e, s, values) {
-                if (e) {
-                    next(e);
-                    return;
+    ModelServer.updateFromSysinfo(sysinfo, function _onUpdate(err, server) {
+        self.log.trace({
+            err: err,
+            serverUuid: serverUuid,
+            sysinfo: sysinfo
+        }, 'Got sysinfo from Ur and attempted update');
+
+        if (sysinfo['Setup'].toString() !== 'true') {
+            ModelServer.upsert(serverUuid, {status: 'running'}, {
+                etagRetries: 0
+            }, function _markedRunning(markRunningErr) {
+                if (markRunningErr) {
+                    self.log.warn({
+                        err: markRunningErr,
+                        serverUuid: serverUuid
+                    }, 'failed to mark server "running"');
                 }
 
-                serverValues = values;
-                if (values && !values.setup) {
-                    setStatusTimeout();
+                if (!self.unsetupServers[serverUuid]) {
+                    self.unsetupServers[serverUuid] = {};
                 }
-
-                next();
-            });
-        },
-        function (next) {
-            // Initiate a sysinfo workflow for server
-            if (self.workflow.connected) {
-                if (!serverValues ||
-                    !deepEqual(newSysinfo, serverValues.sysinfo))
-                {
-                    self.log.info(
-                        'starting server-sysinfo workflow for changed sysinfo');
-                    ModelServer.beginSysinfoWorkflow(newSysinfo);
-                } else {
-                    self.log.debug(
-                        { uuid: serverUuid},
-                        'skipping server-sysinfo workflow ' +
-                        'for sysinfo with no changes');
-                }
-            } else {
-                self.log.error({ uuid: serverUuid},
-                    'could not create sysinfo workflow: workflow unavailable');
-            }
-            next();
-        },
-        function (next) {
-            self.refreshServerFromSysinfo(newSysinfo, function (error) {
-                if (error) {
-                    next(error);
-                    return;
-                }
-                next();
+                self.unsetupServers[serverUuid].lastUrSysinfo = Date.now();
+                self.unsetupServers[serverUuid].sysinfoTimer =
+                    setTimeout(function _markUnknown(_serverUuid, _server) {
+                        self.log.debug('No sysinfo for %d seconds, ' +
+                            'marking status="unknown"',
+                            UNSETUP_UR_SYSINFO_TIMEOUT_SECONDS);
+
+                        ModelServer.upsert(serverUuid, {status: 'unknown'}, {
+                            etagRetries: 0
+                        }, function _markedUnknown(markUnknownErr) {
+                            if (markUnknownErr) {
+                                self.log.warn({
+                                    err: markUnknownErr,
+                                    serverUuid: serverUuid
+                                }, 'failed to mark server "unknown"');
+                            }
+                        });
+                    }, UNSETUP_UR_SYSINFO_TIMEOUT_SECONDS * 1000);
             });
         }
-    ],
-    function (err) {
-        if (err) {
-            self.log.error(err, 'error handling sysinfo message');
-        }
-        self.log.debug('sysinfo handler complete for %s', serverUuid);
-
-        if (callback) {
-            callback(err);
-        }
     });
-
-    function setStatusTimeout() {
-        clearTimeout(self.statusTimeouts[serverUuid]);
-
-        self.statusTimeouts[serverUuid] = setTimeout(function () {
-            self.statusTimeouts[serverUuid] = null;
-            ModelServer.get(serverUuid, function (e, s, so) {
-                if (e) {
-                    self.log.error(e);
-                    return;
-                }
-                if (!so) {
-                    self.log.error(e,
-                        'wanted to update status for sever %s ' +
-                        'but it was not found in moray');
-                    return;
-                }
-
-                s.modify({ status: 'unknown' }, function () {
-                    // Since we're modifying state which is really the job of
-                    // the heartbeats, we ensure we also clear the obervation so
-                    // that when the next heartbeat comes in, the reconciler
-                    // treats this as a server that just showed up.
-                    delete self.observedHeartbeats[serverUuid];
-                    self.log.warn(
-                        { uuid: serverUuid },
-                        'no sysinfo from server in %d ' +
-                        'seconds, status => unknown',
-                        sysinfoTimeoutSeconds);
-                });
-            });
-        }, sysinfoTimeoutSeconds * 1000);
-    }
 };
 
+
 /* BEGIN JSSTYLED */
 /*
  * Set a callback to be executed when a cn-agent task has completed. This
diff --git a/lib/endpoints/allocations.js b/lib/endpoints/allocations.js
index 3ff27d7..0654fd8 100644
--- a/lib/endpoints/allocations.js
+++ b/lib/endpoints/allocations.js
@@ -14,9 +14,7 @@
  * space there is on a set of servers.
  */
 
-var assert    = require('assert-plus');
 var async     = require('async');
-var netconfig = require('triton-netconfig');
 var restify   = require('restify');
 var zlib      = require('zlib');
 
@@ -150,7 +148,6 @@ Allocations.allocate = function handlerAllocationsAllocate(req, res, next) {
 
     var log = req.log;
     var httpBody;
-    var imgapiPeers = [];
     var serverDetails;
     var tickets;
 
@@ -247,59 +244,6 @@ Allocations.allocate = function handlerAllocationsAllocate(req, res, next) {
             }
 
             allocChunk();
-        },
-
-        // Get available IMGAPI peers (cn-agents) that can provide this server
-        // with the image file if it doesn't have it. Three possible situations:
-        // - imgapiPeers is [] if no server has the image
-        // - imgapiPeers is null (i.e. not neeeded) if the server has the image
-        // - imgapiPeers is an array of peers if other servers have the image
-        //
-        function getImgapiPeers(cb) {
-            var hasImage = false;
-            var server = httpBody.server;
-
-            // Prevent this for generating an allocation error. No async
-            // executions inside the try/catch
-            try {
-                if (server.images !== undefined) {
-                    server.images.forEach(function (im) {
-                        if (im.uuid === img.uuid) {
-                            hasImage = true;
-                        }
-                    });
-                }
-
-                if (hasImage) {
-                    imgapiPeers = null;
-                    cb();
-                    return;
-                }
-
-                serverDetails.forEach(function (s) {
-                    var adminIp = netconfig.adminIpFromSysinfo(s.sysinfo);
-
-                    if (!adminIp || s.images === undefined ||
-                        !s.images.length) {
-                        return;
-                    }
-
-                    s.images.forEach(function (im) {
-                        if (im.uuid === img.uuid) {
-                            imgapiPeers.push({
-                                ip: adminIp,
-                                uuid: s.uuid
-                            });
-                        }
-                    });
-                });
-            } catch (peerErr) {
-                req.log.error(peerErr,
-                    'Unexpected error running getImgapiPeers');
-            }
-
-            imgapiPeers = imgapiPeers.slice(0, 3);
-            cb();
         }
 
     ], function (asyncErr) {
@@ -308,7 +252,8 @@ Allocations.allocate = function handlerAllocationsAllocate(req, res, next) {
             return;
         }
 
-        httpBody.imgapiPeers = imgapiPeers;
+        // XXX CAN WE REMOVE THIS TOO?
+        httpBody.imgapiPeers = [];
         res.send(httpBody);
         next();
         return;
diff --git a/lib/endpoints/images.js b/lib/endpoints/images.js
index b0ecf19..65af85d 100644
--- a/lib/endpoints/images.js
+++ b/lib/endpoints/images.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright (c) 2019, Joyent, Inc.
  */
 
 /*
@@ -20,7 +20,6 @@ var async = require('async');
 var verror = require('verror');
 
 var validation = require('../validation/endpoints');
-var ModelServer = require('../models/server');
 var ModelImage = require('../models/image');
 
 function Image() {}
diff --git a/lib/endpoints/index.js b/lib/endpoints/index.js
index 072d155..b1a907c 100644
--- a/lib/endpoints/index.js
+++ b/lib/endpoints/index.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright (c) 2019, Joyent, Inc.
  */
 
 var fs = require('fs');
@@ -105,14 +105,16 @@ function ensureServerRunning(opts, req, res, next) {
     assert.object(req, 'req');
     assert.object(res, 'res');
     assert.func(next, 'next');
-    req.stash.server.getRaw(function (err, serverobj) {
-        if (serverobj.status !== 'running') {
-            next(new errors.ServerNotRunningError());
-            return;
-        } else  {
-            next();
-        }
-    });
+    // server must be prepopulated before checking for running
+    assert.object(req.stash.server, 'req.stash.server');
+    assert.object(req.stash.server.value, 'req.stash.server.value');
+
+    if (req.stash.server.value.status !== 'running') {
+        next(new errors.ServerNotRunningError());
+        return;
+    } else  {
+        next();
+    }
 }
 
 function prepopulateServer(opts, req, res, next) {
@@ -150,31 +152,16 @@ function prepopulateVm(opts, req, res, next) {
     assert.string(req.params.uuid, 'uuid');
     assert.object(req, 'req');
     assert.object(req.params, 'req.params');
+    // server must be prepopulated before VM
+    assert.object(req.stash.server, 'req.stash.server');
 
     if (!isUuid(req.params.uuid)) {
         next(new restify.InvalidArgumentError('Invalid vm_uuid'));
         return;
     }
 
-    var uuid = req.params.uuid;
-
-    req.stash.server.getRaw(function (error, server) {
-        if (error) {
-            req.log.error(error);
-            next(new restify.InternalError(error.message));
-            return;
-        }
-
-        // Check if any servers were returned
-        if (!server) {
-            var errorMsg = 'Server ' + req.params.server_uuid + ' not found';
-            next(new restify.ResourceNotFoundError(errorMsg));
-            return;
-        }
-
-        req.stash.vm = req.stash.server.getVM(uuid);
-        next();
-    });
+    req.stash.vm = req.stash.server.getVM(req.params.uuid);
+    next();
 }
 
 
diff --git a/lib/endpoints/nics.js b/lib/endpoints/nics.js
index ee2ada1..6631af6 100644
--- a/lib/endpoints/nics.js
+++ b/lib/endpoints/nics.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright (c) 2019, Joyent, Inc.
  */
 
 /*
@@ -109,16 +109,15 @@ Nic.update = function handlerNicUpdate(req, res, next) {
 };
 
 Nic.updateTask = function handlerNicUpdateTask(req, res, next) {
-    var self = this;
     var server = req.stash.server;
 
     req.log.info({server: server.uuid, params: req.params},
         'sending nic_update task');
     server.sendTaskRequest({
+        log: req.log,
         task: 'server_update_nics',
         params: req.params,
-        req: req,
-        evcb: ModelServer.createComputeNodeAgentHandler(self, req.params.jobid),
+        req_id: req.getId(),
         cb: function (error, task) {
             res.send({ id: task.id });
             return next();
diff --git a/lib/endpoints/servers.js b/lib/endpoints/servers.js
index b802add..5eb64da 100644
--- a/lib/endpoints/servers.js
+++ b/lib/endpoints/servers.js
@@ -14,18 +14,15 @@
  *
  */
 
+var assert =  require('assert-plus');
 var async = require('async');
-var fs = require('fs');
 var qs = require('qs');
 var restify = require('restify');
 var semver = require('semver');
 var sprintf = require('sprintf').sprintf;
-var util = require('util');
 var vasync = require('vasync');
 var VError = require('verror');
 
-var common = require('../common');
-var datasetEndpoints = require('./zfs');
 var Designation = require('../designation');
 var errors = require('../errors');
 var ModelPlatform = require('../models/platform');
@@ -40,6 +37,34 @@ var SERVER_LIST_MIN_LIMIT = 1;
 var SERVER_LIST_MAX_LIMIT = 1000;
 
 
+// --- helpers
+
+// When 'prepopulate' has 'server', we'll have req.stash.server which will
+// include the server.agents property. This function can be used to pass in
+// the req.stash.server and get back an object with cn-agent's properties
+// if this server has cn-agent in its server.agents.
+function getCnAgentFromStashedServer(stashedServer) {
+    var agent;
+    var cnAgent = {};
+    var idx;
+    var server = stashedServer ? stashedServer.value : undefined;
+
+    if (!server || !Array.isArray(server.agents)) {
+        return cnAgent;
+    }
+
+    for (idx = 0; idx < server.agents.length; idx++) {
+        agent = server.agents[idx];
+        if (agent.name === 'cn-agent') {
+            cnAgent = agent;
+            break;
+        }
+    }
+
+    return cnAgent;
+}
+
+
 // ---- exports
 
 function Server() {}
@@ -269,7 +294,7 @@ Server.get = function handlerServerGet(req, res, next) {
         return;
     }
 
-    req.stash.server.getFinal(
+    req.stash.server.getFinal({extras:
         {
             sysinfo: true,
             vms: true,
@@ -277,7 +302,7 @@ Server.get = function handlerServerGet(req, res, next) {
             agents: true,
             last_heartbeat: true,
             memory: true
-        },
+        }},
         function (error, server) {
             if (error) {
                 next(error);
@@ -335,6 +360,10 @@ Server.get = function handlerServerGet(req, res, next) {
 /* END JSSTYLED */
 
 Server.update = function handlerServerUpdate(req, res, next) {
+    assert.object(req, 'req');
+    assert.object(req.params, 'req.params');
+    assert.uuid(req.params.server_uuid, 'req.params.server_uuid');
+
     var rules = {
         'agents': ['optional', 'isArrayType'],
         'boot_params': ['optional', 'isObjectType'],
@@ -356,6 +385,7 @@ Server.update = function handlerServerUpdate(req, res, next) {
         'traits': ['optional', 'isObjectType'],
         'transitional_status': ['optional', 'isStringType', 'isTrim']
     };
+    var serverUuid = req.params.server_uuid;
 
     if (validation.ensureParamsValid(req, res, rules, { strict: true })) {
         next();
@@ -464,23 +494,6 @@ Server.update = function handlerServerUpdate(req, res, next) {
             });
         },
 
-        // If modifying overprovision ratio, ensure the Server has no Vms
-        function (cb) {
-            if (!change.overprovision_ratios) {
-                cb();
-                return;
-            }
-
-            req.stash.server.getRaw(function (error, server) {
-                if (error) {
-                    cb(new VError('failed to fetch vms'));
-                    return;
-                }
-
-                cb();
-            });
-        },
-
         // If the server is not setup, we don't need to bother updating the
         // on-server configuration value.
         function (cb) {
@@ -489,54 +502,50 @@ Server.update = function handlerServerUpdate(req, res, next) {
                 return;
             }
 
-            req.stash.server.getRaw(function (error, raw) {
-                if (!raw.setup) {
-                    cb();
-                    return;
-                }
+            if (!req.stash.server.value.setup) {
+                cb();
+                return;
+            }
 
-                var request = {
-                    task: 'server_overprovision_ratio',
-                    cb: function (err, task) {
-                    },
-                    evcb: function () {},
-                    synccb: function (err, result) {
-                        cb(err, result);
-                    },
-                    req_id: req.getId(),
-                    params: { value: req.params.overprovision_ratios  }
-                };
+            var request = {
+                task: 'server_overprovision_ratio',
+                cb: function (err, task) {
+                },
+                synccb: function (err, result) {
+                    cb(err, result);
+                },
+                req_id: req.getId(),
+                params: { value: req.params.overprovision_ratios  }
+            };
 
-                req.stash.server.sendTaskRequest(request);
-            });
+            req.stash.server.sendTaskRequest(request);
         }
     ],
     function (error) {
         if (error) {
             if (error.code) {
-                next(
-                    restify.codeToHttpError(error.code, error.message));
+                next(restify.codeToHttpError(error.code, error.message));
                 return;
             }
 
-            next(
-                new restify.InternalError(error.message));
+            next(new restify.InternalError(error.message));
             return;
         }
 
-        req.stash.server.modify(
-            change,
-            function (modifyError) {
-                if (modifyError) {
-                    next(new restify.InternalError(error.message));
-                    return;
-                }
-
-                res.send(204);
-                next();
+        ModelServer.upsert(serverUuid, change, {
+            // XXX should we retry a few times?
+            etagRetries: 0
+        }, function (modifyError) {
+            if (modifyError) {
+                next(new restify.InternalError(modifyError.message));
                 return;
-            });
+            }
+
+            res.send(204);
+            next();
+            return;
         });
+    });
 };
 
 /* BEGIN JSSTYLED */
@@ -555,6 +564,16 @@ Server.update = function handlerServerUpdate(req, res, next) {
 /* END JSSTYLED */
 
 Server.reboot = function handlerServerReboot(req, res, next) {
+    assert.object(req, 'req');
+    assert.object(req.params, 'req.params');
+    assert.object(req.stash, 'req.stash');
+    assert.object(req.stash.server, 'req.stash.server');
+
+    var params = {
+        origin: req.params.origin,
+        creator_uuid: req.params.creator_uuid,
+        drain: req.params.drain
+    };
     var rules = {
         'server_uuid': ['isStringType'],
         'creator_uuid': ['optional', 'isStringType'],
@@ -566,22 +585,14 @@ Server.reboot = function handlerServerReboot(req, res, next) {
         return;
     }
 
-    req.stash.server.getRaw(function (error, rawserver) {
-        var params = {
-            origin: req.params.origin,
-            creator_uuid: req.params.creator_uuid,
-            drain: req.params.drain
-        };
-
-        req.stash.server.reboot(params, function (rebootError, jobUuid) {
-            if (rebootError) {
-                next(new restify.InternalError(rebootError.message));
-                return;
-            }
-            res.send(202, { job_uuid: jobUuid });
-            next();
+    req.stash.server.reboot(params, function (rebootError, jobUuid) {
+        if (rebootError) {
+            next(new restify.InternalError(rebootError.message));
             return;
-        });
+        }
+        res.send(202, { job_uuid: jobUuid });
+        next();
+        return;
     });
 };
 
@@ -719,24 +730,21 @@ Server.setup = function handlerServerSetup(req, res, next) {
         params.disk_layout = layout;
     }
 
-    req.stash.server.getRaw(function (error, rawserver) {
-        if (rawserver.setup) {
-            res.send(204);
-            next();
-            return;
-        }
+    if (req.stash.server.value.setup) {
+        // Already setup
+        res.send(204);
+        next();
+        return;
+    }
 
-        req.stash.server.setup(params, function (setupError, jobUuid) {
-            if (setupError) {
-                next(
-                    new restify.InternalError(
-                        setupError.message));
-                return;
-            }
-            res.send(202, { job_uuid: jobUuid });
-            next();
+    req.stash.server.setup(params, function (setupError, jobUuid) {
+        if (setupError) {
+            next(new restify.InternalError(setupError.message));
             return;
-        });
+        }
+        res.send(202, { job_uuid: jobUuid });
+        next();
+        return;
     });
 };
 
@@ -777,34 +785,41 @@ Server.sysinfoRegister = function handlerServerSysinfoRegister(req, res, next) {
     newSysinfo = req.params.sysinfo;
     server_uuid = req.params.server_uuid;
 
+    assert.equal(server_uuid, newSysinfo['UUID'],
+        'Got sysinfo for wrong server');
+
     req.log.info({
         server_uuid: server_uuid,
         sysinfo: newSysinfo
-    }, 'registering sysinfo for server');
-
-    ModelServer.getApp().onSysinfoReceived(server_uuid, newSysinfo,
-        function onSysinfoUpdated(err) {
-            if (err) {
-                req.log.error({
-                    err: err,
-                    server_uuid: server_uuid,
-                    sysinfo: newSysinfo
-                }, 'failed to update sysinfo');
-            } else {
-                req.log.info({
-                    server_uuid: server_uuid
-                }, 'successsfully updated sysinfo');
-                res.send(200);
-            }
-            next(err);
-        });
+    }, 'Registering sysinfo for server');
+
+    ModelServer.updateFromSysinfo(newSysinfo, function onSysinfoUpdated(err) {
+        if (err) {
+            req.log.error({
+                err: err,
+                server_uuid: server_uuid,
+                sysinfo: newSysinfo
+            }, 'failed to register updated sysinfo');
+        } else {
+            req.log.info({
+                server_uuid: server_uuid
+            }, 'successfully registered updated sysinfo');
+            res.send(200);
+        }
+        next(err);
+    });
 };
 
 /* BEGIN JSSTYLED */
 /**
+ * *IMPORTANT: This endpoint is deprecated and will be removed in a future
+ * release. It exists only for backward compatibility and should not be used for
+ * any new development. As of version 2.9.0, cn-agent will keep the sysinfo
+ * up-to-date, so there's no need to call this.*
+ *
  * Fetch a given server's sysinfo values and store them in the server object.
  *
- * @name ServerSysinfoRefresh
+ * @name ServerSysinfoRefresh (deprecated)
  * @endpoint POST /servers/:server_uuid/sysinfo-refresh
  * @section Server API
  *
@@ -814,6 +829,8 @@ Server.sysinfoRegister = function handlerServerSysinfoRegister(req, res, next) {
 /* END JSSTYLED */
 
 Server.sysinfoRefresh = function handlerServerSysinfoRefresh(req, res, next) {
+    var self = this;
+
     var rules = {
         'server_uuid': ['isStringType']
     };
@@ -823,64 +840,115 @@ Server.sysinfoRefresh = function handlerServerSysinfoRefresh(req, res, next) {
         return;
     }
 
-    req.log.info(
-        'querying Ur agent on %s for server for sysinfo',
-        req.params.server_uuid);
-
-    ModelServer.getUr().serverSysinfo(
-        req.params.server_uuid,
-        {},
-        function (sysinfoerror, sysinfo) {
-            if (sysinfoerror) {
-                next(
-                    new restify.InternalError(
-                        sysinfoerror.message));
+    vasync.pipeline({arg: {}, funcs: [
+        function detectSysinfoTask(ctx, cb) {
+            var cnAgent = getCnAgentFromStashedServer(req.stash.server);
+
+            if (cnAgent.version && semver.gte(cnAgent.version, '2.10.0')) {
+                ctx.haveSysinfoTask = true;
+            } else {
+                ctx.haveSysinfoTask = false;
+            }
+
+            self.log.trace({
+                cnAgent: cnAgent,
+                haveSysinfoTask: ctx.haveSysinfoTask,
+                serverUuid: req.params.server_uuid
+            }, 'cn-agent detection');
+
+            cb();
+        }, function callSysinfoTaskIfExists(ctx, cb) {
+            if (!ctx.haveSysinfoTask) {
+                cb();
                 return;
             }
 
-            req.log.info({ sysinfo: sysinfo }, 'Received sysinfo');
+            req.stash.server.sendTaskRequest({
+                cb: function () {},
+                log: self.log,
+                params: req.params,
+                req_id: req.getId(),
+                synccb: function (error, results) {
+                    if (error) {
+                        cb(error);
+                        return;
+                    }
+
+                    ctx.sysinfo = results.sysinfo;
+                    self.log.trace({
+                        sysinfo: ctx.sysinfo
+                    }, 'Got sysinfo from server_sysinfo task');
+
+                    cb();
+                },
+                task: 'server_sysinfo'
+            });
+        }, function fallbackToExec(ctx, cb) {
+            var params = {
+                script: '#!/bin/bash\n/usr/bin/sysinfo\n'
+            };
+
+            if (ctx.sysinfo !== undefined) {
+                // already got sysinfo, no need to exec
+                cb();
+                return;
+            }
 
-            req.stash.server.getRaw(function (geterror, server) {
-                if (geterror) {
-                    next(
-                        new restify.InternalError(
-                            geterror.message));
+            Server.executeCommand({
+                log: self.log,
+                params: params,
+                req_id: req.getId(),
+                server: req.stash.server
+            }, function _onExecuted(err, results) {
+                if (err) {
+                    cb(err);
                     return;
                 }
-                server.sysinfo = sysinfo;
 
+                if (results.exitCode === 0) {
+                    ctx.sysinfo = JSON.parse(results.stdout.trim());
+                    self.log.trace({
+                        sysinfo: ctx.sysinfo
+                    }, 'Got sysinfo from CommandExecute');
+                } else {
+                    self.log.error({
+                        results: results
+                    }, 'Failed to get sysinfo from CommandExecute');
+                }
 
-                req.log.info('Writing new sysinfo to moray');
+                cb();
+            });
+        }, function updateFromSysinfo(ctx, cb) {
+            if (!ctx.sysinfo) {
+                cb(new Error('Unable to gather latest sysinfo'));
+                return;
+            }
 
-                req.stash.server.modify(server, function (moderror) {
-                    if (moderror) {
-                        next(
-                            new restify.InternalError(
-                                moderror.message));
-                        return;
+            ModelServer.updateFromSysinfo(ctx.sysinfo,
+                function onSysinfoUpdated(err) {
+                    if (err) {
+                        self.log.error({
+                            err: err,
+                            server_uuid: ctx.sysinfo.UUID,
+                            sysinfo: ctx.sysinfo
+                        }, 'Failed to apply sysinfo');
+                    } else {
+                        req.log.info({
+                            server_uuid: ctx.sysinfo.UUID
+                        }, 'Successfully refreshed sysinfo');
                     }
 
-                    // Start workflow with new sysinfo
-                    ModelServer.getWorkflow().getClient().createJob(
-                        'server-sysinfo',
-                        {
-                            sysinfo: sysinfo,
-                            server_uuid: req.params.server_uuid,
-                            target: req.params.server_uuid,
-                            admin_uuid: ModelServer.getConfig().adminUuid
-                        },
-                        function (error, job) {
-                            if (error) {
-                                req.log.error(error, 'error in workflow');
-                                return;
-                            }
-
-                            req.log.info('successfully updated sysinfo');
-                            res.send(202, { job_uuid: job.uuid });
-                            next();
-                        });
+                    cb(err);
                 });
-            });
+        }
+    ]}, function _updatedSysinfo(err) {
+        if (err) {
+            next(err);
+            return;
+        }
+
+        res.send(200);
+        next();
     });
 };
 
@@ -1056,15 +1124,19 @@ Server.eventHeartbeat = function handlerServerEventHeartbeat(req, res, next) {
     next();
 };
 
-Server.eventVmsUpdate = function handlerServerEventVmsUpdate(req, res, next) {
-    ModelServer.getApp().onVmsUpdate(
-        req.params.server_uuid, req.params,
-        function (err) {
-            if (err) {
-                req.log.error({ error: err }, 'processing vms update');
-                return;
-            }
-        });
+Server.eventStatusUpdate =
+function handlerServerEventStatusUpdate(req, res, next) {
+    ModelServer.getApp().onStatusUpdate({
+        params: req.params,
+        serverModel: req.stash.server
+    }, function (err) {
+        if (err) {
+            req.log.error({ error: err }, 'Failed to update status');
+            return;
+        }
+    });
+
+    // We're intentionally updating asynchronously here.
     res.send(204);
     next();
 };
@@ -1087,8 +1159,6 @@ Server.eventVmsUpdate = function handlerServerEventVmsUpdate(req, res, next) {
 /* END JSSTYLED */
 
 Server.ensureImage = function handlerServerEnsureImage(req, res, next) {
-    var self = this;
-
     var rules = {
         'server_uuid': ['isStringType'],
         'image_uuid': ['isStringType'],
@@ -1102,18 +1172,129 @@ Server.ensureImage = function handlerServerEnsureImage(req, res, next) {
     }
 
     req.stash.server.sendTaskRequest({
+        log: req.log,
         task: 'image_ensure_present',
         params: req.params,
-        req: req,
-        evcb: ModelServer.createComputeNodeAgentHandler(self, req.params.jobid),
+        req_id: req.getId(),
         cb: function (error, task) {
             res.send({ id: task.id });
             next();
             return;
-        }});
+        }
+    });
+};
+
+
+Server.executeCommand = function executeCommand(opts, callback) {
+    var self = this;
+
+    assert.object(opts, 'opts');
+    assert.object(opts.log, 'opts.log');
+    assert.object(opts.params, 'opts.params');
+    assert.optionalArray(opts.params.args, 'opts.params.args');
+    assert.optionalObject(opts.params.env, 'opts.params.env');
+    assert.optionalBool(opts.params.json, 'opts.params.json');
+    assert.string(opts.params.script, 'opts.params.script');
+    assert.optionalNumber(opts.params.timeout, 'opts.params.timeout');
+    assert.optionalFunc(opts.evcb, 'opts.evcb');
+    assert.string(opts.req_id, 'opts.req_id');
+    assert.object(opts.server, 'opts.server');
+    assert.func(callback, 'callback');
+
+    var handleWithUr = true; // default to Ur for backward compat
+    var useCnAgentCommandExecute =
+        Boolean(ModelServer.getConfig().useCnAgentCommandExecute);
+
+    opts.log.info({
+        params: opts.params,
+        useCnAgentCommandExecute: useCnAgentCommandExecute
+    }, 'Executing command');
+
+    vasync.pipeline({arg: {}, funcs: [
+        function getCnAgentVersion(ctx, cb) {
+            ctx.cnAgent = getCnAgentFromStashedServer(opts.server);
+            opts.log.trace({cnAgent: ctx.cnAgent}, 'got cn-agent info');
+            cb();
+        }, function callUrIfAncient(ctx, cb) {
+            if (useCnAgentCommandExecute &&
+                ctx.cnAgent.version &&
+                semver.gte(ctx.cnAgent.version, '2.6.0')) {
+
+                handleWithUr = false;
+            }
+
+            opts.log.trace({
+                cnAgent: ctx.cnAgent,
+                handleWithUr: handleWithUr
+            }, 'CommandExecute checked for cn-agent');
+
+            cb();
+            return;
+        }
+    ]}, function sendRequest(err) {
+        var msg;
+        var params = {
+            args: opts.params.args,
+            env: opts.params.env,
+            timeout: opts.params.timeout
+        };
+
+        if (err) {
+            callback(err);
+            return;
+        }
+
+        if (handleWithUr) {
+            // Ur's execute functionality
+            if (opts.params.hasOwnProperty('timeout') &&
+                opts.params.timeout !== undefined) {
+
+                msg = 'timeout only supported when using cn-agent (See: ' +
+                    'FEATURE_USE_CNAGENT_COMMAND_EXECUTE)';
+                self.log.error(msg);
+                callback(new restify.InvalidArgumentError(msg));
+                return;
+            }
+
+            opts.server.invokeUrScript(opts.params.script, params,
+                function _onUrResult(urErr, stdout, stderr, exitStatus) {
+
+                if (urErr) {
+                    callback(urErr);
+                    return;
+                }
+
+                callback(null, {
+                    exitCode: exitStatus,
+                    stderr: stderr,
+                    stdout: stdout
+                });
+            });
+        } else {
+            params.script = opts.params.script;
+
+            // cn-agent's command_execute task
+            opts.server.sendTaskRequest({
+                cb: function () {},
+                log: opts.log,
+                params: params,
+                req_id: opts.req_id,
+                synccb: function (error, results) {
+                    if (error) {
+                        callback(error);
+                        return;
+                    }
+
+                    callback(null, results);
+                },
+                task: 'command_execute'
+            });
+        }
+    });
 };
 
 
+
 /* BEGIN JSSTYLED */
 /**
  * *IMPORTANT: This endpoint is deprecated and will be removed in a future
@@ -1146,7 +1327,6 @@ Server.ensureImage = function handlerServerEnsureImage(req, res, next) {
 Server.execute = function handlerCommandExecute(req, res, next) {
     var self = this;
 
-    var handleWithUr = true; // default to Ur for backward compat
     var rules = {
         'args': ['optional', 'isArrayType'],
         'env': ['optional', 'isObjectType'],
@@ -1158,124 +1338,38 @@ Server.execute = function handlerCommandExecute(req, res, next) {
         'script': ['isStringType'],
         'timeout': ['optional', 'isNumberType']
     };
-    var useCnAgentCommandExecute =
-        Boolean(ModelServer.getConfig().useCnAgentCommandExecute);
 
     if (validation.ensureParamsValid(req, res, rules)) {
         next();
         return;
     }
 
-    self.log.info({
+    Server.executeCommand({
+        log: self.log,
         params: req.params,
-        useCnAgentCommandExecute: useCnAgentCommandExecute
-    }, 'handling CommandExecute');
-
-    vasync.pipeline({arg: {}, funcs: [
-        function getCnAgentVersion(ctx, cb) {
-            req.stash.server.getFinal({
-                sysinfo: false,
-                vms: false,
-                disk: false,
-                agents: true,
-                last_heartbeat: false,
-                memory: false
-            }, function (err, server) {
-                var agent;
-                var idx;
-
-                if (err) {
-                    self.log.error({err: err}, 'unable to load server');
-                    cb(err);
-                    return;
-                }
-
-                ctx.cnAgent = {}; // To ensure we always have an object.
-                for (idx = 0; idx < server.agents.length; idx++) {
-                    agent = server.agents[idx];
-                    if (agent.name === 'cn-agent') {
-                        ctx.cnAgent = agent;
-                        cb();
-                        return;
-                    }
-                }
-
-                cb();
-            });
-        }, function callUrIfAncient(ctx, cb) {
-            if (useCnAgentCommandExecute &&
-                ctx.cnAgent.version &&
-                semver.gte(ctx.cnAgent.version, '2.6.0')) {
-
-                handleWithUr = false;
-            }
-
-            self.log.info({
-                cnAgent: ctx.cnAgent,
-                handleWithUr: handleWithUr
-            }, 'CommandExecute checked for cn-agent');
-
-            cb();
-            return;
-        }
-    ]}, function sendRequest(err) {
-        var msg;
-
+        req_id: req.getId(),
+        server: req.stash.server
+    }, function _onExecuted(err, results) {
         if (err) {
             next(err);
             return;
         }
 
-        if (handleWithUr) {
-            // Ur's execute functionality
-            if (req.params.hasOwnProperty('timeout') &&
-                req.params.timeout !== undefined) {
-
-                msg = 'timeout only supported when using cn-agent (See: ' +
-                    'FEATURE_USE_CNAGENT_COMMAND_EXECUTE)';
-                self.log.error(msg);
-                next(new restify.InvalidArgumentError(msg));
-                return;
-            }
-            ur.execute(req, res, next);
+        if (req.params.json) {
+            res.send(results);
         } else {
-            // cn-agent's command_execute task
-            req.stash.server.sendTaskRequest({
-                cb: function () {},
-                task: 'command_execute',
-                params: {
-                    env: req.params.env,
-                    args: req.params.args,
-                    script: req.params.script,
-                    timeout: req.params.timeout
-                },
-                req: req,
-                evcb: ModelServer.createComputeNodeAgentHandler(self,
-                    req.params.jobid),
-                synccb: function (error, results) {
-                    if (error) {
-                        next(error);
-                        return;
-                    }
-
-                    if (req.params.json) {
-                        res.send(results);
-                    } else {
-                        // for backward compat we want to return an error if
-                        // script exited non-zero.
-                        if (results.exitCode !== 0) {
-                            next(new restify.InternalError(
-                                'Error executing on remote system'));
-                            return;
-                        }
-                        // backward compatibly lose stderr
-                        res.send(results.stdout.trim());
-                    }
-                    next();
+            // for backward compat we want to return an error if
+            // script exited non-zero.
+            if (results.exitCode !== 0) {
+                next(new restify.InternalError(
+                    'Error executing on remote system'));
                     return;
-                }
-            });
+            }
+            // backward compatibly lose stderr
+            res.send(results.stdout.trim());
         }
+        next();
+        return;
     });
 };
 
@@ -1298,13 +1392,11 @@ Server.execute = function handlerCommandExecute(req, res, next) {
 /* END JSSTYLED */
 
 Server.installAgent = function handlerServerInstallAgent(req, res, next) {
-    var self = this;
-
     req.stash.server.sendTaskRequest({
+        log: req.log,
         task: 'agent_install',
         params: req.params,
-        req: req,
-        evcb: ModelServer.createComputeNodeAgentHandler(self, req.params.jobid),
+        req_id: req.getId(),
         cb: function (error, task) {
             res.send({ id: task.id });
             next();
@@ -1349,14 +1441,14 @@ Server.uninstallAgents = function uninstallAgents(req, res, next) {
 
     vasync.pipeline({arg: {}, funcs: [
         function getCnAgentVersion(ctx, cb) {
-            req.stash.server.getFinal({
+            req.stash.server.getFinal({extras: {
                 sysinfo: false,
                 vms: false,
                 disk: false,
                 agents: true,
                 last_heartbeat: false,
                 memory: false
-            }, function (err, server) {
+            }}, function (err, server) {
                 var agent;
                 var idx;
 
@@ -1396,11 +1488,10 @@ Server.uninstallAgents = function uninstallAgents(req, res, next) {
         },
         function requestCnAgentTask(ctx, cb) {
             req.stash.server.sendTaskRequest({
+                log: req.log,
                 task: 'agents_uninstall',
                 params: req.params,
-                req: req,
-                evcb: ModelServer.createComputeNodeAgentHandler(
-                    self, req.params.jobid),
+                req_id: req.getId(),
                 cb: function onTaskRequested(_taskReqErr, task) {
                     res.send({ id: task.id });
                     cb();
@@ -1418,7 +1509,7 @@ Server.nop = function handlerServerNop(req, res, next) {
     req.stash.server.sendTaskRequest({
         task: 'nop',
         params: req.params,
-        req: req,
+        req_id: req.getId(),
         cb: function (error, taskstatus) {
             res.send({ id: taskstatus.id });
             next();
@@ -1636,14 +1727,14 @@ function attachTo(http, app) {
 
     http.post({
         path: '/servers/:server_uuid/events/status',
-        name: 'ServerEventVmsUpdate' },
+        name: 'ServerEventStatusUpdate' },
         ensure({
             connectionTimeoutSeconds: 60 * 60,
             app: app,
-            prepopulate: [],
+            prepopulate: ['server'],
             connected: []
         }),
-        Server.eventVmsUpdate);
+        Server.eventStatusUpdate);
 
     /**
      *
diff --git a/lib/endpoints/ur.js b/lib/endpoints/ur.js
index 8a7e1df..24bee93 100644
--- a/lib/endpoints/ur.js
+++ b/lib/endpoints/ur.js
@@ -25,7 +25,6 @@
 var restify = require('restify');
 
 var validation = require('../validation/endpoints');
-var ModelServer = require('../models/server');
 
 function Ur() {}
 
diff --git a/lib/endpoints/vms.js b/lib/endpoints/vms.js
index 7d2ec1c..56209d8 100644
--- a/lib/endpoints/vms.js
+++ b/lib/endpoints/vms.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright (c) 2019, Joyent, Inc.
  */
 
 /*
@@ -22,7 +22,6 @@ var sdcClients = require('sdc-clients');
 
 var validation = require('../validation/endpoints');
 var errors = require('../errors');
-var ModelServer = require('../models/server');
 var ModelVM = require('../models/vm');
 
 function VM() {}
@@ -380,7 +379,6 @@ VM.update = function handlerVmUpdate(req, res, next) {
  */
 
 VM.nicsUpdate = function handlerVmNicsUpdate(req, res, next) {
-    var self = this;
     var sysinfo = req.stash.server.value.sysinfo;
 
     // We don't support bulk updating of nics on 6.5
@@ -392,11 +390,10 @@ VM.nicsUpdate = function handlerVmNicsUpdate(req, res, next) {
 
     // No req.stash.vm for this task, so we can't use performVmTask():
     req.stash.server.sendTaskRequest({
+        log: req.log,
         task: 'machine_update_nics',
         params: req.params,
         req_id: req.getId(),
-        req: req,
-        evcb: ModelServer.createComputeNodeAgentHandler(self, req.params.jobid),
         cb: function (error, task) {
             res.send({ id: task.id });
             return next();
@@ -923,38 +920,35 @@ VM.dockerExec = function handlerVmDockerExec(req, res, next) {
         return;
     }
 
-
     var timeout = setTimeout(function () {
         responded = true;
         next(new restify.InternalError(
             'Time-out reached waiting for docker_exec request to return'));
     }, vmDockerExecTimeoutSeconds * 1000);
 
-    req.stash.server.getRaw(function (err, serverobj) {
-        req.stash.vm.dockerExec(
-            { req_id: req.getId(), command: req.params.command },
-            function (error, result) {
-                clearTimeout(timeout);
+    req.stash.vm.dockerExec(
+        { req_id: req.getId(), command: req.params.command },
+        function (error, result) {
+            clearTimeout(timeout);
 
-                if (responded && error) {
-                    req.log.error(error.message);
-                    return;
-                }
+            if (responded && error) {
+                req.log.error(error.message);
+                return;
+            }
 
-                if (responded) {
-                    req.log.warn('Got a reply back from an expired request');
-                    return;
-                }
+            if (responded) {
+                req.log.warn('Got a reply back from an expired request');
+                return;
+            }
 
-                if (error) {
-                    next(new restify.InternalError(error.message));
-                    return;
-                }
-                res.send(result);
-                next();
+            if (error) {
+                next(new restify.InternalError(error.message));
                 return;
-            });
-    });
+            }
+            res.send(result);
+            next();
+            return;
+        });
 
 };
 
diff --git a/lib/endpoints/waitlist.js b/lib/endpoints/waitlist.js
index 37c690c..ddf598c 100644
--- a/lib/endpoints/waitlist.js
+++ b/lib/endpoints/waitlist.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright (c) 2019, Joyent, Inc.
  */
 
 /*
@@ -21,7 +21,6 @@ var async = require('async');
 var verror = require('verror');
 
 var validation = require('../validation/endpoints');
-var ModelServer = require('../models/server');
 var ModelVM = require('../models/vm');
 var ModelWaitlist = require('../models/waitlist');
 
diff --git a/lib/endpoints/zfs.js b/lib/endpoints/zfs.js
index d301cb2..52e789a 100644
--- a/lib/endpoints/zfs.js
+++ b/lib/endpoints/zfs.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright (c) 2019, Joyent, Inc.
  */
 
 /*
@@ -15,7 +15,6 @@
 var common = require('../common');
 var restify = require('restify');
 var util = require('util');
-var ModelServer = require('../models/server');
 
 function ZFS() {}
 
diff --git a/lib/models/image.js b/lib/models/image.js
index c889fb8..d380417 100644
--- a/lib/models/image.js
+++ b/lib/models/image.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright (c) 2019, Joyent, Inc.
  */
 
 /*
@@ -66,7 +66,6 @@ ModelImage.prototype.get = function (opts, callback) {
             task: 'image_get',
             cb: function (error, task) {
             },
-            evcb: function () {},
             synccb: function (error, result) {
                 callback(error, result);
             },
diff --git a/lib/models/server.js b/lib/models/server.js
index 37ae113..1b43445 100644
--- a/lib/models/server.js
+++ b/lib/models/server.js
@@ -16,12 +16,14 @@
 
 var async = require('async');
 var assert = require('assert-plus');
+var deepDiff = require('deep-object-diff').diff;
 var dns = require('dns');
+var jsprim = require('jsprim');
 var netconfig = require('triton-netconfig');
 var qs = require('qs');
 var restify = require('restify');
+var sdcClients = require('sdc-clients');
 var sprintf = require('sprintf').sprintf;
-var util = require('util');
 var vasync = require('vasync');
 var VError = require('verror');
 var once = require('once');
@@ -31,15 +33,8 @@ var common = require('../common');
 var ModelBase = require('./base');
 var ModelVM = require('./vm');
 var ModelWaitlist = require('./waitlist');
-var ModelPlatform = require('./platform');
-
-var MEMORY_USAGE_KEYS = [
-    'memory_available_bytes',
-    'memory_arc_bytes',
-    'memory_total_bytes',
-    'memory_provisionable_bytes'
-];
 
+// These are all updated through "status" messages from cn-agent
 var DISK_USAGE_KEYS = [
     'disk_cores_quota_bytes',
     'disk_cores_quota_used_bytes',
@@ -55,6 +50,89 @@ var DISK_USAGE_KEYS = [
     'disk_zone_quota_used_bytes'
 ];
 
+// These are all updated through "status" messages from cn-agent
+var MEMORY_USAGE_KEYS = [
+    'memory_arc_bytes',
+    'memory_available_bytes',
+    'memory_provisionable_bytes',
+    'memory_total_bytes'
+];
+
+/* BEGIN JSSTYLED */
+var GENERAL_KEYS = [
+    'agents',                  // updated by cn-agent (ServerUpdate)
+    'boot_modules',            // bootparams
+    'boot_params',             // bootparams + ServerUpdate
+    'boot_platform',           // bootparams + ServerUpdate
+    'comments',                // added manually (ServerUpdate)
+    'created',                 // set when we first see a server, from zpool info or current timestamp
+    'current_platform',        // sysinfo['Live Image']
+    'datacenter',              // set from CNAPI config when creating server, can be modified with ServerUpdate
+    'default_console',         // bootparams + ServerUpdate
+    'headnode',                // set from sysinfo['Boot Parameters']['headnode']
+    'hostname',                // set from sysinfo on first creation
+    'kernel_flags',            // bootparams
+    'last_boot',               // sysinfo['Boot Time']
+    'next_reboot',             // updated manually (ServerUpdate)
+    'overprovision_ratios',    // ServerUpdate (See also TRITON-441)
+    'rack_identifier',         // starts as empty string, updated with ServerUpdate
+    'ram',                     // sysinfo['MiB of Memory']
+    'reservation_ratio',       // default value at creation, then updated with ServerUpdate
+    'reserved',                // defaults to false, then updated with ServerUpdate
+    'reservoir',               // defaults to false, then updated with ServerUpdate
+    'serial',                  // bootparams + ServerUpdate
+    'setting_up',              // ServerUpdate (set true during server setup)
+    'setup',                   // sysinfo['Setup']
+    'status',                  // special, see below
+    'sysinfo',                 // the whole sysinfo object from /usr/bin/sysinfo
+    'traits',                  // initially empty, updated manually (POST /servers/:uuid
+    'transitional_status',     // initially empty, updated via ServerUpdate when needed
+    'uuid',                    // sysinfo['UUID'] (from SMBIOS)
+    'vms'                      // updated via status messages from cn-agent
+];
+/* END JSSTYLED */
+
+//
+// The special "status" field is currently updated differently depending on
+// whether a server is setup or not. For unsetup servers, we mark status as
+// 'running' if we have seen an ur.sysinfo broadcast message in the last 90
+// seconds. For setup servers, the status is marked running if we have seen
+// heartbeat from cn-agent in the last 11 seconds. Otherwise, the server is
+// marked 'unknown'.
+//
+// The "bootparams" fields are initially set to the default bootparams and
+// maintained after that through the bootparams endpoints. Most of these can
+// also (confusingly) be set through ServerUpdate.
+//
+
+// Only keys in this list will be included in server objects we write to moray.
+var SERVER_KEYS = [].concat(
+    DISK_USAGE_KEYS,
+    GENERAL_KEYS,
+    MEMORY_USAGE_KEYS
+).sort();
+
+//
+// NOTE:
+//
+// There are more fields that will show up in objects, but are not written to
+// Moray. These are:
+//
+//  last_hearbeat (deprecated, added based on heartbeats this CNAPI has seen)
+//
+// and the following which are all added by Designation when doing a GET/LIST:
+//
+//  score
+//  unreserved_cpu
+//  unreserved_disk
+//  unreserved_ram
+//
+
+var NON_UPDATABLE_KEYS = [
+    'created',
+    'hostname',
+    'uuid'
+];
 
 /**
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
@@ -79,7 +157,7 @@ function ModelServer(uuid) {
 }
 
 ModelServer.prototype.getValue = function () {
-    return clone(this.value);
+    return jsprim.deepCopy(this.value);
 };
 
 
@@ -100,37 +178,6 @@ ModelServer.init = function (app) {
 };
 
 
-ModelServer.createComputeNodeAgentHandler = function (app, jobuuid) {
-    var self = this;
-    var workflow = ModelServer.getWorkflow();
-
-    return function (task, event) {
-        var taskid = task.id;
-
-        if (!jobuuid) {
-            return;
-        }
-
-        self.log.info(
-            'Posting task info (task %s) to workflow jobs endpoint (job %s)',
-            taskid, jobuuid);
-        workflow.getClient().client.post(
-            '/jobs/' + jobuuid + '/info',
-            event,
-            function (error, req, res, obj) {
-                if (error) {
-                    self.log.error(
-                        error, 'Error posting info to jobs endpoint');
-                    return;
-                }
-                self.log.info(
-                    'Posted task info (task %s, job %s)',
-                    taskid, jobuuid);
-            });
-    };
-};
-
-
 /**
  * Return a list of servers matching given criteria.
  */
@@ -239,29 +286,12 @@ ModelServer.list = function (params, callback) {
         async.map(
             servers,
             function (server, cb) {
-                var heartbeatInfo =
-                    ModelServer.getApp().observedHeartbeats[server.uuid];
                 var serverModel = new ModelServer(server.uuid);
 
-                if (extras.last_heartbeat === true) {
-                    /*
-                     * IMPORTANT:
-                     *
-                     * extras=last_heartbeat is deprecated, it will removed in a
-                     * future version.
-                     */
-                    if (heartbeatInfo &&
-                        heartbeatInfo.last_heartbeat !== undefined) {
-
-                        server.last_heartbeat = heartbeatInfo.last_heartbeat;
-                    } else {
-                        server.last_heartbeat = null;
-                    }
-                }
-
-                serverModel.setRaw(server);
-
-                serverModel.getFinal(extras, function (error, s) {
+                serverModel.getFinal({
+                    extras: extras,
+                    serverObj: server
+                }, function _gotFinal(error, s) {
                     cb(null, s);
                 });
             },
@@ -272,47 +302,6 @@ ModelServer.list = function (params, callback) {
 };
 
 
-
-/**
- * Initiate a workflow, which can may be can be added to which is run whenever
- * a new server starts up and sends its sysinfo payload via Ur.
- */
-
-ModelServer.beginSysinfoWorkflow = function (sysinfo, callback) {
-    var self = this;
-
-    if (!ModelServer.app.workflow.connected) {
-        self.log.warn(
-            'Cannot start sysinfo workflow: cannot reach workflow API');
-    }
-
-    var uuid = sysinfo.UUID;
-
-    var params = {
-        sysinfo: sysinfo,
-        server_uuid: uuid,
-        target: uuid,
-        admin_uuid: ModelServer.getConfig().adminUuid
-    };
-
-    self.log.info('Instantiating server-sysinfo workflow');
-    ModelServer.getWorkflow().getClient().createJob(
-        'server-sysinfo',
-        params,
-        function (error, job) {
-            if (error) {
-                self.log.error('Error in workflow: %s', error.message);
-                if (callback) {
-                    callback(error);
-                }
-                return;
-            }
-            if (callback) {
-                callback();
-            }
-        });
-};
-
 /**
  * Creates an object that will contain default values for new servers.
  */
@@ -494,33 +483,29 @@ ModelServer.prototype.reboot = function (params, callback) {
         callback = params;
     }
 
-    var uuid = this.uuid;
-    var wfParams;
-
-    self.getRaw(function (geterror, raw) {
-        wfParams = {
-            cnapi_url: ModelServer.getConfig().cnapi.url,
-            server_uuid: uuid,
-            target: uuid,
-            origin: params.origin,
-            creator_uuid: params.creator_uuid,
-            drain: params.drain || false
-        };
+    var uuid = self.uuid;
+    var wfParams = {
+        cnapi_url: ModelServer.getConfig().cnapi.url,
+        server_uuid: uuid,
+        target: uuid,
+        origin: params.origin,
+        creator_uuid: params.creator_uuid,
+        drain: params.drain || false
+    };
 
-        self.log.info('Instantiating server-reboot workflow');
-        ModelServer.getWorkflow().getClient().createJob(
-            'server-reboot',
-            wfParams,
-            function (error, job) {
-                if (error) {
-                    self.log.error('Error in workflow: %s', error.message);
-                    callback(error);
-                    return;
-                }
-                callback(null, job.uuid);
+    self.log.info('Instantiating server-reboot workflow');
+    ModelServer.getWorkflow().getClient().createJob(
+        'server-reboot',
+        wfParams,
+        function (error, job) {
+            if (error) {
+                self.log.error('Error in workflow: %s', error.message);
+                callback(error);
                 return;
-            });
-    });
+            }
+            callback(null, job.uuid);
+            return;
+        });
 };
 
 
@@ -551,7 +536,7 @@ ModelServer.prototype.logerror = function (error, str) {
 ModelServer.prototype.filterFields = function (fields, callback) {
     var self = this;
 
-    var server = clone(self.value);
+    var server = jsprim.deepCopy(self.value);
 
     function isBoolean(a) {
         return !!a === a;
@@ -632,121 +617,97 @@ ModelServer.prototype.filterFields = function (fields, callback) {
 };
 
 
-ModelServer.prototype.updateFromVmsUpdate =
-function (vmsUpdate, callback) {
+//
+// cn-agent sends "status" updates for each server every minute that look like:
+//
+//   {
+//      "server_uuid": "66345530-9491-9e42-972b-ed9a529a4a9a",
+//      "vms": {
+//        "9edf7ee3-86c3-40ef-be3b-ec8f73c3d747": {
+//          "brand": "joyent-minimal",
+//          "cpu_cap": 100,
+//          "last_modified": "2019-02-06T18:49:14.000Z",
+//          "max_physical_memory": 128,
+//          "owner_uuid": "930896af-bf8c-48d4-885c-6573a94b1853",
+//          "quota": 25,
+//          "state": "running",
+//          "uuid": "9edf7ee3-86c3-40ef-be3b-ec8f73c3d747",
+//          "zone_state": "running"
+//        },
+//        ...
+//      },
+//      "zpoolStatus": {
+//        "zones": {
+//          "bytes_available": 199334836736,
+//          "bytes_used": 7662300672
+//        }
+//      },
+//      "meminfo": {
+//        "availrmem_bytes": 5325869056,
+//        "arcsize_bytes": 1331352848,
+//        "total_bytes": 8579944448
+//      },
+//      "diskinfo": {
+//        "kvm_zvol_used_bytes": 0,
+//        "kvm_zvol_volsize_bytes": 0,
+//        "kvm_quota_bytes": 0,
+//        "kvm_quota_used_bytes": 0,
+//        "zone_quota_bytes": 0,
+//        "zone_quota_used_bytes": 0,
+//        "cores_quota_bytes": 0,
+//        "cores_quota_used_bytes": 0,
+//        "installed_images_used_bytes": 0,
+//        "pool_size_bytes": 206997137408,
+//        "pool_alloc_bytes": 7662300672,
+//        "system_used_bytes": 7662300672
+//      },
+//      "boot_time": "2019-02-06T18:45:01.000Z",
+//      "timestamp": "2019-02-14T00:29:46.183Z"
+//    }
+//
+// We take that data here and update the server object's properties.
+//
+ModelServer.prototype.updateFromStatusUpdate =
+function (statusUpdate, callback) {
     var self = this;
 
-    var serverobj = {};
-
-    async.waterfall([
-        // Get the server object
-        getServer,
+    var serverUuid = self.uuid;
+    var updateObj = {};
 
-        // Initialize the server object
-        initializeServer,
+    self.log.trace({
+        statusUpdate: statusUpdate,
+        serverUuid: serverUuid
+    }, 'updateFromStatusUpdate');
 
-        // Update the server's memory
+    vasync.pipeline({funcs: [
         updateMemory,
-
-        // Update the server's disk
         updateDisk,
-
-        // Write the change to moray
+        updateVms,
         writeServerRecord
-    ],
-    function (error) {
+    ]}, function (error) {
         callback(error);
     });
 
-    function getServer(cb) {
-        self.getRaw(function (err, so, s) {
-            if (err) {
-                cb(new VError(err, 'retrieving server on VMs update'));
-                return;
-            }
-
-            serverobj = so;
-            cb();
-        });
-    }
-
-    function initializeServer(cb) {
-        if (!serverobj) {
-            self.log.info(
-                'VMs update server %s was not found in moray, ' +
-                'initializing new server record', self.uuid);
-            // Initialize new server record from default params
-            ModelServer.initialValues({}, function (error, so) {
-                if (error) {
-                    cb(error);
-                    return;
-                }
-
-                serverobj = so;
-                serverobj.uuid = self.uuid;
-                serverobj.vms = {};
-                cb();
-            });
-
-            return;
-        } else {
-            if (!serverobj.sysinfo) {
-                ModelServer.getApp().needSysinfoFromServer(self.uuid);
-            }
-            ModelServer.carryForwardVMChanges(vmsUpdate, serverobj);
-        }
-
-        cb();
-    }
-
-    function updateMemory(cb) {
-        if (!serverobj.sysinfo) {
-            cb();
-            return;
-        }
+    function updateMemory(_, cb) {
         var memoryKeys = [
             ['availrmem_bytes', 'memory_available_bytes'],
             ['arcsize_bytes', 'memory_arc_bytes'],
             ['total_bytes', 'memory_total_bytes'] ];
 
         memoryKeys.forEach(function (keys) {
-            if (vmsUpdate.meminfo &&
-                vmsUpdate.meminfo.hasOwnProperty(keys[0]))
+            if (statusUpdate.meminfo &&
+                statusUpdate.meminfo.hasOwnProperty(keys[0]))
             {
-                serverobj[keys[1]] = vmsUpdate.meminfo[keys[0]];
+                updateObj[keys[1]] = statusUpdate.meminfo[keys[0]];
             } else {
                 self.log.warn('update missing "%s" property', keys[0]);
             }
         });
 
-        /**
-         * Compute the memory_provisionable_bytes value based on the total
-         * memory, the reservation ratio and the max_physical_memory values
-         * of all vms.
-         */
-
-        var reservation_ratio = serverobj.reservation_ratio;
-        var total_memory_bytes
-            = serverobj.sysinfo['MiB of Memory'] * 1024 * 1024;
-
-        serverobj.memory_provisionable_bytes =
-            total_memory_bytes - (total_memory_bytes * reservation_ratio);
-
-        serverobj.memory_provisionable_bytes -= 1024 * 1024 *
-            Object.keys(vmsUpdate.vms)
-                .map(function (uuid) {
-                    return vmsUpdate.vms[uuid];
-                })
-                .reduce(function (prev, curr) {
-                    return prev + curr.max_physical_memory;
-                }, 0);
-
-        serverobj.memory_provisionable_bytes =
-            Math.floor(serverobj.memory_provisionable_bytes);
         cb();
     }
 
-    function updateDisk(cb) {
+    function updateDisk(_, cb) {
         var diskKeys = [
             ['cores_quota_bytes', 'disk_cores_quota_bytes'],
             ['cores_quota_used_bytes', 'disk_cores_quota_used_bytes'],
@@ -763,10 +724,10 @@ function (vmsUpdate, callback) {
         ];
 
         diskKeys.forEach(function (keys) {
-            if (vmsUpdate.diskinfo &&
-                vmsUpdate.diskinfo.hasOwnProperty(keys[0]))
+            if (statusUpdate.diskinfo &&
+                statusUpdate.diskinfo.hasOwnProperty(keys[0]))
             {
-                serverobj[keys[1]] = vmsUpdate.diskinfo[keys[0]];
+                updateObj[keys[1]] = statusUpdate.diskinfo[keys[0]];
             } else {
                 self.log.warn('update missing "%s" property', keys[0]);
             }
@@ -775,141 +736,94 @@ function (vmsUpdate, callback) {
         cb();
     }
 
-    function writeServerRecord(cb) {
-        self.modify(serverobj, function (err) {
-            if (err) {
-                self.log.error(err);
-            }
-            cb(err);
-        });
+    function updateVms(_, cb) {
+        assert.object(statusUpdate.vms, 'statusUpdate.vms');
+
+        updateObj.vms = statusUpdate.vms;
+        cb();
+    }
+
+    function writeServerRecord(_, cb) {
+        self.log.trace({
+            updateObj: updateObj,
+            serverUuid: serverUuid
+        }, 'updateFromStatusUpdate update');
+
+        ModelServer.upsert(serverUuid, updateObj, {
+            etagRetries: 0
+        }, cb);
     }
 };
 
 
 /**
- * Returns a copy of the server model's internal representation retried from
+ * Returns a copy of the server model's internal representation retrieved from
  * the memory, or from memory if this object has been previously
  * fetched.
  */
 
 ModelServer.prototype.getRaw = function (extras, callback) {
     var self = this;
-    var uuid = self.uuid;
-    var server;
 
-    if (arguments.length === 1) {
-        callback = extras;
-        extras = {};
-    }
-
-    if (self.exists === false) {
-        this.log.warn(
-            '%s was not found previously, returning negative result', uuid);
-        callback();
-        return;
-    }
+    assert.object(extras, 'extras');
+    assert.func(callback, 'callback');
 
-    if (self.value) {
-        server = clone(self.value);
-        callback(null, server);
-    } else {
-        this.log.trace('Fetching server %s from moray', uuid);
-        ModelServer.getMoray().getObject(
-            buckets.servers.name,
-            uuid,
-            function (error, obj) {
-                var heartbeatInfo =
-                    ModelServer.getApp().observedHeartbeats[uuid];
+    var uuid = self.uuid;
+    var server;
 
-                if (error && VError.hasCauseWithName(error,
-                                                     'ObjectNotFoundError'))
-                {
-                    self.exists = false;
-                    self.log.error('Server %s not found in moray', uuid);
+    this.log.trace('Fetching server %s from moray', uuid);
 
-                    callback();
-                    return;
-                } else if (error) {
-                    self.log.error(error, 'Error fetching server from moray');
-                    callback(error);
-                    return;
-                }
-                self.found = true;
-                self.exists = true;
-                server = clone(obj.value);
-                self.value = obj.value;
-                self.etag = obj._etag;
-
-                /*
-                 * If:
-                 *
-                 *  - we're the only CNAPI, or we happen to be the CNAPI
-                 *    handling this CN
-                 *  - the server is running
-                 *  - the caller requested extras=last_heartbeat
-                 *
-                 * we'll include the last_heartbeat value we've got. Otherwise
-                 * we'll set it to null.
-                 *
-                 * NOTE: this field is deprecated, and still exists only for
-                 * backward compatibility. All code for extras=last_heartbeat
-                 * can be removed in a future version.
-                 *
-                 */
-                if (extras.last_heartbeat) {
-                    if (heartbeatInfo &&
-                        heartbeatInfo.last_heartbeat !== undefined) {
-
-                        self.value.last_heartbeat = server.last_heartbeat =
-                            heartbeatInfo.last_heartbeat;
-                    } else {
-                        self.value.last_heartbeat =
-                            server.last_heartbeat = null;
-                    }
-                }
-                callback(null, server);
-            });
-    }
-};
+    ModelServer.getMoray().getObject(
+        buckets.servers.name,
+        uuid,
+        function (error, obj) {
+            var heartbeatInfo =
+                ModelServer.getApp().observedHeartbeats[uuid];
 
+            if (error && VError.hasCauseWithName(error, 'ObjectNotFoundError'))
+            {
+                self.log.error('Server %s not found in moray', uuid);
+                callback();
+                return;
+            } else if (error) {
+                self.log.error(error, 'Error fetching server from moray');
+                callback(error);
+                return;
+            }
 
-ModelServer.updateServerPropertiesFromSysinfo = function (opts) {
-    var server = opts.server;
-    var sysinfo = opts.sysinfo;
+            server = jsprim.deepCopy(obj.value);
+            self.value = obj.value;
 
-    server.sysinfo = sysinfo;
-    server.ram = parseInt(sysinfo['MiB of Memory'], 10);
-    server.current_platform = sysinfo['Live Image'];
-    server.headnode = sysinfo['Boot Parameters']['headnode'] === 'true';
-    server.boot_platform = server.boot_platform || sysinfo['Live Image'];
-    server.hostname = server.hostname || sysinfo['Hostname'];
-
-    if (!server.agents ||
-        server.agents && Array.isArray(server.agents) &&
-        server.agents.length === 0)
-    {
-        server.agents = server.agents || sysinfo['SDC Agents'];
-    }
+            /*
+             * If:
+             *
+             *  - we're the only CNAPI, or we happen to be the CNAPI
+             *    handling this CN
+             *  - the server is running
+             *  - the caller requested extras=last_heartbeat
+             *
+             * we'll include the last_heartbeat value we've got. Otherwise
+             * we'll set it to null.
+             *
+             * NOTE: this field is deprecated, and still exists only for
+             * backward compatibility. All code for extras=last_heartbeat
+             * can be removed in a future version.
+             *
+             */
+            if (extras.last_heartbeat) {
+                if (heartbeatInfo &&
+                    heartbeatInfo.last_heartbeat !== undefined) {
 
-    if (sysinfo['SDC Version'] === '7.0' &&
-        !sysinfo.hasOwnProperty('Setup'))
-    {
-        if (sysinfo.hasOwnProperty('Zpool')) {
-            server.setup = true;
-        } else {
-            server.setup = false;
-        }
-    } else if (sysinfo.hasOwnProperty('Setup')) {
-        if (sysinfo['Setup'] === 'true' ||
-            sysinfo['Setup'] === true)
-        {
-            server.setup = true;
-        } else if (sysinfo['Setup'] === 'false' || sysinfo['Setup'] === false) {
-            server.setup = false;
-        }
-    }
+                    self.value.last_heartbeat = server.last_heartbeat =
+                        heartbeatInfo.last_heartbeat;
+                } else {
+                    self.value.last_heartbeat =
+                        server.last_heartbeat = null;
+                }
+            }
 
-    return server;
+            callback(null, server);
+        });
 };
 
 
@@ -947,29 +861,30 @@ ModelServer.initialValues = function (opts, callback) {
         var server = {};
 
         server.agents = [];
+        server.comments = '';
         server.datacenter = ModelServer.getConfig().datacenter_name;
-        server.overprovision_ratio = 1.0;
+        server.rack_identifier = '';
         server.reservation_ratio = 0.15;
+        server.reserved = false;
         server.reservoir = false;
+        server.status = 'running';
+        server.sysinfo = {};
         server.traits = {};
-        server.rack_identifier = '';
-        server.comments = '';
         server.uuid = self.uuid;
-        server.reserved = false;
         server.vms = {};
 
         if (boot_params) {
-            server.boot_platform = boot_params.platform;
             server.boot_params = boot_params.kernel_args;
-            server.kernel_flags = boot_params.kernel_flags;
+            server.boot_platform = boot_params.platform;
             server.default_console = boot_params.default_console;
+            server.kernel_flags = boot_params.kernel_flags;
             server.serial = boot_params.serial;
         }
 
         // set defaults if not set above
         server.boot_params = server.boot_params || {};
-        server.kernel_flags = server.kernel_flags || {};
         server.default_console = server.default_console || 'serial';
+        server.kernel_flags = server.kernel_flags || {};
         server.serial = server.serial || 'ttyb';
 
         server.created = (new Date()).toISOString();
@@ -978,144 +893,18 @@ ModelServer.initialValues = function (opts, callback) {
     });
 };
 
-/**
- * Create a server object in Moray. Use the sysinfo values if they are given in
- * the opts argument. If no sysinfo values are given, do a sysinfo lookup on
- * the server via Ur, and then create the server using those values.
- */
-
-ModelServer.prototype.create = function (opts, callback) {
-    var self = this;
-    var server = {};
-
-    self.log.info({ opts: opts }, 'server creation opts');
-
-    async.waterfall([
-        function (cb) {
-            ModelServer.initialValues({}, function (err, s) {
-                server = s;
-                server.uuid = opts.sysinfo.UUID;
-                server.created = opts.created;
-                server.sysinfo = opts.sysinfo;
-                server.ram = parseInt(opts.sysinfo['MiB of Memory'], 10);
-                server.hostname = opts.sysinfo.Hostname;
-                server.status = opts.status;
-                server.headnode =
-                    opts.sysinfo['Boot Parameters']['headnode'] === 'true';
-                server.current_platform = opts.sysinfo['Live Image'];
-
-                server.setup = opts.setup;
-                server.last_boot = opts.last_boot;
-                cb();
-            });
-        }
-    ],
-    function (error) {
-        self.store(
-            server,
-            function (createError, createdServer) {
-                if (createError) {
-                    self.log.error(
-                        createError,
-                        'Error creating server in moray');
-                    callback(createError);
-                    return;
-                }
-                self.log.info('Stored server record in moray');
-                callback(null, server);
-            });
-    });
-};
-
-
-/**
- * Create a server record in moray.
- */
-
-ModelServer.prototype.store = function (server, callback) {
-    var self = this;
-
-    var uuid = server['uuid'];
-
-    delete server.memory;
-
-    ModelServer.getMoray().putObject(
-        buckets.servers.name,
-        uuid,
-        server,
-        function (error) {
-            if (error) {
-                self.log.error(error, 'Error adding server to moray');
-                callback(error);
-                return;
-            }
-
-            callback();
-        });
-};
-
-
-/**
- * Modify a server record.
- */
-
-ModelServer.prototype.modify = function (server, callback) {
-    var self = this;
-
-    self.value = self.value || {};
-    self.value = clone(server, self.value);
-
-    // Remove obsolete attributes
-    delete self.value.serial_speed;
-    delete self.value.images;
-
-    self.log.trace({ server: self.value.uuid },
-                   'Writing server %s to moray', self.value.uuid);
-
-    var putOpts = {};
-
-    if (self.etag) {
-        putOpts.etag = self.etag;
-    }
-
-    ModelServer.getMoray().putObject(
-        buckets.servers.name,
-        self.uuid,
-        self.value,
-        putOpts,
-        function (error) {
-            if (error) {
-                self.logerror(error, 'modifying server');
-            }
-            callback(error);
-        });
-};
-
-
-function clone(obj, dest) {
-    var target = dest ? dest : ((obj instanceof Array) ? [] : {});
-    for (var i in obj) {
-        if (obj[i] && typeof (obj[i]) == 'object') {
-            target[i] = clone(obj[i]);
-        } else {
-            target[i] = obj[i];
-        }
-    }
-    return target;
-}
-
 
 ModelServer.get = function (uuid, callback) {
     var server = new ModelServer(uuid);
+
     server.getRaw({
-        vms: true, memory: true,
-        disk: true, status: true,
-        sysinfo: true, last_heartbeat: true,
-        agents: true
+        last_heartbeat: true
     }, function (err, serverobj) {
         callback(err, server, serverobj);
     });
 };
+
+
 /**
  * Delete all references to a server.
  */
@@ -1137,7 +926,7 @@ ModelServer.prototype.del = function (callback) {
  */
 
 ModelServer.prototype.setRaw = function (raw, callback) {
-    this.value = clone(raw);
+    this.value = jsprim.deepCopy(raw);
 };
 
 
@@ -1145,34 +934,40 @@ ModelServer.prototype.setRaw = function (raw, callback) {
  * Filter the server attributes based on fields passed in.
  */
 
-ModelServer.prototype.getFinal = function (/* extras, */ callback) {
+ModelServer.prototype.getFinal = function (opts, callback) {
     var self = this;
 
+    assert.object(opts, 'opts');
+    assert.optionalObject(opts.extras, 'opts.extras');
+    assert.optionalObject(opts.serverObj, 'opts.serverObj');
+    assert.func(callback, 'callback');
+
+    var extrasAll = {
+        agents: true,
+        disk: true,
+        last_heartbeat: true,
+        memory: true,
+        status: true,
+        sysinfo: true,
+        vms: true
+    };
     var extrasDefaults = {
-        vms: false, memory: false,
-        disk: false, status: true,
-        sysinfo: false, last_heartbeat: false,
-        agents: false
+        agents: false,
+        disk: false,
+        last_heartbeat: false,
+        memory: false,
+        status: true,
+        sysinfo: false,
+        vms: false
     };
 
-    var extras = extrasDefaults;
-
-    if (arguments.length === 2) {
-        extras = arguments[0];
-        callback = arguments[1];
-
-        if (extras.all) {
-            extras = {
-                vms: true, memory: true,
-                disk: true, sysinfo: true,
-                status: true, last_heartbeat: true,
-                agents: true
-            };
-        } else {
-            for (var extraKey in extrasDefaults) {
-                if (!extras.hasOwnProperty(extraKey)) {
-                    extras[extraKey] = extrasDefaults[extraKey];
-                }
+    var extras = opts.extras || {};
+    if (extras.all) {
+        extras = extrasAll;
+    } else {
+        for (var extraKey in extrasDefaults) {
+            if (!extras.hasOwnProperty(extraKey)) {
+                extras[extraKey] = extrasDefaults[extraKey];
             }
         }
     }
@@ -1181,11 +976,21 @@ ModelServer.prototype.getFinal = function (/* extras, */ callback) {
 
     async.waterfall([
         function (cb) {
+            if (opts.serverObj) {
+                // Users of this are responsible to make sure they got an object
+                // with all the extras they wanted.
+                self.value = opts.serverObj;
+                cb();
+                return;
+            }
             self.getRaw(extras, function (getError, s) {
                 if (getError) {
                     cb(getError);
                     return;
                 }
+
+                // We called getRaw only for its side-effect here of setting
+                // self.value. self.filterFields will then use this self.value.
                 cb();
             });
         },
@@ -1230,7 +1035,7 @@ ModelServer.prototype.getFinal = function (/* extras, */ callback) {
  * particular server.
  */
 ModelServer.carryForwardVMChanges =
-function (vmsUpdate, serverobj) {
+function (statusUpdate, serverobj) {
     var self = this;
 
     var vms = {};
@@ -1241,23 +1046,23 @@ function (vmsUpdate, serverobj) {
         serverobj.vms = {};
     }
 
-    if (!vmsUpdate.vms) {
-        self.log.warn({ server: this.uuid }, 'VMs update missing VMs');
+    if (!statusUpdate.vms) {
+        self.log.warn({ server: this.uuid }, 'Status update is missing VMs');
         serverobj.vms = {};
         return;
     }
 
-    for (vmuuid in vmsUpdate.vms) {
+    for (vmuuid in statusUpdate.vms) {
         if (!serverobj.vms[vmuuid]) {
             self.log.trace({ vm_uuid: vmuuid },
                 'VMs update shows vm changed (now exists)');
         }
 
-        vms[vmuuid] = vmsUpdate.vms[vmuuid];
+        vms[vmuuid] = statusUpdate.vms[vmuuid];
 
         if (serverobj.vms[vmuuid] &&
             serverobj.vms[vmuuid].last_modified !==
-            vmsUpdate.vms[vmuuid].last_modified)
+            statusUpdate.vms[vmuuid].last_modified)
         {
             self.log.trace({ vm_uuid: vmuuid },
                 'changed because last modified changed');
@@ -1280,7 +1085,7 @@ ModelServer.prototype.setup = function (params, callback) {
     var uuid = this.uuid;
     var wfParams;
 
-    self.getRaw(function (geterror, raw) {
+    self.getRaw({}, function (geterror, raw) {
         wfParams = {
             // Set nic action to update, so that we add the nic tags
             // rather than replace or delete
@@ -1289,8 +1094,7 @@ ModelServer.prototype.setup = function (params, callback) {
             cnapi_url: ModelServer.getConfig().cnapi.url,
             assets_url: ModelServer.getConfig().assets.url,
             server_uuid: uuid,
-            target: uuid,
-            overprovision_ratio: raw.overprovision_ratio
+            target: uuid
         };
 
         if (params.hasOwnProperty('nics')) {
@@ -1335,10 +1139,9 @@ ModelServer.prototype.setup = function (params, callback) {
         async.waterfall([
             function (cb) {
                 if (params.hasOwnProperty('hostname') && params.hostname) {
-                    raw.hostname = params.hostname;
-                    self.modify(raw, function (modifyError) {
-                        cb(modifyError);
-                    });
+                    ModelServer.upsert(self.uuid, {hostname: params.hostname}, {
+                        etagRetries: 0
+                    }, cb);
                 } else {
                     cb();
                 }
@@ -1483,7 +1286,7 @@ ModelServer.getBootParamsDefault = function (callback) {
 ModelServer.prototype.getBootParams = function (callback) {
     var self = this;
 
-    self.getRaw(function (error, server) {
+    self.getRaw({}, function (error, server) {
         if (error) {
             callback(error);
             return;
@@ -1567,40 +1370,39 @@ ModelServer.prototype.getBootParams = function (callback) {
 
 
 /**
- * Set the boot parameters on a server object.
+ * Set the boot parameters on a server object, replace all existing
+ * bootparams for this server.
  */
 
 ModelServer.prototype.setBootParams = function (bootParams, callback) {
     var self = this;
 
-    self.getRaw(function (error, server) {
-        if (error) {
-            self.logerror('server to be modified did not exist');
-            callback(error);
-            return;
-        }
-
-        server.default_console = bootParams.default_console;
-        server.serial = bootParams.serial;
-
-        server.boot_params = bootParams.boot_params;
-        server.boot_platform = bootParams.boot_platform;
-        server.kernel_flags = bootParams.kernel_flags || {};
-        server.boot_modules = bootParams.boot_modules || [];
+    var payload = {
+        boot_modules: bootParams.boot_modules || [],
+        boot_params: bootParams.boot_params,
+        boot_platform: bootParams.boot_platform,
+        default_console: bootParams.default_console,
+        kernel_flags: bootParams.kernel_flags || {},
+        serial: bootParams.serial
+    };
 
-        self.modify(server, function (modifyError) {
-            callback(modifyError);
-            return;
-        });
-    });
+    ModelServer.upsert(self.uuid, payload, {
+        etagRetries: 10
+    }, callback);
 };
 
 
+/**
+ * Set the boot parameters on a server object, leaving values that are not
+ * being updated.
+ */
 
 ModelServer.prototype.updateBootParams = function (bootParams, callback) {
     var self = this;
 
-    self.getRaw(function (error, server) {
+    var payload = {};
+
+    self.getRaw({}, function (error, server) {
         if (error) {
             self.logerror('server to be modified did not exist');
             callback(error);
@@ -1608,203 +1410,59 @@ ModelServer.prototype.updateBootParams = function (bootParams, callback) {
         }
 
         if (bootParams.boot_platform) {
-            server.boot_platform = bootParams.boot_platform;
+            payload.boot_platform = bootParams.boot_platform;
         }
 
         if (bootParams.boot_modules) {
-            server.boot_modules = bootParams.boot_modules;
+            payload.boot_modules = bootParams.boot_modules;
         }
 
         var k;
         if (bootParams.boot_params) {
-            if (!server.boot_params) {
-                server.boot_params = {};
+            payload.boot_params = server.boot_params;
+            if (!payload.boot_params) {
+                payload.boot_params = {};
             }
             for (k in bootParams.boot_params) {
                 if (bootParams.boot_params[k] === null) {
-                    delete server.boot_params[k];
+                    delete payload.boot_params[k];
                     continue;
                 }
-                server.boot_params[k] = bootParams.boot_params[k];
+                payload.boot_params[k] = bootParams.boot_params[k];
             }
         }
 
         if (bootParams.kernel_flags) {
-            if (!server.kernel_flags) {
-                server.kernel_flags = {};
+            payload.kernel_flags = server.kernel_flags;
+            if (!payload.kernel_flags) {
+                payload.kernel_flags = {};
             }
             for (k in bootParams.kernel_flags) {
                 if (bootParams.kernel_flags[k] === null) {
-                    delete server.kernel_flags[k];
+                    delete payload.kernel_flags[k];
                     continue;
                 }
-                server.kernel_flags[k] = bootParams.kernel_flags[k];
+                payload.kernel_flags[k] = bootParams.kernel_flags[k];
             }
         }
 
         var names = ['default_console', 'serial'];
 
         names.forEach(function (n) {
+            payload[n] = server[n];
             if (bootParams[n] === null) {
-                server[n] = '';
+                payload[n] = '';
                 return;
             }
-            server[n] = bootParams[n] || server[n];
+            payload[n] = bootParams[n] || payload[n];
         });
 
-        self.modify(server, function (modifyError) {
-            if (modifyError) {
-                callback(new VError(modifyError,
-                                    'modifying server boot param'));
-                return;
-            }
-            callback();
-            return;
-        });
+        ModelServer.upsert(self.uuid, payload, {
+            etagRetries: 10
+        }, callback);
     });
 };
 
-/**
- * Returns a function which acts as a handler for cn-agent tasks.
- *
- * createTaskHandler takes three arguments:
- * - self: a reference to an instance of Model
- * - eventCallback: which will be called whenever an event is received from
- *   the running task. It gets as arguments the task id and the event object.
- * - callback: the function to be called when the returned function sets up
- *   the task handle handler.
- */
-
-ModelServer.createTaskHandler =
-function (self, params, handlerOpts, eventCallback, callback, synccb) {
-    var persist = handlerOpts.persist !== false ? true : false;
-
-    var taskqueue = async.queue(function (qobj, cb) {
-        var task = qobj;
-        if (!persist) {
-            checkFinished();
-            cb();
-            return;
-        }
-
-        var moray = ModelServer.getMoray();
-        moray.putObject(
-            buckets.tasks.name,
-            task.id,
-            task,
-            function (putError) {
-                if (putError) {
-                    self.log.error({
-                        err: putError,
-                        task_id: task.id
-                    }, 'error doing putObject');
-                }
-
-                checkFinished();
-                cb();
-            });
-
-
-        function checkFinished() {
-            var lastHist = task.history[task.history.length-1];
-
-            if (['complete', 'failure'].indexOf(task.status)
-                     !== -1)
-            {
-                var error;
-                if (lastHist &&
-                    lastHist.event.msg &&
-                    lastHist.event.msg.error)
-                {
-                    error = lastHist.event.msg.error;
-                }
-
-                ModelServer.getApp().alertWaitingTasks(
-                    error && new Error(error), task.id, task);
-
-                if (synccb) {
-                    synccb(null, error ? error: lastHist.event);
-                }
-
-            } else {
-                // On the first push to async.queue, history won't have
-                // anything in it so do not try to pull anything out of it.
-                if (task.history.length) {
-                    var event = lastHist.event;
-                    eventCallback(task, event);
-                }
-            }
-        }
-    }, 1);
-
-    if (synccb) {
-        synccb = once(synccb);
-    }
-
-    return function (taskHandle) {
-        var task = {};
-        self.log.info('Task id = %s', taskHandle.id);
-        task.id = taskHandle.id;
-        task.task = params.task;
-        task.progress = 0;
-        task.server_uuid = self.uuid;
-        task.status = 'active';
-        task.history = [];
-        task.timestamp = (new Date()).toISOString();
-
-        if (persist) {
-            var moray = ModelServer.getMoray();
-            moray.putObject(buckets.tasks.name, taskHandle.id, task,
-                function (putError) {
-                    if (putError) {
-                        self.log.error({ err: putError },
-                            'writing initial task details to moray');
-                            return;
-                    }
-                    taskqueue.push(JSON.parse(JSON.stringify(task)));
-                    callback(null, taskHandle);
-                });
-        } else {
-            taskqueue.push(JSON.parse(JSON.stringify(task)));
-            callback(null, taskHandle);
-        }
-
-
-        taskHandle.on('event', function (eventName, msg) {
-            var event = {
-                name: eventName,
-                event: msg
-            };
-            self.log.debug(event, 'Event details');
-            if (!event.timestamp) {
-                event.timestamp = (new Date()).toISOString();
-            }
-            task.history.push(event);
-
-            switch (eventName) {
-                case 'progress':
-                    task.progress = msg.value;
-                break;
-                case 'error':
-                    if (task.status === 'active') {
-                        task.status = 'failure';
-                        taskqueue.push(JSON.parse(JSON.stringify(task)));
-                    }
-                break;
-                case 'finish':
-                    if (task.status === 'active') {
-                        task.status = 'complete';
-                        taskqueue.push(JSON.parse(JSON.stringify(task)));
-                    }
-                break;
-                default:
-                    break;
-            }
-
-        });
-    };
-};
-
 
 /*
  * Initiates a cn-agent task http request.
@@ -1820,33 +1478,25 @@ function (opts) {
         self.log.info({ params: arguments[0].params }, 'task params');
     }
 
+    assert.object(opts, 'opts');
+    assert.optionalObject(opts.log, 'opts.log');
     assert.string(opts.task, 'opts.task');
     assert.object(opts.params, 'opts.params');
-    assert.optionalObject(opts.req, 'opts.req');
     assert.optionalBool(opts.persist, 'opts.persist');
+    assert.string(opts.req_id, 'opts.req_id');
     assert.func(opts.cb, 'opts.cb');
-    assert.optionalFunc(opts.cb, 'opts.cb');
 
-    var task, params, callback, origreq, persist;
+    var task, params, callback, persist;
 
     var client;
-    var req_id;
     var serverAdminIp;
     var serverAdminPort = 5309;
     var synccb;
     var sysinfo;
 
-    if (opts.req_id) {
-        req_id = opts.req_id;
-    } else if (opts.req) {
-        req_id = opts.req.getId();
-    }
-
-    assert.string(req_id, 'req_id');
-
     var taskstatus = {
         id: common.genId(),
-        req_id: req_id,
+        req_id: opts.req_id,
         task: opts.task,
         server_uuid: self.uuid,
         status: 'active',
@@ -1856,10 +1506,10 @@ function (opts) {
     task = opts.task;
     persist = opts.persist !== false ? true : false;
     params = opts.params;
-    origreq = opts.req;
     callback = opts.cb;
     synccb = opts.synccb;
-    var log = origreq && origreq.log || self.log;
+
+    var log = opts.log || self.log;
 
     var payload = {
         task: task,
@@ -1878,7 +1528,7 @@ function (opts) {
         // XXX this code is the same as ModelServer.prototype.sendRequest
         // could use some deduplication
         function getSysinfo(wfcb) {
-            self.getRaw(function (err, server) {
+            self.getRaw({}, function (err, server) {
                 if (err) {
                     wfcb(new VError(err, err));
                     return;
@@ -1888,14 +1538,13 @@ function (opts) {
                     wfcb(new VError('server not found'));
                     return;
                 }
-                sysinfo = server.sysinfo;
 
-                log.info('sysinfo for %s before task %s', self.uuid, task);
+                sysinfo = server.sysinfo;
 
                 wfcb();
             });
         },
-        function getCnapiLocationFromSysinfo(wfcb) {
+        function getCnAgentLocationFromSysinfo(wfcb) {
             /*
              * agentIpFromSysinfo() is intended for use with mockcloud which
              * requires the use of a different IP for contacting agents on a
@@ -1905,7 +1554,7 @@ function (opts) {
              */
             serverAdminIp = netconfig.agentIpFromSysinfo(sysinfo);
             if (!serverAdminIp) {
-                wfcb(new VError('parsing server ip address in sendTaskReq '
+                wfcb(new VError('Parsing server ip address in sendTaskReq '
                     + '(No admin NICs detected.)'));
                 return;
             }
@@ -1943,18 +1592,17 @@ function (opts) {
 
             rOpts.headers = {
                 'x-server-uuid': self.uuid,
-                'x-request-id': req_id
+                'x-request-id': opts.req_id
             };
 
             client = restify.createJsonClient(cOpts);
 
             log.info('posting task to %s%s (req_id=%s)',
-                     cOpts.url, rOpts.path, req_id);
+                     cOpts.url, rOpts.path, opts.req_id);
 
             // write initial task to moray
             // post http request
             // on response from post, write to moray again
-            // call evcb();
 
             // TODO get taskstatus.history from the response from cn-agent
             client.post(rOpts, payload, function (err, req, res, obj) {
@@ -2019,9 +1667,6 @@ function (opts) {
                     });
                 }
 
-
-                log.info({ obj: obj }, 'post came back with');
-
                 if (synccb) {
                     synccb(null, obj);
                 }
@@ -2088,7 +1733,7 @@ ModelServer.prototype.sendRequest = function (opts, cb) {
         // XXX this code is the same as ModelServer.prototype.sendTaskRequest
         // could use some deduplication
         function getSysinfo(wfcb) {
-            self.getRaw(function (err, server) {
+            self.getRaw({}, function (err, server) {
                 if (err) {
                     wfcb(new VError(err, err));
                     return;
@@ -2181,7 +1826,6 @@ ModelServer.prototype.zfsTask = function (task, opts, callback) {
         task: task,
         cb: function (error, taskstatus) {
         },
-        evcb: function () {},
         synccb: function (error, result) {
             callback(error, result);
         },
@@ -2207,4 +1851,444 @@ ModelServer.prototype.getWaitlist = function () {
 };
 
 
+/*
+ * This function is a helper for ModelServer.upsert. It does all the work of
+ * performing a single attempt, and on ETag failure, kicking off the next
+ * attempt.
+ */
+ModelServer._attemptUpsert =
+function _attemptUpsert(opts, serverUuid, properties, etagRetries, callback) {
+    assert.object(opts, 'opts');
+    assert.object(opts.log, 'opts.log');
+    assert.uuid(serverUuid, 'serverUuid');
+    assert.object(properties, 'properties');
+    assert.number(etagRetries, 'etagRetries');
+    assert.func(callback, 'callback');
+
+    var modified = false;
+
+    vasync.pipeline({arg: {}, funcs: [
+        function _getServer(ctx, cb) {
+            ModelServer.getMoray().getObject(
+                buckets.servers.name,
+                serverUuid,
+                function (err, obj) {
+                    if (err) {
+                        if (VError.hasCauseWithName(err,
+                            'ObjectNotFoundError')) {
+
+                            ctx.serverIsNew = true;
+                            cb();
+                            return;
+                        }
+                        cb(err);
+                        return;
+                    }
+
+                    ctx.serverIsNew = false;
+                    ctx.etag = obj._etag;
+                    ctx.serverObj = obj.value;
+
+                    opts.log.trace({
+                        isNew: ctx.serverIsNew,
+                        serverObj: ctx.serverObj
+                    }, 'Got object from moray');
+
+                    cb();
+                });
+        }, function _initializeIfNew(ctx, cb) {
+            if (!ctx.serverIsNew) {
+                cb();
+                return;
+            }
+
+            ModelServer.initialValues({}, function (err, serverObj) {
+                if (err) {
+                    cb(err);
+                    return;
+                }
+
+                opts.log.trace({
+                    properties: properties,
+                    serverObj: serverObj
+                }, 'Initial new server');
+
+                serverObj.uuid = serverUuid;
+                ctx.serverObj = serverObj;
+                modified = true; // need to write this out since it's new
+
+                cb();
+            });
+        }, function _applyProperties(ctx, cb) {
+            var field;
+            var idx;
+            var keys;
+            var newServerObj = jsprim.deepCopy(ctx.serverObj);
+            var reservation_ratio;
+            var total_memory;
+            var value;
+
+            // Under all circumstances, we want the new object to have its
+            // UUID. This guarantees we'll never write a newServerObj w/o
+            // including the UUID. Even if the old object was broken and
+            // missing one.
+            newServerObj.uuid = serverUuid;
+
+            keys = Object.keys(properties).filter(function (k) {
+                if (ctx.serverIsNew) {
+                    // On a new server, we can set all fields.
+                    return true;
+                }
+
+                if (NON_UPDATABLE_KEYS.indexOf(k) === -1) {
+                    // not in blacklist
+                    return true;
+                }
+
+                if (jsprim.deepEqual(newServerObj[k], properties[k])) {
+                    // values are same, so we're not actually updating
+                    return false;
+                }
+
+                opts.log.debug({
+                    key: k,
+                    serverUuid: serverUuid
+                }, 'attempt to update non-updatable key, ignoring');
+
+                return false;
+            });
+
+            for (idx = 0; idx < keys.length; idx++) {
+                field = keys[idx];
+                value = properties[field];
+
+                if (!jsprim.deepEqual(newServerObj[field], value)) {
+                    newServerObj[field] = value;
+                    modified = true;
+                }
+            }
+
+            // BEGIN BACKWARD COMPAT SECTION
+
+            if (properties.sysinfo) {
+                // For backward compat, we only set agents to 'SDC Agents'
+                // when we don't have server.agents. Usually, agents will
+                // be sent by cn-agent via 'POST /servers/<uuid>' when it
+                // starts up.
+                if (!newServerObj.agents ||
+                    (newServerObj.agents &&
+                        Array.isArray(newServerObj.agents) &&
+                        newServerObj.agents.length === 0 &&
+                        properties.sysinfo['SDC Agents'])) {
+
+                    newServerObj.agents = properties.sysinfo['SDC Agents'];
+                    modified = true;
+                }
+            }
+
+            // For backward compat, we recalculate
+            // memory_provisionable_bytes whenever we're changing any fields
+            // that go into this calculation.
+            //
+            // In the future we should redefine how this works.
+            if (newServerObj.reservationRatio && newServerObj.vms &&
+                (properties.reservation_ratio ||
+                properties.vms ||
+                properties.sysinfo ||
+                properties.memory_total_bytes)) {
+
+                total_memory = 0;
+                if (newServerObj.sysinfo &&
+                    newServerObj.sysinfo['MiB of Memory']) {
+
+                    total_memory = newServerObj.sysinfo['MiB of Memory'] *
+                        1024 * 1024;
+                } else if (newServerObj.memory_total_bytes) {
+                    total_memory = newServerObj.memory_total_bytes;
+                }
+
+                if (total_memory > 0) {
+                    reservation_ratio = newServerObj.reservation_ratio;
+                    newServerObj.memory_provisionable_bytes =
+                        total_memory - (total_memory * reservation_ratio);
+                    newServerObj.memory_provisionable_bytes -= 1024 * 1024 *
+                        Object.keys(newServerObj.vms)
+                            .map(function (uuid) {
+                                return newServerObj.vms[uuid];
+                            })
+                            .reduce(function (prev, curr) {
+                                return prev + curr.max_physical_memory;
+                            }, 0);
+                    newServerObj.memory_provisionable_bytes =
+                        Math.floor(newServerObj.memory_provisionable_bytes);
+
+                    modified = true;
+                } else {
+                    opts.log.warn('Unable to determine total memory, ' +
+                        'not updating memory_provisionable_bytes');
+                }
+            }
+
+            // DAPI hardcodes all overprovision_ratio values, so we don't
+            // bother storing these to the object. Eventually overprovisioning
+            // will go away, sanity will prevail, and this will no longer be
+            // necessary.
+            delete newServerObj.overprovision_ratios;
+
+            // END BACKWARD COMPAT SECTION
+
+            ctx.newServerObj = newServerObj;
+
+            cb();
+        }, function _removeIllegalProperties(ctx, cb) {
+            var extraProps;
+            var idx;
+            var prop;
+
+            if (!modified) {
+                // Don't worry about extra properties if we're not going to
+                // write anyway.
+                cb();
+                return;
+            }
+
+            extraProps =
+                jsprim.extraProperties(ctx.newServerObj, SERVER_KEYS);
+
+            if (extraProps.length > 0) {
+                opts.log.warn({unexpectedProps: extraProps},
+                    'Object has unexpected properties');
+            }
+
+            for (idx = 0; idx < extraProps.length; idx++) {
+                 prop = extraProps[idx];
+                 delete ctx.newServerObj[prop];
+            }
+
+            cb();
+        }, function _putObject(ctx, cb) {
+            var putOpts = {};
+
+            if (!modified) {
+                cb();
+                return;
+            }
+
+            if (ctx.etag) {
+                putOpts.etag = ctx.etag;
+            }
+
+            opts.log.trace({
+                diff: deepDiff(ctx.serverIsNew ?  {} : ctx.serverObj,
+                    ctx.newServerObj),
+                putOpts: putOpts,
+                serverUuid: ctx.newServerObj.uuid
+            }, 'Writing change');
+
+            ModelServer.getMoray().putObject(
+                buckets.servers.name,
+                ctx.newServerObj.uuid,
+                ctx.newServerObj,
+                putOpts,
+                function (error) {
+                    opts.log[error ? 'warn' : 'trace']({
+                        err: error,
+                        uuid: ctx.newServerObj.uuid,
+                        value: ctx.newServerObj
+                    }, 'Upsert putObject');
+
+                    cb(error);
+                });
+        }
+    ]}, function _triedPut(err) {
+        if (err && VError.hasCauseWithName(err, 'EtagConflictError') &&
+            etagRetries > 0) {
+
+            setImmediate(ModelServer._attemptUpsert,
+                opts,
+                serverUuid,
+                properties,
+                etagRetries - 1,
+                callback);
+
+            return;
+        }
+
+        callback(err);
+    });
+};
+
+
+/*
+ * This function takes a serverUuid and some properties and then:
+ *
+ *  - tries to get the existing server object with this uuid from moray
+ *  - if the server does not exist, a fresh server object is created
+ *  - the properties are then applied to the server object
+ *  - the resulting object is written out to moray
+ *
+ * If the final write fails due to an ETag error, and opts.etagRetries is set to
+ * a value > 0, the whole process is immediately retried by calling itself again
+ * after decrementing etagRetries.
+ *
+ * The intention is that this is the only function that actually writes server
+ * records to Moray, so that we can ensure this is handled in a consistent way.
+ *
+ */
+ModelServer.upsert = function upsert(serverUuid, properties, opts, callback) {
+    var self = this;
+
+    // NOTE: we don't validate parameters here because they're validated in
+    // ModelServer._attemptUpsert.
+
+    ModelServer._attemptUpsert({
+        log: self.log
+    }, serverUuid, properties, opts.etagRetries || 0, callback);
+};
+
+
+/*
+ * This can go away when TRITON-1216 is implemented and rolled out everywhere.
+ */
+function doNapiSysinfoUpdate(opts, callback) {
+    assert.object(opts, 'opts');
+    assert.object(opts.log, 'opts.log');
+    assert.object(opts.napi, 'opts.napi');
+    assert.object(opts.sysinfo, 'opts.sysinfo');
+    assert.func(callback, 'callback');
+
+    var n;
+    var nic;
+    var sysinfo = opts.sysinfo;
+    var t;
+    var tags = [];
+    var tag;
+
+    for (n in sysinfo['Network Interfaces']) {
+        nic = sysinfo['Network Interfaces'][n];
+        if (nic.hasOwnProperty('NIC Names')) {
+            for (t in nic['NIC Names']) {
+                tag = nic['NIC Names'][t];
+
+                if (tags.indexOf(tag) === -1) {
+                    tags.push(tag);
+                }
+            }
+        }
+    }
+
+    opts.log.info({
+        serverUuid: opts.sysinfo.UUID,
+        tags: tags
+    }, 'Updating NAPI nic_tags due to sysinfo');
+
+    if (tags.length === 0) {
+        callback();
+        return;
+    }
+
+    vasync.forEachParallel({
+        inputs: tags,
+        func: function (tagparam, cb) {
+            opts.napi.createNicTag(tagparam, function (err, res) {
+                if (err) {
+                   if (!(err.body && err.body.errors &&
+                       err.body.errors[0].code === 'Duplicate')) {
+                       opts.log.error({
+                           err: err,
+                           tag: tagparam
+                       }, 'Error adding nic tag to NAPI');
+
+                       cb(err);
+                       return;
+                   }
+                }
+                cb();
+            });
+        }
+    }, callback);
+}
+
+
+ModelServer.updateFromSysinfo = function updateFromSysinfo(sysinfo, callback) {
+    var self = this;
+
+    assert.object(sysinfo, 'sysinfo');
+    assert.uuid(sysinfo.UUID, 'sysinfo.UUID');
+    assert.func(callback, 'callback');
+
+    var napi;
+    var napiUrl = ModelServer.getConfig().napi.url;
+    var serverUuid = sysinfo.UUID;
+    var updateObj = {};
+
+    napi = new sdcClients.NAPI({ url: napiUrl });
+
+    function _setField(obj, serverField, sysinfoField, transform) {
+        var value = sysinfo[sysinfoField];
+
+        if (transform !== undefined) {
+            value = transform(value);
+        }
+
+        if (value === undefined) {
+            return;
+        }
+
+        obj[serverField] = value;
+    }
+
+    self.log.trace({sysinfo: sysinfo}, 'updateFromsysinfo');
+
+    vasync.pipeline({funcs: [
+        function _updateNapi(_, cb) {
+            // This can go away when TRITON-1216 is implemented and rolled out
+            // everywhere.
+            doNapiSysinfoUpdate({
+                log: self.log,
+                napi: napi,
+                sysinfo: sysinfo
+            }, cb);
+        }, function _buildUpdateObj(_, cb) {
+            updateObj.sysinfo = sysinfo;
+
+            _setField(updateObj, 'created', 'Zpool Creation', function (v) {
+                if (v === undefined) {
+                    return v;
+                }
+                return (new Date(Number(v) * 1000)).toISOString();
+            });
+            _setField(updateObj, 'current_platform', 'Live Image');
+            _setField(updateObj, 'headnode', 'Boot Parameters', function (v) {
+                if (v === undefined) {
+                    return v;
+                }
+                return (v.headnode === 'true');
+            });
+            _setField(updateObj, 'hostname', 'Hostname');
+            _setField(updateObj, 'last_boot', 'Boot Time', function (v) {
+                if (v === undefined) {
+                    return v;
+                }
+                return (new Date(Number(v) * 1000)).toISOString();
+            });
+            _setField(updateObj, 'ram', 'MiB of Memory', function (v) {
+                if (v === undefined) {
+                    return v;
+                }
+                return (parseInt(v, 10));
+            });
+            _setField(updateObj, 'setup', 'Setup', function (v) {
+                return (v === 'true' || v === true);
+            });
+
+            cb();
+        }, function _doUpsert(_, cb) {
+            ModelServer.upsert(serverUuid, updateObj, {
+                etagRetries: 0
+            }, cb);
+        }
+    ]}, callback);
+};
+
 module.exports = ModelServer;
diff --git a/lib/models/vm.js b/lib/models/vm.js
index 62cd629..e1683ba 100644
--- a/lib/models/vm.js
+++ b/lib/models/vm.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2016, Joyent, Inc.
+ * Copyright (c) 2019, Joyent, Inc.
  */
 
 /*
@@ -62,16 +62,15 @@ ModelVM.prototype.load = function (opts, callback) {
 
     ModelServer.get(self.serverUuid, function (err, servermodel) {
         var request = {
+            log: opts.req.log,
             persist: false,
             task: 'machine_load',
             cb: function (error, task) {
             },
-            evcb: function () {},
             synccb: function (error, result) {
                 callback(error, result);
             },
             req_id: opts.req_id,
-            req: opts.req,
             params: { uuid: self.uuid }
         };
 
@@ -93,7 +92,6 @@ ModelVM.prototype.proc = function (opts, callback) {
             task: 'machine_proc',
             cb: function (error, task) {
             },
-            evcb: function () {},
             synccb: function (error, result) {
                 callback(error, result);
             },
@@ -119,7 +117,6 @@ ModelVM.prototype.info = function (opts, callback) {
             task: 'machine_info',
             cb: function (error, task) {
             },
-            evcb: function () {},
             synccb: function (error, result) {
                 callback(error, result);
             },
@@ -139,7 +136,6 @@ ModelVM.prototype.dockerCopy = function (opts, callback) {
         var request = {
             task: 'docker_copy',
             cb: function (error, task) {},
-            evcb: function () {},
             synccb: function (error, result) {
                 callback(error, result);
             },
@@ -165,7 +161,6 @@ ModelVM.prototype.dockerStats = function (opts, callback) {
         var request = {
             task: 'docker_stats',
             cb: function (error, task) {},
-            evcb: function () {},
             synccb: function (error, result) {
                 callback(error, result);
             },
@@ -185,7 +180,6 @@ ModelVM.prototype.dockerExec = function (opts, callback) {
         var request = {
             task: 'docker_exec',
             cb: function (error, task) {},
-            evcb: function () {},
             synccb: function (error, stream) {
                 callback(error, stream);
             },
@@ -205,7 +199,6 @@ ModelVM.prototype.dockerBuild = function (opts, callback) {
         var request = {
             task: 'docker_build',
             cb: function (error, task) {},
-            evcb: function () {},
             synccb: function (error, result) {
                 callback(error, result);
             },
@@ -241,12 +234,11 @@ function (task, checkExists, req, res, next, synccb) {
                        task: task, params: req.params},
                       'sending vm cn-agent task');
         servermodel.sendTaskRequest({
+            log: req.log,
             task: task,
             params: req.params,
-            req: req,
+            req_id: req.getId(),
             synccb: synccb,
-            evcb: ModelServer.createComputeNodeAgentHandler(
-                self, req.params.jobid),
             cb: createTaskCallback(req, res, next)
         });
     });
diff --git a/lib/ur.js b/lib/ur.js
index 0a058e4..226d8e5 100644
--- a/lib/ur.js
+++ b/lib/ur.js
@@ -62,108 +62,6 @@ Ur.prototype.bindQueues = function () {
 };
 
 
-/* BEGIN JSSTYLED */
-/**
- * Executes the sysinfo utility on the given compute node and then returns the
- * parsed object.
- *
- * @name UrServerSysinfo
- * @section CnapiUr
- *
- * @param {String} uuid UUID of server on which to run sysinfo
- * @param {Function} callback Function to call once sysinfo processed
- */
-/* END JSSTYLED */
-
-
-Ur.prototype.serverSysinfo = function (uuid, opts, callback) {
-    var self = this;
-
-    var execopts = {
-        'uuid': uuid,
-        'timeoutSeconds': opts.timeoutSeconds,
-        'message': {
-            'type': 'file',
-            'file': '/usr/bin/sysinfo',
-            'args': ['-f']
-        }
-    };
-    opts.uuid = uuid;
-
-    self.execute(execopts, function (err, stdout, stderr, exitStatus) {
-        if (err) {
-            self.log.error(err);
-            return callback(err);
-        }
-
-        // script exited non-zero.
-        if (exitStatus !== 0) {
-            callback(new Error('Error executing on remote system'));
-            return;
-        }
-
-        var sysinfo;
-        try {
-            sysinfo = JSON.parse(stdout.toString());
-        } catch (e) {
-            self.log.error(e);
-            callback(e);
-            return;
-        }
-        return callback(null, sysinfo);
-    });
-};
-
-
-Ur.prototype.broadcastSysinfo = function (callback) {
-    var self = this;
-    var timeout = 10;
-    var sysinfoCollection = [];
-    self.log.info(
-        'Requesting broadcast sysinfo from compute nodes in datacenter');
-    var reqid = common.genId();
-    var qname = 'ur.cnapi.' + reqid;
-    var ctag;
-
-    this.connection.queue(qname, {
-        autoDelete: true,
-        closeChannelOnUnsubscribe: true
-    }, function (queue) {
-        queue.on('error', function (e) {
-            self.log.warn(e, 'BROADCAST QUEUE ERROR execute');
-        });
-
-        queue.subscribe(function (msg, headers, deliveryInfo, messageObject) {
-            sysinfoCollection.push(msg);
-        })
-        .addCallback(function (ok) {
-            ctag = ok.consumerTag;
-
-            queue.bind('ur.execute-reply.*.' + reqid,
-                function () {
-                    exchange.publish(
-                        'ur.broadcast.sysinfo.' + reqid,
-                        {
-                            type: 'file',
-                            file: '/usr/bin/sysinfo'
-                        });
-                });
-        });
-
-        var exchange = self.connection.exchange('amq.topic');
-        setTimeout(function () {
-            self.log.info('Collected sysinfo from %d servers',
-                sysinfoCollection.length);
-            queue.unsubscribe(ctag);
-            setTimeout(function () {
-                queue.destroy();
-            }, 1000);
-            callback(null, sysinfoCollection);
-        }, timeout * 1000);
-    });
-};
-
-
 /* BEGIN JSSTYLED */
 /**
  * Sends an Ur execute payload to a given server's Ur agent and then returns
@@ -200,7 +98,7 @@ Ur.prototype.execute = function (opts, callback) {
         });
 
         queue.subscribe(function (msg, headers, deliveryInfo, messageObject) {
-            self.log.info({ obj: msg }, 'The message');
+            self.log.trace({ obj: msg }, 'Ur reply');
             clearTimeout(timeout);
             queue.unsubscribe(ctag);
             setTimeout(function () {
diff --git a/lib/workflows/server-setup.js b/lib/workflows/server-setup.js
index 3327b33..f50e4f5 100644
--- a/lib/workflows/server-setup.js
+++ b/lib/workflows/server-setup.js
@@ -28,7 +28,6 @@ var VERSION = '1.0.4';
 
 var cnapiCommon = require('wf-shared').cnapi;
 var napiCommon = require('wf-shared').napi;
-var sdcClients = require('sdc-clients');
 var restify = require('restify');
 
 function validateParams(job, callback) {
@@ -80,7 +79,6 @@ function fetchSetupFiles(job, callback) {
     var cnapiUrl = job.params.cnapi_url;
     var assetsUrl = job.params.assets_url;
     var cnapi = restify.createJsonClient({ url: cnapiUrl});
-    var overprovision_ratio = job.params.overprovision_ratio || '1.0';
     var nodeConfigDir = 'config-' + job.params.server_uuid;
     var diskCfg = '';
     if (job.params.disk_layout) {
@@ -102,8 +100,7 @@ function fetchSetupFiles(job, callback) {
         'cd /var/tmp',
         'mkdir /var/tmp/node.config',
         'mkdir /var/tmp/' + nodeConfigDir,
-        '(echo "overprovision_ratio=\'' + overprovision_ratio + '\'"; ' +
-             diskCfg +
+        '(' + diskCfg +
              'curl $1/extra/joysetup/node.config) | tee ' + nodeConfigDir +
              '/node.config node.config/node.config >&-',
         'curl -O $1/extra/joysetup/joysetup.sh',
@@ -457,12 +454,6 @@ module.exports = {
             retry: 1,
             body: touchSetupComplete
         },
-        {
-            name: 'cnapi.refresh_server_sysinfo',
-            timeout: 1000,
-            retry: 1,
-            body: cnapiCommon.refreshServerSysinfo
-        },
         {
             name: 'cnapi.reboot_server',
             timeout: 600,
diff --git a/lib/workflows/server-sysinfo.js b/lib/workflows/server-sysinfo.js
deleted file mode 100644
index 40e3e11..0000000
--- a/lib/workflows/server-sysinfo.js
+++ /dev/null
@@ -1,640 +0,0 @@
-/*
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/.
- */
-
-/*
- * Copyright (c) 2018, Joyent, Inc.
- */
-
-/*
- * This is the workflow responsible for processing a server's sysinfo.
- *
- * - CNAPI receives sysinfo
- * - CNAPI starts workflow
- * - Get server's pre-existing nics from NAPI
- * - Update NAPI with any changed nics and aggrs
- * - Add any new nics and aggrs to NAPI
- *
- * NICs are not deleted from NAPI by this workflow, which if required (e.g. a
- * swap of the physical NIC on the server) should be done directly by the
- * operator via the DeleteNic endpoint in NAPI.
- */
-
-var VERSION = '1.1.3';
-
-var sdcClients = require('sdc-clients');
-var vasync = require('vasync');
-
-// Prevent jsl from complaining.
-var napiUrl = global.napiUrl;
-
-function validateParams(job, callback) {
-    if (!napiUrl) {
-        callback(new Error('NAPI url not set in workflow runner config'));
-        return;
-    }
-
-    if (!job.params.admin_uuid) {
-        callback(new Error('Must specify admin_uuid'));
-        return;
-    }
-
-    if (!job.params.server_uuid) {
-        callback(new Error('Must specify server_uuid'));
-        return;
-    }
-
-    if (!job.params.sysinfo) {
-        callback(new Error('Must specify sysinfo'));
-        return;
-    }
-
-    callback(null, 'Parameters validated');
-}
-
-
-// Query NAPI to see if the sysinfo nics already exist - necessary to catch
-// the case where the nics do exist, but have a different owner
-function getExistingNics(job, callback) {
-    var sysinfo = job.params.sysinfo;
-    var napi = new sdcClients.NAPI({ url: napiUrl });
-    var macs = [];
-    var n;
-
-    for (n in sysinfo['Network Interfaces']) {
-        macs.push(sysinfo['Network Interfaces'][n]['MAC Address']);
-    }
-    for (n in sysinfo['Virtual Network Interfaces']) {
-        macs.push(sysinfo['Virtual Network Interfaces'][n]['MAC Address']);
-    }
-
-    job.params.existingNics = [];
-
-    vasync.forEachParallel({
-        inputs: macs,
-        func: function (mac, next) {
-            napi.getNic(mac, function (err, nic) {
-                job.log.info({
-                    nic: nic ? nic : '<unknown>',
-                    res: err ? 'error: ' + err.message : 'success'
-                }, 'got existing: ' + mac);
-
-                if (err && err.statusCode !== 404) {
-                    return next(err);
-                }
-
-                if (nic) {
-                    job.params.existingNics.push(nic);
-                }
-
-                next();
-            });
-        }
-    },
-    function (err) {
-        if (err) {
-            return callback(err);
-        }
-        job.log.info(
-            { existingNics: job.params.existingNics },
-            'got existing nics from NAPI');
-        return callback(null, 'Got existing nics from NAPI');
-    });
-
-}
-
-
-function getExistingAggrs(job, cb) {
-    var sysinfo = job.params.sysinfo;
-    var napi = new sdcClients.NAPI({ url: napiUrl });
-    var a;
-    var aggr;
-    var errs = [];
-    var listed = 0;
-    var macs = [];
-    var m;
-    var name;
-    var sysAggr = {};
-    var ids = [];
-
-    job.params.existingAggrs = [];
-    job.params.sysinfoAggrs = {};
-
-    if (!sysinfo.hasOwnProperty('Link Aggregations')) {
-        cb(null, 'No link aggregations in sysinfo');
-        return;
-    }
-
-    for (name in sysinfo['Link Aggregations']) {
-        aggr = sysinfo['Link Aggregations'][name];
-        sysAggr = {};
-        for (a in aggr) {
-            sysAggr[a] = aggr[a];
-        }
-        job.params.sysinfoAggrs[name] = sysAggr;
-
-        for (m in aggr.macs) {
-            if (macs.indexOf(aggr.macs[m]) === -1) {
-                macs.push(aggr.macs[m]);
-            }
-        }
-    }
-
-    function afterAggrList(err, aggrs) {
-        if (err) {
-            job.log.error(err, 'Error listing aggregations');
-            errs.push(err);
-
-        } else {
-            job.log.info({ aggrs: aggrs }, 'retrieved existing aggregations');
-            for (var ag in aggrs) {
-                if (ids.indexOf(aggrs[ag].id) === -1) {
-                    ids.push(aggrs[ag].id);
-                    job.params.existingAggrs.push(aggrs[ag]);
-                }
-            }
-        }
-
-        if (++listed === 2) {
-            if (errs.length !== 0) {
-                cb(null, new Error('Error listing aggregations'));
-            } else {
-                job.log.info({
-                    sysinfoAggrs: job.params.sysinfoAggrs,
-                    existingAggrs: job.params.existingAggrs
-                }, 'Got existing aggregations from NAPI');
-                cb(null, 'Got existing aggregations from NAPI');
-            }
-
-            return;
-        }
-    }
-
-    napi.listAggrs({ macs: macs }, afterAggrList);
-    napi.listAggrs({ belongs_to_uuid: sysinfo.UUID }, afterAggrList);
-}
-
-
-function getServerNics(job, cb) {
-    var napi = new sdcClients.NAPI({ url: napiUrl });
-    var adminTag = 'admin';
-    var sysAdminTag = job.params.sysinfo['Admin NIC Tag'];
-
-    if (sysAdminTag) {
-        adminTag = sysAdminTag;
-    }
-
-    napi.getNics(job.params.sysinfo['UUID'], function (err, nics) {
-        if (err) {
-            cb(err);
-            return;
-        }
-
-        // Now that we have the current nics, go through and figure out
-        // if they're adds, updates, or no change.
-        var sysinfo = job.params.sysinfo;
-        var uuid = sysinfo['UUID'];
-        var aggrNics = [];
-        var napiNics = {};
-        var toAddNics = [];
-        var toUpdateNics = [];
-        var sysinfoAggrs = {};
-        var sysinfoNics = {};
-        var n;
-
-        if (sysinfo.hasOwnProperty('Link Aggregations')) {
-            for (n in sysinfo['Link Aggregations']) {
-                sysinfoAggrs[n] = sysinfo['Link Aggregations'][n];
-            }
-        }
-
-        for (n in sysinfo['Network Interfaces']) {
-            if (sysinfoAggrs.hasOwnProperty(n)) {
-                // Don't add if it's an aggregation
-                aggrNics.push(n);
-
-            } else {
-                sysinfoNics[n] = sysinfo['Network Interfaces'][n];
-            }
-        }
-        for (n in sysinfo['Virtual Network Interfaces']) {
-            if (sysinfoAggrs.hasOwnProperty(n)) {
-                // Don't add if it's an aggregation
-                aggrNics.push(n);
-
-            } else {
-                sysinfoNics[n] = sysinfo['Virtual Network Interfaces'][n];
-            }
-        }
-
-        if (aggrNics.length !== 0) {
-            job.log.info({ aggrs: aggrNics },
-                'Skipped adding interfaces because they are link aggregations');
-        }
-
-        for (n in nics) {
-            napiNics[nics[n].mac] = nics[n];
-        }
-        for (n in job.params.existingNics) {
-            napiNics[job.params.existingNics[n].mac]
-                = job.params.existingNics[n];
-        }
-
-        var listEqual;
-
-        for (n in sysinfoNics) {
-            var sysinfoNic = sysinfoNics[n];
-            var napiNic = napiNics[sysinfoNic['MAC Address']];
-            var newNic = {};
-
-            job.log.info({ sysinfoNic: sysinfoNic, napiNic: napiNic },
-                'Checking nic for changes: ' + sysinfoNic['MAC Address']);
-
-            if (!napiNic) {
-                newNic = {
-                  mac: sysinfoNic['MAC Address'],
-                  belongs_to_uuid: uuid,
-                  belongs_to_type: 'server',
-                  owner_uuid: job.params.admin_uuid
-                };
-
-                if (sysinfoNic.ip4addr) {
-                    newNic.ip = sysinfoNic.ip4addr;
-                }
-
-                if (sysinfoNic.hasOwnProperty('NIC Names')) {
-                    newNic.nic_tags_provided = sysinfoNic['NIC Names'];
-                }
-
-                /*
-                 * Only the admin nic should be on the PHYS datalink and have
-                 * an IP (and thus no VLAN id).
-                 */
-                if (!sysinfoNic.hasOwnProperty('VLAN') && sysinfoNic.ip4addr) {
-                    newNic.nic_tag = adminTag;
-                    newNic.vlan_id = 0;
-                }
-
-                if (sysinfoNic.hasOwnProperty('VLAN')) {
-                    newNic.nic_tag = n.replace(/\d+/, '');
-                    newNic.vlan_id = Number(sysinfoNic['VLAN']);
-                }
-
-                toAddNics.push(newNic);
-                continue;
-            }
-
-            if (sysinfoNic.ip4addr && (napiNic.ip !== sysinfoNic.ip4addr)) {
-                newNic.ip = sysinfoNic.ip4addr;
-            }
-
-            if (napiNic.belongs_to_uuid !== uuid) {
-                newNic.belongs_to_uuid = uuid;
-            }
-
-            if (napiNic.belongs_to_type !== 'server') {
-                newNic.belongs_to_type = 'server';
-            }
-
-            // This can't be declared outside of this function, otherwise it
-            // can't be seen when running in a workflow
-            listEqual = function (a, b) {
-                if (!a && !b) {
-                    return true;
-                }
-
-                if (!a || !b || (a.length !== b.length)) {
-                    return false;
-                }
-
-                a.sort();
-                b.sort();
-
-                for (var i = 0; i < a.length; i++) {
-                    if (a[i] !== b[i]) {
-                        return false;
-                    }
-                }
-
-                return true;
-            };
-
-            var equal =
-                listEqual(sysinfoNic['NIC Names'], napiNic.nic_tags_provided);
-
-            if (sysinfoNic.hasOwnProperty('NIC Names') && !equal) {
-                newNic.nic_tags_provided = sysinfoNic['NIC Names'];
-            }
-
-            if (Object.keys(newNic).length !== 0) {
-                newNic.mac = sysinfoNic['MAC Address'];
-                toUpdateNics.push(newNic);
-            }
-
-            delete napiNics[sysinfoNic['MAC Address']];
-        }
-
-        job.params.updateNics = toUpdateNics;
-        job.params.addNics = toAddNics;
-
-        job.log.info({
-            updateNics: toUpdateNics,
-            addNics: toAddNics,
-            napiNics: nics
-        }, 'Got old nics from NAPI');
-
-        cb(null, 'Got old nics from NAPI');
-        return;
-    });
-}
-
-
-function createNicTags(job, callback) {
-    var napi = new sdcClients.NAPI({ url: napiUrl });
-    var sysinfo = job.params.sysinfo;
-    var tags = [];
-    var tag;
-
-    for (var n in sysinfo['Network Interfaces']) {
-        var nic = sysinfo['Network Interfaces'][n];
-        if (nic.hasOwnProperty('NIC Names')) {
-            for (var t in nic['NIC Names']) {
-                tag = nic['NIC Names'][t];
-
-                if (tags.indexOf(tag) === -1) {
-                    tags.push(tag);
-                }
-            }
-        }
-    }
-
-    if (tags.length === 0) {
-        callback(null, 'No nic tags to create in NAPI');
-        return;
-    }
-
-    vasync.forEachParallel({
-        inputs: tags,
-        func: function (tagparam, next) {
-            napi.createNicTag(tagparam, function (err, res) {
-                if (err) {
-                   if (!(err.body && err.body.errors &&
-                       err.body.errors[0].code === 'Duplicate')) {
-                       job.log.error(err, 'Error adding nic tag %s to NAPI',
-                           tagparam);
-                       return next(err);
-                   }
-                }
-                next();
-            });
-        }
-    },
-    function (err) {
-        if (err) {
-            return callback(err);
-        }
-        callback(null, 'added nic tags to NAPI');
-    });
-}
-
-
-function updateNics(job, callback) {
-    var length = job.params.updateNics.length;
-    if (length === 0) {
-        callback(null, 'No nics to update: returning');
-        return;
-    }
-
-    var napi = new sdcClients.NAPI({ url: napiUrl });
-    var updated = [];
-
-    vasync.forEachParallel({
-        inputs: job.params.updateNics,
-        func: function (params, next) {
-            napi.updateNic(params.mac, params, function (err, nic) {
-                job.log.info({
-                    res: nic,
-                    params: params,
-                    status: err ? 'error: ' + err.message : 'success'
-                }, 'updated nic: ' + params.mac);
-                if (err) {
-                    next(err);
-                    return;
-                }
-                updated.push(params.mac);
-                next();
-            });
-        }
-    },
-    function (err) {
-        if (err) {
-            return callback(err);
-        }
-        callback(null, 'nics updated: ' + updated.join(', '));
-        return;
-    });
-}
-
-
-function addNics(job, callback) {
-    var length = job.params.addNics.length;
-    if (length === 0) {
-        callback(null, 'No nics to add: returning');
-        return;
-    }
-
-    var napi = new sdcClients.NAPI({ url: napiUrl });
-    var added = [];
-
-    vasync.forEachParallel({
-        inputs: job.params.addNics,
-        func: function (params, next) {
-            napi.createNic(params.mac, params, function (err, nic) {
-                job.log.info({
-                    res: nic,
-                    params: params,
-                    status: err ? 'error: ' + err.message : 'success'
-                }, 'added nic: ' + params.mac);
-                if (err) {
-                    next(err);
-                    return;
-                }
-                added.push(params.mac);
-                next();
-            });
-        }
-    },
-    function (err) {
-        if (err) {
-            return callback(err);
-        }
-        callback(null, 'nics added: ' + added.join(', '));
-        return;
-    });
-}
-
-
-function updateAggrs(job, cb) {
-    if (job.params.existingAggrs.length === 0 &&
-        Object.keys(job.params.sysinfoAggrs).length === 0) {
-        cb(null, 'No aggregations found');
-        return;
-    }
-    var a;
-    var add = [];
-    var aggr;
-    var beforeAggrs = {};
-    var update = [];
-    var serverUUID = job.params.sysinfo.UUID;
-    var sysinfoNics = job.params.sysinfo['Network Interfaces'];
-
-    for (a in job.params.existingAggrs) {
-        aggr = job.params.existingAggrs[a];
-        if (aggr.belongs_to_uuid == serverUUID) {
-            beforeAggrs[aggr.name] = aggr;
-        }
-    }
-
-    for (a in job.params.sysinfoAggrs) {
-        aggr = job.params.sysinfoAggrs[a];
-        var params = {
-            id: serverUUID + '-' + a,
-            lacp_mode: aggr['LACP mode'] || 'off',
-            macs: aggr.Interfaces.map(function (i) {
-                return sysinfoNics[i]['MAC Address'];
-            }),
-            name: a
-        };
-
-        if (beforeAggrs.hasOwnProperty(a)) {
-            update.push(params);
-        } else {
-            add.push(params);
-        }
-    }
-
-    if (update.length === 0 && add.length === 0) {
-        cb(null, 'No aggregations to update');
-        return;
-    }
-
-    var errs = [];
-    var napi = new sdcClients.NAPI({ url: napiUrl });
-    var totalActions = add.length + update.length;
-    var doneActions = 0;
-
-    job.log.info({ add: add, update: update },
-        'Updating aggregations in NAPI');
-
-    for (a in add) {
-        napi.createAggr(add[a], afterAction.bind(napi, 'add', add[a]));
-    }
-
-    for (a in update) {
-        napi.updateAggr(update[a].id, update[a],
-            afterAction.bind(napi, 'update', update[a]));
-    }
-
-    function afterAction(action, actParams, err, res) {
-        if (err) {
-            job.log.error(err, 'NAPI %s error', action);
-            errs.push(err);
-        } else {
-            job.log.info({ params: actParams, res: res },
-                'NAPI %s success', action);
-        }
-
-        if (++doneActions == totalActions) {
-            if (errs.length !== 0) {
-                cb(new Error('Error updating aggregations in NAPI'));
-            } else {
-                cb(null, 'Successfully updated aggregations in NAPI');
-            }
-
-            return;
-        }
-    }
-}
-
-
-function setMocks(obj) {
-    if (obj.hasOwnProperty('napiUrl')) {
-        napiUrl = obj.napiUrl;
-    }
-
-    if (obj.hasOwnProperty('sdcClients')) {
-        sdcClients = obj.sdcClients;
-    }
-}
-
-
-module.exports = {
-    name: 'server-sysinfo-' + VERSION,
-    version: VERSION,
-    onerror: [
-        {
-            name: 'onerror',
-            body: function (job, cb) {
-                cb(new Error('Error executing job'));
-            }
-        }
-    ],
-
-    chain: [
-        {
-            name: 'cnapi.validate_params',
-            timeout: 10,
-            retry: 1,
-            body: validateParams
-        },
-        {
-            name: 'napi.get_existing_nics',
-            timeout: 10,
-            retry: 1,
-            body: getExistingNics
-        },
-        {
-            name: 'napi.get_existing_aggrs',
-            timeout: 10,
-            retry: 1,
-            body: getExistingAggrs,
-            modules: { sdcClients: 'sdc-clients', vasync: 'vasync' }
-        },
-        {
-            name: 'napi.get_old_server_nics',
-            timeout: 10,
-            retry: 1,
-            body: getServerNics
-        },
-        {
-            name: 'napi.create_nictags',
-            timeout: 10,
-            retry: 1,
-            body: createNicTags,
-            modules: { sdcClients: 'sdc-clients', vasync: 'vasync' }
-        },
-        {
-            name: 'napi.update_nics',
-            timeout: 10,
-            retry: 1,
-            body: updateNics,
-            modules: { sdcClients: 'sdc-clients', vasync: 'vasync' }
-        },
-        {
-            name: 'napi.add_nics',
-            timeout: 10,
-            retry: 1,
-            body: addNics,
-            modules: { sdcClients: 'sdc-clients', vasync: 'vasync' }
-        },
-        {
-            name: 'napi.update_aggrs',
-            timeout: 10,
-            retry: 1,
-            body: updateAggrs
-        }
-    ],
-    _setMocks: setMocks
-};
diff --git a/package.json b/package.json
index 174f150..7cbe498 100644
--- a/package.json
+++ b/package.json
@@ -1,7 +1,7 @@
 {
   "name": "cnapi",
   "description": "SmartDataCenter Compute Node API",
-  "version": "1.20.0",
+  "version": "1.21.0",
   "author": "Joyent (joyent.com)",
   "private": true,
   "dependencies": {
@@ -10,7 +10,7 @@
     "async": "1.5.2",
     "bunyan": "1.8.5",
     "dapi": "git+https://github.com/joyent/sdc-designation.git#296a786be98c325c9f30eff4dce16ed04047c9b5",
-    "deep-equal": "1.0.1",
+    "deep-object-diff": "1.1.0",
     "dox": "0.9.0",
     "gc-stats": "1.2.0",
     "jsprim": "1.4.1",
diff --git a/share/inspect-server.sh b/share/inspect-server.sh
deleted file mode 100644
index 715a80b..0000000
--- a/share/inspect-server.sh
+++ /dev/null
@@ -1,81 +0,0 @@
-#!/bin/bash
-#
-# This Source Code Form is subject to the terms of the Mozilla Public
-# License, v. 2.0. If a copy of the MPL was not distributed with this
-# file, You can obtain one at http://mozilla.org/MPL/2.0/.
-#
-
-#
-# Copyright (c) 2014, Joyent, Inc.
-#
-
-export PATH=/usr:/usr/bin:/usr/sbin:/sbin
-
-function get_zpool_disks()
-{
-   local zpool=$1
-   Zpool_disks=
-
-   for disk in $(/usr/bin/disklist -n); do
-       local disk_in_pool=$(/usr/sbin/zpool status ${zpool} | grep ${disk})
-       if [[ -n ${disk_in_pool} ]]; then
-           Zpool_disks="${Zpool_disks},${disk}"
-       fi
-   done
-
-   Zpool_disks=${Zpool_disks/#,/}
-}
-
-function get_zpool_profile()
-{
-   local zpool=$1
-   local profiles=( mirror raidz3 raidz2 raidz )
-   Zpool_profile="striped"
-
-   for profile in ${profiles[*]}; do
-       if [[ -n $(/usr/sbin/zpool status ${zpool} | grep ${profile}) ]]; then
-           Zpool_profile=${profile}
-           break
-       fi
-   done
-}
-
-function get_zpool()
-{
-   if [[ $(zpool list) != "no pools available" ]]; then
-       Zpool=$(zpool list -H | awk '{print $1}');
-       Zpool_creation=$(zfs get -Hp -o value creation ${Zpool})
-
-       local used=$(zfs get -Hp -o value used ${Zpool})
-       local available=$(zfs get -Hp -o value available ${Zpool})
-       local size=$(( $used + $available ))
-
-       Zpool_size=$(($size / 1024 / 1024 / 1024))
-
-       get_zpool_disks ${Zpool}
-       get_zpool_profile ${Zpool}
-   fi
-}
-
-get_zpool
-
-if [[ -z $Zpool_creation ]]; then
-    Zpool_creation="0"
-fi
-
-if [[ -z $Zpool_size ]]; then
-    Zpool_size="0"
-fi
-
-boot_time=$(/usr/bin/kstat -p -m unix -n system_misc -s boot_time | cut -f2)
-
-cat << __END__;
-{
-    "boot_time": $boot_time,
-    "zpool": "${Zpool}",
-    "zpool_disks": "${Zpool_disks}",
-    "zpool_profile": "${Zpool_profile}",
-    "zpool_creation": $Zpool_creation,
-    "zpool_size": $Zpool_size
-}
-__END__
diff --git a/test/lib/mock.js b/test/lib/mock.js
index e5962dc..8e2b322 100644
--- a/test/lib/mock.js
+++ b/test/lib/mock.js
@@ -9,7 +9,9 @@
  */
 
 var async = require('async');
+var VError = require('verror');
 var common = require('../../lib/common');
+var EventEmitter = require('events');
 var path = require('path');
 var App = require('../../lib/app');
 
@@ -50,7 +52,7 @@ function MockMoray() {
     this.callbackValues = {
         putObject: [],
         findObjects: [],
-        getObjects: [],
+        getObject: [],
         delObject: []
     };
     this.reqs = [];
@@ -87,7 +89,15 @@ MockMoray.prototype._lastReq = function () {
 
 MockMoray.prototype.getObject = function (bucket, key, callback) {
     this.history.push(['getObject', bucket, key]);
+
     var val = this.callbackValues.getObject.pop();
+    if (val === undefined || val.value === null) {
+        callback(new VError({
+            name: 'ObjectNotFoundError'
+        }, 'Object was not found.'));
+        return;
+    }
+
     callback.apply(null, [ null, val ]);
     return this;
 };
@@ -100,14 +110,22 @@ function (bucket, key, value, opts, callback) {
         opts = undefined;
     }
 
+    var arg = null;
     var histItem = ['putObject', bucket, key, value];
+    var val = this.callbackValues.putObject.pop();
 
     if (opts) {
         histItem.push(opts);
     }
 
     this.history.push(histItem);
-    callback.apply(null, [ null ]);
+
+    if (val !== undefined) {
+        // if there's a value, it should be an error
+        arg = val;
+    }
+
+    callback.apply(null, [ arg ]);
     return this;
 };
 
@@ -122,7 +140,7 @@ MockMoray.prototype.delObject = function (bucket, key, callback) {
 MockMoray.prototype.findObjects = function (bucket, filter, opts) {
     var self = this;
     this.history.push(['findObjects', bucket, filter, opts]);
-    var req = new process.EventEmitter();
+    var req = new EventEmitter();
     this.reqs.push(req);
     var results = self.results.shift();
     process.nextTick(function () {
@@ -239,6 +257,7 @@ function newApp(callback) {
                 datacenter: config.datacenter_name,
                 cnapi: config.cnapi,
                 dapi: config.dapi,
+                napi: config.napi,
                 amqp: {
                     host: 'localhost'
                 }
diff --git a/test/model/test-model-platform.js b/test/model/test-model-platform.js
index 7137311..ac80fe2 100644
--- a/test/model/test-model-platform.js
+++ b/test/model/test-model-platform.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2019, Joyent, Inc.
  */
 
 var async = require('async');
diff --git a/test/model/test-model-server.js b/test/model/test-model-server.js
index 3d9225e..d960573 100644
--- a/test/model/test-model-server.js
+++ b/test/model/test-model-server.js
@@ -16,6 +16,7 @@ var common = require('../../lib/common');
 var mock = require('../lib/mock');
 var nodeunit = require('nodeunit');
 var sprintf = require('sprintf').sprintf;
+var VError = require('verror');
 
 var ModelServer = require('../../lib/models/server');
 
@@ -69,14 +70,12 @@ function testListServersAll(test) {
                     uuid: '372bdb58-f8dd-11e1-8038-0b6dbddc5e58',
                     ram: '12345',
                     sysinfo: { setup: true },
-                    last_heartbeat: null,
                     status: 'unknown'
                 },
                 {
                     uuid: '6e8eb888-f8e0-11e1-b1a8-5f74056f9365',
                     ram: '56789',
                     sysinfo: { setup: true },
-                    last_heartbeat: null,
                     status: 'unknown'
                 }
             ];
@@ -133,14 +132,12 @@ function testListServersByUuids(test) {
                     uuid: '372bdb58-f8dd-11e1-8038-0b6dbddc5e58',
                     ram: '12345',
                     sysinfo: { setup: true },
-                    last_heartbeat: null,
                     status: 'unknown'
                 },
                 {
                     uuid: 'b31695ce-f8e6-11e1-b252-fb742866284b',
                     ram: '56789',
                     sysinfo: { setup: true },
-                    last_heartbeat: null,
                     status: 'unknown'
                 }
             ];
@@ -214,14 +211,12 @@ function testListServersSetup(test) {
                     uuid: '372bdb58-f8dd-11e1-8038-0b6dbddc5e58',
                     ram: '12345',
                     sysinfo: { setup: true },
-                    last_heartbeat: null,
                     status: 'unknown'
                 },
                 {
                     uuid: '6e8eb888-f8e0-11e1-b1a8-5f74056f9365',
                     ram: '56789',
                     sysinfo: { setup: true },
-                    last_heartbeat: null,
                     status: 'unknown'
                 }
             ];
@@ -259,8 +254,9 @@ function testFetchServer(test) {
 
         var server = new ModelServer(uuids[0]);
 
-        server.getRaw(function (getError, s) {
+        server.getRaw({}, function (getError, s) {
             test.equal(getError, null, 'should not encounter an error');
+
             test.deepEqual(s, expSearchResults[0], 'results should match');
             test.deepEqual(
                 moray.client.history[0],
@@ -276,30 +272,36 @@ function testFetchServer(test) {
 }
 
 function testCreateServer(test) {
-    test.expect(3);
+    test.expect(5);
 
-    var serverToAdd = { uuid: uuids[0], ram: '12345' };
+    var sysinfoToAdd = {
+        UUID: uuids[0],
+        'MiB of Memory': '12345'
+    };
 
     mock.newApp(function (error, app, components) {
         test.equal(error, null, 'should not encounter an error');
 
         var moray = components.moray;
-        moray.client.when('putObject', []);
         ModelServer.init(app);
 
-        var server = new ModelServer(uuids[0]);
-        server.setRaw(serverToAdd);
-        server.store(serverToAdd, function (storeError) {
+        ModelServer.updateFromSysinfo(sysinfoToAdd, function (storeError) {
             test.equal(storeError, null, 'should not encounter an error');
-            test.deepEqual(
-                moray.client.history[0],
-                [
-                    'putObject',
-                    'cnapi_servers',
-                    uuids[0],
-                    serverToAdd
-                ],
-            'moray command history');
+            // First we getObject the object (which will be not found)
+            // then we getObject 'default' as part of creating the new server
+            // finally the 3rd command should be our putObject
+            test.deepEqual(moray.client.history[2].slice(0, 3), [
+                'putObject',
+                'cnapi_servers',
+                sysinfoToAdd.UUID
+            ], 'should see putObject in moray client history');
+            test.equal(moray.client.history[2][3].sysinfo.UUID,
+                sysinfoToAdd.UUID,
+                'putObject uuid should match');
+            test.equal(moray.client.history[2][3].ram,
+                sysinfoToAdd['MiB of Memory'],
+                'putObject ram should match');
+
             test.done();
         });
     });
@@ -346,8 +348,6 @@ function testRebootServer(test) {
 
         moray.client.when('getObject', [], { value: expSearchResults[0] });
 
-        moray.client.when('putObject', []);
-
         ModelServer.init(app);
 
         moray.client.when('findObjects');
@@ -377,104 +377,93 @@ function testRebootServer(test) {
 }
 
 function testModifyServer(test) {
-    test.expect(3);
-
-    var uuid = uuids[0];
+    test.expect(5);
 
     mock.newApp(function (error, app, components) {
         test.equal(error, null, 'should not encounter an error');
 
         var moray = components.moray;
-        moray.client.when('putObject', []);
+        var origObj = {
+            hostname: 'dummyCN',
+            setup: true
+        };
 
+        // initial object for CN
+        moray.client.when('getObject', [], {value: origObj});
         ModelServer.init(app);
 
-        var server = new ModelServer(uuids[0]);
-
-        var change = {
-            uuid: uuid,
+        // When we do the getObject in upsert, we'll get 'setup: true', so this
+        // upsert should set it to false but leave the other fields alone.
+        ModelServer.upsert(uuids[0], {
             setup: false
-        };
+        }, {
+            etagRetries: 0
+        }, function _onUpsert(err) {
+            var putObj;
 
-        server.modify(change, function (modifyError) {
-            test.deepEqual(
-                moray.client.history[0],
-                [
-                    'putObject',
-                    'cnapi_servers',
-                    uuid,
-                    change,
-                    {}
-                ],
-            'moray command history');
+            test.equal(err, null, 'modify server upsert() should succeed');
+
+            putObj = moray.client.history[1][3];
+
+            test.equal(moray.client.history.length, 2,
+                'should be 2 requests in the moray history');
+            test.equal(putObj.hostname, origObj.hostname,
+                'hostname should not have changed');
+            test.equal(putObj.setup, false, 'setup should have changed');
 
-            test.deepEqual(
-                moray.client.history[0][3].setup,
-                false,
-                'boot platform should match');
             test.done();
         });
     });
 }
 
+//
+// This tests that doing an upsert with an Etag conflict will retry and succeed
+// on the next attempt.
 function testModifyServerWithEtag(test) {
-    test.expect(6);
-
-    var uuid = uuids[0];
-    var etag = 'etag-1234';
+    test.expect(5);
 
     mock.newApp(function (error, app, components) {
         test.equal(error, null, 'should not encounter an error');
 
         var moray = components.moray;
-        moray.client.when('getObject', [], { _etag: etag });
-        moray.client.when('putObject', []);
+        var origObj = {
+            hostname: 'dummyCN',
+            setup: true
+        };
+
+        // initial object for CN
+        moray.client.when('getObject', [], {value: origObj});
+        moray.client.when('putObject', [], new VError({
+            name: 'EtagConflictError'
+        }));
+        moray.client.when('getObject', [], {value: origObj});
 
         ModelServer.init(app);
 
-        var server = new ModelServer(uuids[0]);
-        var change = {
-            uuid: uuid,
+        ModelServer.upsert(uuids[0], {
             setup: false
-        };
+        }, {
+            etagRetries: 10
+        }, function _onUpsert(err) {
+            var putObj;
+
+            test.equal(err, null, 'modify server upsert() should succeed');
+
+            putObj = moray.client.history[1][3];
+
+            // we should see 4 requests:
+            //
+            // getObject,
+            // putObject (which returns EtagConflict),
+            // getObject,
+            // putObject (which succeeds this time)
+            //
+            test.equal(moray.client.history.length, 4,
+                'should be 4 requests in the moray history');
+            test.equal(putObj.hostname, origObj.hostname,
+                'hostname should not have changed');
+            test.equal(putObj.setup, false, 'setup should have changed');
 
-        vasync.pipeline({ funcs: [
-            function doGetServer(_, next) {
-                server.getRaw(function (err) {
-                    test.ifError(err);
-                    test.equal(server.etag, etag);
-                    next();
-                });
-            },
-            function doModifyServer(_, next) {
-                server.modify(change, function (modifyError) {
-                    test.ifError(modifyError);
-                    next();
-                });
-            },
-            function doCheck(_, next) {
-                test.deepEqual(
-                    moray.client.history[0],
-                    [
-                        'getObject',
-                        'cnapi_servers',
-                        uuid
-                    ],
-                    'moray command history');
-                test.deepEqual(
-                    moray.client.history[1],
-                    [
-                        'putObject',
-                        'cnapi_servers',
-                        uuid,
-                        change,
-                        { etag: etag }
-                    ],
-                    'moray command history');
-                next();
-            }
-        ] },
-        function (err) {
             test.done();
         });
     });
@@ -518,7 +507,6 @@ function testSetBootParameters(test) {
 
                 test.equal(error, null, 'should not encounter an error');
 
-                moray.client.when('putObject', []);
                 moray.client.when('getObject', [], { value: expSearchResults });
 
                 ModelServer.init(app);
@@ -622,7 +610,7 @@ function testSetBootParameters(test) {
 
 
 function testUpdateBootParameters(test) {
-    test.expect(5);
+    test.expect(6);
 
     var uuid = uuids[0];
 
@@ -669,9 +657,8 @@ function testUpdateBootParameters(test) {
 
                 test.equal(error, null, 'should not encounter an error');
 
-                moray.client.when('putObject', []);
                 moray.client.when('getObject', [], { value: expSearchResults });
-                moray.client.when('putObject', []);
+                moray.client.when('getObject', [], { value: expSearchResults });
 
                 server = new ModelServer(uuid);
                 callback();
@@ -691,8 +678,16 @@ function testUpdateBootParameters(test) {
                         null,
                         'There should be no error');
 
+                    //
+                    // getObject (updateBootParams calls getRaw)
+                    // getObject (from upsert in updateBootParams)
+                    // putObject (from upsert in updateBootParams)
+                    //
+                    test.equal(moray.client.history.length, 3,
+                        'should have 3 moray client commands');
+
                     test.deepEqual(
-                        moray.client.history[1],
+                        moray.client.history[2],
                         [
                             'putObject',
                             'cnapi_servers',
@@ -717,9 +712,6 @@ function testUpdateBootParameters(test) {
                 });
         },
         function (callback) {
-            moray.client.when('getObject', [], { value: expSearchResults });
-            delete server.value;
-
             expSearchResults = {
                 uuid: uuid,
                 boot_params: updatedBootParams,
@@ -732,6 +724,8 @@ function testUpdateBootParameters(test) {
                 kernel_flags: updatedKernelArgs,
                 serial: 'ttyb'
             };
+            moray.client.when('getObject', [], { value: expSearchResults });
+
             server.getBootParams(function (getError, params) {
                 test.equal(
                      getError,
diff --git a/test/test-servers.js b/test/test-servers.js
index c45cd11..6e36543 100644
--- a/test/test-servers.js
+++ b/test/test-servers.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright (c) 2019, Joyent, Inc.
  */
 
 /*
@@ -788,6 +788,15 @@ function vmAttrTypeEqual(t, vm, attr, exptype) {
 }
 
 function serverAttrTypeEqual(t, server, attr, exptype) {
+    // The unreserved_* fields are only added to servers when a provision
+    // happens. So it is perfectly fine for these to be undefined.
+    if (attr.match(/^unreserved_/) && server[attr] === undefined) {
+        t.ok(true, sprintf(
+            'server "%s" attribute "%s" is undefined (and that is ok)',
+            server.uuid,
+            attr));
+        return;
+    }
     t.equal(typeof (server[attr]), exptype,
         sprintf('ensure type of server "%s" attribute "%s" is "%s"',
             server.uuid, attr, exptype));
diff --git a/test/test-workflow-server-sysinfo.js b/test/test-workflow-server-sysinfo.js
deleted file mode 100644
index e89e7d8..0000000
--- a/test/test-workflow-server-sysinfo.js
+++ /dev/null
@@ -1,525 +0,0 @@
-/*
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/.
- */
-
-/*
- * Copyright (c) 2014, Joyent, Inc.
- */
-
-var util = require('util');
-
-var async = require('async');
-var bunyan = require('bunyan');
-var wf = require('../lib/workflows/server-sysinfo');
-var VError = require('verror').VError;
-
-var LOG = bunyan.createLogger({
-    name: 'test-wf-sysinfo',
-    serializers: bunyan.stdSerializers,
-    streams: [ {
-        level: process.env.LOG_LEVEL || 'fatal',
-        stream: process.stderr
-    } ]
-});
-var NAPI = { };
-var ADMIN_UUID = '9f0cc641-5f9e-476b-b5fc-8cc7cf7eaf90';
-var SERVER_UUID = '28d796de-ae2d-4625-ac8a-c3c341dcd251';
-
-
-
-// --- Helpers
-
-
-
-function clone(obj) {
-    var newObj = {};
-    for (var o in obj) {
-        newObj[o] = obj[o];
-    }
-
-    return newObj;
-}
-
-
-
-// --- NAPI mock
-
-
-
-function resetNAPI(test) {
-    NAPI = {
-        aggrs: {},
-        nics: {},
-        nictags: {}
-    };
-    test.done();
-}
-
-
-function napiAggrs() {
-    return Object.keys(NAPI.aggrs).map(function (a) {
-        return clone(NAPI.aggrs[a]);
-    }).sort(function (a, b) {
-        return a.name - b.name;
-    });
-}
-
-
-function napiNics() {
-    return Object.keys(NAPI.nics).map(function (m) {
-        return clone(NAPI.nics[m]);
-    }).sort(function (a, b) {
-        return a.mac - b.mac;
-    });
-
-}
-
-
-function napiNicTags() {
-    return Object.keys(NAPI.nictags).sort();
-}
-
-
-function MockNAPI(opts) {
-    this.opts = opts;
-}
-
-MockNAPI.prototype.createAggr = function createAggr(params, cb) {
-    if (!params.hasOwnProperty('macs')) {
-        cb(new Error('createAggr: missing macs'));
-        return;
-    }
-    if (!params.hasOwnProperty('name')) {
-        cb(new Error('createAggr: missing name'));
-        return;
-    }
-
-    var key = SERVER_UUID + '-' + params.name;
-
-    if (NAPI.aggrs.hasOwnProperty(key)) {
-        cb(new VError('aggr %s already exists', key));
-        return;
-    }
-
-    var newAggr = clone(params);
-    newAggr.belongs_to_uuid = SERVER_UUID;
-    newAggr.id = key;
-    NAPI.aggrs[key] = newAggr;
-
-    LOG.debug({ aggr: newAggr }, 'creating aggr %s', key);
-    cb(null, clone(newAggr));
-    return;
-};
-
-
-MockNAPI.prototype.createNic = function createNic(mac, params, cb) {
-    if (NAPI.nics.hasOwnProperty(mac)) {
-        cb(new VError('nic %s already exists', mac));
-        return;
-    }
-
-    NAPI.nics[mac] = clone(params);
-    cb(null, clone(params));
-    return;
-};
-
-
-MockNAPI.prototype.createNicTag = function createNicTag(name, cb) {
-    if (NAPI.nictags.hasOwnProperty(name)) {
-        var err = new VError('nic tag %s already exists', name);
-        err.body = {
-            errors: [ { code: 'Duplicate' } ]
-        };
-
-        cb(err);
-        return;
-    }
-
-    var params = { name: name };
-    NAPI.nictags[name] = params;
-    cb(null, clone(params));
-    return;
-};
-
-
-MockNAPI.prototype.deleteAggr = function deleteAggr(id, cb) {
-    if (!NAPI.aggrs.hasOwnProperty(id)) {
-        cb(new VError('aggr %s does not exist', id));
-        return;
-    }
-
-    delete NAPI.aggrs[id];
-    cb(null, {});
-    return;
-};
-
-
-MockNAPI.prototype.getNic = function getNic(mac, cb) {
-    if (!NAPI.nics.hasOwnProperty(mac)) {
-        var err = new VError('nic %s not found', mac);
-        err.statusCode = 404;
-        cb(err);
-        return;
-    }
-
-    cb(null, clone(NAPI.nics[mac]));
-};
-
-MockNAPI.prototype.getNics = function getNics(uuid, cb) {
-    var nics = [];
-
-    for (var n in NAPI.nics) {
-        var nic = NAPI.nics[n];
-        if (nic.belongs_to_uuid == uuid) {
-            nics.push(clone(nic));
-        }
-    }
-
-    cb(null, nics);
-};
-
-MockNAPI.prototype.listAggrs = function listAggrs(params, cb) {
-    var a;
-    var aggr;
-    var aggrs = [];
-    var m;
-    var newAggr;
-
-    if (params.hasOwnProperty('macs')) {
-        for (a in NAPI.aggrs) {
-            aggr = aggrs[a];
-            for (m in params.macs) {
-                if (aggr.macs.indexOf(params.macs[m]) !== -1) {
-                    newAggr = clone(aggr);
-                    newAggr.id = a;
-                    aggrs.push(newAggr);
-                    continue;
-                }
-            }
-        }
-    }
-
-    if (params.hasOwnProperty('belongs_to_uuid')) {
-        for (a in NAPI.aggrs) {
-            aggr = NAPI.aggrs[a];
-            if (aggr.belongs_to_uuid == params.belongs_to_uuid) {
-                newAggr = clone(aggr);
-                newAggr.id = a;
-                aggrs.push(newAggr);
-                continue;
-            }
-        }
-    }
-
-    cb(null, aggrs);
-};
-
-
-MockNAPI.prototype.updateAggr = function updateAggr(id, params, cb) {
-    if (!NAPI.aggrs.hasOwnProperty(id)) {
-        cb(new VError('aggr %s does not exist', id));
-        return;
-    }
-
-    for (var p in params) {
-        if (p == 'id') {
-            continue;
-        }
-        NAPI.aggrs[id][p] = params[p];
-    }
-
-    cb(null, clone(NAPI.aggrs[id]));
-};
-
-
-MockNAPI.prototype.updateNic = function updateNic(mac, params, cb) {
-    if (!NAPI.nics.hasOwnProperty(mac)) {
-        cb(new VError('nic %s does not exist', mac));
-        return;
-    }
-
-    for (var p in params) {
-        NAPI.nics[mac][p] = params[p];
-    }
-
-    cb(null, clone(NAPI.nics[mac]));
-};
-
-
-
-// --- Workflow running functions
-
-
-
-function runWorkflow(test, sysinfo, callback) {
-    var job = {
-        log: LOG,
-        params: {
-            admin_uuid: ADMIN_UUID,
-            server_uuid: SERVER_UUID,
-            sysinfo: sysinfo
-        }
-    };
-    var lastTaskRun = '';
-
-    wf._setMocks({
-        napiUrl: 'http://localhost',
-        sdcClients: { NAPI: MockNAPI }
-    });
-
-    async.forEachSeries(wf.chain, function (task, cb) {
-        LOG.debug('Running %s', task.name);
-        task.body(job, function (err, res) {
-            if (err) {
-                LOG.error(err, 'Error running task %s', task.name);
-            }
-
-            if (res) {
-                LOG.info('Task %s result: %s', task.name, res);
-            }
-
-            lastTaskRun = task.name;
-            cb(err, res);
-            return;
-        });
-
-        return;
-    }, function (err) {
-        test.ifError(err);
-        test.equal(lastTaskRun, wf.chain[wf.chain.length - 1].name,
-            'ran all tasks');
-
-        callback();
-    });
-}
-
-
-function genSysinfo(opts) {
-    var base = {
-        UUID: SERVER_UUID,
-        'Link Aggregations': {},
-        'Network Interfaces': {},
-        'Virtual Network Interfaces': {}
-    };
-
-    for (var o in opts) {
-        if (o == 'aggrs') {
-            base['Link Aggregations'] = opts[o];
-        } else if (o == 'nics') {
-            base['Network Interfaces'] = opts[o];
-        } else if (o == 'vnics') {
-            base['Virtual Network Interfaces'] = opts[o];
-        } else {
-            base[o] = opts[o];
-        }
-    }
-
-    LOG.debug({ sysinfo: base }, 'generated sysinfo');
-    return base;
-}
-
-
-
-// --- Tests
-
-
-
-function setup(callback) {
-    callback();
-}
-
-function teardown(callback) {
-    callback();
-}
-
-var d = {};
-
-var aggrTests = {
-    'reset NAPI': resetNAPI,
-
-    'first boot': function (test) {
-        d = {
-            ips: [ '10.99.99.38', '10.99.99.39' ],
-            macs: [ '00:0c:29:a1:d5:3e', '00:0c:29:a1:d5:48',
-                '00:0c:29:a1:d5:52', '00:0c:29:a1:d5:53',
-                '00:0c:29:a1:d5:54', '00:0c:29:a1:d5:55' ]
-        };
-
-        d.sysinfo = {
-            aggrs: {
-                aggr0: {
-                   'LACP mode': 'off',
-                   'Interfaces': ['e1000g1', 'e1000g2']
-                }
-            },
-
-            nics: {
-                'e1000g0': {
-                    'MAC Address': d.macs[0],
-                    'ip4addr': d.ips[0],
-                    'Link Status': 'up',
-                    'NIC Names': ['admin']
-                },
-                'e1000g1': {
-                    'MAC Address': d.macs[1],
-                    'ip4addr': '',
-                    'Link Status': 'up',
-                    'NIC Names': []
-                },
-                'e1000g2': {
-                    'MAC Address': d.macs[2],
-                    'ip4addr': '',
-                    'Link Status': 'up',
-                    'NIC Names': []
-                },
-                'aggr0': {
-                    'MAC Address': d.macs[1],
-                    'ip4addr': '',
-                    'Link Status': 'up',
-                    'NIC Names': ['internal', 'external']
-                }
-            }
-        };
-
-        runWorkflow(test, genSysinfo(d.sysinfo), function (err) {
-            test.deepEqual(napiNicTags(), ['admin', 'external', 'internal'],
-                'nic tags created');
-
-            d.nics = [
-                {
-                    mac: d.macs[0],
-                    ip: d.ips[0],
-                    belongs_to_uuid: SERVER_UUID,
-                    belongs_to_type: 'server',
-                    owner_uuid: ADMIN_UUID,
-                    nic_tag: 'admin',
-                    nic_tags_provided: ['admin'],
-                    vlan_id: 0
-                },
-                {
-                    mac: d.macs[1],
-                    belongs_to_uuid: SERVER_UUID,
-                    belongs_to_type: 'server',
-                    owner_uuid: ADMIN_UUID,
-                    nic_tags_provided: []
-                },
-                {
-                    mac: d.macs[2],
-                    belongs_to_uuid: SERVER_UUID,
-                    belongs_to_type: 'server',
-                    owner_uuid: ADMIN_UUID,
-                    nic_tags_provided: []
-                }
-            ];
-
-            test.deepEqual(napiNics(), d.nics, 'nics created');
-
-            d.aggrs = [
-                {
-                    belongs_to_uuid: SERVER_UUID,
-                    id: SERVER_UUID + '-aggr0',
-                    name: 'aggr0',
-                    lacp_mode: 'off',
-                    macs: [ d.macs[1], d.macs[2] ]
-                }
-            ];
-            test.deepEqual(napiAggrs(), d.aggrs, 'aggrs created');
-
-            test.done();
-            return;
-        });
-    },
-
-    'add / update aggrs': function (test) {
-        test.ok(Object.keys(NAPI.nics).length > 0, 'still nics in NAPI');
-
-        // Add e1000g3 to aggr0
-        d.sysinfo.nics.e1000g3 = {
-            'MAC Address': d.macs[3],
-            'ip4addr': '',
-            'Link Status': 'up',
-            'NIC Names': []
-        };
-        d.sysinfo.aggrs.aggr0.Interfaces = ['e1000g1', 'e1000g2', 'e1000g3'];
-
-        // Add aggr1
-        d.sysinfo.nics.aggr1 = {
-            'MAC Address': d.macs[4],
-            'ip4addr': '',
-            'Link Status': 'up',
-            'NIC Names': []
-        };
-        d.sysinfo.aggrs.aggr1 = {
-           'LACP mode': 'off',
-           'Interfaces': ['e1000g4', 'e1000g5']
-        };
-        d.sysinfo.nics.e1000g4 = {
-            'MAC Address': d.macs[4],
-            'ip4addr': '',
-            'Link Status': 'up',
-            'NIC Names': []
-        };
-        d.sysinfo.nics.e1000g5 = {
-            'MAC Address': d.macs[5],
-            'ip4addr': '',
-            'Link Status': 'up',
-            'NIC Names': []
-        };
-
-        // Update e1000g0
-        d.sysinfo.nics.e1000g0.ip4addr = d.ips[1];
-
-        runWorkflow(test, genSysinfo(d.sysinfo), function (err) {
-            test.deepEqual(napiNicTags(), ['admin', 'external', 'internal'],
-                'nic tags still around');
-
-            d.nics[0].ip = d.ips[1];
-            d.nics = d.nics.concat([
-                {
-                    mac: d.macs[3],
-                    belongs_to_uuid: SERVER_UUID,
-                    belongs_to_type: 'server',
-                    owner_uuid: ADMIN_UUID,
-                    nic_tags_provided: []
-                },
-                {
-                    mac: d.macs[4],
-                    belongs_to_uuid: SERVER_UUID,
-                    belongs_to_type: 'server',
-                    owner_uuid: ADMIN_UUID,
-                    nic_tags_provided: []
-                },
-                {
-                    mac: d.macs[5],
-                    belongs_to_uuid: SERVER_UUID,
-                    belongs_to_type: 'server',
-                    owner_uuid: ADMIN_UUID,
-                    nic_tags_provided: []
-                }
-            ]);
-
-            test.deepEqual(napiNics(), d.nics, 'new nics added');
-
-            d.aggrs[0].macs = [ d.macs[1], d.macs[2], d.macs[3] ];
-            d.aggrs.push({
-                belongs_to_uuid: SERVER_UUID,
-                id: SERVER_UUID + '-aggr1',
-                name: 'aggr1',
-                lacp_mode: 'off',
-                macs: [ d.macs[4], d.macs[5] ]
-            });
-            test.deepEqual(napiAggrs(), d.aggrs, 'new aggr added');
-
-            test.done();
-            return;
-        });
-    }
-};
-
-module.exports = {
-    setUp: setup,
-    tearDown: teardown,
-    'aggregations': aggrTests
-};
diff --git a/tools/jsl.node.conf b/tools/jsl.node.conf
index e8766c7..c06f1a1 100644
--- a/tools/jsl.node.conf
+++ b/tools/jsl.node.conf
@@ -118,6 +118,7 @@
 +define module
 +define process
 +define require
++define setImmediate
 +define setInterval
 +define setTimeout
 +define Buffer
-- 
2.21.0

