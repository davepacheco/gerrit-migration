commit 8f8455a85dcc4392578d039cb9c2f279a0725645
Author: John Levon <john.levon@joyent.com>
Date:   2019-08-27T21:56:50+00:00 (6 weeks ago)
    
    OS-7960 need fixes for NULL as a pointer
    Reviewed by: Jerry Jelinek <jerry.jelinek@joyent.com>
    Reviewed by: Ryan Zezeski <rpz@joyent.com>
    Reviewed by: Robert Mustacchi <rm@joyent.com>
    Approved by: Robert Mustacchi <rm@joyent.com>

diff --git a/usr/src/cmd/bhyve/pci_virtio_net.c b/usr/src/cmd/bhyve/pci_virtio_net.c
index 74efbcaee1..aa188a3e59 100644
--- a/usr/src/cmd/bhyve/pci_virtio_net.c
+++ b/usr/src/cmd/bhyve/pci_virtio_net.c
@@ -306,8 +306,8 @@ pci_vtnet_tap_tx(struct pci_vtnet_softc *sc, struct iovec *iov, int iovcnt,
 	int i;
 
 	for (i = 0; i < iovcnt; i++) {
-		(void) dlpi_send(sc->vsc_dhp, NULL, NULL,
-				 iov[i].iov_base, iov[i].iov_len, NULL);
+		(void) dlpi_send(sc->vsc_dhp, NULL, 0,
+		    iov[i].iov_base, iov[i].iov_len, NULL);
 	}
 }
 #endif /* __FreeBSD__ */
diff --git a/usr/src/cmd/bhyve/pci_virtio_viona.c b/usr/src/cmd/bhyve/pci_virtio_viona.c
index 26c8cdeeba..9cafa7b111 100644
--- a/usr/src/cmd/bhyve/pci_virtio_viona.c
+++ b/usr/src/cmd/bhyve/pci_virtio_viona.c
@@ -34,7 +34,7 @@
  * http://www.illumos.org/license/CDDL.
  *
  * Copyright 2015 Pluribus Networks Inc.
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 #include <sys/cdefs.h>
@@ -469,7 +469,7 @@ pci_viona_init(struct vmctx *ctx, struct pci_devinst *pi, char *opts)
 
 	/* BAR 0 for legacy-style virtio register access. */
 	error = pci_emul_alloc_bar(pi, 0, PCIBAR_IO, VIONA_REGSZ);
-	if (error != NULL) {
+	if (error != 0) {
 		WPRINTF(("could not allocate virtio BAR\n"));
 		free(sc);
 		return (1);
diff --git a/usr/src/cmd/cmd-inet/usr.sbin/snoop/snoop_svp.c b/usr/src/cmd/cmd-inet/usr.sbin/snoop/snoop_svp.c
index 54f4dded8c..a0768c2234 100644
--- a/usr/src/cmd/cmd-inet/usr.sbin/snoop/snoop_svp.c
+++ b/usr/src/cmd/cmd-inet/usr.sbin/snoop/snoop_svp.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright 2019 Joyent, Inc.  All rights reserved.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -20,6 +20,7 @@
 #include <inttypes.h>
 #include <sys/crc32.h>
 #include <uuid/uuid.h>
+#include <arpa/inet.h>
 #include <stdio.h>
 #include <stdarg.h>
 #include <libvarpd_svp_prot.h>
@@ -51,7 +52,7 @@
 
 static uint32_t svp_crc32_tab[] = { CRC32_TABLE };
 
-#define STR(_x, _buf, _len)				\
+#define	STR(_x, _buf, _len)				\
 	case _x:					\
 		(void) strlcpy(_buf, #_x, _len);	\
 		break
diff --git a/usr/src/cmd/dlmgmtd/dlmgmt_door.c b/usr/src/cmd/dlmgmtd/dlmgmt_door.c
index 647b919864..60fa361caa 100644
--- a/usr/src/cmd/dlmgmtd/dlmgmt_door.c
+++ b/usr/src/cmd/dlmgmtd/dlmgmt_door.c
@@ -1320,7 +1320,7 @@ dlmgmt_zonehalt(void *argp, void *retp, size_t *sz, zoneid_t zoneid,
 	dlmgmt_zonehalt_retval_t *retvalp = retp;
 	static char my_pid[10];
 
-	if (my_pid[0] == NULL)
+	if (my_pid[0] == '\0')
 		(void) snprintf(my_pid, sizeof (my_pid), "%d\n", getpid());
 
 	if ((err = dlmgmt_checkprivs(0, cred)) == 0) {
diff --git a/usr/src/cmd/mdb/common/modules/xhci/xhci.c b/usr/src/cmd/mdb/common/modules/xhci/xhci.c
index fbf3c42417..e6f9ed339a 100644
--- a/usr/src/cmd/mdb/common/modules/xhci/xhci.c
+++ b/usr/src/cmd/mdb/common/modules/xhci/xhci.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright 2016 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 #include <sys/mdb_modapi.h>
@@ -585,7 +585,7 @@ xhci_mdb_walk_xhci_endpoint_step(mdb_walk_state_t *wsp)
 		return (WALK_DONE);
 
 	addr = (uintptr_t)xm->xmwe_device.xd_endpoints[xm->xmwe_ep];
-	if (addr != NULL) {
+	if (addr != (uintptr_t)NULL) {
 		xhci_endpoint_t xe;
 
 		if (mdb_vread(&xe, sizeof (xe), addr) != sizeof (xe)) {
diff --git a/usr/src/cmd/mdb/i86pc/modules/unix/xcall.c b/usr/src/cmd/mdb/i86pc/modules/unix/xcall.c
index c7b625c494..a3057daff1 100644
--- a/usr/src/cmd/mdb/i86pc/modules/unix/xcall.c
+++ b/usr/src/cmd/mdb/i86pc/modules/unix/xcall.c
@@ -9,7 +9,7 @@
  * http://www.illumos.org/license/CDDL.
  */
 /*
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 #include <mdb/mdb_modapi.h>
@@ -67,7 +67,7 @@ cpu_id_to_addr(processorid_t cpun, uintptr_t *addrp)
 		return (-1);
 	}
 
-	if (addr != NULL) {
+	if (addr != (uintptr_t)NULL) {
 		*addrp = addr;
 		return (0);
 	}
@@ -122,7 +122,7 @@ xcall_get_msgs(uintptr_t addr, const void *wdata, void *priv)
 	}
 
 	for (msgaddr = (uintptr_t)xcpu.cpu_m.xc_msgbox;
-	    msgaddr != NULL; msgaddr = (uintptr_t)msg.xc_next) {
+	    msgaddr != (uintptr_t)NULL; msgaddr = (uintptr_t)msg.xc_next) {
 		if (mdb_vread(&msg, sizeof (msg), msgaddr) != sizeof (msg))
 			return (WALK_ERR);
 
@@ -203,7 +203,7 @@ xcall_dcmd(uintptr_t addr, uint_t flags, int argc, const mdb_arg_t *argv)
 	data.xd_cpu_id = xcpu.cpu_id;
 	data.xd_flags = flags;
 
-	if (mdb_pwalk("cpu", xcall_get_msgs, &data, NULL) == -1) {
+	if (mdb_pwalk("cpu", xcall_get_msgs, &data, (uintptr_t)NULL) == -1) {
 		mdb_warn("can't walk CPUs");
 		return (DCMD_ERR);
 	}
diff --git a/usr/src/cmd/zonecfg/zonecfg.c b/usr/src/cmd/zonecfg/zonecfg.c
index 414e59abcd..00fa901539 100644
--- a/usr/src/cmd/zonecfg/zonecfg.c
+++ b/usr/src/cmd/zonecfg/zonecfg.c
@@ -23,7 +23,7 @@
  * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
  * Copyright 2014 Nexenta Systems, Inc.  All rights reserved.
  * Copyright 2014 Gary Mills
- * Copyright 2016, Joyent Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -2972,7 +2972,7 @@ normalize_mac_addr(char *dst, const char *src, int len)
 	p = strtok(buf, ":");
 	while (p != NULL) {
 		n = strtol(p, &e, 16);
-		if (*e != NULL || n > 0xff)
+		if (*e != '\0' || n > 0xff)
 			return;
 		(void) snprintf(tmp, sizeof (tmp), "%s%02x", sep, n);
 		(void) strlcat(dst, tmp, len);
diff --git a/usr/src/lib/brand/lx/librtld_db/common/lx_librtld_db.c b/usr/src/lib/brand/lx/librtld_db/common/lx_librtld_db.c
index ddea4f910d..9f729ab1a6 100644
--- a/usr/src/lib/brand/lx/librtld_db/common/lx_librtld_db.c
+++ b/usr/src/lib/brand/lx/librtld_db/common/lx_librtld_db.c
@@ -24,7 +24,7 @@
  */
 
 /*
- * Copyright 2015 Joyent, Inc. All rights reserved.
+ * Copyright 2019 Joyent, Inc.
  */
 
 #include <stdio.h>
@@ -687,7 +687,7 @@ lx_elf_props32(struct ps_prochandle *php, uint32_t addr, psaddr_t *data_addr)
 	int		i;
 	uint32_t	min = (uint32_t)-1;
 	uint32_t	max = 0;
-	size_t		sz = NULL;
+	size_t		sz = 0;
 
 	if (ps_pread(php, addr, &ehdr, sizeof (ehdr)) != PS_OK) {
 		ps_plog("lx_elf_props: Couldn't read ELF header at 0x%p",
@@ -742,7 +742,7 @@ lx_ldb_loadobj_iter32(rd_helper_data_t rhd, rl_iter_f *cb, void *client_data)
 	struct ps_prochandle	*php = lx_rd->lr_php;
 	lx_r_debug_t		r_debug;
 	lx_link_map_t		map;
-	uint32_t		p = NULL;
+	uint32_t		p = (uint32_t)(uintptr_t)NULL;
 	int			rc;
 	rd_loadobj_t		exec;
 
@@ -786,7 +786,8 @@ lx_ldb_loadobj_iter32(rd_helper_data_t rhd, rl_iter_f *cb, void *client_data)
 	ps_plog("lx_ldb_loadobj_iter: exec base 0x%p dyn 0x%p",
 	    exec.rl_base, exec.rl_dynamic);
 
-	for (p = map.lxm_next; p != NULL; p = map.lxm_next) {
+	for (p = map.lxm_next; p != (uint32_t)(uintptr_t)NULL;
+	    p = map.lxm_next) {
 		rd_loadobj_t	obj;
 
 		if ((rc = ps_pread(php, (psaddr_t)p, &map, sizeof (map))) !=
@@ -805,7 +806,7 @@ lx_ldb_loadobj_iter32(rd_helper_data_t rhd, rl_iter_f *cb, void *client_data)
 		obj.rl_nameaddr = (psaddr_t)map.lxm_name;
 		obj.rl_base = map.lxm_addr;
 		obj.rl_refnameaddr = (psaddr_t)map.lxm_name;
-		obj.rl_plt_base = NULL;
+		obj.rl_plt_base = (psaddr_t)NULL;
 		obj.rl_plt_size = 0;
 		obj.rl_lmident = LM_ID_BASE;
 
diff --git a/usr/src/lib/brand/lx/lx_brand/common/clone.c b/usr/src/lib/brand/lx/lx_brand/common/clone.c
index b540d5a55e..c6048281b5 100644
--- a/usr/src/lib/brand/lx/lx_brand/common/clone.c
+++ b/usr/src/lib/brand/lx/lx_brand/common/clone.c
@@ -22,7 +22,7 @@
 /*
  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 #include <assert.h>
@@ -687,7 +687,7 @@ lx_clone(uintptr_t p1, uintptr_t p2, uintptr_t p3, uintptr_t p4, uintptr_t p5)
 		return (-ENOMEM);
 	}
 
-	rval = thr_create(NULL, NULL, clone_start, cs, THR_DETACHED, &tid);
+	rval = thr_create(NULL, 0, clone_start, cs, THR_DETACHED, &tid);
 
 	/*
 	 * If the thread did not start, free the resources we allocated:
diff --git a/usr/src/lib/brand/lx/lx_brand/common/lx_brand.c b/usr/src/lib/brand/lx/lx_brand/common/lx_brand.c
index 653973a2db..7373a0d02f 100644
--- a/usr/src/lib/brand/lx/lx_brand/common/lx_brand.c
+++ b/usr/src/lib/brand/lx/lx_brand/common/lx_brand.c
@@ -25,7 +25,7 @@
  */
 
 /*
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 #include <sys/types.h>
@@ -519,7 +519,7 @@ lx_start(uintptr_t sp, uintptr_t entry)
 	jump_uc.uc_flags = UC_CPU;
 	jump_uc.uc_brand_data[0] = (void *)LX_UC_STACK_BRAND;
 
-	LX_REG(&jump_uc, REG_FP) = NULL;
+	LX_REG(&jump_uc, REG_FP) = (uintptr_t)NULL;
 	LX_REG(&jump_uc, REG_SP) = sp;
 	LX_REG(&jump_uc, REG_PC) = entry;
 
@@ -531,29 +531,29 @@ lx_start(uintptr_t sp, uintptr_t entry)
 	 * zeroed prior to initial execution.
 	 */
 #if defined(_LP64)
-	LX_REG(&jump_uc, REG_RAX) = NULL;
-	LX_REG(&jump_uc, REG_RCX) = NULL;
-	LX_REG(&jump_uc, REG_RDX) = NULL;
-	LX_REG(&jump_uc, REG_RBX) = NULL;
-	LX_REG(&jump_uc, REG_RBP) = NULL;
-	LX_REG(&jump_uc, REG_RSI) = NULL;
-	LX_REG(&jump_uc, REG_RDI) = NULL;
-	LX_REG(&jump_uc, REG_R8) = NULL;
-	LX_REG(&jump_uc, REG_R9) = NULL;
-	LX_REG(&jump_uc, REG_R10) = NULL;
-	LX_REG(&jump_uc, REG_R11) = NULL;
-	LX_REG(&jump_uc, REG_R12) = NULL;
-	LX_REG(&jump_uc, REG_R13) = NULL;
-	LX_REG(&jump_uc, REG_R14) = NULL;
-	LX_REG(&jump_uc, REG_R15) = NULL;
+	LX_REG(&jump_uc, REG_RAX) = 0;
+	LX_REG(&jump_uc, REG_RCX) = 0;
+	LX_REG(&jump_uc, REG_RDX) = 0;
+	LX_REG(&jump_uc, REG_RBX) = 0;
+	LX_REG(&jump_uc, REG_RBP) = 0;
+	LX_REG(&jump_uc, REG_RSI) = 0;
+	LX_REG(&jump_uc, REG_RDI) = 0;
+	LX_REG(&jump_uc, REG_R8) = 0;
+	LX_REG(&jump_uc, REG_R9) = 0;
+	LX_REG(&jump_uc, REG_R10) = 0;
+	LX_REG(&jump_uc, REG_R11) = 0;
+	LX_REG(&jump_uc, REG_R12) = 0;
+	LX_REG(&jump_uc, REG_R13) = 0;
+	LX_REG(&jump_uc, REG_R14) = 0;
+	LX_REG(&jump_uc, REG_R15) = 0;
 #else
-	LX_REG(&jump_uc, EAX) = NULL;
-	LX_REG(&jump_uc, ECX) = NULL;
-	LX_REG(&jump_uc, EDX) = NULL;
-	LX_REG(&jump_uc, EBX) = NULL;
-	LX_REG(&jump_uc, EBP) = NULL;
-	LX_REG(&jump_uc, ESI) = NULL;
-	LX_REG(&jump_uc, EDI) = NULL;
+	LX_REG(&jump_uc, EAX) = 0;
+	LX_REG(&jump_uc, ECX) = 0;
+	LX_REG(&jump_uc, EDX) = 0;
+	LX_REG(&jump_uc, EBX) = 0;
+	LX_REG(&jump_uc, EBP) = 0;
+	LX_REG(&jump_uc, ESI) = 0;
+	LX_REG(&jump_uc, EDI) = 0;
 #endif /* defined(_LP64) */
 
 	lx_debug("starting Linux program sp %p ldentry %p", sp, entry);
@@ -736,7 +736,7 @@ lx_init(int argc, char *argv[], char *envp[])
 	 * Find the aux vector on the stack.
 	 */
 	p = (long *)envp;
-	while (*p != NULL)
+	while (*p != (uintptr_t)NULL)
 		p++;
 
 	/*
@@ -755,7 +755,7 @@ lx_init(int argc, char *argv[], char *envp[])
 	 */
 	p++;
 	oap = (auxv_t *)p;
-	while (*p == NULL)
+	while (*p == (uintptr_t)NULL)
 		p++;
 	ap = (auxv_t *)p;
 
diff --git a/usr/src/lib/brand/lx/lx_brand/common/signal.c b/usr/src/lib/brand/lx/lx_brand/common/signal.c
index b9356d16ab..74abff9c8c 100644
--- a/usr/src/lib/brand/lx/lx_brand/common/signal.c
+++ b/usr/src/lib/brand/lx/lx_brand/common/signal.c
@@ -25,7 +25,7 @@
  */
 
 /*
- * Copyright 2018 Joyent, Inc. All rights reserved.
+ * Copyright 2019 Joyent, Inc.
  */
 
 #include <sys/types.h>
@@ -617,7 +617,7 @@ lx_sigaltstack(uintptr_t ssp, uintptr_t oss)
 	lx_tsd_t *lxtsd = lx_get_tsd();
 	lx_stack_t ss;
 
-	if (ssp != NULL) {
+	if (ssp != (uintptr_t)NULL) {
 		if (lxtsd->lxtsd_sigaltstack.ss_flags & LX_SS_ONSTACK) {
 			/*
 			 * If we are currently using the installed alternate
@@ -650,7 +650,7 @@ lx_sigaltstack(uintptr_t ssp, uintptr_t oss)
 		}
 	}
 
-	if (oss != NULL) {
+	if (oss != (uintptr_t)NULL) {
 		/*
 		 * User provided old and new stack_t pointers may point to
 		 * the same location.  Copy out before we modify.
@@ -661,7 +661,7 @@ lx_sigaltstack(uintptr_t ssp, uintptr_t oss)
 		}
 	}
 
-	if (ssp != NULL) {
+	if (ssp != (uintptr_t)NULL) {
 		lxtsd->lxtsd_sigaltstack = ss;
 	}
 
@@ -891,7 +891,7 @@ lx_rt_sigtimedwait(uintptr_t set, uintptr_t sinfo, uintptr_t toutp,
 	 */
 	if ((rc = sigtimedwait(&s_set, s_sinfop,
 	    (struct timespec *)toutp)) == -1)
-		return (toutp == NULL ? -EINTR : -errno);
+		return (toutp == (uintptr_t)NULL ? -EINTR : -errno);
 
 	if (s_sinfop == NULL)
 		return (stol_signo[rc]);
@@ -1331,7 +1331,7 @@ lx_build_signal_frame(int lx_sig, siginfo_t *sip, void *p, void *sp,
 	 *   hdlr(int sig, siginfo_t *sip, void *ucp);
 	 */
 	hargs[0] = lx_sig;
-	hargs[1] = sip != NULL ? (uintptr_t)&lx_ssp->si : NULL;
+	hargs[1] = sip != NULL ? (uintptr_t)&lx_ssp->si : (uintptr_t)NULL;
 	hargs[2] = (uintptr_t)lx_ucp;
 #endif
 
diff --git a/usr/src/lib/brand/lx/lx_brand/common/time.c b/usr/src/lib/brand/lx/lx_brand/common/time.c
index db63c5643c..9b82ec98b5 100644
--- a/usr/src/lib/brand/lx/lx_brand/common/time.c
+++ b/usr/src/lib/brand/lx/lx_brand/common/time.c
@@ -22,7 +22,7 @@
 /*
  * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
- * Copyright 2017 Joyent, Inc.  All rights reserved.
+ * Copyright 2019 Joyent, Inc.
  */
 
 #include <errno.h>
@@ -93,7 +93,7 @@ lx_settimeofday(uintptr_t p1, uintptr_t p2)
 	struct timeval tv;
 	struct lx_timezone tz;
 
-	if ((p1 != NULL) &&
+	if ((p1 != (uintptr_t)NULL) &&
 	    (uucopy((struct timeval *)p1, &tv, sizeof (tv)) < 0))
 		return (-errno);
 
@@ -102,11 +102,11 @@ lx_settimeofday(uintptr_t p1, uintptr_t p2)
 	 * but settimeofday(2) should still return EFAULT if it is set
 	 * to a bad non-NULL pointer (sigh...)
 	 */
-	if ((p2 != NULL) &&
+	if ((p2 != (uintptr_t)NULL) &&
 	    (uucopy((struct lx_timezone *)p2, &tz, sizeof (tz)) < 0))
 		return (-errno);
 
-	if ((p1 != NULL) && (settimeofday(&tv, NULL) < 0))
+	if ((p1 != (uintptr_t)NULL) && (settimeofday(&tv, NULL) < 0))
 		return (-errno);
 
 	return (0);
diff --git a/usr/src/lib/brand/lx/lx_vdso/tools/vdso_tool.c b/usr/src/lib/brand/lx/lx_vdso/tools/vdso_tool.c
index 0e1d99f9da..c423184138 100644
--- a/usr/src/lib/brand/lx/lx_vdso/tools/vdso_tool.c
+++ b/usr/src/lib/brand/lx/lx_vdso/tools/vdso_tool.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright 2015 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -293,8 +293,7 @@ update_pt_load_size(vdso_t *v)
 
 		phdr.p_memsz = phdr.p_filesz = v->v_max_offset;
 
-		if (gelf_update_phdr(v->v_elf, v->v_ptload_phdr, &phdr) ==
-		    NULL) {
+		if (gelf_update_phdr(v->v_elf, v->v_ptload_phdr, &phdr) == 0) {
 			(void) fprintf(stderr, "could not update PT_LOAD "
 			    "phdr: %s", elf_errmsg(-1));
 			goto errout;
diff --git a/usr/src/lib/fm/topo/modules/common/ipmi/ipmi_enum.c b/usr/src/lib/fm/topo/modules/common/ipmi/ipmi_enum.c
index c5ef0fbb4c..a2b5274354 100644
--- a/usr/src/lib/fm/topo/modules/common/ipmi/ipmi_enum.c
+++ b/usr/src/lib/fm/topo/modules/common/ipmi/ipmi_enum.c
@@ -568,7 +568,7 @@ ipmi_enum_sp(topo_mod_t *mod, tnode_t *pnode)
 	}
 
 	if (topo_node_fru(pnode, &fmri, NULL, &err) != 0 ||
-	    topo_node_fru_set(sp_node, fmri, NULL, &err) != 0) {
+	    topo_node_fru_set(sp_node, fmri, 0, &err) != 0) {
 		topo_mod_dprintf(mod, "failed to set FRU on %s=%d: %s", SP, 0,
 		    topo_strerror(err));
 		nvlist_free(fmri);
diff --git a/usr/src/lib/libzonecfg/common/libzonecfg.c b/usr/src/lib/libzonecfg/common/libzonecfg.c
index 27eb28206c..e709b7dba8 100644
--- a/usr/src/lib/libzonecfg/common/libzonecfg.c
+++ b/usr/src/lib/libzonecfg/common/libzonecfg.c
@@ -2163,7 +2163,7 @@ normalize_mac_addr(char *dst, const char *src, int len)
 	p = strtok(buf, ":");
 	while (p != NULL) {
 		n = strtol(p, &e, 16);
-		if (*e != NULL || n > 0xff)
+		if (*e != '\0' || n > 0xff)
 			return;
 		(void) snprintf(tmp, sizeof (tmp), "%s%02x", sep, n);
 		(void) strlcat(dst, tmp, len);
diff --git a/usr/src/lib/varpd/libvarpd/common/libvarpd_client.c b/usr/src/lib/varpd/libvarpd/common/libvarpd_client.c
index 260bbb6e92..18e220259c 100644
--- a/usr/src/lib/varpd/libvarpd/common/libvarpd_client.c
+++ b/usr/src/lib/varpd/libvarpd/common/libvarpd_client.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -378,7 +378,7 @@ libvarpd_c_prop_set(varpd_client_prop_handle_t *phdl, const void *buf,
 	varpd_client_prop_arg_t *vcpap = &carg.vca_un.vca_prop;
 	varpd_client_prop_info_t *infop = (varpd_client_prop_info_t *)phdl;
 
-	if (len == NULL || buf == NULL || infop->vcprop_propid == UINT_MAX)
+	if (len == 0 || buf == NULL || infop->vcprop_propid == UINT_MAX)
 		return (EINVAL);
 	if (len > LIBVARPD_PROP_SIZEMAX)
 		return (EOVERFLOW);
diff --git a/usr/src/lib/varpd/svp/common/libvarpd_svp_remote.c b/usr/src/lib/varpd/svp/common/libvarpd_svp_remote.c
index 8d482e4a12..99775f93c0 100644
--- a/usr/src/lib/varpd/svp/common/libvarpd_svp_remote.c
+++ b/usr/src/lib/varpd/svp/common/libvarpd_svp_remote.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright 2015 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -347,7 +347,7 @@ svp_remote_vl2_lookup(svp_t *svp, svp_query_t *sqp, const uint8_t *mac,
 
 	mutex_enter(&srp->sr_lock);
 	if (svp_remote_conn_queue(srp, sqp) == B_FALSE)
-		svp->svp_cb.scb_vl2_lookup(svp, SVP_S_FATAL, NULL, NULL, arg);
+		svp->svp_cb.scb_vl2_lookup(svp, SVP_S_FATAL, NULL, 0, arg);
 	mutex_exit(&srp->sr_lock);
 }
 
diff --git a/usr/src/uts/common/brand/lx/devfs/lxd_vfsops.c b/usr/src/uts/common/brand/lx/devfs/lxd_vfsops.c
index b2e2b9b9e3..69c131d886 100644
--- a/usr/src/uts/common/brand/lx/devfs/lxd_vfsops.c
+++ b/usr/src/uts/common/brand/lx/devfs/lxd_vfsops.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright 2016 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -179,7 +179,7 @@ lxd_devt_translator_t lxd_devt_translators[] = {
 	{ "zcons",	0, DTT_LIST,	(uintptr_t)&lxd_mtranslator_zcons },
 	{ LX_PTM_DRV,	0, DTT_CUSTOM,	(uintptr_t)lxd_ptm_devt_translator },
 	{ "pts",	0, DTT_CUSTOM,	(uintptr_t)lxd_pts_devt_translator },
-	{ NULL,		0, DTT_INVALID,	NULL }
+	{ NULL,		0, DTT_INVALID,	(uintptr_t)NULL }
 };
 
 int
diff --git a/usr/src/uts/common/brand/lx/dtrace/lx_systrace.c b/usr/src/uts/common/brand/lx/dtrace/lx_systrace.c
index de5a16c414..a55b436088 100644
--- a/usr/src/uts/common/brand/lx/dtrace/lx_systrace.c
+++ b/usr/src/uts/common/brand/lx/dtrace/lx_systrace.c
@@ -22,7 +22,7 @@
 /*
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
- * Copyright 2016 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 
@@ -335,7 +335,7 @@ lx_systrace_attach(dev_info_t *devi, ddi_attach_cmd_t cmd)
 	}
 
 	if (ddi_create_minor_node(devi, "lx_systrace", S_IFCHR,
-	    0, DDI_PSEUDO, NULL) == DDI_FAILURE ||
+	    0, DDI_PSEUDO, 0) == DDI_FAILURE ||
 	    dtrace_register("lx-syscall", &lx_systrace_attr,
 	    DTRACE_PRIV_USER, 0, &lx_systrace_pops, NULL,
 	    &lx_systrace_id) != 0) {
diff --git a/usr/src/uts/common/brand/lx/os/lx_brand.c b/usr/src/uts/common/brand/lx/os/lx_brand.c
index 0f78bca605..83fbd6adb7 100644
--- a/usr/src/uts/common/brand/lx/os/lx_brand.c
+++ b/usr/src/uts/common/brand/lx/os/lx_brand.c
@@ -824,7 +824,7 @@ lx_savecontext32(ucontext32_t *ucp)
 			flags |= LX_UC_RESTART_SYSCALL;
 		}
 	} else {
-		ucp->uc_brand_data[2] = NULL;
+		ucp->uc_brand_data[2] = (caddr32_t)(uintptr_t)NULL;
 	}
 
 	ucp->uc_brand_data[0] = flags;
@@ -920,7 +920,7 @@ lx_zvol_props(ldi_handle_t lh, zfs_cmd_t *zc, uint64_t *vsz, uint64_t *bsz)
 	ASSERT(rc == 0);
 
 	kmem_free((void *)(uintptr_t)zc->zc_nvlist_dst, size);
-	zc->zc_nvlist_dst = NULL;
+	zc->zc_nvlist_dst = (uintptr_t)NULL;
 	zc->zc_nvlist_dst_size = 0;
 
 	if ((rc = nvlist_lookup_nvlist(nv, "volsize", &nv2)) == 0) {
@@ -1727,7 +1727,7 @@ lx_brandsys(int cmd, int64_t *rval, uintptr_t arg1, uintptr_t arg2,
 		 * arg1 = ucontext_t pointer for jump state
 		 */
 
-		if (arg1 == NULL)
+		if (arg1 == (uintptr_t)NULL)
 			return (EINVAL);
 
 		switch (lwpd->br_stack_mode) {
@@ -2061,8 +2061,8 @@ lx_map_vdso(struct uarg *args, struct cred *cred)
 	/*
 	 * The comm page should have been mapped in already.
 	 */
-	if (args->commpage == NULL) {
-		return (NULL);
+	if (args->commpage == (uintptr_t)NULL) {
+		return ((uintptr_t)NULL);
 	}
 
 	/*
@@ -2075,7 +2075,7 @@ lx_map_vdso(struct uarg *args, struct cred *cred)
 	fpath++;
 	if (lookupnameat(fpath, UIO_SYSSPACE, FOLLOW, NULLVPP, &vp,
 	    curzone->zone_rootvp) != 0) {
-		return (NULL);
+		return ((uintptr_t)NULL);
 	}
 
 	/*
@@ -2088,14 +2088,14 @@ lx_map_vdso(struct uarg *args, struct cred *cred)
 	if (VOP_GETATTR(vp, &attr, 0, cred, NULL) != 0 ||
 	    attr.va_size > LX_VDSO_SIZE) {
 		VN_RELE(vp);
-		return (NULL);
+		return ((uintptr_t)NULL);
 	}
 
 	err = execmap(vp, addr, attr.va_size, 0, 0,
 	    PROT_USER|PROT_READ|PROT_EXEC, 1, 0);
 	VN_RELE(vp);
 	if (err != 0) {
-		return (NULL);
+		return ((uintptr_t)NULL);
 	}
 	return ((uintptr_t)addr);
 }
@@ -2116,7 +2116,7 @@ lx_elfexec(struct vnode *vp, struct execa *uap, struct uarg *args,
 	Addr		uphdr_vaddr;
 	intptr_t	voffset;
 	char		*interp = NULL;
-	uintptr_t	ldaddr = NULL;
+	uintptr_t	ldaddr = (uintptr_t)NULL;
 	proc_t		*p = ttoproc(curthread);
 	klwp_t		*lwp = ttolwp(curthread);
 	lx_proc_data_t	*lxpd = ptolxproc(p);
diff --git a/usr/src/uts/common/brand/lx/os/lx_misc.c b/usr/src/uts/common/brand/lx/os/lx_misc.c
index 35e42edaa3..b73e7f430a 100644
--- a/usr/src/uts/common/brand/lx/os/lx_misc.c
+++ b/usr/src/uts/common/brand/lx/os/lx_misc.c
@@ -24,7 +24,7 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 #include <sys/errno.h>
@@ -89,7 +89,7 @@ lx_exec()
 	 * Any l_handler handlers set as a result of B_REGISTER are now
 	 * invalid; clear them.
 	 */
-	pd->l_handler = NULL;
+	pd->l_handler = (uintptr_t)NULL;
 
 	/*
 	 * If this was a multi-threaded Linux process and this lwp wasn't the
@@ -107,10 +107,10 @@ lx_exec()
 	(void) lx_ptrace_stop_for_option(LX_PTRACE_O_TRACEEXEC, B_FALSE, 0, 0);
 
 	/* clear the fs/gsbase values until the app. can reinitialize them */
-	lwpd->br_lx_fsbase = NULL;
-	lwpd->br_ntv_fsbase = NULL;
-	lwpd->br_lx_gsbase = NULL;
-	lwpd->br_ntv_gsbase = NULL;
+	lwpd->br_lx_fsbase = (uintptr_t)NULL;
+	lwpd->br_ntv_fsbase = (uintptr_t)NULL;
+	lwpd->br_lx_gsbase = (uintptr_t)NULL;
+	lwpd->br_ntv_gsbase = (uintptr_t)NULL;
 
 	/*
 	 * Clear the native stack flags.  This will be reinitialised by
@@ -227,7 +227,7 @@ lx_exitlwp(klwp_t *lwp)
 	if (lwpd->br_clear_ctidp != NULL) {
 		(void) suword32(lwpd->br_clear_ctidp, 0);
 		(void) lx_futex((uintptr_t)lwpd->br_clear_ctidp, FUTEX_WAKE, 1,
-		    NULL, NULL, 0);
+		    (uintptr_t)NULL, (uintptr_t)NULL, 0);
 		lwpd->br_clear_ctidp = NULL;
 	}
 
@@ -712,7 +712,7 @@ lx_fsbase(klwp_t *lwp, uintptr_t fsbase)
 	lx_lwp_data_t *lwpd = lwp->lwp_brand;
 
 	if (lwpd->br_stack_mode != LX_STACK_MODE_BRAND ||
-	    lwpd->br_ntv_fsbase == NULL) {
+	    lwpd->br_ntv_fsbase == (uintptr_t)NULL) {
 		return (fsbase);
 	}
 
@@ -1094,7 +1094,7 @@ lx_read_argv_bounds(proc_t *p)
 	 * to a large amount of stack growth and anonymous memory allocation,
 	 * all of which is pointless since the first page can't be mapped.
 	 */
-	if (addr_arg != NULL || addr_env != NULL) {
+	if (addr_arg != (uintptr_t)NULL || addr_env != (uintptr_t)NULL) {
 		mutex_exit(&p->p_lock);
 #if defined(_LP64)
 		if (p->p_model != DATAMODEL_NATIVE) {
@@ -1180,7 +1180,7 @@ lx_regs_location(lx_lwp_data_t *lwpd, void **ucp, boolean_t for_write)
 		break;
 	}
 
-	if (lwpd->br_ptrace_stopucp != NULL) {
+	if (lwpd->br_ptrace_stopucp != (uintptr_t)NULL) {
 		/*
 		 * The LWP was stopped in the usermode emulation library
 		 * but a ucontext_t for the preserved brand stack and
diff --git a/usr/src/uts/common/brand/lx/os/lx_ptrace.c b/usr/src/uts/common/brand/lx/os/lx_ptrace.c
index 252f83fd3f..07757ab0aa 100644
--- a/usr/src/uts/common/brand/lx/os/lx_ptrace.c
+++ b/usr/src/uts/common/brand/lx/os/lx_ptrace.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright 2017 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -1449,7 +1449,7 @@ lx_ptrace_stop_common(proc_t *p, lx_lwp_data_t *lwpd, ushort_t what)
 	 */
 	lwpd->br_ptrace_flags &= ~(LX_PTF_STOPPING | LX_PTF_STOPPED |
 	    LX_PTF_CLDPEND);
-	lwpd->br_ptrace_stopucp = NULL;
+	lwpd->br_ptrace_stopucp = (uintptr_t)NULL;
 	cv_broadcast(&lx_ptrace_busy_cv);
 	mutex_exit(&p->p_lock);
 
diff --git a/usr/src/uts/common/brand/lx/os/lx_syscall.c b/usr/src/uts/common/brand/lx/os/lx_syscall.c
index 5a8f9322a0..f349cfec1f 100644
--- a/usr/src/uts/common/brand/lx/os/lx_syscall.c
+++ b/usr/src/uts/common/brand/lx/os/lx_syscall.c
@@ -22,7 +22,7 @@
 /*
  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  * Copyright 2019 OmniOS Community Edition (OmniOSce) Association.
  */
 
@@ -106,7 +106,7 @@ struct lx_vsyscall
 	{ LX_VSYS_gettimeofday, LX_SYS_gettimeofday },
 	{ LX_VSYS_time, LX_SYS_time },
 	{ LX_VSYS_getcpu, LX_SYS_getcpu },
-	{ NULL, NULL }
+	{ (uintptr_t)NULL, (uintptr_t)NULL }
 };
 #endif
 
@@ -509,7 +509,7 @@ lx_vsyscall_iscall(klwp_t *lwp, uintptr_t addr, int *scnum)
 		return (B_FALSE);
 	}
 
-	for (i = 0; lx_vsyscalls[i].lv_addr != NULL; i++) {
+	for (i = 0; lx_vsyscalls[i].lv_addr != (uintptr_t)NULL; i++) {
 		if (addr == lx_vsyscalls[i].lv_addr) {
 			/*
 			 * This is a valid vsyscall address.
diff --git a/usr/src/uts/common/brand/lx/syscall/lx_aio.c b/usr/src/uts/common/brand/lx/syscall/lx_aio.c
index c821e72538..1b673066e6 100644
--- a/usr/src/uts/common/brand/lx/syscall/lx_aio.c
+++ b/usr/src/uts/common/brand/lx/syscall/lx_aio.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright 2017 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -601,7 +601,7 @@ lx_io_setup(uint_t nr_events, void *ctxp)
 		return (set_errno(EFAULT));
 
 	/* The cid in user-land must be NULL to start */
-	if (cid != NULL || nr_events > LX_AIO_MAX_NR)
+	if (cid != (uintptr_t)NULL || nr_events > LX_AIO_MAX_NR)
 		return (set_errno(EINVAL));
 
 	mutex_enter(&lxzd->lxzd_lock);
@@ -1308,7 +1308,7 @@ lx_io_clear(lx_proc_data_t *cpd)
 {
 	cpd->l_io_ctxs = NULL;
 	cpd->l_io_ctx_cnt = 0;
-	cpd->l_io_ctxpage = NULL;
+	cpd->l_io_ctxpage = (uintptr_t)NULL;
 }
 
 /*
diff --git a/usr/src/uts/common/brand/lx/syscall/lx_futex.c b/usr/src/uts/common/brand/lx/syscall/lx_futex.c
index afde816b39..3642b006c0 100644
--- a/usr/src/uts/common/brand/lx/syscall/lx_futex.c
+++ b/usr/src/uts/common/brand/lx/syscall/lx_futex.c
@@ -1265,7 +1265,7 @@ lx_futex(uintptr_t addr, int op, int val, uintptr_t lx_timeout,
 	memid_t memid, memid2;
 	timestruc_t timeout;
 	timestruc_t *tptr = NULL;
-	int val2 = NULL;
+	int val2 = 0;
 	int rval = 0;
 	int cmd = op & FUTEX_CMD_MASK;
 	int private = op & FUTEX_PRIVATE_FLAG;
@@ -1314,7 +1314,7 @@ lx_futex(uintptr_t addr, int op, int val, uintptr_t lx_timeout,
 
 	/* Copy in the timeout structure from userspace. */
 	if ((cmd == FUTEX_WAIT || cmd == FUTEX_WAIT_BITSET ||
-	    cmd == FUTEX_LOCK_PI) && lx_timeout != NULL) {
+	    cmd == FUTEX_LOCK_PI) && lx_timeout != (uintptr_t)NULL) {
 		rval = get_timeout((timespec_t *)lx_timeout, &timeout, cmd);
 
 		if (rval != 0)
@@ -1562,7 +1562,7 @@ lx_futex_robust_exit(uintptr_t addr, uint32_t tid)
 	/*
 	 * Finally, drop the pending lock if there is one.
 	 */
-	if (list.frl_pending != NULL && list.frl_pending +
+	if (list.frl_pending != (uint32_t)(uintptr_t)NULL && list.frl_pending +
 	    list.frl_offset + sizeof (uint32_t) < KERNELBASE)
 		lx_futex_robust_drop(list.frl_pending + list.frl_offset, tid);
 
diff --git a/usr/src/uts/common/brand/lx/syscall/lx_ioctl.c b/usr/src/uts/common/brand/lx/syscall/lx_ioctl.c
index 9d8d88d6f6..9e9073d049 100644
--- a/usr/src/uts/common/brand/lx/syscall/lx_ioctl.c
+++ b/usr/src/uts/common/brand/lx/syscall/lx_ioctl.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 #include <sys/errno.h>
@@ -1467,7 +1467,7 @@ ict_siocgifconf32(file_t *fp, int cmd, intptr_t arg, int lxcmd)
 		return (set_errno(EFAULT));
 
 	/* They want to know how many interfaces there are. */
-	if (conf.if_len <= 0 || conf.if_buf == NULL) {
+	if (conf.if_len <= 0 || conf.if_buf == (uint32_t)(uintptr_t)NULL) {
 		error = ict_if_ioctl(fp->f_vnode, SIOCGIFNUM,
 		    (intptr_t)&ifcount, FLFAKE(fp), fp->f_cred);
 		if (error != 0)
diff --git a/usr/src/uts/common/brand/lx/syscall/lx_mem.c b/usr/src/uts/common/brand/lx/syscall/lx_mem.c
index cc756717f1..15351444c8 100644
--- a/usr/src/uts/common/brand/lx/syscall/lx_mem.c
+++ b/usr/src/uts/common/brand/lx/syscall/lx_mem.c
@@ -12,7 +12,7 @@
 /*
  * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 #include <sys/types.h>
@@ -891,7 +891,7 @@ lx_mremap(uintptr_t old_addr, size_t old_size, size_t new_size, int flags,
 			return (old_addr);
 
 		/* new_addr is optional and only valid when LX_MREMAP_FIXED. */
-		new_addr = NULL;
+		new_addr = (uintptr_t)NULL;
 	}
 
 	if (old_addr & PAGEOFFSET)
diff --git a/usr/src/uts/common/brand/lx/syscall/lx_miscsys.c b/usr/src/uts/common/brand/lx/syscall/lx_miscsys.c
index 5245b32870..25f06e134b 100644
--- a/usr/src/uts/common/brand/lx/syscall/lx_miscsys.c
+++ b/usr/src/uts/common/brand/lx/syscall/lx_miscsys.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright 2017 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 #include <sys/systeminfo.h>
@@ -327,12 +327,12 @@ lx_reboot(int magic1, int magic2, uint_t flag, uintptr_t p4)
 
 	case LINUX_REBOOT_CMD_POWER_OFF:
 	case LINUX_REBOOT_CMD_HALT:
-		return (uadmin(A_SHUTDOWN, AD_HALT, NULL));
+		return (uadmin(A_SHUTDOWN, AD_HALT, (uintptr_t)NULL));
 
 	case LINUX_REBOOT_CMD_RESTART:
 	case LINUX_REBOOT_CMD_RESTART2:
 		/* RESTART2 may need more work */
-		return (uadmin(A_SHUTDOWN, AD_BOOT, NULL));
+		return (uadmin(A_SHUTDOWN, AD_BOOT, (uintptr_t)NULL));
 
 	default:
 		return (set_errno(EINVAL));
diff --git a/usr/src/uts/common/brand/lx/syscall/lx_wait.c b/usr/src/uts/common/brand/lx/syscall/lx_wait.c
index e8358f9f69..3a5ba69b93 100644
--- a/usr/src/uts/common/brand/lx/syscall/lx_wait.c
+++ b/usr/src/uts/common/brand/lx/syscall/lx_wait.c
@@ -22,7 +22,7 @@
 /*
  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
- * Copyright 2015 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -322,7 +322,7 @@ lx_wait4(uintptr_t p1, uintptr_t p2, uintptr_t p3, uintptr_t p4)
 long
 lx_waitpid(uintptr_t p1, uintptr_t p2, uintptr_t p3)
 {
-	return (lx_wait4(p1, p2, p3, NULL));
+	return (lx_wait4(p1, p2, p3, (uintptr_t)NULL));
 }
 
 long
diff --git a/usr/src/uts/common/exec/elf/elf.c b/usr/src/uts/common/exec/elf/elf.c
index a4078bb351..ad7e47e852 100644
--- a/usr/src/uts/common/exec/elf/elf.c
+++ b/usr/src/uts/common/exec/elf/elf.c
@@ -26,7 +26,7 @@
 /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
 /*	   All Rights Reserved	*/
 /*
- * Copyright (c) 2019, Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 #include <sys/types.h>
@@ -269,7 +269,7 @@ mapexec_brand(vnode_t *vp, uarg_t *args, Ehdr *ehdr, Addr *uphdr_vaddr,
 		*lddatap = 0;
 
 	if (minaddrp != NULL)
-		*minaddrp = NULL;
+		*minaddrp = (uintptr_t)NULL;
 
 	if (error = execpermissions(vp, &vat, args)) {
 		uprintf("%s: Cannot execute %s\n", exec_file, args->pathname);
diff --git a/usr/src/uts/common/fs/dev/sdev_plugin.c b/usr/src/uts/common/fs/dev/sdev_plugin.c
index 621eb3287f..8f825eccff 100644
--- a/usr/src/uts/common/fs/dev/sdev_plugin.c
+++ b/usr/src/uts/common/fs/dev/sdev_plugin.c
@@ -566,23 +566,23 @@ sdev_plugin_register(const char *name, sdev_plugin_ops_t *ops, int *errp)
 
 	if (sdev_plugin_name_isvalid(name, SDEV_PLUGIN_NAMELEN) == 0) {
 		*errp = EINVAL;
-		return (NULL);
+		return ((sdev_plugin_hdl_t)NULL);
 	}
 
 	if (ops->spo_version != 1) {
 		*errp = EINVAL;
-		return (NULL);
+		return ((sdev_plugin_hdl_t)NULL);
 	}
 
 	if (ops->spo_validate == NULL || ops->spo_filldir == NULL ||
 	    ops->spo_inactive == NULL) {
 		*errp = EINVAL;
-		return (NULL);
+		return ((sdev_plugin_hdl_t)NULL);
 	}
 
 	if ((ops->spo_flags & ~SDEV_PLUGIN_FLAGS_MASK) != 0) {
 		*errp = EINVAL;
-		return (NULL);
+		return ((sdev_plugin_hdl_t)NULL);
 	}
 
 	spp = kmem_cache_alloc(sdev_plugin_cache, KM_SLEEP);
@@ -619,7 +619,7 @@ sdev_plugin_register(const char *name, sdev_plugin_ops_t *ops, int *errp)
 	if (ret != 0) {
 		*errp = ret;
 		kmem_cache_free(sdev_plugin_cache, spp);
-		return (NULL);
+		return ((sdev_plugin_hdl_t)NULL);
 	}
 	/* Make sure we have the real vnode */
 	if (VOP_REALVP(vp, &nvp, NULL) == 0) {
@@ -638,7 +638,7 @@ sdev_plugin_register(const char *name, sdev_plugin_ops_t *ops, int *errp)
 		VN_RELE(vp);
 		*errp = EEXIST;
 		kmem_cache_free(sdev_plugin_cache, spp);
-		return (NULL);
+		return ((sdev_plugin_hdl_t)NULL);
 	}
 
 	mutex_enter(&sdev_plugin_lock);
@@ -650,7 +650,7 @@ sdev_plugin_register(const char *name, sdev_plugin_ops_t *ops, int *errp)
 			VN_RELE(vp);
 			*errp = EEXIST;
 			kmem_cache_free(sdev_plugin_cache, spp);
-			return (NULL);
+			return ((sdev_plugin_hdl_t)NULL);
 		}
 	}
 
diff --git a/usr/src/uts/common/fs/proc/prargv.c b/usr/src/uts/common/fs/proc/prargv.c
index b09a9c8afc..40d47598ac 100644
--- a/usr/src/uts/common/fs/proc/prargv.c
+++ b/usr/src/uts/common/fs/proc/prargv.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright 2015, Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 #include <sys/types.h>
@@ -90,7 +90,7 @@ prreadargv(proc_t *p, char *buf, size_t bufsz, size_t *slen)
 	up = PTOU(p);
 	as = p->p_as;
 
-	if ((p->p_flag & SSYS) || as == &kas || up->u_argv == NULL) {
+	if ((p->p_flag & SSYS) || as == &kas || up->u_argv == (uintptr_t)NULL) {
 		/*
 		 * Return the regular psargs string to the caller.
 		 */
@@ -146,7 +146,7 @@ prreadargv(proc_t *p, char *buf, size_t bufsz, size_t *slen)
 		 * Stop trying to read arguments if we reach a NULL
 		 * pointer in the vector.
 		 */
-		if (arg == NULL)
+		if (arg == (uintptr_t)NULL)
 			break;
 
 		/*
@@ -249,7 +249,7 @@ prreadenvv(proc_t *p, char *buf, size_t bufsz, size_t *slen)
 	struct as *as;
 	size_t pos = 0;
 	caddr_t *envp = NULL;
-	uintptr_t tmpp = NULL;
+	uintptr_t tmpp = (uintptr_t)NULL;
 	size_t envpsz = 0, rdsz = 0;
 	int i;
 	int cnt, bound;
@@ -260,7 +260,7 @@ prreadenvv(proc_t *p, char *buf, size_t bufsz, size_t *slen)
 	up = PTOU(p);
 	as = p->p_as;
 
-	if ((p->p_flag & SSYS) || as == &kas || up->u_envp == NULL) {
+	if ((p->p_flag & SSYS) || as == &kas || up->u_envp == (uintptr_t)NULL) {
 		/*
 		 * Return empty string.
 		 */
@@ -350,7 +350,7 @@ prreadenvv(proc_t *p, char *buf, size_t bufsz, size_t *slen)
 		 * Stop trying to read env entries if we reach a NULL
 		 * pointer in the vector.
 		 */
-		if (ev == NULL)
+		if (ev == (uintptr_t)NULL)
 			break;
 
 		/*
diff --git a/usr/src/uts/common/fs/zfs/spa_misc.c b/usr/src/uts/common/fs/zfs/spa_misc.c
index d291b7b62f..07ccf6b1cc 100644
--- a/usr/src/uts/common/fs/zfs/spa_misc.c
+++ b/usr/src/uts/common/fs/zfs/spa_misc.c
@@ -1044,7 +1044,7 @@ spa_spare_poll(spa_t *spa)
 		mutex_enter(&spa_spare_lock);
 		found = avl_find(&spa_spare_avl, &search, NULL);
 		/* This spare is in use by a pool. */
-		if (found != NULL && found->aux_pool != NULL) {
+		if (found != NULL && found->aux_pool != 0ULL) {
 			mutex_exit(&spa_spare_lock);
 			continue;
 		}
diff --git a/usr/src/uts/common/fs/zfs/zfs_ioctl.c b/usr/src/uts/common/fs/zfs/zfs_ioctl.c
index 45de48cfda..6f21344ef6 100644
--- a/usr/src/uts/common/fs/zfs/zfs_ioctl.c
+++ b/usr/src/uts/common/fs/zfs/zfs_ioctl.c
@@ -25,7 +25,7 @@
  * Portions Copyright 2011 Martin Matuska
  * Copyright 2015, OmniTI Computer Consulting, Inc. All rights reserved.
  * Copyright 2016 Nexenta Systems, Inc.  All rights reserved.
- * Copyright (c) 2014, 2016 Joyent, Inc. All rights reserved.
+ * Copyright 2019 Joyent, Inc.
  * Copyright (c) 2011, 2017 by Delphix. All rights reserved.
  * Copyright (c) 2013 by Saso Kiselkov. All rights reserved.
  * Copyright (c) 2013 Steven Hartland. All rights reserved.
@@ -2193,7 +2193,7 @@ zfs_ioc_objset_stats(zfs_cmd_t *zc)
 	boolean_t cachedpropsonly = B_FALSE;
 	int error;
 
-	if (zc->zc_nvlist_src != NULL &&
+	if (zc->zc_nvlist_src != (uintptr_t)NULL &&
 	    (error = get_nvlist(zc->zc_nvlist_src, zc->zc_nvlist_src_size,
 	    zc->zc_iflags, &nvl) != 0))
 		return (error);
@@ -2405,7 +2405,7 @@ zfs_ioc_snapshot_list_next(zfs_cmd_t *zc)
 	boolean_t cachedpropsonly = B_FALSE;
 	int error;
 
-	if (zc->zc_nvlist_src != NULL &&
+	if (zc->zc_nvlist_src != (uintptr_t)NULL &&
 	    (error = get_nvlist(zc->zc_nvlist_src, zc->zc_nvlist_src_size,
 	    zc->zc_iflags, &nvl) != 0))
 		return (error);
diff --git a/usr/src/uts/common/inet/ip/ip_if.c b/usr/src/uts/common/inet/ip/ip_if.c
index 11a9024053..24e4c200d4 100644
--- a/usr/src/uts/common/inet/ip/ip_if.c
+++ b/usr/src/uts/common/inet/ip/ip_if.c
@@ -22,7 +22,7 @@
  * Copyright (c) 1991, 2010, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 1990 Mentat Inc.
  * Copyright (c) 2013 by Delphix. All rights reserved.
- * Copyright (c) 2016, Joyent, Inc. All rights reserved.
+ * Copyright 2019 Joyent, Inc.
  * Copyright (c) 2014, OmniTI Computer Consulting, Inc. All rights reserved.
  */
 
@@ -3513,7 +3513,7 @@ ill_init_common(ill_t *ill, queue_t *q, boolean_t isv6, boolean_t is_loopback,
 	ill->ill_max_buf = ND_MAX_Q;
 	ill->ill_refcnt = 0;
 
-	cv_init(&ill->ill_dlpi_capab_cv, NULL, NULL, NULL);
+	cv_init(&ill->ill_dlpi_capab_cv, NULL, CV_DEFAULT, NULL);
 	mutex_init(&ill->ill_dlpi_capab_lock, NULL, MUTEX_DEFAULT, NULL);
 
 	return (0);
diff --git a/usr/src/uts/common/inet/tcp/tcp_timers.c b/usr/src/uts/common/inet/tcp/tcp_timers.c
index 804160f628..df8b50f345 100644
--- a/usr/src/uts/common/inet/tcp/tcp_timers.c
+++ b/usr/src/uts/common/inet/tcp/tcp_timers.c
@@ -22,7 +22,7 @@
 /*
  * Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2011 Nexenta Systems, Inc. All rights reserved.
- * Copyright 2011 Joyent, Inc.  All rights reserved.
+ * Copyright 2019 Joyent, Inc.
  * Copyright (c) 2014, 2017 by Delphix. All rights reserved.
  */
 
@@ -784,7 +784,7 @@ tcp_timer(void *arg)
 					    SL_TRACE, "tcp_timer: zero win");
 				}
 			} else {
-				cc_cong_signal(tcp, NULL, CC_RTO);
+				cc_cong_signal(tcp, 0, CC_RTO);
 			}
 			break;
 		}
diff --git a/usr/src/uts/common/io/dld/dld_str.c b/usr/src/uts/common/io/dld/dld_str.c
index 5efbe0576d..e9e98441b5 100644
--- a/usr/src/uts/common/io/dld/dld_str.c
+++ b/usr/src/uts/common/io/dld/dld_str.c
@@ -22,6 +22,10 @@
  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
  */
 
+/*
+ * Copyright 2019 Joyent, Inc.
+ */
+
 /*
  * Data-Link Driver
  */
@@ -916,14 +920,14 @@ str_mdata_raw_fastpath_put(dld_str_t *dsp, mblk_t *mp, uintptr_t f_hint,
 			goto discard;
 	}
 
-	if ((cookie = DLD_TX(dsp, mp, f_hint, flag)) != NULL) {
+	if ((cookie = DLD_TX(dsp, mp, f_hint, flag)) != (mac_tx_cookie_t)NULL) {
 		DLD_SETQFULL(dsp);
 	}
 	return (cookie);
 discard:
 	/* TODO: bump kstat? */
 	freemsg(mp);
-	return (NULL);
+	return ((mac_tx_cookie_t)NULL);
 }
 
 
diff --git a/usr/src/uts/common/io/dls/dls_mgmt.c b/usr/src/uts/common/io/dls/dls_mgmt.c
index dba205b7a2..90b65ab36a 100644
--- a/usr/src/uts/common/io/dls/dls_mgmt.c
+++ b/usr/src/uts/common/io/dls/dls_mgmt.c
@@ -21,7 +21,7 @@
 /*
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
- * Copyright (c) 2017 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 /*
  * Copyright (c) 2016 by Delphix. All rights reserved.
@@ -986,8 +986,8 @@ done:
 			*ddpp = ddp;
 
 		mutex_enter(&ddp->dd_mutex);
-		if (linkid != DATALINK_INVALID_LINKID &&
-		    !ddp->dd_prop_loaded && ddp->dd_prop_taskid == NULL) {
+		if (linkid != DATALINK_INVALID_LINKID && !ddp->dd_prop_loaded &&
+		    ddp->dd_prop_taskid == TASKQID_INVALID) {
 			ddp->dd_prop_taskid = taskq_dispatch(system_taskq,
 			    dls_devnet_prop_task, ddp, TQ_SLEEP);
 		}
diff --git a/usr/src/uts/common/io/dr_sas/dr_sas.c b/usr/src/uts/common/io/dr_sas/dr_sas.c
index 3f7be11abf..0d277ada42 100644
--- a/usr/src/uts/common/io/dr_sas/dr_sas.c
+++ b/usr/src/uts/common/io/dr_sas/dr_sas.c
@@ -2585,7 +2585,7 @@ service_mfi_aen(struct drsas_instance *instance, struct drsas_cmd *cmd)
 		for (tgt = 0; tgt < MRDRV_MAX_LD; tgt++) {
 			if (instance->dr_ld_list[tgt].dip != NULL) {
 				rval = drsas_service_evt(instance, tgt, 0,
-				    DRSAS_EVT_UNCONFIG_TGT, NULL);
+				    DRSAS_EVT_UNCONFIG_TGT);
 				con_log(CL_ANN1, (CE_WARN,
 				    "dr_sas: CFG CLEARED AEN rval = %d "
 				    "tgt id = %d", rval, tgt));
@@ -2597,7 +2597,7 @@ service_mfi_aen(struct drsas_instance *instance, struct drsas_cmd *cmd)
 	case DR_EVT_LD_DELETED: {
 		rval = drsas_service_evt(instance,
 		    ddi_get16(acc_handle, &evt_detail->args.ld.target_id), 0,
-		    DRSAS_EVT_UNCONFIG_TGT, NULL);
+		    DRSAS_EVT_UNCONFIG_TGT);
 		con_log(CL_ANN1, (CE_WARN, "dr_sas: LD DELETED AEN rval = %d "
 		    "tgt id = %d index = %d", rval,
 		    ddi_get16(acc_handle, &evt_detail->args.ld.target_id),
@@ -2608,7 +2608,7 @@ service_mfi_aen(struct drsas_instance *instance, struct drsas_cmd *cmd)
 	case DR_EVT_LD_CREATED: {
 		rval = drsas_service_evt(instance,
 		    ddi_get16(acc_handle, &evt_detail->args.ld.target_id), 0,
-		    DRSAS_EVT_CONFIG_TGT, NULL);
+		    DRSAS_EVT_CONFIG_TGT);
 		con_log(CL_ANN1, (CE_WARN, "dr_sas: LD CREATED AEN rval = %d "
 		    "tgt id = %d index = %d", rval,
 		    ddi_get16(acc_handle, &evt_detail->args.ld.target_id),
@@ -3442,7 +3442,7 @@ build_cmd(struct drsas_instance *instance, struct scsi_address *ap,
 			switch (page_code) {
 			case 0x3:
 			case 0x4:
-				(void) drsas_mode_sense_build(pkt);
+				drsas_mode_sense_build(pkt);
 				return_mfi_pkt(instance, cmd);
 				*cmd_done = 1;
 				return (NULL);
@@ -5352,10 +5352,8 @@ finish:
 	return (rval);
 }
 
-/*ARGSUSED*/
 static int
-drsas_service_evt(struct drsas_instance *instance, int tgt, int lun, int event,
-    uint64_t wwn)
+drsas_service_evt(struct drsas_instance *instance, int tgt, int lun, int event)
 {
 	struct drsas_eventinfo *mrevt = NULL;
 
@@ -5454,7 +5452,7 @@ drsas_issue_evt_taskq(struct drsas_eventinfo *mrevt)
 	ndi_devi_exit(instance->dip, circ1);
 }
 
-static int
+static void
 drsas_mode_sense_build(struct scsi_pkt *pkt)
 {
 	union scsi_cdb		*cdbp;
@@ -5470,7 +5468,7 @@ drsas_mode_sense_build(struct scsi_pkt *pkt)
 	if ((!bp) && bp->b_un.b_addr && bp->b_bcount && acmd->cmd_dmacount) {
 		con_log(CL_ANN1, (CE_WARN, "Failing MODESENSE Command"));
 		/* ADD pkt statistics as Command failed. */
-		return (NULL);
+		return;
 	}
 
 	bp_mapin(bp);
@@ -5508,5 +5506,4 @@ drsas_mode_sense_build(struct scsi_pkt *pkt)
 		default:
 			break;
 	}
-	return (NULL);
 }
diff --git a/usr/src/uts/common/io/dr_sas/dr_sas.h b/usr/src/uts/common/io/dr_sas/dr_sas.h
index 8f78658edf..aa95aa3d08 100644
--- a/usr/src/uts/common/io/dr_sas/dr_sas.h
+++ b/usr/src/uts/common/io/dr_sas/dr_sas.h
@@ -38,6 +38,10 @@
  * Use is subject to license terms.
  */
 
+/*
+ * Copyright 2019 Joyent, Inc.
+ */
+
 #ifndef	_DR_SAS_H_
 #define	_DR_SAS_H_
 
@@ -1755,9 +1759,8 @@ static dev_info_t *drsas_find_child(struct drsas_instance *, uint16_t,
 			uint8_t);
 static int	drsas_name_node(dev_info_t *, char *, int);
 static void	drsas_issue_evt_taskq(struct drsas_eventinfo *);
-static int	drsas_service_evt(struct drsas_instance *, int, int, int,
-			uint64_t);
-static int	drsas_mode_sense_build(struct scsi_pkt *);
+static int	drsas_service_evt(struct drsas_instance *, int, int, int);
+static void	drsas_mode_sense_build(struct scsi_pkt *);
 
 #ifdef	__cplusplus
 }
diff --git a/usr/src/uts/common/io/inotify.c b/usr/src/uts/common/io/inotify.c
index eaa0c33f0f..b20c63481f 100644
--- a/usr/src/uts/common/io/inotify.c
+++ b/usr/src/uts/common/io/inotify.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright 2017 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  * Copyright (c) 2015 The MathWorks, Inc.  All rights reserved.
  */
 
@@ -1121,7 +1121,7 @@ inotify_open(dev_t *devp, int flag, int otyp, cred_t *cred_p)
 	if (ddi_soft_state_zalloc(inotify_softstate, minor) != DDI_SUCCESS) {
 		vmem_free(inotify_minor, (void *)(uintptr_t)minor, 1);
 		mutex_exit(&inotify_lock);
-		return (NULL);
+		return (EINVAL);
 	}
 
 	state = ddi_get_soft_state(inotify_softstate, minor);
@@ -1414,7 +1414,7 @@ inotify_attach(dev_info_t *devi, ddi_attach_cmd_t cmd)
 	}
 
 	if (ddi_create_minor_node(devi, "inotify", S_IFCHR,
-	    INOTIFYMNRN_INOTIFY, DDI_PSEUDO, NULL) == DDI_FAILURE) {
+	    INOTIFYMNRN_INOTIFY, DDI_PSEUDO, 0) == DDI_FAILURE) {
 		cmn_err(CE_NOTE, "/dev/inotify couldn't create minor node");
 		ddi_soft_state_fini(&inotify_softstate);
 		mutex_exit(&inotify_lock);
diff --git a/usr/src/uts/common/io/mac/mac.c b/usr/src/uts/common/io/mac/mac.c
index e748e6d57b..6b966b65f3 100644
--- a/usr/src/uts/common/io/mac/mac.c
+++ b/usr/src/uts/common/io/mac/mac.c
@@ -6847,7 +6847,7 @@ i_mac_clients_hw(mac_group_t *grp, uint32_t mask)
 	for (mgcip = grp->mrg_clients; mgcip != NULL; mgcip = mgcip->mgc_next) {
 		mcip = mgcip->mgc_client;
 		mrp = MCIP_RESOURCE_PROPS(mcip);
-		if (mcip->mci_share != NULL || (mrp->mrp_mask & mask) != 0)
+		if (mcip->mci_share != 0 || (mrp->mrp_mask & mask) != 0)
 			return (B_TRUE);
 	}
 
diff --git a/usr/src/uts/common/io/vnd/frameio.c b/usr/src/uts/common/io/vnd/frameio.c
index 198c14d4be..d36608efcd 100644
--- a/usr/src/uts/common/io/vnd/frameio.c
+++ b/usr/src/uts/common/io/vnd/frameio.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright 2017 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -286,7 +286,7 @@ failed:
 	if (error == EAGAIN) {
 		if (frame != 0)
 			error = 0;
-		if (*nvecs != NULL)
+		if (nvecs != NULL)
 			*nvecs = frame;
 		ASSERT(*mpp != NULL);
 	} else {
diff --git a/usr/src/uts/common/io/vnd/vnd.c b/usr/src/uts/common/io/vnd/vnd.c
index ac60fe678b..9ed57f30c4 100644
--- a/usr/src/uts/common/io/vnd/vnd.c
+++ b/usr/src/uts/common/io/vnd/vnd.c
@@ -2246,7 +2246,7 @@ vnd_mac_flow_control(void *arg, vnd_mac_cookie_t cookie)
 	ASSERT(vsp->vns_flags & VNS_F_FLOW_CONTROLLED);
 	ASSERT(vsp->vns_caps.vsc_fc_cookie == cookie);
 	vsp->vns_flags &= ~VNS_F_FLOW_CONTROLLED;
-	vsp->vns_caps.vsc_fc_cookie = NULL;
+	vsp->vns_caps.vsc_fc_cookie = (vnd_mac_cookie_t)NULL;
 	vsp->vns_fclatch = 0;
 	DTRACE_VND3(flow__resumed, vnd_str_t *, vsp, uint64_t,
 	    vsp->vns_dq_write.vdq_cur, uintptr_t, cookie);
@@ -3656,18 +3656,18 @@ vnd_squeue_tx_one(vnd_str_t *vsp, mblk_t *mp)
 	 * punch (txtime > vns_fcupdate), then we know that it's safe to wait
 	 * for a notification.
 	 */
-	if (vc != NULL) {
+	if (vc != (vnd_mac_cookie_t)NULL) {
 		hrtime_t diff;
 
 		if (vsp->vns_caps.vsc_is_fc_f(vsp->vns_caps.vsc_is_fc_hdl,
 		    vc) == 0)
-			return (NULL);
+			return ((vnd_mac_cookie_t)NULL);
 		mutex_enter(&vsp->vns_lock);
 		diff = vsp->vns_fcupdate - txtime;
 		if (diff > 0) {
 			mutex_exit(&vsp->vns_lock);
 			vnd_mac_flow_control_stat(vsp, diff);
-			return (NULL);
+			return ((vnd_mac_cookie_t)NULL);
 		}
 		vsp->vns_flags |= VNS_F_FLOW_CONTROLLED;
 		vsp->vns_caps.vsc_fc_cookie = vc;
@@ -3737,7 +3737,7 @@ vnd_squeue_tx_drain(void *arg, mblk_t *drain_mp, gsqueue_t *gsp, void *dummy)
 
 		nmps++;
 		mptot += msgsize(mp);
-		if (vnd_squeue_tx_one(vsp, mp) != NULL) {
+		if (vnd_squeue_tx_one(vsp, mp) != (vnd_mac_cookie_t)NULL) {
 			blocked = B_TRUE;
 			break;
 		}
@@ -5588,7 +5588,7 @@ vnd_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
 
 	vnd_sdev_hdl = sdev_plugin_register(VND_SDEV_NAME, &vnd_sdev_ops,
 	    &errp);
-	if (vnd_sdev_hdl == NULL) {
+	if (vnd_sdev_hdl == (sdev_plugin_hdl_t)NULL) {
 		ddi_remove_minor_node(vnd_dip, NULL);
 		ddi_prop_remove_all(vnd_dip);
 		vnd_dip = NULL;
diff --git a/usr/src/uts/i86pc/io/vmm/io/ppt.c b/usr/src/uts/i86pc/io/vmm/io/ppt.c
index 64efa954fa..a71ce86c2d 100644
--- a/usr/src/uts/i86pc/io/vmm/io/ppt.c
+++ b/usr/src/uts/i86pc/io/vmm/io/ppt.c
@@ -29,7 +29,7 @@
  */
 
 /*
- * Copyright 2019 Joyent, Inc
+ * Copyright 2019 Joyent, Inc.
  */
 
 #include <sys/cdefs.h>
@@ -690,7 +690,7 @@ ppt_wait_for_pending_txn(dev_info_t *dip, uint_t max_delay_us)
 		return (B_FALSE);
 	}
 
-	devsts = PCI_CAP_GET16(hdl, NULL, cap_ptr, PCIE_DEVSTS);
+	devsts = PCI_CAP_GET16(hdl, 0, cap_ptr, PCIE_DEVSTS);
 	while ((devsts & PCIE_DEVSTS_TRANS_PENDING) != 0) {
 		if (max_delay_us == 0) {
 			pci_config_teardown(&hdl);
@@ -705,7 +705,7 @@ ppt_wait_for_pending_txn(dev_info_t *dip, uint_t max_delay_us)
 			delay(drv_usectohz(max_delay_us));
 			max_delay_us = 0;
 		}
-		devsts = PCI_CAP_GET16(hdl, NULL, cap_ptr, PCIE_DEVSTS);
+		devsts = PCI_CAP_GET16(hdl, 0, cap_ptr, PCIE_DEVSTS);
 	}
 
 	pci_config_teardown(&hdl);
@@ -743,15 +743,15 @@ ppt_max_completion_tmo_us(dev_info_t *dip)
 	if (PCI_CAP_LOCATE(hdl, PCI_CAP_ID_PCI_E, &cap_ptr) != DDI_SUCCESS)
 		goto out;
 
-	if ((PCI_CAP_GET16(hdl, NULL, cap_ptr, PCIE_PCIECAP) &
+	if ((PCI_CAP_GET16(hdl, 0, cap_ptr, PCIE_PCIECAP) &
 	    PCIE_PCIECAP_VER_MASK) < PCIE_PCIECAP_VER_2_0)
 		goto out;
 
-	if ((PCI_CAP_GET16(hdl, NULL, cap_ptr, PCIE_DEVCAP2) &
+	if ((PCI_CAP_GET16(hdl, 0, cap_ptr, PCIE_DEVCAP2) &
 	    PCIE_DEVCTL2_COM_TO_RANGE_MASK) == 0)
 		goto out;
 
-	timo = timo_ranges[PCI_CAP_GET16(hdl, NULL, cap_ptr, PCIE_DEVCTL2) &
+	timo = timo_ranges[PCI_CAP_GET16(hdl, 0, cap_ptr, PCIE_DEVCTL2) &
 	    PCIE_DEVCAP2_COM_TO_RANGE_MASK];
 
 out:
@@ -775,7 +775,7 @@ ppt_flr(dev_info_t *dip, boolean_t force)
 	if (PCI_CAP_LOCATE(hdl, PCI_CAP_ID_PCI_E, &cap_ptr) != DDI_SUCCESS)
 		goto fail;
 
-	if ((PCI_CAP_GET16(hdl, NULL, cap_ptr, PCIE_DEVCAP) & PCIE_DEVCAP_FLR)
+	if ((PCI_CAP_GET16(hdl, 0, cap_ptr, PCIE_DEVCAP) & PCIE_DEVCAP_FLR)
 	    == 0)
 		goto fail;
 
@@ -806,8 +806,8 @@ ppt_flr(dev_info_t *dip, boolean_t force)
 	}
 
 	/* Initiate the reset. */
-	ctl = PCI_CAP_GET16(hdl, NULL, cap_ptr, PCIE_DEVCTL);
-	(void) PCI_CAP_PUT16(hdl, NULL, cap_ptr, PCIE_DEVCTL,
+	ctl = PCI_CAP_GET16(hdl, 0, cap_ptr, PCIE_DEVCTL);
+	(void) PCI_CAP_PUT16(hdl, 0, cap_ptr, PCIE_DEVCTL,
 	    ctl | PCIE_DEVCTL_INITIATE_FLR);
 
 	/* Wait for at least 100ms */
@@ -1044,10 +1044,10 @@ ppt_reset_pci_power_state(dev_info_t *dip)
 	if (PCI_CAP_LOCATE(cfg, PCI_CAP_ID_PM, &cap_ptr) == DDI_SUCCESS) {
 		uint16_t val;
 
-		val = PCI_CAP_GET16(cfg, NULL, cap_ptr, PCI_PMCSR);
+		val = PCI_CAP_GET16(cfg, 0, cap_ptr, PCI_PMCSR);
 		if ((val & PCI_PMCSR_STATE_MASK) != PCI_PMCSR_D0) {
 			val = (val & ~PCI_PMCSR_STATE_MASK) | PCI_PMCSR_D0;
-			(void) PCI_CAP_PUT16(cfg, NULL, cap_ptr, PCI_PMCSR,
+			(void) PCI_CAP_PUT16(cfg, 0, cap_ptr, PCI_PMCSR,
 			    val);
 		}
 	}
diff --git a/usr/src/uts/i86pc/io/vmm/vmm_sol_dev.c b/usr/src/uts/i86pc/io/vmm/vmm_sol_dev.c
index a5e60d4887..634575427e 100644
--- a/usr/src/uts/i86pc/io/vmm/vmm_sol_dev.c
+++ b/usr/src/uts/i86pc/io/vmm/vmm_sol_dev.c
@@ -1844,7 +1844,7 @@ vmm_is_supported(intptr_t arg)
 		msg = "Unsupported CPU vendor";
 	}
 
-	if (r != 0 && arg != NULL) {
+	if (r != 0 && arg != (intptr_t)NULL) {
 		if (copyoutstr(msg, (char *)arg, strlen(msg), NULL) != 0)
 			return (EFAULT);
 	}
@@ -2089,7 +2089,8 @@ vmm_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
 		goto fail;
 	}
 
-	if ((sph = sdev_plugin_register("vmm", &vmm_sdev_ops, NULL)) == NULL) {
+	if ((sph = sdev_plugin_register("vmm", &vmm_sdev_ops, NULL)) ==
+	    (sdev_plugin_hdl_t)NULL) {
 		ddi_remove_minor_node(dip, NULL);
 		goto fail;
 	}
@@ -2140,12 +2141,12 @@ vmm_detach(dev_info_t *dip, ddi_detach_cmd_t cmd)
 	}
 	mutex_exit(&vmm_mtx);
 
-	VERIFY(vmmdev_sdev_hdl != NULL);
+	VERIFY(vmmdev_sdev_hdl != (sdev_plugin_hdl_t)NULL);
 	if (sdev_plugin_unregister(vmmdev_sdev_hdl) != 0) {
 		mutex_exit(&vmmdev_mtx);
 		return (DDI_FAILURE);
 	}
-	vmmdev_sdev_hdl = NULL;
+	vmmdev_sdev_hdl = (sdev_plugin_hdl_t)NULL;
 
 	/* Remove the control node. */
 	ddi_remove_minor_node(dip, "ctl");
diff --git a/usr/src/uts/i86pc/io/vmm/vmm_sol_glue.c b/usr/src/uts/i86pc/io/vmm/vmm_sol_glue.c
index 8dc7118ee1..c8d5aa24e9 100644
--- a/usr/src/uts/i86pc/io/vmm/vmm_sol_glue.c
+++ b/usr/src/uts/i86pc/io/vmm/vmm_sol_glue.c
@@ -36,7 +36,7 @@
  * http://www.illumos.org/license/CDDL.
  *
  * Copyright 2014 Pluribus Networks Inc.
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 #include <sys/types.h>
@@ -99,7 +99,8 @@ pmap_invalidate_cache(void)
 
 	kpreempt_disable();
 	cpuset_all_but(&cpuset, CPU->cpu_id);
-	xc_call(NULL, NULL, NULL, CPUSET2BV(cpuset), (xc_func_t)invalidate_cache);
+	xc_call((xc_arg_t)NULL, (xc_arg_t)NULL, (xc_arg_t)NULL,
+	    CPUSET2BV(cpuset), (xc_func_t)invalidate_cache);
 	invalidate_cache();
 	kpreempt_enable();
 }
diff --git a/usr/src/uts/intel/io/vmxnet/vmxnet.c b/usr/src/uts/intel/io/vmxnet/vmxnet.c
index e170f049d9..14a87fa22e 100644
--- a/usr/src/uts/intel/io/vmxnet/vmxnet.c
+++ b/usr/src/uts/intel/io/vmxnet/vmxnet.c
@@ -15,7 +15,7 @@
  *********************************************************/
 
 /*
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 #include <sys/types.h>
@@ -1681,7 +1681,7 @@ Vxn_FreeDmaMem(dma_buf_t *dma)
    ddi_dma_free_handle(&dma->dmaHdl);
 
    dma->buf = NULL;
-   dma->phyBuf = NULL;
+   dma->phyBuf = (uint32_t)(uintptr_t)NULL;
    dma->bufLen = 0;
 }
 
