commit 2df8a755e8ecd0f565b6893bfdde703d022fe755 (refs/changes/74/3174/2)
Author: Jason King <jason.king@joyent.com>
Date:   2018-01-09T01:24:54+00:00 (1 year, 9 months ago)
    
    Review round 2

diff --git a/usr/src/cmd/cmd-inet/usr.lib/Makefile b/usr/src/cmd/cmd-inet/usr.lib/Makefile
index 718d4ed15a..1c12372446 100644
--- a/usr/src/cmd/cmd-inet/usr.lib/Makefile
+++ b/usr/src/cmd/cmd-inet/usr.lib/Makefile
@@ -27,7 +27,7 @@
 SUBDIRS=	bridged ilbd in.chargend in.daytimed \
 		in.discardd in.echod in.mpathd in.ndpd \
 		in.ripngd in.timed inetd mdnsd ncaconfd pppoe \
-		slpd vrrpd wanboot wpad
+		slpd vrrpd wanboot wpad in.ikev2
 
 MSGSUBDIRS=	ilbd inetd ncaconfd vrrpd wanboot
 
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/Makefile b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/Makefile
new file mode 100644
index 0000000000..32e56aa6fc
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/Makefile
@@ -0,0 +1,58 @@
+#
+# CDDL HEADER START
+#
+# The contents of this file are subject to the terms of the
+# Common Development and Distribution License (the "License").
+# You may not use this file except in compliance with the License.
+#
+# You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+# or http://www.opensolaris.org/os/licensing.
+# See the License for the specific language governing permissions
+# and limitations under the License.
+#
+# When distributing Covered Code, include this CDDL HEADER in each
+# file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+# If applicable, add the following below this CDDL HEADER, with the
+# fields enclosed by brackets "[]" replaced with your own identifying
+# information: Portions Copyright [yyyy] [name of copyright owner]
+#
+# CDDL HEADER END
+#
+
+#
+# Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
+# Use is subject to license terms.
+#
+
+PROG= in.ikev2d
+
+include ../../../Makefile.cmd
+
+SUBDIRS=
+$(INTEL_BLD)SUBDIRS += $(MACH)
+$(BUILD64)SUBDIRS += $(MACH64)
+
+all	:=	TARGET = all
+install	:=	TARGET = install
+clean	:=	TARGET = clean
+clobber	:=	TARGET = clobber
+lint	:=	TARGET = lint
+
+.KEEP_STATE:
+
+all:	$(SUBDIRS)
+
+clean clobber lint:	$(SUBDIRS)
+
+include ../Makefile.lib
+
+install:	$(SUBDIRS)
+	-$(RM) $(ROOTLIBINETPROG)
+	-$(LN) $(ISAEXEC) $(ROOTLIBINETPROG)
+
+$(SUBDIRS):	FRC
+	@cd $@; pwd; $(MAKE) $(TARGET)
+
+FRC:
+
+include ../../../Makefile.targ
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/Makefile.com b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/Makefile.com
new file mode 100644
index 0000000000..2137000f87
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/Makefile.com
@@ -0,0 +1,116 @@
+#
+# CDDL HEADER START
+#
+# The contents of this file are subject to the terms of the
+# Common Development and Distribution License (the "License").
+# You may not use this file except in compliance with the License.
+#
+# You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+# or http://www.opensolaris.org/os/licensing.
+# See the License for the specific language governing permissions
+# and limitations under the License.
+#
+# When distributing Covered Code, include this CDDL HEADER in each
+# file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+# If applicable, add the following below this CDDL HEADER, with the
+# fields enclosed by brackets "[]" replaced with your own identifying
+# information: Portions Copyright [yyyy] [name of copyright owner]
+#
+# CDDL HEADER END
+#
+
+#
+# Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
+# Copyright 2017 Jason King.
+# Copyright (c) 2017, Joyent, Inc.
+#
+
+PROG = in.ikev2d
+
+CMD_OBJS =	config.o		\
+		config_parse.o		\
+		dh.o			\
+		fromto.o		\
+		ikev2_child_sa.o	\
+		ikev2_common.o		\
+		ikev2_cookie.o		\
+		ikev2_enum.o		\
+		ikev2_ike_auth.o	\
+		ikev2_pkt.o		\
+		ikev2_pkt_check.o	\
+		ikev2_proto.o		\
+		ikev2_sa.o		\
+		ikev2_sa_init.o		\
+		inbound.o		\
+		main.o			\
+		pfkey.o			\
+		preshared.o		\
+		prf.o			\
+		pkcs11.o		\
+		pkt.o			\
+		ts.o			\
+		util.o			\
+		worker.o
+
+COM_OBJS = list.o
+COMDIR = $(SRC)/common/list
+SRCDIR = ../common
+
+OBJS = $(CMD_OBJS) $(COM_OBJS)
+SRCS =	$(CMD_OBJS:%.o=$(SRCDIR)/%.c) \
+	$(COM_OBJS:%.o=$(COMDIR)/%.c)
+
+include $(SRC)/cmd/Makefile.cmd
+include $(SRC)/cmd/Makefile.ctf
+
+CPPFLAGS += -D__EXTENSIONS__
+CPPFLAGS += -D_POSIX_PTHREAD_SEMANTICS
+
+LINTFLAGS += $(C99LMODE) -erroff=E_STATIC_UNUSED
+LINTFLAGS64 += $(C99LMODE) -erroff=E_STATIC_UNUSED
+
+LINTFLAGS += -errfmt=macro
+
+# Use X/Open sockets for fromto.c so we can use control messages for
+# source address selection
+fromto.o := CPPFLAGS += -D_XOPEN_SOURCE=600
+
+# ... but as a consequence, you have to disable a few lint checks.
+LINTFLAGS += -erroff=E_INCONS_ARG_DECL2 -erroff=E_INCONS_VAL_TYPE_DECL2
+LINTFLAGS64 += -erroff=E_INCONS_ARG_DECL2 -erroff=E_INCONS_VAL_TYPE_DECL2
+
+C99MODE = $(C99_ENABLE)
+CFLAGS += $(CCVERBOSE) -D_REENTRANT
+CFLAGS64 += $(CCVERBOSE) -D_REENTRANT
+LDLIBS += -lnsl -lsecdb -lumem -lxnet -lipsecutil -lpkcs11 -lcryptoutil
+LDLIBS += -lnvpair -lbunyan -lperiodic -linetutil -lrefhash -lcmdutils
+
+FILEMODE = 0555
+GROUP = bin
+
+CLEANFILES += $(OBJS)
+
+.KEEP_STATE:
+
+.PARALLEL:
+
+all: $(PROG)
+
+$(PROG): $(OBJS)
+	$(LINK.c) -o $@ $(OBJS) $(LDLIBS)
+	$(POST_PROCESS)
+
+clean:
+	-$(RM) $(CLEANFILES)
+
+lint: lint_SRCS
+
+%.o: ../common/%.c
+	$(COMPILE.c) $<
+	$(POST_PROCESS_O)
+
+%.o: $(COMDIR)/%.c
+	$(COMPILE.c) $<
+	$(POST_PROCESS_O)
+
+include $(SRC)/cmd/Makefile.targ
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/THIRDPARTYLICENSE b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/THIRDPARTYLICENSE
new file mode 100644
index 0000000000..4c2439f5ce
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/THIRDPARTYLICENSE
@@ -0,0 +1,26 @@
+ * Copyright (C) 1995-2009 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/THIRDPARTYLICENSE.descrip b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/THIRDPARTYLICENSE.descrip
new file mode 100644
index 0000000000..e8d43870fb
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/THIRDPARTYLICENSE.descrip
@@ -0,0 +1 @@
+PORTIONS OF IKEv2 FROM "racoon2"
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/amd64/Makefile b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/amd64/Makefile
new file mode 100644
index 0000000000..930b865dd8
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/amd64/Makefile
@@ -0,0 +1,30 @@
+#
+# CDDL HEADER START
+#
+# The contents of this file are subject to the terms of the
+# Common Development and Distribution License (the "License").
+# You may not use this file except in compliance with the License.
+#
+# You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+# or http://www.opensolaris.org/os/licensing.
+# See the License for the specific language governing permissions
+# and limitations under the License.
+#
+# When distributing Covered Code, include this CDDL HEADER in each
+# file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+# If applicable, add the following below this CDDL HEADER, with the
+# fields enclosed by brackets "[]" replaced with your own identifying
+# information: Portions Copyright [yyyy] [name of copyright owner]
+#
+# CDDL HEADER END
+#
+
+#
+# Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
+# Use is subject to license terms.
+#
+
+include ../Makefile.com
+include ../../../../Makefile.cmd.64
+
+install: all $(ROOTLIBINETPROG64)
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/config.c b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/config.c
new file mode 100644
index 0000000000..9379c1e055
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/config.c
@@ -0,0 +1,418 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+#include <arpa/inet.h>
+#include <netinet/in.h>
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <sys/debug.h>
+#include <pthread.h>
+#include <string.h>
+#include <strings.h>
+#include <umem.h>
+#include "defs.h"
+#include "config.h"
+#include "ikev2_enum.h"
+
+pthread_rwlock_t cfg_lock = PTHREAD_RWLOCK_INITIALIZER;
+config_t *config;
+
+static boolean_t cfg_addr_match(const sockaddr_u_t,
+    const config_addr_t *restrict);
+
+config_t *
+config_get(void)
+{
+	config_t *cfg = NULL;
+
+	VERIFY0(pthread_rwlock_rdlock(&cfg_lock));
+	cfg = config;
+	CONFIG_REFHOLD(cfg);
+	VERIFY0(pthread_rwlock_unlock(&cfg_lock));
+	return (cfg);
+}
+
+void
+config_xf_log(bunyan_logger_t *b, bunyan_level_t level, const char *msg,
+    const config_xf_t *xf)
+{
+	getlog(level)(b, msg,
+	    BUNYAN_T_STRING, "xf_encralg", ikev2_xf_encr_str(xf->xf_encr),
+	    BUNYAN_T_UINT32, "xf_minbits", (uint32_t)xf->xf_minbits,
+	    BUNYAN_T_UINT32, "xf_maxbits", (uint32_t)xf->xf_maxbits,
+	    BUNYAN_T_STRING, "xf_authalg", ikev2_xf_auth_str(xf->xf_auth),
+	    BUNYAN_T_STRING, "xf_authtype",
+	    ikev2_auth_type_str(xf->xf_authtype),
+	    BUNYAN_T_STRING, "xf_dh", ikev2_dh_str(xf->xf_dh),
+	    BUNYAN_T_END);
+}
+
+/*
+ * Return the first rule that matches the given local and remote addresses.
+ * If no rule matches, return the default rule.  The config is refheld on
+ * return.
+ */
+config_rule_t *
+config_get_rule(sockaddr_u_t local, sockaddr_u_t remote)
+{
+	config_t *cfg = config_get();
+
+	for (size_t i = 0; cfg->cfg_rules[i] != NULL; i++) {
+		config_rule_t *rule = cfg->cfg_rules[i];
+		boolean_t local_match = B_FALSE;
+		boolean_t remote_match = B_FALSE;
+
+		for (size_t j = 0; j < rule->rule_nlocal_addr; j++) {
+			if (cfg_addr_match(local, &rule->rule_local_addr[j])) {
+				local_match = B_TRUE;
+				break;
+			}
+		}
+		for (size_t j = 0; j < rule->rule_nremote_addr; j++) {
+			if (cfg_addr_match(remote,
+			    &rule->rule_remote_addr[j])) {
+				remote_match = B_TRUE;
+				break;
+			}
+		}
+		if (local_match && remote_match)
+			return (rule);
+	}
+
+	return (&cfg->cfg_default);
+}
+
+boolean_t
+config_addr_to_ss(const config_addr_t *restrict caddr,
+    struct sockaddr_storage *restrict ss)
+{
+	switch (caddr->cfa_type) {
+	case CFG_ADDR_IPV4_PREFIX:
+	case CFG_ADDR_IPV4_RANGE:
+	case CFG_ADDR_IPV6_PREFIX:
+	case CFG_ADDR_IPV6_RANGE:
+		return (B_FALSE);
+	case CFG_ADDR_IPV4:
+		ss->ss_family = AF_INET;
+		((struct sockaddr_in *)ss)->sin_port = htons(IPPORT_IKE);
+		bcopy(&caddr->cfa_start4, (void *)ss_addr(SSTOSA(ss)),
+		    sizeof (in_addr_t));
+		break;
+	case CFG_ADDR_IPV6:
+		ss->ss_family = AF_INET6;
+		((struct sockaddr_in6 *)ss)->sin6_port = htons(IPPORT_IKE);
+		bcopy(&caddr->cfa_start6, (void *)ss_addr(SSTOSA(ss)),
+		    sizeof (in6_addr_t));
+		break;
+	}
+	return (B_TRUE);
+}
+
+static boolean_t
+cfg_addr_match(const sockaddr_u_t l, const config_addr_t *restrict r)
+{
+	uint32_t mask;
+
+	switch (r->cfa_type) {
+	case CFG_ADDR_IPV4:
+		if (l.sau_ss->ss_family != AF_INET)
+			return (B_FALSE);
+		if (l.sau_sin->sin_addr.s_addr != r->cfa_start4)
+			return (B_FALSE);
+		return (B_TRUE);
+	case CFG_ADDR_IPV4_PREFIX:
+		/* XXX: this needs testing */
+		if (l.sau_ss->ss_family != AF_INET)
+			return (B_FALSE);
+		mask = (0xffffffff << (32 - r->cfa_endu.cfa_num)) &
+		    0xffffffff;
+		if ((l.sau_sin->sin_addr.s_addr & mask) ==
+		    (r->cfa_start4 & mask))
+			return (B_TRUE);
+		return (B_FALSE);
+	case CFG_ADDR_IPV4_RANGE:
+		if (l.sau_ss->ss_family != AF_INET)
+			return (B_FALSE);
+		if (l.sau_sin->sin_addr.s_addr >= r->cfa_start4 &&
+		    l.sau_sin->sin_addr.s_addr <= r->cfa_end4)
+			return (B_TRUE);
+		return (B_FALSE);
+	case CFG_ADDR_IPV6:
+		if (l.sau_ss->ss_family != AF_INET6)
+			return (B_FALSE);
+		if (IN6_ARE_ADDR_EQUAL(&l.sau_sin6->sin6_addr,
+		    &r->cfa_start6))
+			return (B_TRUE);
+		return (B_FALSE);
+	case CFG_ADDR_IPV6_PREFIX:
+		if (l.sau_ss->ss_family != AF_INET6)
+			return (B_FALSE);
+		if (IN6_ARE_PREFIXEDADDR_EQUAL(&l.sau_sin6->sin6_addr,
+		    &r->cfa_start6, r->cfa_endu.cfa_num))
+			return (B_TRUE);
+		return (B_FALSE);
+	case CFG_ADDR_IPV6_RANGE:
+		if (l.sau_ss->ss_family != AF_INET6)
+			return (B_FALSE);
+		for (size_t i = 0; i < 16; i++) {
+			if ((l.sau_sin6->sin6_addr.s6_addr[i] <
+			    r->cfa_start6.s6_addr[i]) ||
+			    (l.sau_sin6->sin6_addr.s6_addr[i] >
+			    r->cfa_end6.s6_addr[i]))
+				return (B_FALSE);
+		}
+		return (B_TRUE);
+	}
+	return (B_FALSE);
+}
+
+const char *
+config_id_type_str(config_auth_id_t type)
+{
+	switch (type) {
+	case CFG_AUTH_ID_DNS:
+		return ("dns");
+	case CFG_AUTH_ID_EMAIL:
+		return ("email");
+	case CFG_AUTH_ID_DN:
+		return ("dn");
+	case CFG_AUTH_ID_GN:
+		return ("gn");
+	case CFG_AUTH_ID_IPV4:
+		return ("ipv4");
+	case CFG_AUTH_ID_IPV4_PREFIX:
+		return ("ipv4_prefix");
+	case CFG_AUTH_ID_IPV4_RANGE:
+		return ("ipv4_range");
+	case CFG_AUTH_ID_IPV6:
+		return ("ipv6");
+	case CFG_AUTH_ID_IPV6_PREFIX:
+		return ("ipv6_prefix");
+	case CFG_AUTH_ID_IPV6_RANGE:
+		return ("ipv6_range");
+	}
+
+	INVALID(id->cid_type);
+	/*NOTREACHED*/
+	return (NULL);
+}
+
+char *
+config_id_str(const config_id_t *id, char *buf, size_t buflen)
+{
+	const void *ptr = id->cid_data;
+	int af = 0;
+
+	switch (id->cid_type) {
+	case CFG_AUTH_ID_DNS:
+	case CFG_AUTH_ID_EMAIL:
+		(void) strlcpy(buf, (const char *)ptr, buflen);
+		break;
+	case CFG_AUTH_ID_DN:
+	case CFG_AUTH_ID_GN:
+		/* TODO! */
+		INVALID("dn/gn to str not implemented yet");
+		break;
+	case CFG_AUTH_ID_IPV4:
+	case CFG_AUTH_ID_IPV4_PREFIX:
+	case CFG_AUTH_ID_IPV4_RANGE:
+		af = AF_INET;
+		break;
+	case CFG_AUTH_ID_IPV6:
+	case CFG_AUTH_ID_IPV6_PREFIX:
+	case CFG_AUTH_ID_IPV6_RANGE:
+		af = AF_INET6;
+		break;
+	}
+
+	if (inet_ntop(af, ptr, buf, buflen) == NULL)
+		bzero(buf, buflen);
+
+	return (buf);
+}
+
+size_t
+config_id_strlen(const config_id_t *id)
+{
+	switch (id->cid_type) {
+	case CFG_AUTH_ID_DNS:
+	case CFG_AUTH_ID_EMAIL:
+		return (id->cid_len + 1);
+	case CFG_AUTH_ID_DN:
+	case CFG_AUTH_ID_GN:
+		/*TODO*/
+		INVALID(id->cid_type);
+		break;
+	case CFG_AUTH_ID_IPV4:
+		return (INET_ADDRSTRLEN);
+	case CFG_AUTH_ID_IPV4_PREFIX:
+		return (INET_ADDRSTRLEN + 3);
+	case CFG_AUTH_ID_IPV4_RANGE:
+		return (2 * INET_ADDRSTRLEN + 1);
+	case CFG_AUTH_ID_IPV6:
+		return (INET6_ADDRSTRLEN);
+	case CFG_AUTH_ID_IPV6_PREFIX:
+		return (INET6_ADDRSTRLEN + 4);
+	case CFG_AUTH_ID_IPV6_RANGE:
+		return (2 * INET6_ADDRSTRLEN + 1);
+	}
+
+	/*NOTREACHED*/
+	return (0);
+}
+config_auth_id_t
+ikev2_id_to_cfg(ikev2_id_type_t i2id)
+{
+	switch (i2id) {
+	case IKEV2_ID_IPV4_ADDR:
+		return (CFG_AUTH_ID_IPV4);
+	case IKEV2_ID_FQDN:
+		return (CFG_AUTH_ID_DNS);
+	case IKEV2_ID_RFC822_ADDR:
+		return (CFG_AUTH_ID_EMAIL);
+	case IKEV2_ID_IPV6_ADDR:
+		return (CFG_AUTH_ID_IPV6);
+	case IKEV2_ID_DER_ASN1_DN:
+		return (CFG_AUTH_ID_DN);
+	case IKEV2_ID_DER_ASN1_GN:
+		return (CFG_AUTH_ID_GN);
+	case IKEV2_ID_KEY_ID:
+		INVALID(i2id);
+		/*NOTREACHED*/
+		return (0);
+	case IKEV2_ID_FC_NAME:
+		INVALID(i2id);
+		/*NOTREACHED*/
+		return (0);
+	}
+	return (0);
+}
+
+config_id_t *
+config_id_new(config_auth_id_t type, const void *data, size_t len)
+{
+	config_id_t *cid = NULL;
+
+	if ((cid = umem_zalloc(sizeof (*cid) + len, UMEM_DEFAULT)) == NULL)
+		return (NULL);
+
+	cid->cid_type = type;
+	cid->cid_len = len;
+	bcopy(data, cid->cid_data, len);
+	return (cid);
+}
+
+config_id_t *
+config_id_copy(const config_id_t *src)
+{
+	return (config_id_new(src->cid_type, src->cid_data, src->cid_len));
+}
+
+int
+config_id_cmp(const config_id_t *l, const config_id_t *r)
+{
+	if (l->cid_type != r->cid_type)
+		return (l->cid_type - r->cid_type);
+	return (memcmp(l->cid_data, r->cid_data, MIN(l->cid_len, r->cid_len)));
+}
+
+void
+config_id_free(config_id_t *id)
+{
+	if (id == NULL)
+		return;
+
+	size_t len = id->cid_len + sizeof (config_id_t);
+
+	umem_free(id, len);
+}
+
+void
+cfg_rule_free(config_rule_t *rule)
+{
+	size_t i;
+
+	if (rule == NULL)
+		return;
+
+	if (rule->rule_xf != NULL) {
+		for (i = 0; rule->rule_xf[i] != NULL; i++) {
+			char *s = rule->rule_xf[i]->xf_str;
+
+			ustrfree(rule->rule_xf[i]->xf_str);
+			umem_free(rule->rule_xf[i], sizeof (config_xf_t));
+		}
+		umem_cfree(rule->rule_xf, i + 1, sizeof (config_xf_t *));
+	}
+
+	if (rule->rule_remote_id != NULL) {
+		for (i = 0; rule->rule_remote_id[i] != NULL; i++)
+			config_id_free(rule->rule_remote_id[i]);
+
+		umem_cfree(rule->rule_remote_id, i + 1, sizeof (config_id_t *));
+	}
+
+	free(rule->rule_local_addr);
+	free(rule->rule_remote_addr);
+	ustrfree(rule->rule_label);
+	umem_free(rule, sizeof (*rule));
+}
+
+void
+cfg_free(config_t *cfg)
+{
+	if (cfg == NULL)
+		return;
+
+	size_t i;
+
+	VERIFY3U(cfg->cfg_refcnt, ==, 0);
+
+	for (i = 0;
+	    cfg->cfg_cert_root != NULL && cfg->cfg_cert_root[i] != NULL;
+	    i++)
+		free(cfg->cfg_cert_root[i]);
+	free(cfg->cfg_cert_root);
+
+	if (cfg->cfg_cert_trust != NULL) {
+		for (i = 0; cfg->cfg_cert_trust[i] != NULL; i++)
+			free(cfg->cfg_cert_trust[i]);
+		free(cfg->cfg_cert_trust);
+	}
+
+	if (cfg->cfg_default.rule_xf != NULL) {
+		size_t nxf = 0;
+
+		for (i = 0; cfg->cfg_default.rule_xf[i] != NULL; i++, nxf++) {
+			umem_free(cfg->cfg_default.rule_xf[i],
+			    sizeof (config_xf_t));
+		}
+
+		umem_cfree(cfg->cfg_default.rule_xf, nxf,
+		    sizeof (config_xf_t *));
+	}
+
+	if (cfg->cfg_rules != NULL) {
+		size_t amt = 0;
+
+		for (i = 0; cfg->cfg_rules[i] != NULL; i++, amt++)
+			cfg_rule_free(cfg->cfg_rules[i]);
+
+		umem_cfree(cfg->cfg_rules, amt + 1, sizeof (config_rule_t *));
+	}
+
+	ustrfree(cfg->cfg_proxy);
+	ustrfree(cfg->cfg_socks);
+	umem_free(cfg, sizeof (*cfg));
+}
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/config.h b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/config.h
new file mode 100644
index 0000000000..9dd4d3848f
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/config.h
@@ -0,0 +1,178 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2014 Jason King.
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+#ifndef _CONFIG_H
+#define	_CONFIG_H
+
+#include <sys/types.h>
+#include <sys/time.h>
+#include <netinet/in.h>
+#include <stdio.h>
+#include <bunyan.h>
+#include <pthread.h>
+#include <atomic.h>
+#include "ikev2.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define	CONFIG_P2_LIFETIME_SECS	3600
+#define	CONFIG_P2_SOFTLIFE_SECS	3240
+#define	CONFIG_P2_LIFETIME_KB	(100 * 1024)
+#define CONFIG_P2_SOFTLIFE_KB	(90 * 1024)
+#define	CONFIG_P2_IDLETIME_SECS 600
+
+typedef enum config_auth_id_e {
+	CFG_AUTH_ID_DN,
+	CFG_AUTH_ID_DNS,
+	CFG_AUTH_ID_GN,
+	CFG_AUTH_ID_IPV4,
+	CFG_AUTH_ID_IPV4_PREFIX,
+	CFG_AUTH_ID_IPV4_RANGE,
+	CFG_AUTH_ID_IPV6,
+	CFG_AUTH_ID_IPV6_PREFIX,
+	CFG_AUTH_ID_IPV6_RANGE,
+	CFG_AUTH_ID_EMAIL
+} config_auth_id_t;
+
+typedef enum config_addr_e {
+	CFG_ADDR_IPV4,
+	CFG_ADDR_IPV4_PREFIX,
+	CFG_ADDR_IPV4_RANGE,
+	CFG_ADDR_IPV6,
+	CFG_ADDR_IPV6_PREFIX,
+	CFG_ADDR_IPV6_RANGE
+} config_addr_type_t;
+
+typedef struct config_addr_s {
+	config_addr_type_t	cfa_type;
+	union {
+		in_addr_t	cfa_ip4;
+		in6_addr_t	cfa_ip6;
+	} cfa_startu;
+	union {
+		in_addr_t	cfa_ip4;
+		in6_addr_t	cfa_ip6;
+		uint8_t		cfa_num;
+	} cfa_endu;
+#define	cfa_start4	cfa_startu.cfa_ip4
+#define	cfa_start6	cfa_startu.cfa_ip6
+#define	cfa_end4	cfa_endu.cfa_ip4
+#define	cfa_end6	cfa_endu.cfa_ip6
+} config_addr_t;
+
+typedef struct config_id_s {
+	config_auth_id_t	cid_type;
+				/*
+				 * size of cid_data, for string types, includes
+				 * trailing NUL.
+				 */
+	size_t			cid_len;
+	uint8_t			cid_data[];
+} config_id_t;
+
+typedef struct config_xf_s {
+	char			*xf_str;
+	ikev2_xf_encr_t		xf_encr;
+	size_t			xf_minbits;
+	size_t			xf_maxbits;
+	ikev2_xf_auth_t		xf_auth;
+	ikev2_dh_t		xf_dh;
+	ikev2_auth_type_t	xf_authtype;
+	size_t			xf_lifetime_secs;
+	size_t			xf_nonce_len;
+} config_xf_t;
+
+struct config_s;
+typedef struct config_rule_s {
+	struct config_s		*rule_config;
+	char			*rule_label;
+	config_addr_t		*rule_local_addr;
+	size_t			rule_nlocal_addr;
+	config_addr_t		*rule_remote_addr;
+	size_t			rule_nremote_addr;
+	config_xf_t		**rule_xf;
+	ikev2_dh_t		rule_p2_dh;
+	config_id_t		*rule_local_id;
+	config_id_t		**rule_remote_id;
+	size_t			rule_remote_id_alloc;
+	boolean_t		rule_immediate;
+} config_rule_t;
+
+struct config_s {
+	volatile uint32_t	cfg_refcnt;
+	config_rule_t		cfg_default;
+	config_rule_t		**cfg_rules;
+	size_t			cfg_xforms_alloc;
+	char			*cfg_proxy;
+	char			*cfg_socks;
+	config_auth_id_t	cfg_local_id_type;
+	char			**cfg_cert_root;
+	size_t			cfg_cert_root_alloc;
+	char			**cfg_cert_trust;
+	size_t			cfg_cert_trust_alloc;
+	hrtime_t		cfg_expire_timer;	/* ns */
+	hrtime_t		cfg_lifetime_secs;	/* ns */
+	hrtime_t		cfg_retry_max;		/* ns */
+	hrtime_t		cfg_retry_init;		/* ns */
+	size_t			cfg_retry_limit;
+	boolean_t		cfg_ignore_crls;
+	boolean_t		cfg_use_http;
+	size_t			cfg_p1_softlife_secs;
+	size_t			cfg_p1_hardlife_secs;
+	size_t			cfg_p1_nonce_len;
+	size_t			cfg_p2_lifetime_secs;
+	size_t			cfg_p2_softlife_secs;
+	size_t			cfg_p2_idletime_secs;
+	size_t			cfg_p2_lifetime_kb;
+	size_t			cfg_p2_softlife_kb;
+	size_t			cfg_p2_nonce_len;
+};
+typedef struct config_s config_t;
+#define	CONFIG_REFHOLD(cp) atomic_inc_32(&(cp)->cfg_refcnt)
+#define	CONFIG_REFRELE(cp) \
+	(void) ((atomic_dec_32_nv(&(cp)->cfg_refcnt) != 0) || \
+	    (cfg_free(cp), 0))
+#define	RULE_IS_DEFAULT(r) (!!(&(r)->rule_config->cfg_default == (r)))
+
+union sockaddr_u_s;
+extern pthread_rwlock_t cfg_lock;
+extern config_t *config;
+
+void process_config(FILE *, boolean_t);
+config_t *config_get(void);
+config_rule_t *config_get_rule(union sockaddr_u_s,
+    union sockaddr_u_s);
+void cfg_rule_free(config_rule_t *);
+void cfg_free(config_t *);
+
+boolean_t config_addr_to_ss(const config_addr_t *restrict,
+    struct sockaddr_storage *restrict);
+
+config_auth_id_t ikev2_id_to_cfg(ikev2_id_type_t);
+config_id_t *config_id_new(config_auth_id_t, const void *, size_t);
+config_id_t *config_id_copy(const config_id_t *);
+int config_id_cmp(const config_id_t *, const config_id_t *);
+const char *config_id_type_str(config_auth_id_t);
+char *config_id_str(const config_id_t *, char *, size_t);
+size_t config_id_strlen(const config_id_t *);
+void config_id_free(config_id_t *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _CONFIG_H */
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/config_parse.c b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/config_parse.c
new file mode 100644
index 0000000000..3894c44297
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/config_parse.c
@@ -0,0 +1,1852 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+#include <sys/time.h>
+#include <sys/debug.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/sysmacros.h>
+#include <sys/stat.h>
+#include <arpa/inet.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <string.h>
+#include <strings.h>
+#include <stdarg.h>
+#include <umem.h>
+#include <netinet/in.h>
+#include <errno.h>
+#include <bunyan.h>
+#include <ctype.h>
+#include <stdio.h>
+#include <err.h>
+#include "defs.h"
+#include "config.h"
+#include "ikev2.h"
+#include "ikev2_enum.h"
+
+#ifndef ARRAY_SIZE
+#define	ARRAY_SIZE(x)	(sizeof (x) / sizeof (x[0]))
+#endif
+
+#define	CONFIG_MAX	((size_t)(1024*1024))
+#define	CONFIG_CHUNK	((size_t)1024)
+
+typedef enum keyword_e {
+	KW_NONE = 0,
+	KW_CERT_ROOT,
+	KW_CERT_TRUST,
+	KW_EXPIRE_TIMER,
+	KW_IGNORE_CRLS,
+	KW_LDAP_SERVER,
+	KW_PKCS11_PATH,
+	KW_RETRY_LIMIT,
+	KW_RETRY_TIMER_INIT,
+	KW_RETRY_TIMER_MAX,
+	KW_PROXY,
+	KW_SOCKS,
+	KW_USE_HTTP,
+	KW_P1_LIFETIME_SECS,
+	KW_P1_NONCE_LEN,
+	KW_P2_LIFETIME_SECS,
+	KW_P2_SOFTLIFE_SECS,
+	KW_P2_IDLETIME_SECS,
+	KW_P2_LIFETIME_KB,
+	KW_P2_SOFTLIFE_KB,
+	KW_P2_NONCE_LEN,
+	KW_LOCAL_ID_TYPE,
+	KW_P1_XFORM,
+	KW_AUTH_METHOD,
+	KW_OAKLEY_GROUP,
+	KW_AUTH_ALG,
+	KW_ENCR_ALG,
+	KW_LABEL,
+	KW_LOCAL_ADDR,
+	KW_REMOTE_ADDR,
+	KW_P2_PFS,
+	KW_LOCAL_ID,
+	KW_REMOTE_ID,
+	KW_IMMEDIATE,
+	KW_P1_SOFTLIFE_SECS,
+	KW_P1_HARDLIFE_SECS,
+	KW_MAX
+} keyword_t;
+
+#define	KWF_ARG		(1 << 0)	/* keyword has argument */
+#define	KWF_MINUS	(1 << 1)	/* minus is a separator for arg */
+#define	KWF_MULTI	(1 << 2)	/* keyword can appear multiple times */
+
+#define	KW_HAS_ARG(k)	(!!(keyword_tab[(k)].kw_flags & KWF_ARG))
+#define	KW_IS_MULTI(k)	(!!(keyword_tab[(k)].kw_flags & KWF_MULTI))
+#define	KW_USE_MINUS(k)	(!!(keyword_tab[(k)].kw_flags & KWF_MINUS))
+
+static struct {
+	const char	*kw_str;
+	uint_t		kw_flags;
+} keyword_tab[] = {
+	{ "",			0 },
+	{ "cert_root",		KWF_ARG|KWF_MULTI },
+	{ "cert_trust",		KWF_ARG|KWF_MULTI },
+	{ "expire_timer",	KWF_ARG },
+	{ "ignore_crls",	0 },
+	{ "ldap_server",	KWF_ARG|KWF_MULTI },
+	{ "pkcs11_path",	KWF_ARG|KWF_MULTI },
+	{ "retry_limit",	KWF_ARG },
+	{ "retry_timer_init",	KWF_ARG },
+	{ "retry_timer_max",	KWF_ARG },
+	{ "proxy",		KWF_ARG },
+	{ "socks",		KWF_ARG },
+	{ "use_http",		0 },
+	{ "p1_lifetime_secs",	KWF_ARG },
+	{ "p1_nonce_len",	KWF_ARG },
+	{ "p2_lifetime_secs",	KWF_ARG },
+	{ "p2_softlife_secs",	KWF_ARG },
+	{ "p2_idletime_secs",	KWF_ARG },
+	{ "p2_lifetime_kb",	KWF_ARG },
+	{ "p2_softlife_kb",	KWF_ARG },
+	{ "p2_nonce_len",	KWF_ARG },
+	{ "local_id_type",	KWF_ARG },
+	{ "p1_xform",		KWF_MULTI },
+	{ "auth_method",	KWF_ARG },
+	{ "oakley_group",	KWF_ARG },
+	{ "auth_alg",		KWF_ARG },
+	{ "encr_alg",		KWF_ARG },
+	{ "label",		KWF_ARG },
+	{ "local_addr",		KWF_ARG|KWF_MINUS|KWF_MULTI },
+	{ "remote_addr",	KWF_ARG|KWF_MINUS|KWF_MULTI },
+	{ "p2_pfs",		KWF_ARG },
+	/*
+	 * XXX: The manpage implies local_id can appear multiple times, but
+	 * only the first one is used.  This may just be poor phrasing.
+	 */
+	{ "local_id",		KWF_ARG },
+	{ "remote_id",		KWF_ARG|KWF_MULTI },
+	{ "immediate",		0 },
+	{ "p1_softlife_secs",	KWF_ARG },
+	{ "p1_hardlife_secs",	KWF_ARG },
+};
+
+static struct {
+	ikev2_auth_type_t	a_id;
+	const char		*a_str;
+} auth_tab[] = {
+	{ IKEV2_AUTH_NONE, "" },
+	{ IKEV2_AUTH_RSA_SIG, "rsa_sig" },
+	{ IKEV2_AUTH_SHARED_KEY_MIC, "preshared" },
+	{ IKEV2_AUTH_DSS_SIG, "dss_sig" }
+};
+
+static struct {
+	config_auth_id_t	p1_id;
+	const char		*p1_str;
+} p1_id_tab[] = {
+	{ CFG_AUTH_ID_DN, "dn" },
+	{ CFG_AUTH_ID_DN, "DN" },
+	{ CFG_AUTH_ID_DNS, "dns" },
+	{ CFG_AUTH_ID_DNS, "DNS" },
+	{ CFG_AUTH_ID_DNS, "fqdn" },
+	{ CFG_AUTH_ID_DNS, "FQDN" },
+	{ CFG_AUTH_ID_GN, "gn" },
+	{ CFG_AUTH_ID_GN, "GN" },
+	{ CFG_AUTH_ID_IPV4, "ip" },
+	{ CFG_AUTH_ID_IPV4, "IP" },
+	{ CFG_AUTH_ID_IPV4, "ipv4" },
+	{ CFG_AUTH_ID_IPV4_PREFIX, "ipv4_prefix" },
+	{ CFG_AUTH_ID_IPV4_RANGE, "ipv4_range" },
+	{ CFG_AUTH_ID_IPV6, "ipv6" },
+	{ CFG_AUTH_ID_IPV6_PREFIX, "ipv6_prefix" },
+	{ CFG_AUTH_ID_IPV6_RANGE, "ipv6_range" },
+	{ CFG_AUTH_ID_EMAIL, "mbox" },
+	{ CFG_AUTH_ID_EMAIL, "MBOX" },
+	{ CFG_AUTH_ID_EMAIL, "user_fqdn" }
+};
+
+static struct {
+	ikev2_xf_auth_t xfa_id;
+	const char	*xfa_str;
+} xf_auth_tab[] = {
+	{ IKEV2_XF_AUTH_HMAC_MD5_128, "md5" },	/* XXX: verify this */
+	{ IKEV2_XF_AUTH_HMAC_SHA1_160, "sha" },
+	{ IKEV2_XF_AUTH_HMAC_SHA1_160, "sha1" },
+	{ IKEV2_XF_AUTH_HMAC_SHA2_256_128, "sha256" },
+	{ IKEV2_XF_AUTH_HMAC_SHA2_384_192, "sha384" },
+	{ IKEV2_XF_AUTH_HMAC_SHA2_512_256, "sha512" }
+};
+
+static struct {
+	ikev2_xf_encr_t xfe_id;
+	const char	*xfe_str;
+} xf_encr_tab[] = {
+	{ IKEV2_ENCR_DES, "des" },
+	{ IKEV2_ENCR_DES, "des-cbc" },
+	{ IKEV2_ENCR_3DES, "3des" },
+	{ IKEV2_ENCR_3DES, "3des-cbc" },
+	{ IKEV2_ENCR_BLOWFISH, "blowfish" },
+	{ IKEV2_ENCR_BLOWFISH, "blowfish-cbc" },
+	{ IKEV2_ENCR_AES_CBC, "aes" },
+	{ IKEV2_ENCR_AES_CBC, "aes-cbc" },
+	{ IKEV2_ENCR_AES_CCM_16, "aes-ccm" },
+	{ IKEV2_ENCR_AES_GCM_16, "aes-gcm" }
+};
+
+static struct {
+	ikev2_dh_t xfd_id;
+	const char *xfd_str;
+} xf_dh_tab[] = {
+	{ IKEV2_DH_MODP_768, "modp768" },
+	{ IKEV2_DH_MODP_1024, "modp1024" },
+	{ IKEV2_DH_EC2N_155, "ec2n155" },
+	{ IKEV2_DH_EC2N_185, "ec2n185" },
+	{ IKEV2_DH_MODP_1536, "modp1536" },
+	{ IKEV2_DH_MODP_2048, "modp2048" },
+	{ IKEV2_DH_MODP_3072, "modp3072" },
+	{ IKEV2_DH_MODP_4096, "modp4096" },
+	{ IKEV2_DH_MODP_6144, "modp6144" },
+	{ IKEV2_DH_MODP_8192, "modp8192" },
+	{ IKEV2_DH_ECP_256, "ecp256" },
+	{ IKEV2_DH_ECP_384, "ecp384" },
+	{ IKEV2_DH_ECP_521, "ecp521" },
+	{ IKEV2_DH_MODP_1024_160, "modp1024_160" },
+	{ IKEV2_DH_MODP_2048_224, "modp2048_224" },
+	{ IKEV2_DH_MODP_2048_256, "modp2048_256" },
+	{ IKEV2_DH_ECP_192, "ecp192" },
+	{ IKEV2_DH_ECP_224, "ecp224" },
+	{ IKEV2_DH_BRAINPOOL_P224R1, "brainpoolp224r1" },
+	{ IKEV2_DH_BRAINPOOL_P256R1, "brainpoolp256r1" },
+	{ IKEV2_DH_BRAINPOOL_P384R1, "brainpoolp384r1" },
+	{ IKEV2_DH_BRAINPOOL_P512R1, "brainpoolp512r1" },
+};
+
+/*
+ * size_t would be a more appropriate type for t_{line,col}, but using
+ * uint32_t makes it cleaner for logging with bunyan
+ */
+typedef struct token {
+	char		*t_str;
+	const char	*t_linep;
+	uint32_t	t_line;
+	uint32_t	t_col;
+} token_t;
+
+typedef struct input {
+	char	*in_buf;
+	size_t	in_buflen;
+	char	**in_lines;
+} input_t;
+
+typedef struct input_cursor {
+	input_t		*ic_input;
+	char		*ic_p;
+	token_t		*ic_peek;
+} input_cursor_t;
+
+static void add_str(char ***restrict, size_t *restrict, const char *restrict);
+static void add_addr(config_addr_t **restrict, size_t *restrict,
+    const config_addr_t *restrict);
+static void add_xf(config_rule_t *restrict, config_xf_t *restrict);
+static void add_rule(config_t *restrict, config_rule_t *restrict);
+static void add_remid(config_rule_t *restrict, config_id_t *restrict);
+
+static token_t *tok_new(const char *, const char *, const char *, size_t,
+    size_t);
+static void tok_free(token_t *);
+static void tok_log(const token_t *restrict, bunyan_level_t,
+    const char *restrict, const char *restrict);
+static void tok_error(const token_t *restrict, const char *restrict,
+    const char *restrict);
+static void tok_invalid(token_t *restrict, keyword_t);
+
+static boolean_t parse_rule(input_cursor_t *restrict, const token_t *restrict,
+    config_rule_t **restrict);
+static boolean_t parse_address(input_cursor_t *restrict, token_t *restrict,
+    config_addr_t *restrict);
+static boolean_t parse_p1_id(input_cursor_t *restrict, token_t *restrict,
+    config_id_t **restrict);
+static boolean_t parse_xform(input_cursor_t *restrict, config_xf_t **restrict);
+static boolean_t parse_encrbits(input_cursor_t *restrict,
+    config_xf_t *restrict);
+
+static boolean_t parse_kw(const char *restrict, keyword_t *restrict);
+static boolean_t parse_auth(const char *restrict, ikev2_auth_type_t *restrict);
+static boolean_t parse_authalg(const char *restrict, ikev2_xf_auth_t *restrict);
+static boolean_t parse_encralg(const char *restrict, ikev2_xf_encr_t *restrict);
+static boolean_t parse_p1_id_type(const char *restrict,
+    config_auth_id_t *restrict);
+static boolean_t parse_dh(const char *restrict, ikev2_dh_t *restrict);
+static boolean_t parse_ip(const char *restrict, in_addr_t *restrict);
+static boolean_t parse_ip6(const char *restrict, in6_addr_t *restrict);
+static boolean_t parse_int(const char *restrict, uint64_t *restrict);
+static boolean_t parse_fp(const char *restrict, double *restrict);
+
+static input_t *input_new(FILE *restrict);
+static void input_free(input_t *);
+
+static void input_cursor_init(input_cursor_t *, input_t *);
+static void input_cursor_fini(input_cursor_t *);
+static token_t *input_token(input_cursor_t *, boolean_t);
+static const token_t *input_peek(input_cursor_t *, boolean_t);
+static token_t *input_next_token(input_cursor_t *, boolean_t);
+static void input_cursor_getpos(input_cursor_t *restrict, const char *restrict,
+    const char **restrict, uint32_t *restrict, uint32_t *restrict);
+
+static boolean_t issep(char c, boolean_t);
+
+/*
+ * When processing a configuration file, we first load the entire contents
+ * into memory before doing any parsing.  This is to hopefully allow more
+ * contextual error messages (such as being able to output the full line of
+ * text where an error occurs, as well as the location where the error occurs).
+ * Once successfully parsed, the contents are discarded.
+ *
+ * The general approach is to then generate a stream of string tokens.  We
+ * defer interpretation of the tokens (e.g. 'IP address') since there are
+ * some instances where it'd be complicated to do so due to potential
+ * ambiguities.  Instead it's simpler to wait until there's more context.
+ *
+ * For example, once the 'local_addr' keyword has been seen, we know the next
+ * token should be either an IPV4 or IPV6 address, an IPV[46] address prefix
+ * (address/masklen), or an IPV[46] range (start address-end address).  We can
+ * attempt to convert the string accordingly without ambiguity.
+ *
+ * To assist in that, there is a (currently) limited ability to peek (view
+ * without advancing the stream) at the next token.  This has (so far)
+ * proven sufficient.
+ *
+ * To check the configuration, we build a new copy of config_t, and if it
+ * succeeds to completion, we know the configuration does not have any
+ * errors, and then discard it (instead of replacing the current configuration).
+ *
+ * TODO: We should probably support the ability to add and remove individual
+ * rules.
+ *
+ * TODO: Currently the lifetimes can only be specified globally, the current
+ * ike.config suggests this can be overwritten per-rule, so we should add
+ * support for that.
+ */
+void
+process_config(FILE *f, boolean_t check_only)
+{
+	input_t *in = input_new(f);
+	token_t *t = NULL, *targ = NULL;
+	config_t *cfg = NULL;
+	config_xf_t *xf = NULL;
+	input_cursor_t ic = { 0 };
+	union {
+		uint64_t	ui;
+		double		d;
+	} val;
+	size_t rule_count = 0;
+
+	(void) bunyan_trace(log, "process_config() enter", BUNYAN_T_END);
+
+	if (in == NULL) {
+		STDERR(error, "failure reading input");
+		(void) bunyan_trace(log, "process_config() exit", BUNYAN_T_END);
+		return;
+	}
+
+	cfg = umem_zalloc(sizeof (*cfg), UMEM_NOFAIL);
+
+	/* Set defaults */
+	cfg->cfg_local_id_type = CFG_AUTH_ID_IPV4;
+	cfg->cfg_expire_timer = SEC2NSEC(300);
+	cfg->cfg_retry_init = MSEC2NSEC(500);
+	cfg->cfg_retry_max = SEC2NSEC(30);
+	cfg->cfg_retry_limit = 5;
+	cfg->cfg_p2_lifetime_secs = CONFIG_P2_LIFETIME_SECS;
+	cfg->cfg_p2_softlife_secs = CONFIG_P2_SOFTLIFE_SECS;
+	cfg->cfg_p2_lifetime_kb = CONFIG_P2_LIFETIME_KB;
+	cfg->cfg_p2_softlife_kb = CONFIG_P2_SOFTLIFE_KB;
+
+	input_cursor_init(&ic, in);
+	while ((t = input_token(&ic, B_TRUE)) != NULL) {
+		keyword_t kw;
+
+		if (strcmp(t->t_str, "{") == 0) {
+			config_rule_t *rule = NULL;
+
+			if (!parse_rule(&ic, t, &rule))
+				goto fail;
+
+			add_rule(cfg, rule);
+			tok_free(t);
+			rule_count++;
+			continue;
+		}
+
+		if (!parse_kw(t->t_str, &kw)) {
+			tok_error(t, "Unrecognized configuration parameter",
+			    "parameter");
+			goto fail;
+		}
+
+		VERIFY3S(kw, !=, KW_NONE);
+		VERIFY3S(kw, !=, KW_MAX);
+
+		if (KW_HAS_ARG(kw)) {
+			targ = input_token(&ic, KW_USE_MINUS(kw));
+			if (targ == NULL) {
+				tok_error(t, "Parameter is missing argument",
+				    "parameter");
+				goto fail;
+			}
+		}
+
+		switch (kw) {
+		case KW_NONE:
+		case KW_MAX:
+			INVALID("t->t_val.t_kw");
+			break;
+		case KW_CERT_ROOT:
+			add_str(&cfg->cfg_cert_root, &cfg->cfg_cert_root_alloc,
+			    targ->t_str);
+			break;
+		case KW_CERT_TRUST:
+			add_str(&cfg->cfg_cert_trust,
+			    &cfg->cfg_cert_trust_alloc, targ->t_str);
+			break;
+		case KW_EXPIRE_TIMER:
+			if (!parse_int(targ->t_str, &val.ui)) {
+				tok_invalid(t, KW_EXPIRE_TIMER);
+				goto fail;
+			}
+			cfg->cfg_expire_timer = val.ui * NANOSEC;
+			break;
+		case KW_IGNORE_CRLS:
+			cfg->cfg_ignore_crls = B_TRUE;
+			break;
+		case KW_LDAP_SERVER:
+		case KW_PKCS11_PATH:
+			tok_log(t, BUNYAN_L_INFO,
+			    "Ignoring deprecated configuration parameter",
+			    "parameter");
+			break;
+		case KW_RETRY_LIMIT:
+			if (!parse_int(targ->t_str, &val.ui)) {
+				tok_invalid(t, KW_RETRY_LIMIT);
+				goto fail;
+			}
+			cfg->cfg_retry_limit = val.ui;
+			break;
+		case KW_PROXY:
+			cfg->cfg_proxy = ustrdup(targ->t_str, UMEM_NOFAIL);
+			break;
+		case KW_SOCKS:
+			cfg->cfg_socks = ustrdup(targ->t_str, UMEM_NOFAIL);
+			break;
+		case KW_RETRY_TIMER_INIT:
+			if (parse_int(targ->t_str, &val.ui)) {
+				cfg->cfg_retry_init = val.ui * NANOSEC;
+			} else if (parse_fp(targ->t_str, &val.d)) {
+				cfg->cfg_retry_init =
+				    (hrtime_t)(val.d * NANOSEC);
+			} else {
+				tok_invalid(targ, kw);
+				goto fail;
+			}
+			break;
+		case KW_RETRY_TIMER_MAX:
+			if (parse_int(targ->t_str, &val.ui)) {
+				cfg->cfg_retry_max = val.ui * NANOSEC;
+			} else if (parse_fp(targ->t_str, &val.d)) {
+				cfg->cfg_retry_max =
+				    (hrtime_t)(val.d * NANOSEC);
+			} else {
+				tok_invalid(targ, kw);
+				goto fail;
+			}
+			break;
+		case KW_P1_SOFTLIFE_SECS:
+			if (!parse_int(targ->t_str, &val.ui)) {
+				tok_invalid(targ, kw);
+				goto fail;
+			}
+			cfg->cfg_p1_softlife_secs = val.ui;
+			break;
+		case KW_P1_HARDLIFE_SECS:
+		case KW_P1_LIFETIME_SECS:
+			if (!parse_int(targ->t_str, &val.ui)) {
+				tok_invalid(targ, kw);
+				goto fail;
+			}
+			cfg->cfg_p1_hardlife_secs = val.ui;
+			break;
+		case KW_P1_NONCE_LEN:
+			if (!parse_int(targ->t_str, &val.ui)) {
+				tok_invalid(targ, kw);
+				goto fail;
+			}
+			/* XXX: check size */
+			cfg->cfg_p1_nonce_len = val.ui;
+			break;
+		case KW_P2_LIFETIME_SECS:
+			if (!parse_int(targ->t_str, &val.ui)) {
+				tok_invalid(targ, kw);
+				goto fail;
+			}
+			/* XXX: check size */
+			cfg->cfg_p2_lifetime_secs = val.ui;
+			break;
+		case KW_P2_SOFTLIFE_SECS:
+			if (!parse_int(targ->t_str, &val.ui)) {
+				tok_invalid(targ, kw);
+				goto fail;
+			}
+			/* XXX: check size */
+			cfg->cfg_p2_softlife_secs = val.ui;
+			break;
+		case KW_P2_IDLETIME_SECS:
+			if (!parse_int(targ->t_str, &val.ui)) {
+				tok_invalid(targ, kw);
+				goto fail;
+			}
+			/* XXX: check size */
+			cfg->cfg_p2_idletime_secs = val.ui;
+			break;
+		case KW_P2_LIFETIME_KB:
+			if (!parse_int(targ->t_str, &val.ui)) {
+				tok_invalid(targ, kw);
+				goto fail;
+			}
+			/* XXX: check size */
+			cfg->cfg_p2_lifetime_kb = val.ui;
+			break;
+		case KW_P2_SOFTLIFE_KB:
+			if (!parse_int(targ->t_str, &val.ui)) {
+				tok_invalid(targ, kw);
+				goto fail;
+			}
+			/* XXX: check size */
+			cfg->cfg_p2_softlife_kb = val.ui;
+			break;
+		case KW_P2_NONCE_LEN:
+			if (!parse_int(targ->t_str, &val.ui)) {
+				tok_invalid(targ, kw);
+				goto fail;
+			}
+			/* XXX: check size */
+			cfg->cfg_p2_nonce_len = val.ui;
+			break;
+		case KW_LOCAL_ID_TYPE:
+			if (!parse_p1_id_type(targ->t_str,
+			    &cfg->cfg_local_id_type)) {
+				tok_invalid(targ, kw);
+				goto fail;
+			}
+			break;
+		case KW_USE_HTTP:
+			cfg->cfg_use_http = B_TRUE;
+			break;
+		case KW_P2_PFS:
+			if (!parse_dh(targ->t_str,
+			    &cfg->cfg_default.rule_p2_dh)) {
+				tok_error(targ, "Invalid p2_pfs value",
+				    "value");
+				goto fail;
+			}
+			break;
+		case KW_P1_XFORM:
+			if (!parse_xform(&ic, &xf))
+				goto fail;
+			add_xf(&cfg->cfg_default, xf);
+			xf = NULL;
+			break;
+		case KW_AUTH_METHOD:
+		case KW_OAKLEY_GROUP:
+		case KW_AUTH_ALG:
+		case KW_ENCR_ALG:
+			tok_error(t, "Configuration parameter cannot be "
+			    "used outside of a transform definition",
+			    "parameter");
+			goto fail;
+		case KW_LABEL:
+		case KW_LOCAL_ADDR:
+		case KW_REMOTE_ADDR:
+		case KW_LOCAL_ID:
+		case KW_REMOTE_ID:
+		case KW_IMMEDIATE:
+			tok_error(t, "Configuration parameter cannot be "
+			    "used outside of a rule definition", "parameter");
+			goto fail;
+		}
+
+		tok_free(t);
+		tok_free(targ);
+		t = NULL;
+		targ = NULL;
+	}
+
+	tok_free(t);
+	tok_free(targ);
+	input_cursor_fini(&ic);
+	input_free(in);
+
+	(void) bunyan_info(log, "Finished processing config",
+	    BUNYAN_T_UINT32, "numrules", (uint32_t)rule_count,
+	    BUNYAN_T_END);
+
+	if (check_only) {
+		cfg_free(cfg);
+	} else {
+		config_t *old = NULL;
+
+		cfg->cfg_refcnt = 1;
+
+		VERIFY0(pthread_rwlock_wrlock(&cfg_lock));
+		old = config;
+		config = cfg;
+		VERIFY0(pthread_rwlock_unlock(&cfg_lock));
+		if (old != NULL)
+			CONFIG_REFRELE(old);
+	}
+	(void) bunyan_trace(log, "process_config() exit", BUNYAN_T_END);
+	return;
+
+fail:
+	tok_free(t);
+	tok_free(targ);
+	input_cursor_fini(&ic);
+	input_free(in);
+	cfg_free(cfg);
+	cfg = NULL;
+
+	if (!check_only)
+		exit(1);
+}
+
+static boolean_t
+parse_xform(input_cursor_t *restrict ic, config_xf_t **restrict xfp)
+{
+	config_xf_t *xf = NULL;
+	token_t *start_t = NULL, *t = NULL, *targ = NULL;
+	uint64_t val = 0;
+	const char *start = NULL, *end = NULL;
+	size_t kwcount[KW_MAX] = { 0 };
+	boolean_t ok = B_TRUE;
+
+	xf = umem_zalloc(sizeof (*xf), UMEM_NOFAIL);
+
+	if ((start_t = input_token(ic, B_FALSE)) == NULL) {
+		(void) bunyan_error(log,
+		    "Unexpected end of input processing transform",
+		    BUNYAN_T_END);
+		goto fail;
+	}
+
+	if (strcmp(start_t->t_str, "{") != 0) {
+		(void) bunyan_error(log, "Expected '{' after p1_xform",
+		    BUNYAN_T_STRING, "string", start_t->t_str,
+		    BUNYAN_T_END);
+		goto fail;
+	}
+
+	start = start_t->t_linep + start_t->t_col;
+
+	/*CONSTCOND*/
+	while (1) {
+		t = input_token(ic, B_FALSE);
+		if (t == NULL) {
+			(void) bunyan_error(log,
+			    "Unexpected end of input processing transform",
+			    BUNYAN_T_END);
+			goto fail;
+		}
+		if (strcmp(t->t_str, "}") == 0)
+			break;
+
+		keyword_t kw = KW_NONE;
+		if (!parse_kw(t->t_str, &kw)) {
+			tok_error(t, "Unknown configuration parameter",
+			    "parameter");
+			goto fail;
+		}
+
+		if (kwcount[kw] > 0 && !KW_IS_MULTI(kw)) {
+			tok_error(t,
+			    "Parameter can only appear once in a transform",
+			    "parameter");
+			goto fail;
+		}
+
+		if (KW_HAS_ARG(kw)) {
+			targ = input_token(ic, KW_USE_MINUS(kw));
+			if (targ == NULL) {
+				tok_error(t,
+				    "Parameter is missing an argument",
+				    "parameter");
+				goto fail;
+			}
+		}
+
+		switch (kw) {
+		case KW_AUTH_METHOD:
+			if (!parse_auth(targ->t_str, &xf->xf_authtype)) {
+				tok_error(targ,
+				    "Unknown authentication method",
+				    "authmethod");
+				goto fail;
+			}
+			break;
+		case KW_OAKLEY_GROUP:
+			if (!parse_dh(targ->t_str, &xf->xf_dh)) {
+				tok_error(targ,
+				    "Unknown oakley (DH) group",
+				    "group");
+				goto fail;
+			}
+			break;
+		case KW_AUTH_ALG:
+			if (!parse_authalg(targ->t_str, &xf->xf_auth)) {
+				tok_error(targ,
+				    "Unknown authentication algorithm",
+				    "algorithm");
+				goto fail;
+			}
+			break;
+		case KW_ENCR_ALG:
+			if (!parse_encralg(targ->t_str, &xf->xf_encr)) {
+				tok_error(targ,
+				    "Unknown encryption algorithm",
+				    "algorithm");
+				goto fail;
+			}
+			if (!parse_encrbits(ic, xf))
+				goto fail;
+			break;
+		case KW_P1_LIFETIME_SECS:
+			if (!parse_int(targ->t_str, &val)) {
+				tok_error(targ, "Invalid value", "value");
+				goto fail;
+			}
+			xf->xf_lifetime_secs = (uint32_t)val;
+			break;
+		case KW_P1_NONCE_LEN:
+			if (!parse_int(targ->t_str, &val)) {
+				tok_error(targ, "Invalid value", "value");
+				goto fail;
+			}
+			/* XXX: validate length */
+			xf->xf_nonce_len = (uint32_t)val;
+			break;
+		default:
+			(void) bunyan_error(log, "Parameter keyword not "
+			    "allowed in transform definition",
+			    BUNYAN_T_STRING, "keyword", t->t_str,
+			    BUNYAN_T_END);
+			goto fail;
+		}
+
+		kwcount[kw]++;
+
+		tok_free(t);
+		tok_free(targ);
+		t = NULL;
+		targ = NULL;
+	}
+
+	if (kwcount[KW_ENCR_ALG] == 0) {
+		tok_error(start_t,
+		    "Transform missing encryption algorithm", NULL);
+		ok = B_FALSE;
+	}
+	if (kwcount[KW_AUTH_ALG] == 0) {
+		tok_error(start_t,
+		    "Transform missing authentication algorithm", NULL);
+		ok = B_FALSE;
+	}
+
+	end = t->t_linep + t->t_col;
+
+	if (!ok)
+		goto fail;
+
+	/*
+	 * end points to closing '}' of transform, so end - start + 2
+	 * includes closing } plus room for NUL
+	 */
+	val = (uint64_t)(end - start) + 2;
+	xf->xf_str = umem_zalloc(val, UMEM_NOFAIL);
+	bcopy(start, xf->xf_str, val - 1);
+
+	tok_free(start_t);
+	tok_free(t);
+	tok_free(targ);
+	*xfp = xf;
+	return (B_TRUE);
+
+fail:
+	tok_free(start_t);
+	tok_free(t);
+	tok_free(targ);
+	umem_free(xf, sizeof (*xf));
+	*xfp = NULL;
+	return (B_FALSE);
+}
+
+static boolean_t
+parse_encrbits(input_cursor_t *restrict ic, config_xf_t *restrict xf)
+{
+	const token_t *tpeek = NULL;
+	token_t *t = NULL;
+	uint64_t val = 0;
+
+	if ((tpeek = input_peek(ic, B_FALSE)) == NULL)
+		goto truncated;
+
+	/* No key length given, that's ok */
+	if (strcmp(tpeek->t_str, "(") != 0)
+		return (B_TRUE);
+
+	/* consume '(' */
+	tok_free(input_token(ic, B_FALSE));
+
+	if ((t = input_token(ic, B_FALSE)) == NULL)
+		goto truncated;
+
+	if (!parse_int(t->t_str, &val))
+		goto invalid;
+	if (val > SIZE_MAX)
+		goto toobig;
+	xf->xf_minbits = (size_t)val;
+	tok_free(t);
+
+	if ((t = input_token(ic, B_FALSE)) == NULL)
+		goto truncated;
+	if (strcmp(t->t_str, ")") == 0) {
+		xf->xf_maxbits = xf->xf_minbits;
+		goto done;
+	}
+
+	if (strcmp(t->t_str, "..") != 0)
+		goto unexpected;
+	tok_free(t);
+
+	if ((t = input_token(ic, B_TRUE)) == NULL)
+		goto truncated;
+	if (!parse_int(t->t_str, &val))
+		goto invalid;
+	if (val > SIZE_MAX)
+		goto toobig;
+	xf->xf_maxbits = val;
+
+	if (xf->xf_maxbits < xf->xf_minbits) {
+		(void) bunyan_error(log,
+		    "Maximum keysize is smaller than minimum keysize",
+		    BUNYAN_T_STRING, "value", t->t_str,
+		    BUNYAN_T_UINT32, "line", t->t_line,
+		    BUNYAN_T_UINT32, "col", t->t_col,
+		    BUNYAN_T_END);
+		tok_free(t);
+		return (B_FALSE);
+	}
+
+	tok_free(t);
+	if ((t = input_token(ic, B_TRUE)) == NULL)
+		goto truncated;
+	if (strcmp(t->t_str, ")") != 0)
+		goto unexpected;
+
+done:
+	tok_free(t);
+	return (B_TRUE);
+
+unexpected:
+	(void) bunyan_error(log, "Unexpected value after key length",
+	    BUNYAN_T_STRING, "value", t->t_str,
+	    BUNYAN_T_UINT32, "line", t->t_line,
+	    BUNYAN_T_UINT32, "col", t->t_col,
+	    BUNYAN_T_END);
+	tok_free(t);
+	return (B_FALSE);
+
+invalid:
+	(void) bunyan_error(log, "Invalid key bitlength",
+	    BUNYAN_T_STRING, "bitlength", t->t_str,
+	    BUNYAN_T_UINT32, "line", t->t_line,
+	    BUNYAN_T_UINT32, "col", t->t_col,
+	    BUNYAN_T_END);
+	tok_free(t);
+	return (B_FALSE);
+
+toobig:
+	(void) bunyan_error(log, "Keysize is too large",
+	    BUNYAN_T_UINT64, "keysize", val,
+	    BUNYAN_T_UINT32, "line", t->t_line,
+	    BUNYAN_T_UINT32, "col", t->t_col,
+	    BUNYAN_T_END);
+	tok_free(t);
+	return (B_FALSE);
+
+truncated:
+	tok_free(t);
+	bunyan_error(log, "Truncated input while reading transform",
+	    BUNYAN_T_END);
+	return (B_FALSE);
+}
+
+static boolean_t
+parse_rule(input_cursor_t *restrict ic, const token_t *start,
+    config_rule_t **restrict rulep)
+{
+	token_t *t = NULL, *targ = NULL;
+	token_t *local_id = NULL;
+	config_rule_t *rule = NULL;
+	config_xf_t *xf = NULL;
+	config_id_t *remid = NULL;
+	config_addr_t addr = { 0 };
+	size_t kwcount[KW_MAX] = { 0 };
+	config_auth_id_t local_id_type = CFG_AUTH_ID_IPV4;
+	boolean_t ok = B_TRUE;
+
+	*rulep = NULL;
+
+	rule = umem_zalloc(sizeof (*rule), UMEM_NOFAIL);
+
+	while ((t = input_token(ic, B_FALSE)) != NULL) {
+		keyword_t kw = KW_NONE;
+
+		if (strcmp(t->t_str, "}") == 0)
+			break;
+
+		if (!parse_kw(t->t_str, &kw)) {
+			tok_log(t, BUNYAN_L_ERROR,
+			    "Unrecognized configuration parameter",
+			    "parameter");
+			goto fail;
+		}
+
+		if (KW_HAS_ARG(kw)) {
+			targ = input_token(ic, KW_USE_MINUS(kw));
+			if (targ == NULL) {
+				(void) bunyan_error(log, "Input truncated "
+				    "while reading rule", BUNYAN_T_END);
+				goto fail;
+			}
+		}
+
+		if (kwcount[kw] > 0 && !KW_IS_MULTI(kw)) {
+			tok_log(t, BUNYAN_L_ERROR,
+			    "Configuration parameter can only appear once in a "
+			    "transform definition", "parameter");
+			goto fail;
+		}
+
+		switch (kw) {
+		case KW_LABEL:
+			rule->rule_label = ustrdup(targ->t_str, UMEM_NOFAIL);
+			break;
+		case KW_P2_PFS:
+			if (!parse_dh(targ->t_str, &rule->rule_p2_dh)) {
+				tok_invalid(targ, KW_P2_PFS);
+				goto fail;
+			}
+			break;
+		case KW_P1_XFORM:
+			if (!parse_xform(ic, &xf))
+				goto fail;
+
+			add_xf(rule, xf);
+			xf = NULL;
+			break;
+		case KW_LOCAL_ADDR:
+			bzero(&addr, sizeof (addr));
+			if (!parse_address(ic, targ, &addr))
+				goto fail;
+			add_addr(&rule->rule_local_addr,
+			    &rule->rule_nlocal_addr, &addr);
+			break;
+		case KW_REMOTE_ADDR:
+			bzero(&addr, sizeof (addr));
+			if (!parse_address(ic, targ, &addr))
+				goto fail;
+			add_addr(&rule->rule_remote_addr,
+			    &rule->rule_nremote_addr, &addr);
+			break;
+		case KW_LOCAL_ID:
+			/* Set aside we're done */
+			VERIFY3P(local_id, ==, NULL);
+			local_id = targ;
+			targ = NULL;
+			break;
+		case KW_REMOTE_ID:
+			if (!parse_p1_id(ic, targ, &remid))
+				goto fail;
+			add_remid(rule, remid);
+			break;
+		case KW_LOCAL_ID_TYPE:
+			if (!parse_p1_id_type(targ->t_str, &local_id_type)) {
+				tok_log(t, BUNYAN_L_ERROR,
+				    "Unable to parse local_id_type", "value");
+				goto fail;
+			}
+			break;
+		case KW_IMMEDIATE:
+			rule->rule_immediate = B_TRUE;
+			break;
+		default:
+			tok_log(t, BUNYAN_L_ERROR, "Configuration "
+			    "parameter is invalid inside a rule definition",
+			    "parameter");
+			goto fail;
+		}
+
+		kwcount[(kw)]++;
+
+		tok_free(t);
+		tok_free(targ);
+		t = NULL;
+		targ = NULL;
+	}
+
+	if (t == NULL) {
+		(void) bunyan_error(log,
+		    "Input truncated while reading rule",
+		    BUNYAN_T_END);
+		goto fail;
+	}
+
+	if (kwcount[KW_LOCAL_ID_TYPE] > 0 && kwcount[KW_LOCAL_ID] == 0) {
+		switch (local_id_type) {
+		case CFG_AUTH_ID_IPV4:
+		case CFG_AUTH_ID_IPV6:
+			break;
+		default:
+			tok_error(start,
+			    "Local ID type specified, but "
+			    "local ID value missing in rule", NULL);
+			goto fail;
+		}
+	} else if (kwcount[KW_LOCAL_ID_TYPE] > 0 && kwcount[KW_LOCAL_ID] > 0) {
+		if (!parse_p1_id(ic, local_id, &rule->rule_local_id)) {
+			if (errno == EINVAL)
+				tok_error(local_id,
+				    "Unable to parse local id type", "str");
+			goto fail;
+		}
+		if (local_id_type != rule->rule_local_id->cid_type) {
+			tok_error(local_id,
+			    "Local ID type in rule does not match given "
+			    "local ID", NULL);
+			goto fail;
+		}
+	} else if (kwcount[KW_LOCAL_ID_TYPE] == 0 && kwcount[KW_LOCAL_ID] > 0) {
+		if (!parse_p1_id(ic, local_id, &rule->rule_local_id))
+			goto fail;
+	}
+
+	/* Try to show as many errors as we can */
+	if (kwcount[KW_LABEL] == 0) {
+		tok_error(start, "Rule is missing a required label",
+		    NULL);
+		ok = B_FALSE;
+	}
+	if (kwcount[KW_LOCAL_ADDR] == 0) {
+		tok_error(start,
+		    "Rule is missing a required local address", NULL);
+		ok = B_FALSE;
+	}
+	if (kwcount[KW_REMOTE_ADDR] == 0) {
+		tok_error(start,
+		    "Rule is missing a required remote address", NULL);
+		ok = B_FALSE;
+	}
+	if (kwcount[KW_P1_XFORM] > 1) {
+		ikev2_auth_type_t authtype = rule->rule_xf[0]->xf_authtype;
+
+		for (size_t i = 1; rule->rule_xf[i] != NULL; i++) {
+			if (rule->rule_xf[i]->xf_authtype == authtype)
+				continue;
+			tok_error(start,
+			    "All transforms in rule must use the same "
+			    "authentication type", NULL);
+			ok = B_FALSE;
+			break;
+		}
+
+		if (authtype != IKEV2_AUTH_SHARED_KEY_MIC &&
+		    kwcount[KW_LOCAL_ID] == 0) {
+			tok_error(start,
+			    "Non-preshared authentication methods require "
+			    "a local-id", NULL);
+			ok = B_FALSE;
+		}
+	}
+
+	if (!ok)
+		goto fail;
+
+	tok_free(t);
+	tok_free(targ);
+	tok_free(local_id);
+	*rulep = rule;
+	return (B_TRUE);
+
+fail:
+	tok_free(t);
+	tok_free(targ);
+	tok_free(local_id);
+	umem_free(rule, sizeof (*rule));
+	return (B_FALSE);
+}
+
+static boolean_t
+parse_address(input_cursor_t *restrict ic, token_t *restrict taddr,
+    config_addr_t *restrict addrp)
+{
+	const token_t *tpeek = NULL;
+	token_t *t = NULL;
+	boolean_t ip6 = B_FALSE;
+	boolean_t ok = B_FALSE;
+
+	t = taddr;
+
+	if (!parse_ip(t->t_str, &addrp->cfa_start4)) {
+		if (!parse_ip6(t->t_str, &addrp->cfa_start6)) {
+			tok_log(t, BUNYAN_L_ERROR,
+			    "Unable to parse address", "address");
+			return (B_FALSE);
+		}
+		ip6 = B_TRUE;
+	}
+
+	tpeek = input_peek(ic, B_TRUE);
+	if (strcmp(tpeek->t_str, "-") == 0) {
+		/* consume - */
+		tok_free(input_token(ic, B_TRUE));
+
+		addrp->cfa_type =
+		    ip6 ? CFG_ADDR_IPV6_RANGE : CFG_ADDR_IPV4_RANGE;
+
+		t = input_token(ic, B_FALSE);
+		if (t == NULL)
+			goto truncated;
+
+		ok = ip6 ? parse_ip6(t->t_str, &addrp->cfa_end6) :
+		    parse_ip(t->t_str, &addrp->cfa_end4);
+		if (!ok) {
+			tok_log(t, BUNYAN_L_ERROR,
+			    "Unable to parse address range", "address");
+		}
+		tok_free(t);
+		return (ok);
+	} else if (strcmp(tpeek->t_str, "/") == 0) {
+		uint64_t val = 0;
+
+		addrp->cfa_type =
+		    ip6 ? CFG_ADDR_IPV6_PREFIX : CFG_ADDR_IPV4_PREFIX;
+
+		/* consume "/" */
+		tok_free(input_token(ic, B_TRUE));
+
+		t = input_token(ic, B_FALSE);
+		if (t == NULL)
+			goto truncated;
+
+		if (!parse_int(t->t_str, &val)) {
+			tok_log(t, BUNYAN_L_ERROR,
+			    "Cannot parse mask length", "mask_len");
+			return (B_FALSE);
+		}
+		tok_free(t);
+		t = NULL;
+		if ((ip6 && val > 128) || (!ip6 && val > 32)) {
+			(void) bunyan_error(log, "Mask length too long",
+			    BUNYAN_T_UINT64, "mask", val,
+			    BUNYAN_T_END);
+			return (B_FALSE);
+		}
+		addrp->cfa_endu.cfa_num = (uint8_t)val;
+		return (B_TRUE);
+	} else {
+		addrp->cfa_type =
+		    ip6 ? CFG_ADDR_IPV6 : CFG_ADDR_IPV4;
+	}
+
+	return (B_TRUE);
+
+truncated:
+	(void) bunyan_error(log, "Input truncated while parsing address",
+	    BUNYAN_T_END);
+	return (B_FALSE);
+}
+
+static boolean_t
+parse_dh(const char *restrict str, ikev2_dh_t *dhp)
+{
+	uint64_t val = 0;
+	boolean_t found = B_FALSE;
+
+	for (size_t i = 0; i < ARRAY_SIZE(xf_dh_tab); i++) {
+		if (strcmp(xf_dh_tab[i].xfd_str, str) == 0) {
+			val = xf_dh_tab[i].xfd_id;
+			found = B_TRUE;
+			break;
+		}
+	}
+
+	if (!found && !parse_int(str, &val))
+		return (B_FALSE);
+
+	/*
+	 * NOTE: a default case is explicitly avoided so that the addition
+	 * of newer values in ikev2.h will cause a compilation error if they
+	 * are not added here.
+	 */
+	switch ((ikev2_dh_t)val) {
+	case IKEV2_DH_NONE:
+	case IKEV2_DH_MODP_768:
+	case IKEV2_DH_MODP_1024:
+	case IKEV2_DH_EC2N_155:
+	case IKEV2_DH_EC2N_185:
+	case IKEV2_DH_MODP_1536:
+	case IKEV2_DH_MODP_2048:
+	case IKEV2_DH_MODP_3072:
+	case IKEV2_DH_MODP_4096:
+	case IKEV2_DH_MODP_6144:
+	case IKEV2_DH_MODP_8192:
+	case IKEV2_DH_ECP_256:
+	case IKEV2_DH_ECP_384:
+	case IKEV2_DH_ECP_521:
+	case IKEV2_DH_MODP_1024_160:
+	case IKEV2_DH_MODP_2048_224:
+	case IKEV2_DH_MODP_2048_256:
+	case IKEV2_DH_ECP_192:
+	case IKEV2_DH_ECP_224:
+	case IKEV2_DH_BRAINPOOL_P224R1:
+	case IKEV2_DH_BRAINPOOL_P256R1:
+	case IKEV2_DH_BRAINPOOL_P384R1:
+	case IKEV2_DH_BRAINPOOL_P512R1:
+		*dhp = (ikev2_dh_t)val;
+		return (B_TRUE);
+	}
+
+	return (B_FALSE);
+}
+
+static boolean_t
+parse_ip(const char *restrict str, in_addr_t *restrict addrp)
+{
+	if (inet_pton(AF_INET, str, addrp) != 1)
+		return (B_FALSE);
+	return (B_TRUE);
+}
+
+static boolean_t
+parse_ip6(const char *restrict str, in6_addr_t *restrict addrp)
+{
+	if (inet_pton(AF_INET6, str, addrp) != 1)
+		return (B_FALSE);
+	return (B_TRUE);
+}
+
+static boolean_t
+parse_int(const char *restrict str, uint64_t *restrict intp)
+{
+	errno = 0;
+	*intp = strtoull(str, NULL, 0);
+	return ((errno == 0) ? B_TRUE : B_FALSE);
+}
+
+static boolean_t
+parse_fp(const char *restrict str, double *restrict dp)
+{
+	errno = 0;
+	*dp = strtod(str, NULL);
+	return ((errno == 0) ? B_TRUE : B_FALSE);
+}
+
+static boolean_t
+parse_kw(const char *restrict str, keyword_t *restrict kwp)
+{
+	for (keyword_t kw = KW_NONE; kw < KW_MAX; kw++) {
+		if (strcmp(keyword_tab[kw].kw_str, str) == 0) {
+			*kwp = kw;
+			VERIFY3S(*kwp, <, KW_MAX);
+			return (B_TRUE);
+		}
+	}
+	return (B_FALSE);
+}
+
+static boolean_t
+parse_auth(const char *restrict str, ikev2_auth_type_t *restrict authp)
+{
+	for (size_t i = 0; i < ARRAY_SIZE(auth_tab); i++) {
+		if (strcmp(auth_tab[i].a_str, str) == 0) {
+			*authp = auth_tab[i].a_id;
+			return (B_TRUE);
+		}
+	}
+	return (B_FALSE);
+}
+
+static boolean_t
+parse_authalg(const char *restrict str, ikev2_xf_auth_t *authp)
+{
+	for (size_t i = 0; i < ARRAY_SIZE(xf_auth_tab); i++) {
+		if (strcmp(xf_auth_tab[i].xfa_str, str) == 0) {
+			*authp = xf_auth_tab[i].xfa_id;
+			return (B_TRUE);
+		}
+	}
+	return (B_FALSE);
+}
+
+static boolean_t
+parse_encralg(const char *restrict str, ikev2_xf_encr_t *restrict encp)
+{
+	for (size_t i = 0; i < ARRAY_SIZE(xf_encr_tab); i++) {
+		if (strcmp(xf_encr_tab[i].xfe_str, str) == 0) {
+			*encp = xf_encr_tab[i].xfe_id;
+			return (B_TRUE);
+		}
+	}
+	return (B_FALSE);
+}
+
+static boolean_t
+parse_p1_id_type(const char *restrict str, config_auth_id_t *restrict p1p)
+{
+	for (size_t i = 0; i < ARRAY_SIZE(p1_id_tab); i++) {
+		if (strcmp(p1_id_tab[i].p1_str, str) == 0) {
+			*p1p = p1_id_tab[i].p1_id;
+			return (B_TRUE);
+		}
+	}
+	return (B_FALSE);
+}
+
+static boolean_t
+parse_p1_id(input_cursor_t *restrict ic, token_t *restrict t,
+    config_id_t **restrict idp)
+{
+	config_id_t *id = NULL;
+	void *ptr = NULL;
+	struct sockaddr_storage ss = { 0 };
+	sockaddr_u_t addr = { .sau_ss = &ss };
+	size_t len = 0;
+	config_auth_id_t idtype = CFG_AUTH_ID_DNS;
+
+	*idp = NULL;
+
+	/*
+	* Sadly, while the existing ike.config requires one specify a type
+	* for the local id, it tries to guess the type of the remote ID
+	* string, however it is not documented on how that is done.  This
+	* is a best guess at matching that.  We assume if the string
+	* successfully parses as either an IPV4 or IPV6 address that it
+	* should should be of the respective type, an email address must
+	* contain a '@', something with '.' that didn't parse as an
+	* IPV4 address is a DNS name, something with ':' that didn't parse
+	* as an IPV6 address is a GN (based on draft-ietf-pkix-generalname-00),
+	* while something with '=' that didn't parse as a GN is a DN.
+	*
+	* We currently don't parse the _{PREFIX,RANGE} variants of IPV4 and
+	* IPV6.  Those seem to be ID types specific to IKEv1, and are not
+	* present in IKEv2.  When we add IKEv1 support, we likely will
+	* get rid of them altogether and require our peer to never offer
+	* such an ID.  Every IKEv1 implementation encountered so far appears to
+	* allow one to choose the type of ID presented during authentication,
+	* so it seems unlikely it would cause any interoperability concerns.
+	*/
+	if (inet_pton(AF_INET, t->t_str, addr.sau_sin) == 1) {
+		idtype = CFG_AUTH_ID_IPV4;
+		len = sizeof (in_addr_t);
+		ptr = &addr.sau_sin->sin_addr;
+	} else if (inet_pton(AF_INET6, t->t_str, addr.sau_sin6) == 1) {
+		idtype = CFG_AUTH_ID_IPV6;
+		len = sizeof (in6_addr_t);
+		ptr = &addr.sau_sin6->sin6_addr;
+	} else if (strchr(t->t_str, '@') != NULL) {
+		idtype = CFG_AUTH_ID_EMAIL;
+		len = strlen(t->t_str) + 1;
+		ptr = t->t_str;
+	} else if (strchr(t->t_str, '.') != NULL) {
+		idtype = CFG_AUTH_ID_DNS;
+		len = strlen(t->t_str) + 1;
+		ptr = t->t_str;
+	} else if (strchr(t->t_str, ':') != NULL) {
+		idtype = CFG_AUTH_ID_GN;
+		/* TODO */
+		INVALID("implement me!");
+	} else if (strchr(t->t_str, '=') != NULL) {
+		idtype = CFG_AUTH_ID_DN;
+		/* TODO */
+		INVALID("implement me!");
+	} else {
+		tok_error(t, "Unable to determine ID type", "id");
+		return (B_FALSE);
+	}
+
+	if ((id = config_id_new(idtype, ptr, len)) == NULL)
+		return (B_FALSE);
+
+	*idp = id;
+	return (B_TRUE);
+}
+
+static token_t *
+tok_new(const char *startp, const char *endp, const char *linep, size_t line,
+    size_t col)
+{
+	VERIFY3P(endp, >=, startp);
+
+	token_t *t = NULL;
+	size_t len = (size_t)(endp - startp) + 1;
+
+	t = umem_zalloc(sizeof (*t), UMEM_NOFAIL);
+	t->t_str = umem_zalloc(len, UMEM_NOFAIL);
+	bcopy(startp, t->t_str, len -1);
+
+	t->t_linep = linep;
+	t->t_line = line;
+	t->t_col = col;
+	return (t);
+}
+
+static void
+tok_free(token_t *t)
+{
+	if (t == NULL)
+		return;
+	ustrfree(t->t_str);
+	umem_free(t, sizeof (*t));
+}
+
+#define	STR(x) case x: return (#x)
+static const char *
+cfg_auth_id_str(config_auth_id_t id)
+{
+	switch (id) {
+	STR(CFG_AUTH_ID_DN);
+	STR(CFG_AUTH_ID_DNS);
+	STR(CFG_AUTH_ID_GN);
+	STR(CFG_AUTH_ID_IPV4);
+	STR(CFG_AUTH_ID_IPV4_PREFIX);
+	STR(CFG_AUTH_ID_IPV4_RANGE);
+	STR(CFG_AUTH_ID_IPV6);
+	STR(CFG_AUTH_ID_IPV6_PREFIX);
+	STR(CFG_AUTH_ID_IPV6_RANGE);
+	STR(CFG_AUTH_ID_EMAIL);
+	}
+	return ("UNKNOWN");
+}
+#undef	STR
+
+static void
+tok_log(const token_t *restrict t, bunyan_level_t level, const char *msg,
+    const char *strname)
+{
+	char *linecpy = NULL;
+	const char *endp = strchr(t->t_linep, '\n');
+	size_t len = 0;
+
+	if (endp != NULL)
+		len = endp - t->t_linep + 1;
+	else
+		len = strlen(t->t_linep) + 1;
+
+	if ((linecpy = umem_alloc(len, UMEM_DEFAULT)) == NULL)
+		return;
+
+	(void) strlcpy(linecpy, t->t_linep, len);
+
+	getlog(level)(log, msg,
+	    BUNYAN_T_STRING, "line", linecpy,
+	    BUNYAN_T_UINT32, "lineno", t->t_line + 1,
+	    BUNYAN_T_UINT32, "col", t->t_col + 1,
+	    (strname != NULL) ? BUNYAN_T_STRING : BUNYAN_T_END,
+	    strname, t->t_str, BUNYAN_T_END);
+
+	umem_free(linecpy, len);
+}
+
+static void
+tok_error(const token_t *restrict t, const char *restrict msg,
+    const char *restrict tname)
+{
+	tok_log(t, BUNYAN_L_ERROR, msg, tname);
+}
+
+static void
+tok_invalid(token_t *restrict t, keyword_t kw)
+{
+	char buf[128] = { 0 };
+	(void) snprintf(buf, sizeof (buf), "Invalid %s parameter",
+	    keyword_tab[kw]);
+	tok_error(t, buf, "parameter");
+}
+
+static input_t *
+input_new(FILE *restrict f)
+{
+	input_t *in = NULL;
+	char *p = NULL;
+	ssize_t n = 0;
+	size_t cnt = 0;
+	size_t nlines = 0;
+	struct stat sb = { 0 };
+	int fd = -1;
+
+	in = umem_zalloc(sizeof (*in), UMEM_NOFAIL);
+
+	fd = fileno(f);
+	if (fstat(fd, &sb) == -1) {
+		STDERR(error, "stat failed");
+		goto fail;
+	}
+
+	/*
+	 * Try to read in one go, however the input could be a pipe instead
+	 * of a file, in which case we have to keep growing the buffer
+	 * (up to the limit)
+	 */
+	if (S_ISREG(sb.st_mode)) {
+		in->in_buflen = sb.st_size + 2;
+	} else {
+		in->in_buflen = CONFIG_CHUNK;
+	}
+	in->in_buf = umem_zalloc(in->in_buflen, UMEM_NOFAIL);
+
+	do {
+		n = fread(in->in_buf + cnt, 1, in->in_buflen - cnt - 1, f);
+		if (n < 0) {
+			STDERR(error, "read failed");
+			goto fail;
+		}
+		cnt += n;
+
+		if (cnt + 1 >= in->in_buflen) {
+			if (in->in_buflen >= CONFIG_MAX) {
+				(void) bunyan_error(log,
+				    "Input size exceeds limits",
+				    BUNYAN_T_UINT32, "size",
+				    (uint32_t)in->in_buflen,
+				    BUNYAN_T_UINT32, "limit",
+				    (uint32_t)CONFIG_MAX,
+				    BUNYAN_T_END);
+				goto fail;
+			}
+
+			size_t newlen = P2ROUNDUP(in->in_buflen + CONFIG_CHUNK,
+			    CONFIG_CHUNK);
+
+			in->in_buf = umem_realloc(in->in_buf, in->in_buflen,
+			    newlen, UMEM_NOFAIL);
+			in->in_buflen = newlen;
+		}
+	} while (n > 0);
+	in->in_buf[cnt] = '\0';
+
+	for (p = in->in_buf, nlines = 0; p != NULL; p = strchr(p + 1, '\n'))
+		nlines++;
+
+	in->in_lines = umem_calloc(nlines + 1, sizeof (char *), UMEM_NOFAIL);
+
+	for (p = in->in_buf, nlines = 0; p != NULL; p = strchr(p + 1, '\n'))
+		in->in_lines[nlines++] = p;
+
+	return (in);
+
+fail:
+	input_free(in);
+	return (NULL);
+}
+
+static token_t *
+input_token(input_cursor_t *ic, boolean_t minus_is_sep)
+{
+	token_t *t = NULL;
+	if (ic->ic_peek != NULL) {
+		t = ic->ic_peek;
+		ic->ic_peek = NULL;
+	} else {
+		t = input_next_token(ic, minus_is_sep);
+	}
+
+	return (t);
+}
+
+/* NOTE: Results of input_peek() should NOT be freed */
+static const token_t *
+input_peek(input_cursor_t *ic, boolean_t minus_is_sep)
+{
+	if (ic->ic_peek != NULL)
+		return (ic->ic_peek);
+
+	ic->ic_peek = input_next_token(ic, minus_is_sep);
+	return (ic->ic_peek);
+}
+
+/*
+ * Actually get the next token from the input.  This is used both by
+ * input_token() and input_peek() and shouldn't be called by anything else.
+ */
+static token_t *
+input_next_token(input_cursor_t *ic, boolean_t minus_is_sep)
+{
+	char *start = NULL, *end = NULL;
+	const char *linep = NULL;
+	uint32_t line = 0, col = 0;
+
+	VERIFY3P(ic->ic_p, >=, ic->ic_input->in_buf);
+	VERIFY3P(ic->ic_p, <, ic->ic_input->in_buf + ic->ic_input->in_buflen);
+
+again:
+	while (*ic->ic_p != '\0' && isspace(*ic->ic_p))
+		ic->ic_p++;
+
+	if (*ic->ic_p == '#') {
+		/* skip to next line */
+		while (*ic->ic_p != '\0' && *ic->ic_p != '\n')
+			ic->ic_p++;
+		goto again;
+	}
+
+	if (*ic->ic_p == '\0')
+		return (NULL);
+
+	start = ic->ic_p;
+	end = start + 1;
+
+	/* If the first character is a separator, we're done */
+	if (issep(*start, minus_is_sep)) {
+		ic->ic_p = end;
+		goto done;
+	}
+
+	if (*start == '"') {
+		while (*end != '\0' && *end != '\n' && *end != '"')
+			end++;
+
+		if (*end != '"') {
+			input_cursor_getpos(ic, start, &linep, &line, &col);
+			(void) bunyan_error(log, "Unterminated quoted string",
+			    BUNYAN_T_UINT32, "line", line,
+			    BUNYAN_T_UINT32, "col", col,
+			    BUNYAN_T_END);
+			return (NULL);
+		}
+
+		start++;
+		ic->ic_p = end + 1;
+		goto done;
+	}
+
+	while (*end != '\0' && !isspace(*end)) {
+		if (issep(*end, minus_is_sep) || isspace(*end))
+			break;
+		end++;
+	}
+	ic->ic_p = end;
+
+done:
+	input_cursor_getpos(ic, start, &linep, &line, &col);
+	return (tok_new(start, end, linep, line, col));
+}
+
+static void
+input_cursor_getpos(input_cursor_t *restrict ic, const char *restrict p,
+    const char **restrict linepp, uint32_t *restrict linep,
+    uint32_t *restrict colp)
+{
+	VERIFY3P(ic->ic_input->in_buf, <=, p);
+	VERIFY3P(ic->ic_input->in_buf + ic->ic_input->in_buflen, >, p);
+
+	char **lineidx = ic->ic_input->in_lines;
+	uint32_t line;
+	for (line = 1; lineidx[line] != NULL && lineidx[line] <= p; line++)
+		;
+
+	line--;
+	*linep = line;
+	*colp = (uint32_t)(p - lineidx[line]);
+	*linepp = lineidx[line];
+}
+
+static void
+input_cursor_init(input_cursor_t *restrict ic, input_t *restrict in)
+{
+	bzero(ic, sizeof (*ic));
+	ic->ic_input = in;
+	ic->ic_p = in->in_buf;
+}
+
+static void
+input_cursor_fini(input_cursor_t *ic)
+{
+	tok_free(ic->ic_peek);
+	bzero(ic, sizeof (*ic));
+}
+
+static void
+input_free(input_t *in)
+{
+	if (in == NULL)
+		return;
+
+	umem_free(in->in_buf, in->in_buflen);
+	if (in->in_lines != NULL) {
+		size_t i = 0;
+
+		while (in->in_lines[i] != NULL)
+			i++;
+
+		umem_cfree(in->in_lines, i + 1, sizeof (char *));
+	}
+	umem_free(in, sizeof (*in));
+}
+
+#define	CHUNK_SZ	(8)
+/*
+ * Append a string onto an array of strings.  Since these shouldn't be heavily
+ * called, we're not (currently at least) worried about the possibility
+ * of excessive realloc() calls.
+ */
+static void
+add_str(char ***restrict ppp, size_t *restrict allocp, const char *restrict str)
+{
+	char *newstr = NULL;
+	char **array = *ppp;
+	size_t nelems = 0;
+
+	while (nelems < *allocp && array[nelems] != NULL)
+		nelems++;
+
+	if (nelems + 2 > *allocp) {
+		char **newarray = NULL;
+		size_t newsize = *allocp + CHUNK_SZ;
+		size_t amt = newsize * sizeof (char *);
+
+		VERIFY3U(amt, >, newsize);
+		VERIFY3U(amt, >=, sizeof (char *));
+
+		/* realloc_array() would be nice */
+		newarray = realloc(array, amt);
+		VERIFY3P(newarray, !=, NULL);
+
+		*ppp = array = newarray;
+		*allocp = newsize;
+	}
+
+	newstr = strdup(str);
+	VERIFY3P(newstr, !=, NULL);
+
+	array[nelems++] = newstr;
+	array[nelems] = NULL;
+}
+
+static void
+add_xf(config_rule_t *restrict rule, config_xf_t *restrict xf)
+{
+	if (rule->rule_xf == NULL) {
+		rule->rule_xf = umem_calloc(2, sizeof (config_xf_t *),
+		    UMEM_NOFAIL);
+		rule->rule_xf[0] = xf;
+		return;
+	}
+
+	size_t nxf = 0;
+
+	while (rule->rule_xf[nxf] != NULL)
+		nxf++;
+
+	/* We include space for a trailing NULL entry */
+	rule->rule_xf = umem_reallocarray(rule->rule_xf, nxf + 1, nxf + 2,
+	    sizeof (config_xf_t *), UMEM_NOFAIL);
+	rule->rule_xf[nxf] = xf;
+}
+
+static void
+add_rule(config_t *restrict cfg, config_rule_t *restrict rule)
+{
+	/* TODO: validate label value is unique */
+
+	rule->rule_config = cfg;
+
+	if (cfg->cfg_rules == NULL) {
+		cfg->cfg_rules = umem_calloc(2, sizeof (config_rule_t *),
+		    UMEM_NOFAIL);
+		cfg->cfg_rules[0] = rule;
+		return;
+	}
+
+	size_t nrules = 0;
+
+	while (cfg->cfg_rules[nrules] != NULL)
+		nrules++;
+
+	cfg->cfg_rules = umem_reallocarray(cfg->cfg_rules, nrules + 1,
+	    nrules + 2, sizeof (config_rule_t *), UMEM_NOFAIL);
+
+	cfg->cfg_rules[nrules] = rule;
+}
+
+static void
+add_addr(config_addr_t **restrict addrs, size_t *restrict naddrs,
+    const config_addr_t *restrict src)
+{
+	config_addr_t *newaddrs = NULL;
+	size_t newlen = *naddrs + 1;
+	size_t newamt = newlen * sizeof (config_addr_t);
+
+	VERIFY3U(newamt, >=, sizeof (config_addr_t));
+	VERIFY3U(newamt, >, newlen);
+
+	newaddrs = realloc(*addrs, newamt);
+	VERIFY3P(newaddrs, !=, NULL);
+
+	(void) memcpy(&newaddrs[*naddrs], src, sizeof (*src));
+
+	*addrs = newaddrs;
+	*naddrs += 1;
+}
+
+static void
+add_remid(config_rule_t *restrict rule, config_id_t *restrict id)
+{
+	if (rule->rule_remote_id == NULL) {
+		rule->rule_remote_id = umem_calloc(2, sizeof (config_id_t *),
+		    UMEM_NOFAIL);
+		rule->rule_remote_id[0] = id;
+		return;
+	}
+
+	size_t i = 0;
+
+	while (rule->rule_remote_id[i] != NULL)
+		i++;
+
+	rule->rule_remote_id = umem_reallocarray(rule->rule_remote_id, i + 1,
+	    i + 2, sizeof (config_id_t *), UMEM_NOFAIL);
+
+	rule->rule_remote_id[i] = id;
+}
+
+/* Is the given character a token separator? */
+static boolean_t
+issep(char c, boolean_t minus_is_sep)
+{
+	switch (c) {
+	case '{': case '}':
+	case '(': case ')':
+	case '/':
+		return (B_TRUE);
+	case '-':
+		if (minus_is_sep)
+			return (B_TRUE);
+		break;
+	}
+	return (B_FALSE);
+}
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/defs.h b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/defs.h
new file mode 100644
index 0000000000..faf4c4b3eb
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/defs.h
@@ -0,0 +1,243 @@
+
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the "License").
+ * You may not use this file except in compliance with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ */
+
+/*
+ * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ *
+ * Copyright 2017 Jason King.
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+#ifndef _DEFS_H
+#define	_DEFS_H
+
+#include <bunyan.h>
+#include <cryptoutil.h>
+#include <libintl.h>
+#include <security/cryptoki.h>
+#include <sys/debug.h>
+#include <sys/list.h>
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <ikedoor.h>
+#include <stdio.h>
+#include <umem.h>
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+#ifndef SOCKADDR_U_T
+#define	SOCKADDR_U_T
+typedef union sockaddr_u_s {
+	struct sockaddr		*sau_sa;
+	struct sockaddr_storage *sau_ss;
+	struct sockaddr_in	*sau_sin;
+	struct sockaddr_in6	*sau_sin6;
+} sockaddr_u_t;
+#endif /* SOCKADDR_U_T */
+
+struct ikev2_sa_s;
+
+/* Parsed-out PF_KEY message. */
+typedef struct parsedmsg_s {
+	list_node_t pmsg_node;
+	sadb_msg_t *pmsg_samsg;
+	sadb_ext_t *pmsg_exts[SADB_EXT_MAX + 2]; /* 2 for alignment */
+	sockaddr_u_t pmsg_sau;
+	sockaddr_u_t pmsg_dau;
+	sockaddr_u_t pmsg_isau;
+	sockaddr_u_t pmsg_idau;
+	sockaddr_u_t pmsg_nlau;
+	sockaddr_u_t pmsg_nrau;
+} parsedmsg_t;
+
+#define	pmsg_ssa pmsg_sau.sau_sa
+#define	pmsg_sss pmsg_sau.sau_ss
+#define	pmsg_ssin pmsg_sau.sau_sin
+#define	pmsg_ssin6 pmsg_sau.sau_sin6
+#define	pmsg_dsa pmsg_dau.sau_sa
+#define	pmsg_dss pmsg_dau.sau_ss
+#define	pmsg_dsin pmsg_dau.sau_sin
+#define	pmsg_dsin6 pmsg_dau.sau_sin6
+#define	pmsg_issa pmsg_isau.sau_sa
+#define	pmsg_isss pmsg_isau.sau_ss
+#define	pmsg_issin pmsg_isau.sau_sin
+#define	pmsg_issin6 pmsg_isau.sau_sin6
+#define	pmsg_idsa pmsg_idau.sau_sa
+#define	pmsg_idss pmsg_idau.sau_ss
+#define	pmsg_idsin pmsg_idau.sau_sin
+#define	pmsg_idsin6 pmsg_idau.sau_sin6
+#define	pmsg_nlsa pmsg_nlau.sau_sa
+#define	pmsg_nlss pmsg_nlau.sau_ss
+#define	pmsg_nlsin pmsg_nlau.sau_sin
+#define	pmsg_nlsin6 pmsg_nlau.sau_sin6
+#define	pmsg_nrsa pmsg_nrau.sau_sa
+#define	pmsg_nrss pmsg_nrau.sau_ss
+#define	pmsg_nrsin pmsg_rnau.sau_sin
+#define	pmsg_nrsin6 pmsg_nrau.sau_sin6
+void parsedmsg_free(parsedmsg_t *);
+
+#define	PMSG_FROM_KERNEL(pmsg) ((pmsg)->pmsg_samsg->sadb_msg_pid == 0)
+
+/* XXX: Any better way to determine this? */
+#define	PMSG_IS_TRANSPORT(pmsg) ((pmsg)->pmsg_isss == NULL)
+
+typedef struct algindex {
+	const char *desc;
+	int doi_num;
+} algindex_t;
+
+/*
+ * Compare two AF_INET{,6} sockaddrs (no port).  Assume sockaddr_storage
+ * pointers are passed, and also verifies the address families match and
+ * are either AF_INET or AF_INET6.
+ */
+#define	SA_ADDR_EQ(sa1, sa2)						\
+	(((sa1)->ss_family == (sa2)->ss_family) &&			\
+	    ((((sa1)->ss_family == AF_INET) &&				\
+		((struct sockaddr_in *)(sa1))->sin_addr.s_addr ==	\
+		((struct sockaddr_in *)(sa2))->sin_addr.s_addr) ||	\
+		(((sa1)->ss_family == AF_INET6) &&			\
+		IN6_ARE_ADDR_EQUAL(&((struct sockaddr_in6 *)(sa1))->sin6_addr,\
+		    &((struct sockaddr_in6 *)(sa2))->sin6_addr))))
+
+/*
+ * Compare two AF_INET{,6} sockaddr ports.  Exploit the identical offsets for
+ * sin_port/sin6_port.  (Does not check sockaddr families a priori.)
+ */
+#define	SA_PORT_EQ(sa1, sa2) (((struct sockaddr_in *)(sa1))->sin_port == \
+	    ((struct sockaddr_in *)(sa2))->sin_port)
+
+/*
+ * Compare two AF_INET{,6} sockaddrs (including ports).  Exploit the
+ * identical offsets for sin_port/sin6_port.
+ */
+#define	SA_FULL_EQ(sa1, sa2) (SA_ADDR_EQ(sa1, sa2) && SA_PORT_EQ(sa1, sa2))
+
+#define	SSTOSA(ss) ((struct sockaddr *)(ss))
+
+#define	INVALID(var) assfail("Invalid value of " # var, __FILE__, __LINE__)
+
+#ifndef ARRAY_SIZE
+#define	ARRAY_SIZE(x) (sizeof (x) / sizeof (x[0]))
+#endif
+
+/* A few simple functions to simplify using sockaddr's w/ bunyan */
+int ss_bunyan(const struct sockaddr *);
+uint32_t ss_port(const struct sockaddr *);
+const void *ss_addr(const struct sockaddr *);
+size_t ss_addrlen(const struct sockaddr *);
+uint8_t ss_addrbits(const struct sockaddr *);
+
+#define	LOG_KEY_ERRMSG	"err"
+#define	LOG_KEY_ERRNO	"errno"
+#define	LOG_KEY_FILE	"file"
+#define	LOG_KEY_FUNC	"func"
+#define	LOG_KEY_LINE	"line"
+
+#define	LOG_KEY_I2SA		"i2sa"
+#define	LOG_KEY_LADDR		"local_addr"
+#define	LOG_KEY_RADDR		"remote_addr"
+#define	LOG_KEY_LSPI		"local_spi"
+#define	LOG_KEY_RSPI		"remote_spi"
+#define	LOG_KEY_INITIATOR	"initiator"
+#define	LOG_KEY_LOCAL_ID	"local_id"
+#define	LOG_KEY_LOCAL_ID_TYPE	LOG_KEY_LOCAL_ID "_type"
+#define	LOG_KEY_REMOTE_ID	"remote_id"
+#define	LOG_KEY_REMOTE_ID_TYPE	LOG_KEY_REMOTE_ID "_type"
+
+#define	LOG_KEY_REQ	"req_pkt"
+#define	LOG_KEY_RESP	"resp_pkt"
+#define	LOG_KEY_VERSION	"ike_version"
+#define	LOG_KEY_MSGID	"msgid"
+#define	LOG_KEY_EXCHTYPE "exch_type"
+
+/* cstyle cannot handle ## __VA_ARGS */
+/* BEGIN CSTYLED */
+#define	TSTDERR(_e, _lvl, _msg, ...)			\
+	(void) bunyan_##_lvl(log, (_msg),			\
+	BUNYAN_T_STRING, LOG_KEY_ERRMSG, strerror(_e),		\
+	BUNYAN_T_INT32, LOG_KEY_ERRNO, (int32_t)(_e),		\
+	BUNYAN_T_STRING, LOG_KEY_FUNC, __func__,		\
+	BUNYAN_T_STRING, LOG_KEY_FILE, __FILE__,		\
+	BUNYAN_T_INT32, LOG_KEY_LINE, __LINE__,		\
+	## __VA_ARGS__,						\
+	BUNYAN_T_END)
+
+#define	STDERR(_lvl, _msg, ...) \
+	TSTDERR(errno, _lvl, _msg, ## __VA_ARGS__)
+
+/* END CSTYLED */
+
+typedef enum event {
+	EVENT_NONE,
+	EVENT_SIGNAL
+} event_t;
+
+/* Required for libipsecutils */
+extern char *my_fmri;
+
+extern int main_port;
+extern boolean_t show_keys;
+
+/*
+ * While bunyan itself is multithreaded, since every thread runs some sort
+ * of event loop, by guaranteeing every thread it's own instance, we can
+ * build up keys as the event goes through processing, and then reset the keys
+ * before we loop around again.
+ */
+extern __thread bunyan_logger_t *log;
+extern bunyan_logger_t *main_log;
+
+typedef int (*bunyan_logfn_t)(bunyan_logger_t *, const char *, ...);
+bunyan_logfn_t getlog(bunyan_level_t);
+
+const char *enum_printf(const char *, ...);
+
+const char *afstr(sa_family_t);
+const char *event_str(event_t);
+const char *port_source_str(ushort_t);
+const char *symstr(void *, char *, size_t);
+
+void log_reset_keys(void);
+void key_add_ike_version(const char *, uint8_t);
+void key_add_ike_spi(const char *, uint64_t);
+void key_add_addr(const char *, const struct sockaddr *);
+struct config_id_s;
+void key_add_id(const char *, const char *, struct config_id_s *);
+char *writehex(uint8_t *, size_t, char *, char *, size_t);
+
+void sockaddr_copy(const struct sockaddr *, struct sockaddr_storage *,
+    boolean_t);
+int sockaddr_cmp(const struct sockaddr *, const struct sockaddr *);
+boolean_t addr_is_zero(const struct sockaddr *);
+
+char *ustrdup(const char *, int);
+void ustrfree(char *);
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif  /* _DEFS_H */
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/dh.c b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/dh.c
new file mode 100644
index 0000000000..a1e0f9aa68
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/dh.c
@@ -0,0 +1,425 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2017 Jason King.
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+#include <sys/types.h>
+#include <security/cryptoki.h>
+#include <bunyan.h>
+#include "dh.h"
+#include "ikev2_enum.h"
+#include "pkcs11.h"
+
+typedef struct {
+	ikev2_dh_t	id;
+	size_t		bits;
+	size_t		genbits;
+	uint8_t		*prime;
+	uint8_t		*generator;
+} dhgroup_t;
+
+
+static dhgroup_t dh_groups[] = {
+	{
+		.id = IKEV2_DH_MODP_768,
+		.bits = 768,
+		.genbits = 8,
+		.generator = (uint8_t *)"\x02",
+		.prime = (uint8_t *)"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xC9\x0F"
+		    "\xDA\xA2\x21\x68\xC2\x34\xC4\xC6\x62\x8B\x80\xDC\x1C\xD1"
+		    "\x29\x02\x4E\x08\x8A\x67\xCC\x74\x02\x0B\xBE\xA6\x3B\x13"
+		    "\x9B\x22\x51\x4A\x08\x79\x8E\x34\x04\xDD\xEF\x95\x19\xB3"
+		    "\xCD\x3A\x43\x1B\x30\x2B\x0A\x6D\xF2\x5F\x14\x37\x4F\xE1"
+		    "\x35\x6D\x6D\x51\xC2\x45"
+	},
+	{
+		.id = IKEV2_DH_MODP_1024,
+		.bits = 1024,
+		.genbits = 8,
+		.generator = (uint8_t *)"\x02",
+		.prime = (uint8_t *)"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xC9\x0F"
+		    "\xDA\xA2\x21\x68\xC2\x34\xC4\xC6\x62\x8B\x80\xDC\x1C\xD1"
+		    "\x29\x02\x4E\x08\x8A\x67\xCC\x74\x02\x0B\xBE\xA6\x3B\x13"
+		    "\x9B\x22\x51\x4A\x08\x79\x8E\x34\x04\xDD\xEF\x95\x19\xB3"
+		    "\xCD\x3A\x43\x1B\x30\x2B\x0A\x6D\xF2\x5F\x14\x37\x4F\xE1"
+		    "\x35\x6D\x6D\x51\xC2\x45\xE4\x85\xB5\x76\x62\x5E\x7E\xC6"
+		    "\xF4\x4C\x42\xE9\xA6\x37\xED\x6B\x0B\xFF\x5C\xB6\xF4\x06"
+		    "\xB7\xED\xEE\x38\x6B\xFB\x5A\x89\x9F\xA5\xAE\x9F\x24\x11"
+		    "\x7C\x4B\x1F\xE6\x49\x28\x66\x51\xEC\xE6\x53\x81\xFF\xFF"
+		    "\xFF\xFF\xFF\xFF\xFF\xFF"
+	},
+	{
+		.id = IKEV2_DH_MODP_1536,
+		.bits = 1536,
+		.genbits = 8,
+		.generator = (uint8_t *)"\x02",
+		.prime = (uint8_t *)"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xC9\x0F"
+		    "\xDA\xA2\x21\x68\xC2\x34\xC4\xC6\x62\x8B\x80\xDC\x1C\xD1"
+		    "\x29\x02\x4E\x08\x8A\x67\xCC\x74\x02\x0B\xBE\xA6\x3B\x13"
+		    "\x9B\x22\x51\x4A\x08\x79\x8E\x34\x04\xDD\xEF\x95\x19\xB3"
+		    "\xCD\x3A\x43\x1B\x30\x2B\x0A\x6D\xF2\x5F\x14\x37\x4F\xE1"
+		    "\x35\x6D\x6D\x51\xC2\x45\xE4\x85\xB5\x76\x62\x5E\x7E\xC6"
+		    "\xF4\x4C\x42\xE9\xA6\x37\xED\x6B\x0B\xFF\x5C\xB6\xF4\x06"
+		    "\xB7\xED\xEE\x38\x6B\xFB\x5A\x89\x9F\xA5\xAE\x9F\x24\x11"
+		    "\x7C\x4B\x1F\xE6\x49\x28\x66\x51\xEC\xE4\x5B\x3D\xC2\x00"
+		    "\x7C\xB8\xA1\x63\xBF\x05\x98\xDA\x48\x36\x1C\x55\xD3\x9A"
+		    "\x69\x16\x3F\xA8\xFD\x24\xCF\x5F\x83\x65\x5D\x23\xDC\xA3"
+		    "\xAD\x96\x1C\x62\xF3\x56\x20\x85\x52\xBB\x9E\xD5\x29\x07"
+		    "\x70\x96\x96\x6D\x67\x0C\x35\x4E\x4A\xBC\x98\x04\xF1\x74"
+		    "\x6C\x08\xCA\x23\x73\x27\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
+	},
+	{
+		.id = IKEV2_DH_MODP_2048,
+		.bits = 2048,
+		.genbits = 8,
+		.generator = (uint8_t *)"\x02",
+		.prime = (uint8_t *)"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xC9\x0F"
+		    "\xDA\xA2\x21\x68\xC2\x34\xC4\xC6\x62\x8B\x80\xDC\x1C\xD1"
+		    "\x29\x02\x4E\x08\x8A\x67\xCC\x74\x02\x0B\xBE\xA6\x3B\x13"
+		    "\x9B\x22\x51\x4A\x08\x79\x8E\x34\x04\xDD\xEF\x95\x19\xB3"
+		    "\xCD\x3A\x43\x1B\x30\x2B\x0A\x6D\xF2\x5F\x14\x37\x4F\xE1"
+		    "\x35\x6D\x6D\x51\xC2\x45\xE4\x85\xB5\x76\x62\x5E\x7E\xC6"
+		    "\xF4\x4C\x42\xE9\xA6\x37\xED\x6B\x0B\xFF\x5C\xB6\xF4\x06"
+		    "\xB7\xED\xEE\x38\x6B\xFB\x5A\x89\x9F\xA5\xAE\x9F\x24\x11"
+		    "\x7C\x4B\x1F\xE6\x49\x28\x66\x51\xEC\xE4\x5B\x3D\xC2\x00"
+		    "\x7C\xB8\xA1\x63\xBF\x05\x98\xDA\x48\x36\x1C\x55\xD3\x9A"
+		    "\x69\x16\x3F\xA8\xFD\x24\xCF\x5F\x83\x65\x5D\x23\xDC\xA3"
+		    "\xAD\x96\x1C\x62\xF3\x56\x20\x85\x52\xBB\x9E\xD5\x29\x07"
+		    "\x70\x96\x96\x6D\x67\x0C\x35\x4E\x4A\xBC\x98\x04\xF1\x74"
+		    "\x6C\x08\xCA\x18\x21\x7C\x32\x90\x5E\x46\x2E\x36\xCE\x3B"
+		    "\xE3\x9E\x77\x2C\x18\x0E\x86\x03\x9B\x27\x83\xA2\xEC\x07"
+		    "\xA2\x8F\xB5\xC5\x5D\xF0\x6F\x4C\x52\xC9\xDE\x2B\xCB\xF6"
+		    "\x95\x58\x17\x18\x39\x95\x49\x7C\xEA\x95\x6A\xE5\x15\xD2"
+		    "\x26\x18\x98\xFA\x05\x10\x15\x72\x8E\x5A\x8A\xAC\xAA\x68"
+		    "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
+	},
+	{
+		.id = IKEV2_DH_MODP_3072,
+		.bits = 3072,
+		.genbits = 8,
+		.generator = (uint8_t *)"\x02",
+		.prime = (uint8_t *)"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xC9\x0F"
+		    "\xDA\xA2\x21\x68\xC2\x34\xC4\xC6\x62\x8B\x80\xDC\x1C\xD1"
+		    "\x29\x02\x4E\x08\x8A\x67\xCC\x74\x02\x0B\xBE\xA6\x3B\x13"
+		    "\x9B\x22\x51\x4A\x08\x79\x8E\x34\x04\xDD\xEF\x95\x19\xB3"
+		    "\xCD\x3A\x43\x1B\x30\x2B\x0A\x6D\xF2\x5F\x14\x37\x4F\xE1"
+		    "\x35\x6D\x6D\x51\xC2\x45\xE4\x85\xB5\x76\x62\x5E\x7E\xC6"
+		    "\xF4\x4C\x42\xE9\xA6\x37\xED\x6B\x0B\xFF\x5C\xB6\xF4\x06"
+		    "\xB7\xED\xEE\x38\x6B\xFB\x5A\x89\x9F\xA5\xAE\x9F\x24\x11"
+		    "\x7C\x4B\x1F\xE6\x49\x28\x66\x51\xEC\xE4\x5B\x3D\xC2\x00"
+		    "\x7C\xB8\xA1\x63\xBF\x05\x98\xDA\x48\x36\x1C\x55\xD3\x9A"
+		    "\x69\x16\x3F\xA8\xFD\x24\xCF\x5F\x83\x65\x5D\x23\xDC\xA3"
+		    "\xAD\x96\x1C\x62\xF3\x56\x20\x85\x52\xBB\x9E\xD5\x29\x07"
+		    "\x70\x96\x96\x6D\x67\x0C\x35\x4E\x4A\xBC\x98\x04\xF1\x74"
+		    "\x6C\x08\xCA\x18\x21\x7C\x32\x90\x5E\x46\x2E\x36\xCE\x3B"
+		    "\xE3\x9E\x77\x2C\x18\x0E\x86\x03\x9B\x27\x83\xA2\xEC\x07"
+		    "\xA2\x8F\xB5\xC5\x5D\xF0\x6F\x4C\x52\xC9\xDE\x2B\xCB\xF6"
+		    "\x95\x58\x17\x18\x39\x95\x49\x7C\xEA\x95\x6A\xE5\x15\xD2"
+		    "\x26\x18\x98\xFA\x05\x10\x15\x72\x8E\x5A\x8A\xAA\xC4\x2D"
+		    "\xAD\x33\x17\x0D\x04\x50\x7A\x33\xA8\x55\x21\xAB\xDF\x1C"
+		    "\xBA\x64\xEC\xFB\x85\x04\x58\xDB\xEF\x0A\x8A\xEA\x71\x57"
+		    "\x5D\x06\x0C\x7D\xB3\x97\x0F\x85\xA6\xE1\xE4\xC7\xAB\xF5"
+		    "\xAE\x8C\xDB\x09\x33\xD7\x1E\x8C\x94\xE0\x4A\x25\x61\x9D"
+		    "\xCE\xE3\xD2\x26\x1A\xD2\xEE\x6B\xF1\x2F\xFA\x06\xD9\x8A"
+		    "\x08\x64\xD8\x76\x02\x73\x3E\xC8\x6A\x64\x52\x1F\x2B\x18"
+		    "\x17\x7B\x20\x0C\xBB\xE1\x17\x57\x7A\x61\x5D\x6C\x77\x09"
+		    "\x88\xC0\xBA\xD9\x46\xE2\x08\xE2\x4F\xA0\x74\xE5\xAB\x31"
+		    "\x43\xDB\x5B\xFC\xE0\xFD\x10\x8E\x4B\x82\xD1\x20\xA9\x3A"
+		    "\xD2\xCA\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
+	},
+	{
+		.id = IKEV2_DH_MODP_4096,
+		.bits = 4096,
+		.genbits = 8,
+		.generator = (uint8_t *)"\x02",
+		.prime = (uint8_t *)"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xC9\x0F"
+		    "\xDA\xA2\x21\x68\xC2\x34\xC4\xC6\x62\x8B\x80\xDC\x1C\xD1"
+		    "\x29\x02\x4E\x08\x8A\x67\xCC\x74\x02\x0B\xBE\xA6\x3B\x13"
+		    "\x9B\x22\x51\x4A\x08\x79\x8E\x34\x04\xDD\xEF\x95\x19\xB3"
+		    "\xCD\x3A\x43\x1B\x30\x2B\x0A\x6D\xF2\x5F\x14\x37\x4F\xE1"
+		    "\x35\x6D\x6D\x51\xC2\x45\xE4\x85\xB5\x76\x62\x5E\x7E\xC6"
+		    "\xF4\x4C\x42\xE9\xA6\x37\xED\x6B\x0B\xFF\x5C\xB6\xF4\x06"
+		    "\xB7\xED\xEE\x38\x6B\xFB\x5A\x89\x9F\xA5\xAE\x9F\x24\x11"
+		    "\x7C\x4B\x1F\xE6\x49\x28\x66\x51\xEC\xE4\x5B\x3D\xC2\x00"
+		    "\x7C\xB8\xA1\x63\xBF\x05\x98\xDA\x48\x36\x1C\x55\xD3\x9A"
+		    "\x69\x16\x3F\xA8\xFD\x24\xCF\x5F\x83\x65\x5D\x23\xDC\xA3"
+		    "\xAD\x96\x1C\x62\xF3\x56\x20\x85\x52\xBB\x9E\xD5\x29\x07"
+		    "\x70\x96\x96\x6D\x67\x0C\x35\x4E\x4A\xBC\x98\x04\xF1\x74"
+		    "\x6C\x08\xCA\x18\x21\x7C\x32\x90\x5E\x46\x2E\x36\xCE\x3B"
+		    "\xE3\x9E\x77\x2C\x18\x0E\x86\x03\x9B\x27\x83\xA2\xEC\x07"
+		    "\xA2\x8F\xB5\xC5\x5D\xF0\x6F\x4C\x52\xC9\xDE\x2B\xCB\xF6"
+		    "\x95\x58\x17\x18\x39\x95\x49\x7C\xEA\x95\x6A\xE5\x15\xD2"
+		    "\x26\x18\x98\xFA\x05\x10\x15\x72\x8E\x5A\x8A\xAA\xC4\x2D"
+		    "\xAD\x33\x17\x0D\x04\x50\x7A\x33\xA8\x55\x21\xAB\xDF\x1C"
+		    "\xBA\x64\xEC\xFB\x85\x04\x58\xDB\xEF\x0A\x8A\xEA\x71\x57"
+		    "\x5D\x06\x0C\x7D\xB3\x97\x0F\x85\xA6\xE1\xE4\xC7\xAB\xF5"
+		    "\xAE\x8C\xDB\x09\x33\xD7\x1E\x8C\x94\xE0\x4A\x25\x61\x9D"
+		    "\xCE\xE3\xD2\x26\x1A\xD2\xEE\x6B\xF1\x2F\xFA\x06\xD9\x8A"
+		    "\x08\x64\xD8\x76\x02\x73\x3E\xC8\x6A\x64\x52\x1F\x2B\x18"
+		    "\x17\x7B\x20\x0C\xBB\xE1\x17\x57\x7A\x61\x5D\x6C\x77\x09"
+		    "\x88\xC0\xBA\xD9\x46\xE2\x08\xE2\x4F\xA0\x74\xE5\xAB\x31"
+		    "\x43\xDB\x5B\xFC\xE0\xFD\x10\x8E\x4B\x82\xD1\x20\xA9\x21"
+		    "\x08\x01\x1A\x72\x3C\x12\xA7\x87\xE6\xD7\x88\x71\x9A\x10"
+		    "\xBD\xBA\x5B\x26\x99\xC3\x27\x18\x6A\xF4\xE2\x3C\x1A\x94"
+		    "\x68\x34\xB6\x15\x0B\xDA\x25\x83\xE9\xCA\x2A\xD4\x4C\xE8"
+		    "\xDB\xBB\xC2\xDB\x04\xDE\x8E\xF9\x2E\x8E\xFC\x14\x1F\xBE"
+		    "\xCA\xA6\x28\x7C\x59\x47\x4E\x6B\xC0\x5D\x99\xB2\x96\x4F"
+		    "\xA0\x90\xC3\xA2\x23\x3B\xA1\x86\x51\x5B\xE7\xED\x1F\x61"
+		    "\x29\x70\xCE\xE2\xD7\xAF\xB8\x1B\xDD\x76\x21\x70\x48\x1C"
+		    "\xD0\x06\x91\x27\xD5\xB0\x5A\xA9\x93\xB4\xEA\x98\x8D\x8F"
+		    "\xDD\xC1\x86\xFF\xB7\xDC\x90\xA6\xC0\x8F\x4D\xF4\x35\xC9"
+		    "\x34\x06\x31\x99\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
+	},
+	{
+		.id = IKEV2_DH_MODP_6144,
+		.bits = 6144,
+		.genbits = 8,
+		.generator = (uint8_t *)"\x02",
+		.prime = (uint8_t *)"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xC9\x0F"
+		    "\xDA\xA2\x21\x68\xC2\x34\xC4\xC6\x62\x8B\x80\xDC\x1C\xD1"
+		    "\x29\x02\x4E\x08\x8A\x67\xCC\x74\x02\x0B\xBE\xA6\x3B\x13"
+		    "\x9B\x22\x51\x4A\x08\x79\x8E\x34\x04\xDD\xEF\x95\x19\xB3"
+		    "\xCD\x3A\x43\x1B\x30\x2B\x0A\x6D\xF2\x5F\x14\x37\x4F\xE1"
+		    "\x35\x6D\x6D\x51\xC2\x45\xE4\x85\xB5\x76\x62\x5E\x7E\xC6"
+		    "\xF4\x4C\x42\xE9\xA6\x37\xED\x6B\x0B\xFF\x5C\xB6\xF4\x06"
+		    "\xB7\xED\xEE\x38\x6B\xFB\x5A\x89\x9F\xA5\xAE\x9F\x24\x11"
+		    "\x7C\x4B\x1F\xE6\x49\x28\x66\x51\xEC\xE4\x5B\x3D\xC2\x00"
+		    "\x7C\xB8\xA1\x63\xBF\x05\x98\xDA\x48\x36\x1C\x55\xD3\x9A"
+		    "\x69\x16\x3F\xA8\xFD\x24\xCF\x5F\x83\x65\x5D\x23\xDC\xA3"
+		    "\xAD\x96\x1C\x62\xF3\x56\x20\x85\x52\xBB\x9E\xD5\x29\x07"
+		    "\x70\x96\x96\x6D\x67\x0C\x35\x4E\x4A\xBC\x98\x04\xF1\x74"
+		    "\x6C\x08\xCA\x18\x21\x7C\x32\x90\x5E\x46\x2E\x36\xCE\x3B"
+		    "\xE3\x9E\x77\x2C\x18\x0E\x86\x03\x9B\x27\x83\xA2\xEC\x07"
+		    "\xA2\x8F\xB5\xC5\x5D\xF0\x6F\x4C\x52\xC9\xDE\x2B\xCB\xF6"
+		    "\x95\x58\x17\x18\x39\x95\x49\x7C\xEA\x95\x6A\xE5\x15\xD2"
+		    "\x26\x18\x98\xFA\x05\x10\x15\x72\x8E\x5A\x8A\xAA\xC4\x2D"
+		    "\xAD\x33\x17\x0D\x04\x50\x7A\x33\xA8\x55\x21\xAB\xDF\x1C"
+		    "\xBA\x64\xEC\xFB\x85\x04\x58\xDB\xEF\x0A\x8A\xEA\x71\x57"
+		    "\x5D\x06\x0C\x7D\xB3\x97\x0F\x85\xA6\xE1\xE4\xC7\xAB\xF5"
+		    "\xAE\x8C\xDB\x09\x33\xD7\x1E\x8C\x94\xE0\x4A\x25\x61\x9D"
+		    "\xCE\xE3\xD2\x26\x1A\xD2\xEE\x6B\xF1\x2F\xFA\x06\xD9\x8A"
+		    "\x08\x64\xD8\x76\x02\x73\x3E\xC8\x6A\x64\x52\x1F\x2B\x18"
+		    "\x17\x7B\x20\x0C\xBB\xE1\x17\x57\x7A\x61\x5D\x6C\x77\x09"
+		    "\x88\xC0\xBA\xD9\x46\xE2\x08\xE2\x4F\xA0\x74\xE5\xAB\x31"
+		    "\x43\xDB\x5B\xFC\xE0\xFD\x10\x8E\x4B\x82\xD1\x20\xA9\x21"
+		    "\x08\x01\x1A\x72\x3C\x12\xA7\x87\xE6\xD7\x88\x71\x9A\x10"
+		    "\xBD\xBA\x5B\x26\x99\xC3\x27\x18\x6A\xF4\xE2\x3C\x1A\x94"
+		    "\x68\x34\xB6\x15\x0B\xDA\x25\x83\xE9\xCA\x2A\xD4\x4C\xE8"
+		    "\xDB\xBB\xC2\xDB\x04\xDE\x8E\xF9\x2E\x8E\xFC\x14\x1F\xBE"
+		    "\xCA\xA6\x28\x7C\x59\x47\x4E\x6B\xC0\x5D\x99\xB2\x96\x4F"
+		    "\xA0\x90\xC3\xA2\x23\x3B\xA1\x86\x51\x5B\xE7\xED\x1F\x61"
+		    "\x29\x70\xCE\xE2\xD7\xAF\xB8\x1B\xDD\x76\x21\x70\x48\x1C"
+		    "\xD0\x06\x91\x27\xD5\xB0\x5A\xA9\x93\xB4\xEA\x98\x8D\x8F"
+		    "\xDD\xC1\x86\xFF\xB7\xDC\x90\xA6\xC0\x8F\x4D\xF4\x35\xC9"
+		    "\x34\x02\x84\x92\x36\xC3\xFA\xB4\xD2\x7C\x70\x26\xC1\xD4"
+		    "\xDC\xB2\x60\x26\x46\xDE\xC9\x75\x1E\x76\x3D\xBA\x37\xBD"
+		    "\xF8\xFF\x94\x06\xAD\x9E\x53\x0E\xE5\xDB\x38\x2F\x41\x30"
+		    "\x01\xAE\xB0\x6A\x53\xED\x90\x27\xD8\x31\x17\x97\x27\xB0"
+		    "\x86\x5A\x89\x18\xDA\x3E\xDB\xEB\xCF\x9B\x14\xED\x44\xCE"
+		    "\x6C\xBA\xCE\xD4\xBB\x1B\xDB\x7F\x14\x47\xE6\xCC\x25\x4B"
+		    "\x33\x20\x51\x51\x2B\xD7\xAF\x42\x6F\xB8\xF4\x01\x37\x8C"
+		    "\xD2\xBF\x59\x83\xCA\x01\xC6\x4B\x92\xEC\xF0\x32\xEA\x15"
+		    "\xD1\x72\x1D\x03\xF4\x82\xD7\xCE\x6E\x74\xFE\xF6\xD5\x5E"
+		    "\x70\x2F\x46\x98\x0C\x82\xB5\xA8\x40\x31\x90\x0B\x1C\x9E"
+		    "\x59\xE7\xC9\x7F\xBE\xC7\xE8\xF3\x23\xA9\x7A\x7E\x36\xCC"
+		    "\x88\xBE\x0F\x1D\x45\xB7\xFF\x58\x5A\xC5\x4B\xD4\x07\xB2"
+		    "\x2B\x41\x54\xAA\xCC\x8F\x6D\x7E\xBF\x48\xE1\xD8\x14\xCC"
+		    "\x5E\xD2\x0F\x80\x37\xE0\xA7\x97\x15\xEE\xF2\x9B\xE3\x28"
+		    "\x06\xA1\xD5\x8B\xB7\xC5\xDA\x76\xF5\x50\xAA\x3D\x8A\x1F"
+		    "\xBF\xF0\xEB\x19\xCC\xB1\xA3\x13\xD5\x5C\xDA\x56\xC9\xEC"
+		    "\x2E\xF2\x96\x32\x38\x7F\xE8\xD7\x6E\x3C\x04\x68\x04\x3E"
+		    "\x8F\x66\x3F\x48\x60\xEE\x12\xBF\x2D\x5B\x0B\x74\x74\xD6"
+		    "\xE6\x94\xF9\x1E\x6D\xCC\x40\x24\xFF\xFF\xFF\xFF\xFF\xFF"
+		    "\xFF\xFF"
+	},
+	{
+		.id = IKEV2_DH_MODP_8192,
+		.bits = 8192,
+		.genbits = 8,
+		.generator = (uint8_t *)"\x02",
+		.prime = (uint8_t *)"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xC9\x0F"
+		    "\xDA\xA2\x21\x68\xC2\x34\xC4\xC6\x62\x8B\x80\xDC\x1C\xD1"
+		    "\x29\x02\x4E\x08\x8A\x67\xCC\x74\x02\x0B\xBE\xA6\x3B\x13"
+		    "\x9B\x22\x51\x4A\x08\x79\x8E\x34\x04\xDD\xEF\x95\x19\xB3"
+		    "\xCD\x3A\x43\x1B\x30\x2B\x0A\x6D\xF2\x5F\x14\x37\x4F\xE1"
+		    "\x35\x6D\x6D\x51\xC2\x45\xE4\x85\xB5\x76\x62\x5E\x7E\xC6"
+		    "\xF4\x4C\x42\xE9\xA6\x37\xED\x6B\x0B\xFF\x5C\xB6\xF4\x06"
+		    "\xB7\xED\xEE\x38\x6B\xFB\x5A\x89\x9F\xA5\xAE\x9F\x24\x11"
+		    "\x7C\x4B\x1F\xE6\x49\x28\x66\x51\xEC\xE4\x5B\x3D\xC2\x00"
+		    "\x7C\xB8\xA1\x63\xBF\x05\x98\xDA\x48\x36\x1C\x55\xD3\x9A"
+		    "\x69\x16\x3F\xA8\xFD\x24\xCF\x5F\x83\x65\x5D\x23\xDC\xA3"
+		    "\xAD\x96\x1C\x62\xF3\x56\x20\x85\x52\xBB\x9E\xD5\x29\x07"
+		    "\x70\x96\x96\x6D\x67\x0C\x35\x4E\x4A\xBC\x98\x04\xF1\x74"
+		    "\x6C\x08\xCA\x18\x21\x7C\x32\x90\x5E\x46\x2E\x36\xCE\x3B"
+		    "\xE3\x9E\x77\x2C\x18\x0E\x86\x03\x9B\x27\x83\xA2\xEC\x07"
+		    "\xA2\x8F\xB5\xC5\x5D\xF0\x6F\x4C\x52\xC9\xDE\x2B\xCB\xF6"
+		    "\x95\x58\x17\x18\x39\x95\x49\x7C\xEA\x95\x6A\xE5\x15\xD2"
+		    "\x26\x18\x98\xFA\x05\x10\x15\x72\x8E\x5A\x8A\xAA\xC4\x2D"
+		    "\xAD\x33\x17\x0D\x04\x50\x7A\x33\xA8\x55\x21\xAB\xDF\x1C"
+		    "\xBA\x64\xEC\xFB\x85\x04\x58\xDB\xEF\x0A\x8A\xEA\x71\x57"
+		    "\x5D\x06\x0C\x7D\xB3\x97\x0F\x85\xA6\xE1\xE4\xC7\xAB\xF5"
+		    "\xAE\x8C\xDB\x09\x33\xD7\x1E\x8C\x94\xE0\x4A\x25\x61\x9D"
+		    "\xCE\xE3\xD2\x26\x1A\xD2\xEE\x6B\xF1\x2F\xFA\x06\xD9\x8A"
+		    "\x08\x64\xD8\x76\x02\x73\x3E\xC8\x6A\x64\x52\x1F\x2B\x18"
+		    "\x17\x7B\x20\x0C\xBB\xE1\x17\x57\x7A\x61\x5D\x6C\x77\x09"
+		    "\x88\xC0\xBA\xD9\x46\xE2\x08\xE2\x4F\xA0\x74\xE5\xAB\x31"
+		    "\x43\xDB\x5B\xFC\xE0\xFD\x10\x8E\x4B\x82\xD1\x20\xA9\x21"
+		    "\x08\x01\x1A\x72\x3C\x12\xA7\x87\xE6\xD7\x88\x71\x9A\x10"
+		    "\xBD\xBA\x5B\x26\x99\xC3\x27\x18\x6A\xF4\xE2\x3C\x1A\x94"
+		    "\x68\x34\xB6\x15\x0B\xDA\x25\x83\xE9\xCA\x2A\xD4\x4C\xE8"
+		    "\xDB\xBB\xC2\xDB\x04\xDE\x8E\xF9\x2E\x8E\xFC\x14\x1F\xBE"
+		    "\xCA\xA6\x28\x7C\x59\x47\x4E\x6B\xC0\x5D\x99\xB2\x96\x4F"
+		    "\xA0\x90\xC3\xA2\x23\x3B\xA1\x86\x51\x5B\xE7\xED\x1F\x61"
+		    "\x29\x70\xCE\xE2\xD7\xAF\xB8\x1B\xDD\x76\x21\x70\x48\x1C"
+		    "\xD0\x06\x91\x27\xD5\xB0\x5A\xA9\x93\xB4\xEA\x98\x8D\x8F"
+		    "\xDD\xC1\x86\xFF\xB7\xDC\x90\xA6\xC0\x8F\x4D\xF4\x35\xC9"
+		    "\x34\x02\x84\x92\x36\xC3\xFA\xB4\xD2\x7C\x70\x26\xC1\xD4"
+		    "\xDC\xB2\x60\x26\x46\xDE\xC9\x75\x1E\x76\x3D\xBA\x37\xBD"
+		    "\xF8\xFF\x94\x06\xAD\x9E\x53\x0E\xE5\xDB\x38\x2F\x41\x30"
+		    "\x01\xAE\xB0\x6A\x53\xED\x90\x27\xD8\x31\x17\x97\x27\xB0"
+		    "\x86\x5A\x89\x18\xDA\x3E\xDB\xEB\xCF\x9B\x14\xED\x44\xCE"
+		    "\x6C\xBA\xCE\xD4\xBB\x1B\xDB\x7F\x14\x47\xE6\xCC\x25\x4B"
+		    "\x33\x20\x51\x51\x2B\xD7\xAF\x42\x6F\xB8\xF4\x01\x37\x8C"
+		    "\xD2\xBF\x59\x83\xCA\x01\xC6\x4B\x92\xEC\xF0\x32\xEA\x15"
+		    "\xD1\x72\x1D\x03\xF4\x82\xD7\xCE\x6E\x74\xFE\xF6\xD5\x5E"
+		    "\x70\x2F\x46\x98\x0C\x82\xB5\xA8\x40\x31\x90\x0B\x1C\x9E"
+		    "\x59\xE7\xC9\x7F\xBE\xC7\xE8\xF3\x23\xA9\x7A\x7E\x36\xCC"
+		    "\x88\xBE\x0F\x1D\x45\xB7\xFF\x58\x5A\xC5\x4B\xD4\x07\xB2"
+		    "\x2B\x41\x54\xAA\xCC\x8F\x6D\x7E\xBF\x48\xE1\xD8\x14\xCC"
+		    "\x5E\xD2\x0F\x80\x37\xE0\xA7\x97\x15\xEE\xF2\x9B\xE3\x28"
+		    "\x06\xA1\xD5\x8B\xB7\xC5\xDA\x76\xF5\x50\xAA\x3D\x8A\x1F"
+		    "\xBF\xF0\xEB\x19\xCC\xB1\xA3\x13\xD5\x5C\xDA\x56\xC9\xEC"
+		    "\x2E\xF2\x96\x32\x38\x7F\xE8\xD7\x6E\x3C\x04\x68\x04\x3E"
+		    "\x8F\x66\x3F\x48\x60\xEE\x12\xBF\x2D\x5B\x0B\x74\x74\xD6"
+		    "\xE6\x94\xF9\x1E\x6D\xBE\x11\x59\x74\xA3\x92\x6F\x12\xFE"
+		    "\xE5\xE4\x38\x77\x7C\xB6\xA9\x32\xDF\x8C\xD8\xBE\xC4\xD0"
+		    "\x73\xB9\x31\xBA\x3B\xC8\x32\xB6\x8D\x9D\xD3\x00\x74\x1F"
+		    "\xA7\xBF\x8A\xFC\x47\xED\x25\x76\xF6\x93\x6B\xA4\x24\x66"
+		    "\x3A\xAB\x63\x9C\x5A\xE4\xF5\x68\x34\x23\xB4\x74\x2B\xF1"
+		    "\xC9\x78\x23\x8F\x16\xCB\xE3\x9D\x65\x2D\xE3\xFD\xB8\xBE"
+		    "\xFC\x84\x8A\xD9\x22\x22\x2E\x04\xA4\x03\x7C\x07\x13\xEB"
+		    "\x57\xA8\x1A\x23\xF0\xC7\x34\x73\xFC\x64\x6C\xEA\x30\x6B"
+		    "\x4B\xCB\xC8\x86\x2F\x83\x85\xDD\xFA\x9D\x4B\x7F\xA2\xC0"
+		    "\x87\xE8\x79\x68\x33\x03\xED\x5B\xDD\x3A\x06\x2B\x3C\xF5"
+		    "\xB3\xA2\x78\xA6\x6D\x2A\x13\xF8\x3F\x44\xF8\x2D\xDF\x31"
+		    "\x0E\xE0\x74\xAB\x6A\x36\x45\x97\xE8\x99\xA0\x25\x5D\xC1"
+		    "\x64\xF3\x1C\xC5\x08\x46\x85\x1D\xF9\xAB\x48\x19\x5D\xED"
+		    "\x7E\xA1\xB1\xD5\x10\xBD\x7E\xE7\x4D\x73\xFA\xF3\x6B\xC3"
+		    "\x1E\xCF\xA2\x68\x35\x90\x46\xF4\xEB\x87\x9F\x92\x40\x09"
+		    "\x43\x8B\x48\x1C\x6C\xD7\x88\x9A\x00\x2E\xD5\xEE\x38\x2B"
+		    "\xC9\x19\x0D\xA6\xFC\x02\x6E\x47\x95\x58\xE4\x47\x56\x77"
+		    "\xE9\xAA\x9E\x30\x50\xE2\x76\x56\x94\xDF\xC8\x1F\x56\xE8"
+		    "\x80\xB9\x6E\x71\x60\xC9\x80\xDD\x98\xED\xD3\xDF\xFF\xFF"
+		    "\xFF\xFF\xFF\xFF\xFF\xFF"
+	}
+};
+#define	NUM_DHGROUPS	(ARRAY_SIZE(dh_groups))
+
+static dhgroup_t *
+dh_get_group(ikev2_dh_t id)
+{
+	int i;
+
+	for (i = 0; i < NUM_DHGROUPS; i++) {
+		if (dh_groups[i].id == id)
+			return (&dh_groups[i]);
+	}
+
+	return (NULL);
+}
+
+boolean_t
+dh_genpair(ikev2_dh_t group, CK_OBJECT_HANDLE_PTR restrict pub,
+    CK_OBJECT_HANDLE_PTR restrict priv)
+{
+	dhgroup_t *dh;
+	CK_MECHANISM mech = { CKM_DH_PKCS_KEY_PAIR_GEN, NULL_PTR, 0 };
+	CK_BBOOL trueval = CK_TRUE;
+	CK_ATTRIBUTE pub_template[2];
+	CK_ATTRIBUTE priv_template[1] = {
+	    CKA_DERIVE, &trueval, sizeof (trueval)
+	};
+	CK_RV rc;
+
+	if (group == IKEV2_DH_NONE) {
+		(void) bunyan_debug(log,
+		    "Skipping creation of DH pair due to no DH group specified",
+		    BUNYAN_T_END);
+		return (B_TRUE);
+	}
+
+	if (*pub != CK_INVALID_HANDLE && *priv != CK_INVALID_HANDLE) {
+		(void) bunyan_debug(log,
+		    "Skipping creation of DH pair due to pair already created",
+		    BUNYAN_T_END);
+		return (B_TRUE);
+	}
+
+	dh = dh_get_group(group);
+	if (dh == NULL) {
+		(void) bunyan_error(log, "Invalid DH group",
+		    BUNYAN_T_STRING, "dhgrp", ikev2_dh_str(group),
+		    BUNYAN_T_INT32, "val", (int32_t)group,
+		    BUNYAN_T_END);
+		return (B_FALSE);
+	}
+
+	pub_template[0].type = CKA_PRIME;
+	pub_template[0].pValue = dh->prime;
+	pub_template[0].ulValueLen = dh->bits / 8;
+	pub_template[1].type = CKA_BASE;
+	pub_template[1].pValue = dh->generator;
+	pub_template[1].ulValueLen = dh->genbits / 8;
+
+	rc = C_GenerateKeyPair(p11h(), &mech,
+	    pub_template, ARRAY_SIZE(pub_template),
+	    priv_template, ARRAY_SIZE(priv_template), pub, priv);
+	if (rc != CKR_OK) {
+		PKCS11ERR(error, "C_GenerateKeyPair", rc);
+		return (B_FALSE);
+	} else {
+		(void) bunyan_trace(log, "Created DH keypair",
+		    BUNYAN_T_STRING, "group", ikev2_dh_str(group),
+		    BUNYAN_T_UINT64, "pub_handle", (uint64_t)*pub,
+		    BUNYAN_T_UINT64, "priv_handle", (uint64_t)*priv,
+		    BUNYAN_T_END);
+	}
+
+	return (B_TRUE);
+}
+
+boolean_t
+dh_derivekey(CK_OBJECT_HANDLE privkey, uint8_t *restrict pub, size_t len,
+    CK_OBJECT_HANDLE_PTR restrict seckey)
+{
+	CK_OBJECT_CLASS key_class = CKO_SECRET_KEY;
+	CK_KEY_TYPE key_type = CKK_GENERIC_SECRET;
+	CK_BBOOL trueval = CK_TRUE;
+	CK_MECHANISM mech = { CKM_DH_PKCS_DERIVE, pub, len };
+	CK_ATTRIBUTE template[] = {
+		{ CKA_CLASS, &key_class, sizeof (key_class) },
+		{ CKA_KEY_TYPE, &key_type, sizeof (key_type) },
+		{ CKA_ENCRYPT, &trueval, sizeof (trueval) },
+		{ CKA_DECRYPT, &trueval, sizeof (trueval) }
+	};
+	CK_RV rc;
+
+	rc = C_DeriveKey(p11h(), &mech, privkey, template,
+	    ARRAY_SIZE(template), seckey);
+	if (rc != CKR_OK) {
+		PKCS11ERR(error, "C_DeriveKey", rc);
+		return (B_FALSE);
+	}
+	return (B_TRUE);
+}
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/dh.h b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/dh.h
new file mode 100644
index 0000000000..a877b08d4d
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/dh.h
@@ -0,0 +1,37 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2017 Jason King.
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+#ifndef _DH_H
+#define	_DH_H
+
+#include <sys/types.h>
+#include <security/cryptoki.h>
+#include "ikev2.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+boolean_t dh_genpair(ikev2_dh_t, CK_OBJECT_HANDLE_PTR restrict,
+    CK_OBJECT_HANDLE_PTR restrict);
+boolean_t dh_derivekey(CK_OBJECT_HANDLE, uint8_t *restrict, size_t,
+    CK_OBJECT_HANDLE_PTR restrict);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _DH_H */
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/fromto.c b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/fromto.c
new file mode 100644
index 0000000000..1c2bcbc44e
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/fromto.c
@@ -0,0 +1,300 @@
+/*
+ * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ *
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+/* Portions of the following are... */
+/*
+ * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*
+ * These functions provide an easy way to receive a packet with FULL address
+ * information, and send one using precise addresses.
+ */
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/int_fmtio.h>
+#include <sys/debug.h>
+#include <net/if.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include "defs.h"
+#include "fromto.h"
+#include "ike.h"
+
+#ifdef lint
+/*
+ * Since this file uses XTI sockets, it also defines boolean_t with values
+ * _B_FALSE and _B_TRUE instead of the typical B_FALSE/B_TRUE.  This keeps
+ * lint from complaining about conflicting definitions.
+ */
+#define	_B_FALSE B_FALSE
+#define	_B_TRUE B_TRUE
+#endif
+
+/*
+ * Receive packet, with src/dst information.  It is assumed that necessary
+ * setsockopt()s (e.g. IP_SEC_OPT(NEVER)) have already performed on socket.
+ */
+ssize_t
+recvfromto(int s, void *restrict buf, size_t buflen, int flags,
+    struct sockaddr_storage *restrict from, socklen_t *restrict fromlen,
+    struct sockaddr_storage *restrict to, socklen_t *restrict tolen)
+{
+	socklen_t otolen;
+	ssize_t len;
+	socklen_t sslen;
+	struct sockaddr_storage ss;
+	struct msghdr m;
+	struct iovec iov[1] = { 0 };
+	uint32_t cmsgbuf[64] = { 0 };
+	struct cmsghdr *cm = (struct cmsghdr *)cmsgbuf;
+	struct in6_pktinfo *pi;
+	struct sockaddr_in6 *sin6;
+	struct sockaddr_in *sin;
+	boolean_t toset = _B_FALSE;
+
+	sslen = sizeof (ss);
+	if (getsockname(s, (struct sockaddr *)&ss, &sslen) < 0) {
+		STDERR(error, "getsockname() failed",
+		    BUNYAN_T_INT32, "socket", (int32_t)s);
+		return (-1);
+	}
+
+	/* Quick hack -- snapshot the current socket's port, at least. */
+	(void) memcpy(to, &ss, sslen < *tolen ? sslen : *tolen);
+
+	m.msg_name = (caddr_t)from;
+	m.msg_namelen = *fromlen;
+	iov[0].iov_base = (caddr_t)buf;
+	iov[0].iov_len = buflen;
+	m.msg_iov = iov;
+	m.msg_iovlen = 1;
+	m.msg_control = (caddr_t)cm;
+	m.msg_controllen = sizeof (cmsgbuf);
+	if ((len = recvmsg(s, &m, flags)) < 0) {
+		STDERR(error, "recvmsg() failed",
+		    BUNYAN_T_INT32, "socket", (int32_t)s,
+		    BUNYAN_T_END);
+		return (-1);
+	}
+	key_add_addr(LOG_KEY_RADDR, SSTOSA(from));
+
+	if (m.msg_flags & MSG_TRUNC) {
+		/*
+		 * size_t and ssize_t should always be "long", but not in 32-
+		 * bit apps for some bizarre reason.
+		 */
+		(void) bunyan_warn(log, "Received oversized message",
+		    BUNYAN_T_INT32, "socket", (int32_t)s,
+		    BUNYAN_T_UINT32, "msglen", (uint32_t)len,
+		    BUNYAN_T_UINT32, "maxlen", (uint32_t)buflen,
+		    BUNYAN_T_END);
+
+		errno = E2BIG;	/* Not returned from normal recvmsg()... */
+		return (-1);
+	}
+
+	if (len < sizeof (ike_header_t)) {
+		(void) bunyan_warn(log, "Received undersized message",
+		    BUNYAN_T_INT32, "socket", (int32_t)s,
+		    BUNYAN_T_UINT32, "msglen", (uint32_t)len,
+		    BUNYAN_T_END);
+		return (-1);
+	}
+
+	*fromlen = m.msg_namelen;
+
+	otolen = *tolen;
+	*tolen = 0;
+	for (cm = (struct cmsghdr *)CMSG_FIRSTHDR(&m);
+	    m.msg_controllen != 0 && cm;
+	    cm = (struct cmsghdr *)CMSG_NXTHDR(&m, cm)) {
+		if (!toset && ss.ss_family == AF_INET6 &&
+		    cm->cmsg_level == IPPROTO_IPV6 &&
+		    cm->cmsg_type == IPV6_PKTINFO &&
+		    otolen >= sizeof (*sin6)) {
+			/* LINTED */
+			pi = (struct in6_pktinfo *)(CMSG_DATA(cm));
+			*tolen = sizeof (*sin6);
+			sin6 = (struct sockaddr_in6 *)to;
+			(void) memset(sin6, 0, sizeof (*sin6));
+			sin6->sin6_family = AF_INET6;
+			sin6->sin6_addr = pi->ipi6_addr;
+			/* XXX other cases, such as site-local? */
+			if (IN6_IS_ADDR_LINKLOCAL(&sin6->sin6_addr))
+				sin6->sin6_scope_id = pi->ipi6_ifindex;
+			else
+				sin6->sin6_scope_id = 0;
+			sin6->sin6_port =
+			    ((struct sockaddr_in6 *)&ss)->sin6_port;
+			toset = _B_TRUE;
+			continue;
+		}
+
+		if (!toset &&
+		    ss.ss_family == AF_INET && cm->cmsg_level == IPPROTO_IP &&
+		    cm->cmsg_type == IP_RECVDSTADDR &&
+		    otolen >= sizeof (struct sockaddr_in)) {
+			*tolen = sizeof (*sin);
+			sin = (struct sockaddr_in *)to;
+			(void) memset(sin, 0, sizeof (*sin));
+			sin->sin_family = AF_INET;
+			(void) memcpy(&sin->sin_addr, CMSG_DATA(cm),
+			    sizeof (sin->sin_addr));
+			sin->sin_port = ((struct sockaddr_in *)&ss)->sin_port;
+			toset = _B_TRUE;
+			continue;
+		}
+	}
+	key_add_addr(LOG_KEY_LADDR, SSTOSA(to));
+
+	(void) bunyan_debug(log, "Received datagram",
+	    BUNYAN_T_INT32, "socket", (int32_t)s,
+	    BUNYAN_T_UINT32, "msglen", (uint32_t)len,
+	    BUNYAN_T_END);
+
+	return (len);
+}
+
+/*
+ * Send packet, with fixing src/dst address pair. It should be noted
+ * that the source port value used is the one that was set on the
+ * socket being used (i.e. the port value in 'src' is ignored), while
+ * the port value in 'dest' IS used to determine the destination port of
+ * the datagram.
+ */
+ssize_t
+sendfromto(int s, const uint8_t *restrict buf, size_t buflen,
+    const struct sockaddr *restrict src,
+    const struct sockaddr *restrict dst)
+{
+	uint32_t cmsgbuf[64] = { 0 };
+	struct msghdr m = { 0 };
+	struct iovec iov[1];
+	struct cmsghdr *cm = (struct cmsghdr *)&cmsgbuf;
+	struct in6_pktinfo *pi6;
+	struct in_pktinfo *pi;
+	ssize_t n;
+
+	if (src->sa_family != AF_INET && src->sa_family != AF_INET6) {
+		(void) bunyan_error(log, "Unsupported address family",
+		    BUNYAN_T_STRING, LOG_KEY_FUNC, __func__,
+		    BUNYAN_T_STRING, LOG_KEY_FILE, __FILE__,
+		    BUNYAN_T_INT32, LOG_KEY_LINE, __LINE__,
+		    BUNYAN_T_UINT32, "af", (uint32_t)src->sa_family,
+		    BUNYAN_T_END);
+		errno = EAFNOSUPPORT;
+		return (-1);
+	}
+
+	if (src->sa_family != dst->sa_family) {
+		(void) bunyan_error(log, "Address family mismatch",
+		    BUNYAN_T_INT32, "socket", (int32_t)s,
+		    BUNYAN_T_UINT32, "srcaf", (uint32_t)src->sa_family,
+		    BUNYAN_T_UINT32, "destaf", (uint32_t)src->sa_family,
+		    BUNYAN_T_END);
+
+		errno = EADDRNOTAVAIL;	/* XXX KEBE ASKS - Better ideas? */
+		return (-1);
+	}
+
+	key_add_addr(LOG_KEY_RADDR, dst);
+	key_add_addr(LOG_KEY_LADDR, src);
+
+	(void) bunyan_debug(log, "Sending datagram",
+	    BUNYAN_T_INT32, "socket", (int32_t)s,
+	    BUNYAN_T_UINT32, "msglen", (uint32_t)buflen,
+	    BUNYAN_T_END);
+
+	m.msg_name = (caddr_t)dst;
+	iov[0].iov_base = (caddr_t)buf;
+	iov[0].iov_len = buflen;
+	m.msg_iov = iov;
+	m.msg_iovlen = 1;
+	m.msg_control = (caddr_t)cm;
+	if (src->sa_family == AF_INET6) {
+		/* v6 setup */
+		struct sockaddr_in6 *src6;
+
+		src6 = (struct sockaddr_in6 *)src;
+		m.msg_namelen = sizeof (*src6);
+		m.msg_controllen = CMSG_SPACE(sizeof (*pi6));
+		cm->cmsg_len = CMSG_LEN(sizeof (*pi6));
+		cm->cmsg_level = IPPROTO_IPV6;
+		cm->cmsg_type = IPV6_PKTINFO;
+		/* LINTED */
+		pi6 = (struct in6_pktinfo *)CMSG_DATA(cm);
+		pi6->ipi6_addr = src6->sin6_addr;
+		if (IN6_IS_ADDR_LINKLOCAL(&src6->sin6_addr)) {
+			pi6->ipi6_ifindex = src6->sin6_scope_id;
+		} else {
+			pi6->ipi6_ifindex = 0;
+		}
+	} else if (src->sa_family == AF_INET) {
+		/* v4 setup */
+		struct sockaddr_in *src4;
+
+		src4 = (struct sockaddr_in *)src;
+		m.msg_namelen = sizeof (*src4);
+		m.msg_controllen = CMSG_SPACE(sizeof (*pi));
+		cm->cmsg_len = CMSG_LEN(sizeof (*pi));
+		cm->cmsg_level = IPPROTO_IP;
+		cm->cmsg_type = IP_PKTINFO;
+		/* LINTED */
+		pi = (struct in_pktinfo *)CMSG_DATA(cm);
+		pi->ipi_addr = src4->sin_addr;
+		/* Zero out the other fields for IPv4. */
+		pi->ipi_spec_dst.s_addr = 0;
+		pi->ipi_ifindex = 0;
+	} else {
+		/*NOTREACHED*/
+		INVALID(src->ss_family);
+	}
+
+	n = sendmsg(s, &m, 0);
+	if (n < 0) {
+		STDERR(error, "sendmsg() failed",
+		    BUNYAN_T_INT32, "socket", (int32_t)s,
+		    BUNYAN_T_END);
+	} else {
+		(void) bunyan_trace(log, "Sent datagram",
+		    BUNYAN_T_INT32, "socket", (int32_t)s,
+		    BUNYAN_T_INT32, "len", (int32_t)n,
+		    BUNYAN_T_END);
+	}
+
+	return (n);
+}
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/fromto.h b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/fromto.h
new file mode 100644
index 0000000000..12706d2af3
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/fromto.h
@@ -0,0 +1,38 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2017 Joyent, Inc
+ */
+
+#ifndef _FROMTO_H
+#define	_FROMTO_H
+
+#include <sys/types.h>
+#include <sys/socket.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+ssize_t recvfromto(int, void *restrict, size_t, int,
+    struct sockaddr_storage *restrict, socklen_t *restrict,
+    struct sockaddr_storage *restrict, socklen_t *restrict);
+
+ssize_t sendfromto(int, const uint8_t *restrict, size_t,
+    const struct sockaddr *restrict,
+    const struct sockaddr *restrict);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _FROMTO_H */
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ike.h b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ike.h
new file mode 100644
index 0000000000..710eb68ccc
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ike.h
@@ -0,0 +1,119 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the "License").
+ * You may not use this file except in compliance with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ */
+
+/*
+ * Copyright 2014 Jason King.
+ */
+
+#ifndef _IKE_H
+#define	_IKE_H
+
+#include <sys/types.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Stuff that is the same between IKEv1 and IKEv2 */
+
+#define	IKE_GET_MAJORV(v)	(((v) & 0xf0) >> 4)
+#define	IKE_GET_MINORV(v)	((v) & 0x0f)
+#define	IKE_VERSION(_maj, _min) (((_maj) & 0xf0 << 4) | (_min) & 0x0f)
+
+#ifndef __packed
+#define	__packed __attribute__((packed))
+#endif
+
+struct ike_header {
+	uint64_t	initiator_spi;
+	uint64_t	responder_spi;
+	uint8_t		next_payload;
+	uint8_t		version;
+	uint8_t		exch_type;
+	uint8_t		flags;
+	uint32_t	msgid;
+	uint32_t	length;
+} __packed;
+typedef struct ike_header ike_header_t;
+#define	IKE_HEADER_LEN	(sizeof (ike_header_t))
+
+struct ike_payload {
+	uint8_t		pay_next;
+	uint8_t		pay_reserved;
+	uint16_t	pay_length;
+} __packed;
+typedef struct ike_payload ike_payload_t;
+
+#define	IKE_PAYLOAD_NONE	0
+
+/* Of the IKEv1 and IKEv2 payloads we recognize, this is MAX of the two */
+#define	IKE_NUM_PAYLOADS 17
+
+struct ike_prop {
+	uint8_t		prop_more;
+	uint8_t		prop_resv;
+	uint16_t	prop_len;
+	uint8_t		prop_num;
+	uint8_t		prop_proto;
+	uint8_t		prop_spilen;
+	uint8_t		prop_numxform;
+} __packed;
+typedef struct ike_prop ike_prop_t;
+#define	IKE_PROP_NONE	0
+#define	IKE_PROP_MORE	2
+
+struct ike_xform {
+	uint8_t		xf_more;
+	uint8_t		xf_resv;
+	uint16_t	xf_len;
+	uint8_t		xf_type;
+	uint8_t		xf_resv2;
+	uint16_t	xf_id;
+} __packed;
+typedef struct ike_xform ike_xform_t;
+#define	IKE_XFORM_NONE	0
+#define	IKE_XFORM_MORE	3
+
+#define	IKE_ATTR_MAXTYPE	0x7fff
+#define	IKE_ATTR_MAXLEN		(UINT16_MAX - sizeof (ike_xf_attr_t))
+#define	IKE_ATTR_MAXVAL		(UINT16_MAX)
+struct ike_xf_attr {
+	uint16_t	attr_type;
+	uint16_t	attr_len;
+};
+typedef struct ike_xf_attr ike_xf_attr_t;
+#define	IKE_ATTR_TV			0x8000
+#define	IKE_ATTR_TLV			0
+#define	IKE_ATTR_GET_TYPE(_t)		((_t) & 0x7fff)
+#define	IKE_ATTR_GET_FORMAT(_t)		((_t) & 0x8000)
+#define	IKE_ATTR_TYPE(_fmt, _t)		(IKE_ATTR_GET_FORMAT(_fmt) | (_t))
+
+struct ike_ke {
+	uint16_t	ke_group;
+	uint16_t	ke_resv;
+};
+typedef struct ike_ke ike_ke_t;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _IKE_H */
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev1.h b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev1.h
new file mode 100644
index 0000000000..e1a22c229c
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev1.h
@@ -0,0 +1,174 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the "License").
+ * You may not use this file except in compliance with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ */
+
+/*
+ * Copyright 2014 Jason King.
+ */
+
+#ifndef _IKEV1_H
+#define	_IKEV1_H
+
+#include <sys/types.h>
+#include "ike.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define	IKEV1_MAJOR_VERSION	1
+#define	IKEV1_MINOR_VERSION	0
+#define	IKEV1_VERSION		0x10
+
+typedef struct ike_header ikev1_header_t;
+
+enum ikev1_exch {
+	IKEV1_EXCH_BASE			= 1,
+	IKEV1_EXCH_IDPROT		= 2,
+	IKEV1_EXCH_AUTH_ONLY		= 3,
+	IKEV1_EXCH_AGGRESSIVE		= 4,
+	IKEV1_EXCH_INFORMATIONAL	= 5,
+};
+#define	IKEV1_VALID_EXCH(exch) \
+	(((exch) >= IKEV1_EXCH_BASE) && (exch) <= ((IKEV1_EXCH_INFORMATIONAL)))
+typedef enum ikev1_exch ikev1_exch_t;
+
+#define	IKEV1_FLAG_ENCR		(1 << 0)
+#define	IKEV1_FLAG_COMMIT	(1 << 1)
+#define	IKEV1_FLAG_AUTH_ONLY	(1 << 2)
+#define	IKEV1_FLAGS \
+	(IKEV1_FLAG_ENCR|IKEV1_FLAG_COMMIT|IKEV1_FLAG_AUTH_ONLY)
+
+typedef struct ike_payload ikev1_payload_t;
+
+enum ikev1_pay_type {
+	IKEV1_PAYLOAD_SA	= 1,
+	IKEV1_PAYLOAD_PROP	= 2,
+	IKEV1_PAYLOAD_XFORM	= 3,
+	IKEV1_PAYLOAD_KE	= 4,
+	IKEV1_PAYLOAD_ID	= 5,
+	IKEV1_PAYLOAD_CERT	= 6,
+	IKEV1_PAYLOAD_CREQ	= 7,
+	IKEV1_PAYLOAD_HASH	= 8,
+	IKEV1_PAYLOAD_SIG	= 9,
+	IKEV1_PAYLOAD_NONCE	= 10,
+	IKEV1_PAYLOAD_NOTIFY	= 11,
+	IKEV1_PAYLOAD_DELETE	= 12,
+	IKEV1_PAYLOAD_VENDOR	= 13,
+};
+typedef enum ikev1_pay_type ikev1_pay_t;
+#define	IKEV1_VALID_PAYLOAD(p) \
+	(((p) >= IKEV1_PAYLOAD_SA) && ((p) <= IKEV1_PAYLOAD_VENDOR))
+
+#define	IKEV1_SIT_IDENTITY_ONLY	(0x01)
+#define	IKEV1_SIT_SECRECY	(0x02)
+#define	IKEV1_SIT_INTEGRITY	(0x04)
+
+typedef enum ikev1_spi_proto_e {
+	IKEV1_SPI_PROTO_ISAKMP		= 1,
+	IKEV1_SPI_PROTO_IPSEC_AH	= 2,
+	IKEV1_SPI_PROTO_IPSEC_ESP	= 3,
+	IKEV1_SPI_PROTO_IPCOMP		= 4
+} ikev1_spi_proto_t;
+
+typedef struct ike_prop ikev1_prop_t;
+#define	IKEV1_PROP_LAST	0
+#define	IKEV1_PROP_MORE	2
+
+typedef struct ike_xform ikev1_xform_t;
+#define	IKEV1_XFORM_LAST	0
+#define	IKEV1_XFORM_MORE	3
+
+enum ikev1_xf_type {
+	IKEV1_XF_ENCR		= 1,
+	IKEV1_XF_HASH		= 2,
+	IKEV1_XF_AUTH		= 3,
+	IKEV1_XF_GROUP_DESC	= 4,
+	IKEV1_XF_GROUP_TYPE	= 5,
+	IKEV1_XF_GROUP_PRIME	= 6,
+	IKEV1_XF_GROUP_GEN_1	= 7,
+	IKEV1_XF_GROUP_GEN_2	= 8,
+	IKEV1_XF_GROUP_CURVE_A	= 9,
+	IKEV1_XF_GROUP_CURVE_B	= 10,
+	IKEV1_XF_LIFE_TYPE	= 11,
+	IKEV1_XF_LIFE_DUR	= 12,
+	IKEV1_XF_PRF		= 13,
+	IKEV1_XF_KEYLEN		= 14,
+	IKEV1_XF_FIELD_SIZE	= 15,
+	IKEV1_XF_GROUP_ORDER	= 16
+};
+typedef enum ikev1_xf_type ikev1_xf_type_t;
+
+typedef struct ike_xf_attr ikev1_xf_attr_t;
+#define	IKEV1_ATTR_TV			IKE_ATTR_TV
+#define	IKEV1_ATTR_TLV			IKE_ATTR_TLV
+#define	IKEV1_ATTR_GET_TYPE(t)		IKE_GET_TYPE(t)
+#define	IKEV1_ATTR_GET_FORMAT(t)	IKE_GET_FORMAT(t)
+#define	IKEV1_ATTR_TYPE(f, t)		IKE_ATTR_TYPE(f, t)
+
+struct ikev1_notify {
+	uint32_t	n_doi;
+	uint8_t		n_protoid;
+	uint8_t		n_spisize;
+	uint16_t	n_type;
+	/* Followed by variable length SPI */
+	/* Followed by notification data */
+} __packed;
+typedef struct ikev1_notify ikev1_notify_t;
+
+enum ikev1_notify_e {
+	IKEV1_N_INVALID_PAYLOAD_TYPE	= 1,
+	IKEV1_N_DOI_NOT_SUPPORTED	= 2,
+	IKEV1_N_SITUATION_NOT_SUPPORTED	= 3,
+	IKEV1_N_INVALID_COOKIE		= 4,
+	IKEV1_N_INVALID_MAJOR_VERSION	= 5,
+	IKEV1_N_INVALID_MINOR_VERSION	= 6,
+	IKEV1_N_INVALID_EXCHANGE_TYPE	= 7,
+	IKEV1_N_INVALID_FLAGS		= 8,
+	IKEV1_N_INVALID_MESSAGE_ID	= 9,
+	IKEV1_N_INVALID_PROTOCOL_ID	= 10,
+	IKEV1_N_INVALID_SPI		= 11,
+	IKEV1_N_INVALID_TRANSFORM_ID	= 12,
+	IKEV1_N_ATTRIBUTES_NOT_SUPPORTED = 13,
+	IKEV1_N_NO_PROPOSAL_CHOSEN	= 14,
+	IKEV1_N_BAD_PROPOSAL_SYNTAX	= 15,
+	IKEV1_N_PAYLOAD_MALFORMED	= 16,
+	IKEV1_N_INVALID_KEY_INFORMATION	= 17,
+	IKEV1_N_INVALID_ID_INFORMATION	= 18,
+	IKEV1_N_INVALID_CERT_ENCODING	= 19,
+	IKEV1_N_INVALID_CERTIFICATE	= 20,
+	IKEV1_N_CERT_TYPE_UNSUPPORTED	= 21,
+	IKEV1_N_INVALID_CERT_AUTHORITY	= 22,
+	IKEV1_N_INVALID_HASH_INFORMATION = 23,
+	IKEV1_N_AUTHENTICATION_FAILED	= 24,
+	IKEV1_N_INVALID_SIGNATURE	= 25,
+	IKEV1_N_ADDRESS_NOTIFICATION	= 26,
+	IKEV1_N_NOTIFY_SA_LIFETIME	= 27,
+	IKEV1_N_CERTIFICATE_UNAVAILABLE	= 28,
+	IKEV1_N_UNSUPPORTED_EXCHANGE_TYPE = 29,
+	IKEV1_N_UNEQUAL_PAYLOAD_LENGTHS	= 30,
+};
+typedef enum ikev1_notify_e ikev1_notify_type_t;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _IKEV1_H */
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev1_pkt.c b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev1_pkt.c
new file mode 100644
index 0000000000..c3be1cd518
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev1_pkt.c
@@ -0,0 +1,78 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2015 Jason King.  All rights reserved.
+ */
+
+#include <stddef.h>
+#include <assert.h>
+#include <umem.h>
+#include <string.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/byteorder.h>
+#include <ipsec_util.h>
+#include <locale.h>
+#include <netinet/in.h>
+#include <security/cryptoki.h>
+#include <errno.h>
+#include <sys/socket.h>
+#include <pthread.h>
+#include <sys/debug.h>
+#include <note.h>
+#include "ikev2.h"
+#include "ikev2_sa.h"
+#include "pkt.h"
+#include "pkt_impl.h"
+#include "pkcs11.h"
+
+static void
+ikev1_add_payload(pkt_t *pkt, ikev1_pay_t type)
+{
+	ASSERT(IKEV1_VALID_PAYLOAD(type));
+	ASSERT(IKE_GET_MAJORV(pkt->header.version) == IKEV1_VERSION);
+	pkt_add_payload(pkt, type, 0);
+}
+
+
+void
+ikev1_add_sa(pkt_t *pkt, uint32_t doi, uint32_t sit)
+{
+	ikev1_add_payload(pkt, IKEV1_PAYLOAD_SA);
+	buf_put32(&pkt->buf, doi);
+	buf_put32(&pkt->buf, sit);
+}
+
+void
+ikev1_add_prop(pkt_t *pkt, uint8_t propnum, ikev1_spi_proto_t spitype,
+    uint64_t spi)
+{
+	size_t spilen;
+
+	switch (spitype) {
+	case IKEV1_SPI_PROTO_ISAKMP:
+		spilen = sizeof (uint64_t);
+		break;
+	case IKEV1_SPI_PROTO_IPSEC_AH:
+	case IKEV1_SPI_PROTO_IPSEC_ESP:
+	case IKEV1_SPI_PROTO_IPCOMP:
+		spilen = sizeof (uint32_t);
+		break;
+	default:
+		INVALID(spitype);
+	}
+
+	pkt_add_prop(pkt, propnum, spitype, spi);
+}
+
+
+/* TODO */
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2.h b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2.h
new file mode 100644
index 0000000000..aea1c3052f
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2.h
@@ -0,0 +1,557 @@
+/*
+ * Copyright (c) 2010-2013 Reyk Floeter <reyk@openbsd.org>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+#ifndef _IKEV2_H
+#define	_IKEV2_H
+
+#include <inttypes.h>
+#include <sys/sha1.h>	/* For SHA1_DIGEST_LENGTH */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef __packed
+#define	__packed __attribute__((packed))
+#endif
+
+#define	IKEV2_VERSION		0x20	/* IKE version 2.0 */
+#define	IKEV2_KEYPAD		"Key Pad for IKEv2"	/* don't change! */
+
+/* RFC7296 3.9 - Nonce size must be between 16 and 256 octets (inclusive) */
+#define	IKEV2_NONCE_MIN		16
+#define	IKEV2_NONCE_MAX		256
+
+/*
+ * RFC7296 2.10 - Nonce must be at least half the key size of the PRF alg
+ * chosen.  This is half the largest keysize of all the PRF algs we currently
+ * support, so is always a valid size for any SA we negotiate.
+ */
+#define	IKEV2_NONCE_DEFAULT	32
+
+/* RFC7296 2.6 -- cookies are betwee 1 and 64 octets in length */
+#define	IKEV2_COOKIE_MIN	1
+#define	IKEV2_COOKIE_MAX	64
+
+/* The NAT detection notification data are SHA1 hashes */
+#define	IKEV2_N_NAT_SIZE	SHA1_DIGEST_LENGTH
+
+/*
+ * "IKEv2 Parameters" based on the official RFC-based assignments by IANA
+ * (http://www.iana.org/assignments/ikev2-parameters/ikev2-parameters.txt)
+ *
+ * GSA parameters are based on the draft Group Key Management RFC
+ * https://tools.ietf.org/html/draft-yeung-g-ikev2-11
+ */
+
+/*
+ * IKEv2 definitions of the IKE header
+ */
+
+/* IKEv2 exchange types */
+typedef enum ikev2_exch_e {
+	IKEV2_EXCH_IKE_SA_INIT		= 34,
+	IKEV2_EXCH_IKE_AUTH		= 35,
+	IKEV2_EXCH_CREATE_CHILD_SA	= 36,
+	IKEV2_EXCH_INFORMATIONAL	= 37,
+	IKEV2_EXCH_IKE_SESSION_RESUME	= 38,
+	IKEV2_EXCH_GSA_AUTH		= 39,	/* draft-yeung-g-ikev2 */
+	IKEV2_EXCH_GSA_REGISTRATION	= 40,	/* draft-yeung-g-ikev2 */
+	IKEV2_EXCH_GSA_REKEY		= 41,	/* draft-yeung-g-ikev2 */
+} ikev2_exch_t;
+
+/* IKEv2 message flags */
+#define	IKEV2_FLAG_INITIATOR	0x08	/* Sent by the initiator */
+#define	IKEV2_FLAG_VERSION	0x10	/* Supports a higher IKE version */
+#define	IKEV2_FLAG_RESPONSE	0x20	/* Message is a response */
+
+/*
+ * IKEv2 payloads
+ */
+struct ikev2_payload {
+	uint8_t		pld_nextpayload;	/* Next payload type */
+	uint8_t		pld_reserved;		/* Contains the critical bit */
+	uint16_t	pld_length;		/* Payload length with header */
+} __packed;
+
+#define	IKEV2_CRITICAL_PAYLOAD	0x01	/* First bit in the reserved field */
+
+/* IKEv2 payload types */
+typedef enum ikev2_pay_type {
+	IKEV2_PAYLOAD_NONE =	0,	/* No payload */
+	IKEV2_PAYLOAD_SA =	33,	/* Security Association */
+	IKEV2_PAYLOAD_KE =	34,	/* Key Exchange */
+	IKEV2_PAYLOAD_IDi =	35,	/* Identification - Initiator */
+	IKEV2_PAYLOAD_IDr =	36,	/* Identification - Responder */
+	IKEV2_PAYLOAD_CERT =	37,	/* Certificate */
+	IKEV2_PAYLOAD_CERTREQ =	38,	/* Certificate Request */
+	IKEV2_PAYLOAD_AUTH =	39,	/* Authentication */
+	IKEV2_PAYLOAD_NONCE =	40,	/* Nonce */
+	IKEV2_PAYLOAD_NOTIFY =	41,	/* Notify */
+	IKEV2_PAYLOAD_DELETE =	42,	/* Delete */
+	IKEV2_PAYLOAD_VENDOR =	43,	/* Vendor ID */
+	IKEV2_PAYLOAD_TSi =	44,	/* Traffic Selector - Initiator */
+	IKEV2_PAYLOAD_TSr =	45,	/* Traffic Selector - Responder */
+	IKEV2_PAYLOAD_SK =	46,	/* Encrypted */
+	IKEV2_PAYLOAD_CP =	47,	/* Configuration Payload */
+	IKEV2_PAYLOAD_EAP =	48,	/* Extensible Authentication */
+	IKEV2_PAYLOAD_GSPM =	49,	/* RFC6467 Generic Secure Password */
+	IKEV2_PAYLOAD_IDg =	50,	/* draft-yeung-g-ikev2 */
+	IKEV2_PAYLOAD_GSA =	51,	/* draft-yeung-g-ikev2 */
+	IKEV2_PAYLOAD_KD =	52,	/* draft-yeung-g-ikev2 */
+	IKEV2_PAYLOAD_SKF =	53,	/* RFC7383 */
+	IKEV2_PAYLOAD_PS =	54,	/* RFC8019 */
+} ikev2_pay_type_t;
+
+#define	IKEV2_PAYLOAD_MIN	IKEV2_PAYLOAD_SA
+#define	IKEV2_PAYLOAD_MAX	IKEV2_PAYLOAD_PS
+#define	IKEV2_NUM_PAYLOADS	(IKEV2_PAYLOAD_MAX - IKEV2_PAYLOAD_MIN + 1)
+#define	IKEV2_VALID_PAYLOAD(paytype) \
+	(((paytype) >= IKEV2_PAYLOAD_MIN) && ((paytype) <= IKEV2_PAYLOAD_MAX))
+
+/*
+ * SA payload
+ */
+
+struct ikev2_sa_proposal {
+	uint8_t		proto_more;		/* Last proposal or more */
+	uint8_t		proto_reserved;		/* Must be set to zero */
+	uint16_t	proto_length;		/* Proposal length */
+	uint8_t		proto_proposalnr;	/* Proposal number */
+	uint8_t		proto_protoid;		/* Protocol Id */
+	uint8_t		proto_spisize;		/* SPI size */
+	uint8_t		proto_transforms;	/* Number of transforms */
+	/* Followed by variable-length SPI */
+	/* Followed by variable-length transforms */
+} __packed;
+
+#define	IKEV2_PROP_LAST	0
+#define	IKEV2_PROP_MORE	2
+
+typedef enum ikev2_spi_proto_e {
+	IKEV2_PROTO_NONE		= 0,	/* None */
+	IKEV2_PROTO_IKE			= 1,	/* IKEv2 */
+	IKEV2_PROTO_AH			= 2,	/* AH */
+	IKEV2_PROTO_ESP			= 3,	/* ESP */
+	IKEV2_PROTO_FC_ESP_HEADER	= 4,	/* RFC4595 */
+	IKEV2_PROTO_FC_CT_AUTH		= 5	/* RFC4595 */
+} ikev2_spi_proto_t;
+
+struct ikev2_transform {
+	uint8_t		xf_more;		/* Last transform or more */
+	uint8_t		xf_reserved;		/* Must be set to zero */
+	uint16_t	xf_length;		/* Transform length */
+	uint8_t		xf_type;		/* Transform type */
+	uint8_t		xf_reserved1;		/* Must be set to zero */
+	uint16_t	xf_id;		/* Transform Id */
+	/* Followed by variable-length transform attributes */
+} __packed;
+
+#define	IKEV2_XF_LAST		0
+#define	IKEV2_XF_MORE		3
+
+typedef enum ikev2_xf_type_e {
+	IKEV2_XF_ENCR	= 1,	/* Encryption */
+	IKEV2_XF_PRF	= 2,	/* Pseudo-Random Function */
+	IKEV2_XF_AUTH	= 3,	/* Integrity Algorithm */
+	IKEV2_XF_DH	= 4,	/* Diffie-Hellman Group */
+	IKEV2_XF_ESN	= 5	/* Extended Sequence Numbers */
+} ikev2_xf_type_t;
+#define	IKEV2_XF_MAX		6
+
+typedef enum ikev2_encr_e {
+	IKEV2_ENCR_NONE			= 0,	/* None */
+	IKEV2_ENCR_DES_IV64		= 1,	/* RFC1827 */
+	IKEV2_ENCR_DES			= 2,	/* RFC2405 */
+	IKEV2_ENCR_3DES			= 3,	/* RFC2451 */
+	IKEV2_ENCR_RC5			= 4,	/* RFC2451 */
+	IKEV2_ENCR_IDEA			= 5,	/* RFC2451 */
+	IKEV2_ENCR_CAST			= 6,	/* RFC2451 */
+	IKEV2_ENCR_BLOWFISH		= 7,	/* RFC2451 */
+	IKEV2_ENCR_3IDEA		= 8,	/* RFC2451 */
+	IKEV2_ENCR_DES_IV32		= 9,	/* DESIV32 */
+	IKEV2_ENCR_RC4			= 10,	/* RFC2451 */
+	IKEV2_ENCR_NULL			= 11,	/* RFC2410 */
+	IKEV2_ENCR_AES_CBC		= 12,	/* RFC3602 */
+	IKEV2_ENCR_AES_CTR		= 13,	/* RFC3664 */
+	IKEV2_ENCR_AES_CCM_8		= 14,	/* RFC5282 */
+	IKEV2_ENCR_AES_CCM_12		= 15,	/* RFC5282 */
+	IKEV2_ENCR_AES_CCM_16		= 16,	/* RFC5282 */
+	IKEV2_ENCR_AES_GCM_8		= 18,	/* RFC5282 */
+	IKEV2_ENCR_AES_GCM_12		= 19,	/* RFC5282 */
+	IKEV2_ENCR_AES_GCM_16		= 20,	/* RFC5282 */
+	IKEV2_ENCR_NULL_AES_GMAC	= 21,	/* RFC4543 */
+	IKEV2_ENCR_XTS_AES		= 22,	/* IEEE P1619 */
+	IKEV2_ENCR_CAMELLIA_CBC		= 23,	/* RFC5529 */
+	IKEV2_ENCR_CAMELLIA_CTR		= 24,	/* RFC5529 */
+	IKEV2_ENCR_CAMELLIA_CCM_8	= 25,	/* RFC5529 */
+	IKEV2_ENCR_CAMELLIA_CCM_12	= 26,	/* RFC5529 */
+	IKEV2_ENCR_CAMELLIA_CCM_16	= 27,	/* RFC5529 */
+} ikev2_xf_encr_t;
+#define	IKEV2_ENCR_MAX	IKEV2_ENCR_CAMELLIA_CCM_16
+
+#define	IKEV2_IPCOMP_OUI		1	/* RFC5996 */
+#define	IKEV2_IPCOMP_DEFLATE		2	/* RFC2394 */
+#define	IKEV2_IPCOMP_LZS		3	/* RFC2395 */
+#define	IKEV2_IPCOMP_LZJH		4	/* RFC3051 */
+
+typedef enum ikev2_prf {
+	IKEV2_PRF_HMAC_MD5		= 1,	/* RFC2104 */
+	IKEV2_PRF_HMAC_SHA1		= 2,	/* RFC2104 */
+	IKEV2_PRF_HMAC_TIGER		= 3,	/* RFC2104 */
+	IKEV2_PRF_AES128_XCBC		= 4,	/* RFC3664 */
+	IKEV2_PRF_HMAC_SHA2_256		= 5,	/* RFC4868 */
+	IKEV2_PRF_HMAC_SHA2_384		= 6,	/* RFC4868 */
+	IKEV2_PRF_HMAC_SHA2_512		= 7,	/* RFC4868 */
+	IKEV2_PRF_AES128_CMAC		= 8	/* RFC4615 */
+} ikev2_prf_t;
+
+typedef enum ikev2_xf_auth_e {
+	IKEV2_XF_AUTH_NONE			= 0,	/* No Authentication */
+	IKEV2_XF_AUTH_HMAC_MD5_96		= 1,	/* RFC2403 */
+	IKEV2_XF_AUTH_HMAC_SHA1_96		= 2,	/* RFC2404 */
+	IKEV2_XF_AUTH_DES_MAC			= 3,	/* DES-MAC */
+	IKEV2_XF_AUTH_KPDK_MD5			= 4,	/* RFC1826 */
+	IKEV2_XF_AUTH_AES_XCBC_96		= 5,	/* RFC3566 */
+	IKEV2_XF_AUTH_HMAC_MD5_128		= 6,	/* RFC4595 */
+	IKEV2_XF_AUTH_HMAC_SHA1_160		= 7,	/* RFC4595 */
+	IKEV2_XF_AUTH_AES_CMAC_96		= 8,	/* RFC4494 */
+	IKEV2_XF_AUTH_AES_128_GMAC		= 9,	/* RFC4543 */
+	IKEV2_XF_AUTH_AES_192_GMAC		= 10,	/* RFC4543 */
+	IKEV2_XF_AUTH_AES_256_GMAC		= 11,	/* RFC4543 */
+	IKEV2_XF_AUTH_HMAC_SHA2_256_128 	= 12,	/* RFC4868 */
+	IKEV2_XF_AUTH_HMAC_SHA2_384_192 	= 13,	/* RFC4868 */
+	IKEV2_XF_AUTH_HMAC_SHA2_512_256 	= 14	/* RFC4868 */
+} ikev2_xf_auth_t;
+#define	IKEV2_XF_AUTH_MAX	IKEV2_XF_AUTH_HMAC_SHA2_512_256
+
+typedef enum ikev2_dh {
+	IKEV2_DH_NONE			= 0,	/* No DH */
+	IKEV2_DH_MODP_768		= 1,	/* DH Group 1 */
+	IKEV2_DH_MODP_1024		= 2,	/* DH Group 2 */
+	IKEV2_DH_EC2N_155		= 3,	/* DH Group 3 */
+	IKEV2_DH_EC2N_185		= 4,	/* DH Group 3 */
+	IKEV2_DH_MODP_1536		= 5,	/* DH Group 5 */
+	IKEV2_DH_MODP_2048		= 14,	/* DH Group 14 */
+	IKEV2_DH_MODP_3072		= 15,	/* DH Group 15 */
+	IKEV2_DH_MODP_4096		= 16,	/* DH Group 16 */
+	IKEV2_DH_MODP_6144		= 17,	/* DH Group 17 */
+	IKEV2_DH_MODP_8192		= 18,	/* DH Group 18 */
+	IKEV2_DH_ECP_256		= 19,	/* DH Group 19 */
+	IKEV2_DH_ECP_384		= 20,	/* DH Group 20 */
+	IKEV2_DH_ECP_521		= 21,	/* DH Group 21 */
+	IKEV2_DH_MODP_1024_160		= 22,	/* DH Group 22 */
+	IKEV2_DH_MODP_2048_224		= 23,	/* DH Group 23 */
+	IKEV2_DH_MODP_2048_256		= 24,	/* DH Group 24 */
+	IKEV2_DH_ECP_192		= 25,	/* DH Group 25 */
+	IKEV2_DH_ECP_224		= 26,	/* DH Group 26 */
+	IKEV2_DH_BRAINPOOL_P224R1	= 27,	/* DH Group 27 */
+	IKEV2_DH_BRAINPOOL_P256R1	= 28,	/* DH Group 28 */
+	IKEV2_DH_BRAINPOOL_P384R1	= 29,	/* DH Group 29 */
+	IKEV2_DH_BRAINPOOL_P512R1	= 30	/* DH Group 30 */
+} ikev2_dh_t;
+#define	IKEV2_DH_MAX			31
+
+typedef enum ikev2_esn_e {
+	IKEV2_ESN_NONE = 0,
+	IKEV2_ESN_YES = 1
+} ikev2_esn_t;
+
+struct ikev2_attribute {
+	uint16_t	attr_type;	/* Attribute type */
+	uint16_t	attr_length;	/* Attribute length or value */
+	/* Followed by variable length (TLV) */
+} __packed;
+
+#define	IKEV2_ATTRAF_TLV		0x0000	/* Type-Length-Value format */
+#define	IKEV2_ATTRAF_TV			0x8000	/* Type-Value format */
+
+typedef enum ikev2_xf_attr_type {
+	IKEV2_XF_ATTR_KEYLEN	= 14		/* Key length */
+} ikev2_xf_attr_type_t;
+
+/*
+ * KE Payload
+ */
+struct ikev2_ke {
+	uint16_t	 kex_dhgroup;		/* DH Group # */
+	uint16_t	 kex_reserved;		/* Reserved */
+} __packed;
+
+/*
+ * N payload
+ */
+struct ikev2_notify {
+	uint8_t		n_protoid;		/* Protocol Id */
+	uint8_t		n_spisize;		/* SPI size */
+	uint16_t	n_type;		/* Notify message type */
+	/* Followed by variable length SPI */
+	/* Followed by variable length notification data */
+} __packed;
+
+/*
+ * NOTIFY types.  We don't support all of these, however for observability
+ * and debugging purposes, we try to maintain a list of all known values.
+ */
+typedef enum ikev2_notify_type {
+	IKEV2_N_UNSUPPORTED_CRITICAL_PAYLOAD	= 1,		/* RFC4306 */
+	IKEV2_N_INVALID_IKE_SPI			= 4,		/* RFC4306 */
+	IKEV2_N_INVALID_MAJOR_VERSION		= 5,		/* RFC4306 */
+	IKEV2_N_INVALID_SYNTAX			= 7,		/* RFC4306 */
+	IKEV2_N_INVALID_MESSAGE_ID		= 9,		/* RFC4306 */
+	IKEV2_N_INVALID_SPI			= 11,		/* RFC4306 */
+	IKEV2_N_NO_PROPOSAL_CHOSEN		= 14,		/* RFC4306 */
+	IKEV2_N_INVALID_KE_PAYLOAD		= 17,		/* RFC4306 */
+	IKEV2_N_AUTHENTICATION_FAILED		= 24,		/* RFC4306 */
+	IKEV2_N_SINGLE_PAIR_REQUIRED		= 34,		/* RFC4306 */
+	IKEV2_N_NO_ADDITIONAL_SAS		= 35,		/* RFC4306 */
+	IKEV2_N_INTERNAL_ADDRESS_FAILURE	= 36,		/* RFC4306 */
+	IKEV2_N_FAILED_CP_REQUIRED		= 37,		/* RFC4306 */
+	IKEV2_N_TS_UNACCEPTABLE			= 38,		/* RFC4306 */
+	IKEV2_N_INVALID_SELECTORS		= 39,		/* RFC4306 */
+	IKEV2_N_UNACCEPTABLE_ADDRESSES		= 40,		/* RFC4555 */
+	IKEV2_N_UNEXPECTED_NAT_DETECTED		= 41,		/* RFC4555 */
+	IKEV2_N_USE_ASSIGNED_HoA		= 42,		/* RFC5026 */
+	IKEV2_N_TEMPORARY_FAILURE		= 43,		/* RFC5996 */
+	IKEV2_N_CHILD_SA_NOT_FOUND		= 44,		/* RFC5996 */
+	IKEV2_N_INITIAL_CONTACT			= 16384,	/* RFC4306 */
+	IKEV2_N_SET_WINDOW_SIZE			= 16385,	/* RFC4306 */
+	IKEV2_N_ADDITIONAL_TS_POSSIBLE		= 16386,	/* RFC4306 */
+	IKEV2_N_IPCOMP_SUPPORTED		= 16387,	/* RFC4306 */
+	IKEV2_N_NAT_DETECTION_SOURCE_IP		= 16388,	/* RFC4306 */
+	IKEV2_N_NAT_DETECTION_DESTINATION_IP	= 16389,	/* RFC4306 */
+	IKEV2_N_COOKIE				= 16390,	/* RFC4306 */
+	IKEV2_N_USE_TRANSPORT_MODE		= 16391,	/* RFC4306 */
+	IKEV2_N_HTTP_CERT_LOOKUP_SUPPORTED	= 16392,	/* RFC4306 */
+	IKEV2_N_REKEY_SA			= 16393,	/* RFC4306 */
+	IKEV2_N_ESP_TFC_PADDING_NOT_SUPPORTED	= 16394,	/* RFC4306 */
+	IKEV2_N_NON_FIRST_FRAGMENTS_ALSO	= 16395,	/* RFC4306 */
+	IKEV2_N_MOBIKE_SUPPORTED		= 16396,	/* RFC4555 */
+	IKEV2_N_ADDITIONAL_IP4_ADDRESS		= 16397,	/* RFC4555 */
+	IKEV2_N_ADDITIONAL_IP6_ADDRESS		= 16398,	/* RFC4555 */
+	IKEV2_N_NO_ADDITIONAL_ADDRESSES		= 16399,	/* RFC4555 */
+	IKEV2_N_UPDATE_SA_ADDRESSES		= 16400,	/* RFC4555 */
+	IKEV2_N_COOKIE2				= 16401,	/* RFC4555 */
+	IKEV2_N_NO_NATS_ALLOWED			= 16402,	/* RFC4555 */
+	IKEV2_N_AUTH_LIFETIME			= 16403,	/* RFC4478 */
+	IKEV2_N_MULTIPLE_AUTH_SUPPORTED		= 16404,	/* RFC4739 */
+	IKEV2_N_ANOTHER_AUTH_FOLLOWS		= 16405,	/* RFC4739 */
+	IKEV2_N_REDIRECT_SUPPORTED		= 16406,	/* RFC5685 */
+	IKEV2_N_REDIRECT			= 16407,	/* RFC5685 */
+	IKEV2_N_REDIRECTED_FROM			= 16408,	/* RFC5685 */
+	IKEV2_N_TICKET_LT_OPAQUE		= 16409,	/* RFC5723 */
+	IKEV2_N_TICKET_REQUEST			= 16410,	/* RFC5723 */
+	IKEV2_N_TICKET_ACK			= 16411,	/* RFC5723 */
+	IKEV2_N_TICKET_NACK			= 16412,	/* RFC5723 */
+	IKEV2_N_TICKET_OPAQUE			= 16413,	/* RFC5723 */
+	IKEV2_N_LINK_ID				= 16414,	/* RFC5739 */
+	IKEV2_N_USE_WESP_MODE			= 16415,
+			/* RFC-ietf-ipsecme-traffic-visibility-12.txt */
+	IKEV2_N_ROHC_SUPPORTED			= 16416,
+			/* RFC-ietf-rohc-ikev2-extensions-hcoipsec-12.txt */
+	IKEV2_N_EAP_ONLY_AUTHENTICATION		= 16417,	/* RFC5998 */
+	IKEV2_N_CHILDLESS_IKEV2_SUPPORTED	= 16418,	/* RFC6023 */
+	IKEV2_N_QUICK_CRASH_DETECTION		= 16419,	/* RFC6290 */
+	IKEV2_N_IKEV2_MESSAGE_ID_SYNC_SUPPORTED	= 16420,	/* RFC6311 */
+	IKEV2_N_IPSEC_REPLAY_CTR_SYNC_SUPPORTED	= 16421,	/* RFC6311 */
+	IKEV2_N_IKEV2_MESSAGE_ID_SYNC		= 16422,	/* RFC6311 */
+	IKEV2_N_IPSEC_REPLAY_CTR_SYNC		= 16423,	/* RFC6311 */
+	IKEV2_N_SECURE_PASSWORD_METHODS		= 16424,	/* RFC6467 */
+	IKEV2_N_PSK_PERSIST			= 16425,	/* RFC6631 */
+	IKEV2_N_PSK_CONFIRM			= 16426,	/* RFC6631 */
+	IKEV2_N_ERX_SUPPORTED			= 16427,	/* RFC6867 */
+	IKEV2_N_IFOM_CAPABILITY			= 16428		/* OA3GPP */
+} ikev2_notify_type_t;
+#define	IKEV2_NOTIFY_ERROR(n) ((n) < 16384)
+
+/*
+ * DELETE payload
+ */
+struct ikev2_delete {
+	uint8_t		del_protoid;		/* Protocol Id */
+	uint8_t		del_spisize;		/* SPI size */
+	uint16_t	del_nspi;		/* Number of SPIs */
+	/* Followed by variable length SPIs */
+} __packed;
+
+/*
+ * ID payload
+ */
+struct ikev2_id {
+	uint8_t	id_type;		/* Id type */
+	uint8_t	id_reserved[3];		/* Reserved */
+	uint8_t	id_data[];		/* Identification data */
+} __packed;
+
+typedef enum ikev2_id_type {
+	IKEV2_ID_IPV4_ADDR	= 1,	/* RFC7296 */
+	IKEV2_ID_FQDN		= 2,	/* RFC7296 */
+	IKEV2_ID_RFC822_ADDR	= 3,	/* RFC7296 */
+	IKEV2_ID_IPV6_ADDR	= 5,	/* RFC7296 */
+	IKEV2_ID_DER_ASN1_DN	= 9,	/* RFC7296 */
+	IKEV2_ID_DER_ASN1_GN	= 10,	/* RFC7296 */
+	IKEV2_ID_KEY_ID		= 11,	/* RFC7296 */
+	IKEV2_ID_FC_NAME	= 12	/* RFC4595 */
+} ikev2_id_type_t;
+
+/*
+ * CERT/CERTREQ payloads
+ */
+typedef enum ikev2_cert {
+	IKEV2_CERT_NONE =			0,	/* None */
+	IKEV2_CERT_X509_PKCS7 =			1,	/* RFC4306 */
+	IKEV2_CERT_PGP =			2,	/* RFC4306 */
+	IKEV2_CERT_DNS_SIGNED_KEY =		3,	/* RFC4306 */
+	IKEV2_CERT_X509_CERT =			4,	/* RFC4306 */
+	IKEV2_CERT_KERBEROS_TOKEN =		6,	/* RFC4306 */
+	IKEV2_CERT_CRL =			7,	/* RFC4306 */
+	IKEV2_CERT_ARL =			8,	/* RFC4306 */
+	IKEV2_CERT_SPKI =			9,	/* RFC4306 */
+	IKEV2_CERT_X509_ATTR =			10,	/* RFC4306 */
+	IKEV2_CERT_RSA_KEY =			11,	/* RFC4306 */
+	IKEV2_CERT_HASHURL_X509 =		12,	/* RFC4306 */
+	IKEV2_CERT_HASHURL_X509_BUNDLE =	13,	/* RFC4306 */
+	IKEV2_CERT_OCSP =			14	/* RFC4806 */
+} ikev2_cert_t;
+
+/*
+ * TSi/TSr payloads
+ */
+struct ikev2_tsp {
+	uint8_t	tsp_count;		/* Number of TSs */
+	uint8_t	tsp_reserved[3];	/* Reserved */
+	/* Followed by the traffic selectors */
+} __packed;
+
+struct ikev2_ts_hdr {
+	uint8_t		tsh_type;		/* TS type */
+	uint8_t		tsh_reserved;		/* Reserved */
+	uint16_t	tsh_length;		/* Length */
+};
+
+struct ikev2_ts {
+	uint8_t		ts_type;		/* TS type */
+	uint8_t		ts_protoid;		/* Protocol Id */
+	uint16_t	ts_length;		/* Length */
+	uint16_t	ts_startport;		/* Start port */
+	uint16_t	ts_endport;		/* End port */
+} __packed;
+
+typedef enum ikev2_ts_type {
+	IKEV2_TS_IPV4_ADDR_RANGE =	7,	/* RFC4306 */
+	IKEV2_TS_IPV6_ADDR_RANGE =	8,	/* RFC4306 */
+	IKEV2_TS_FC_ADDR_RANGE =	9	/* RFC4595 */
+} ikev2_ts_type_t;
+
+/*
+ * AUTH payload
+ */
+struct ikev2_auth {
+	uint8_t	auth_method;		/* Signature type */
+	uint8_t	auth_reserved[3];	/* Reserved */
+	/* Followed by the signature */
+} __packed;
+
+typedef enum ikev2_auth_type {
+	IKEV2_AUTH_NONE =		0,	/* None */
+	IKEV2_AUTH_RSA_SIG =		1,	/* RFC4306 */
+	IKEV2_AUTH_SHARED_KEY_MIC =	2,	/* RFC4306 */
+	IKEV2_AUTH_DSS_SIG =		3,	/* RFC4306 */
+	IKEV2_AUTH_ECDSA_256 =		9,	/* RFC4754 */
+	IKEV2_AUTH_ECDSA_384 =		10,	/* RFC4754 */
+	IKEV2_AUTH_ECDSA_512 =		11,	/* RFC4754 */
+	IKEV2_AUTH_GSPM =		12	/* RFC6467 */
+} ikev2_auth_type_t;
+
+/*
+ * CP payload
+ */
+struct ikev2_cp {
+	uint8_t	cp_type;
+	uint8_t	cp_reserved[3];
+	/* Followed by the attributes */
+} __packed;
+
+typedef enum ikev2_cfg_type {
+	IKEV2_CP_REQUEST	= 1,	/* CFG-Request */
+	IKEV2_CP_REPLY		= 2,	/* CFG-Reply */
+	IKEV2_CP_SET		= 3,	/* CFG-SET */
+	IKEV2_CP_ACK		= 4	/* CFG-ACK */
+} ikev2_cfg_type_t;
+
+struct ikev2_cfg {
+	uint16_t	cfg_type;	/* first bit must be set to zero */
+	uint16_t	cfg_length;
+	/* Followed by variable-length data */
+} __packed;
+
+typedef enum ikev2_cfg_attr_type {
+	IKEV2_CFG_INTERNAL_IP4_ADDRESS		= 1,	/* RFC5996 */
+	IKEV2_CFG_INTERNAL_IP4_NETMASK		= 2,	/* RFC5996 */
+	IKEV2_CFG_INTERNAL_IP4_DNS		= 3,	/* RFC5996 */
+	IKEV2_CFG_INTERNAL_IP4_NBNS		= 4,	/* RFC5996 */
+	IKEV2_CFG_INTERNAL_ADDRESS_EXPIRY	= 5,	/* RFC4306 */
+	IKEV2_CFG_INTERNAL_IP4_DHCP		= 6,	/* RFC5996 */
+	IKEV2_CFG_APPLICATION_VERSION		= 7,	/* RFC5996 */
+	IKEV2_CFG_INTERNAL_IP6_ADDRESS		= 8,	/* RFC5996 */
+	IKEV2_CFG_INTERNAL_IP6_DNS		= 10,	/* RFC5996 */
+	IKEV2_CFG_INTERNAL_IP6_NBNS		= 11,	/* RFC4306 */
+	IKEV2_CFG_INTERNAL_IP6_DHCP		= 12,	/* RFC5996 */
+	IKEV2_CFG_INTERNAL_IP4_SUBNET		= 13,	/* RFC5996 */
+	IKEV2_CFG_SUPPORTED_ATTRIBUTES		= 14,	/* RFC5996 */
+	IKEV2_CFG_INTERNAL_IP6_SUBNET		= 15,	/* RFC5996 */
+	IKEV2_CFG_MIP6_HOME_PREFIX		= 16,	/* RFC5026 */
+	IKEV2_CFG_INTERNAL_IP6_LINK		= 17,	/* RFC5739 */
+	IKEV2_CFG_INTERNAL_IP6_PREFIX		= 18,	/* RFC5739 */
+	IKEV2_CFG_HOME_AGENT_ADDRESS		= 19,
+/* BEGIN CSTYLED */
+		/* http://www.3gpp.org/ftp/Specs/html-info/24302.htm */
+/* END CSTYLED */
+	IKEV2_CFG_INTERNAL_IP4_SERVER		= 23456, /* MS-IKEE */
+	IKEV2_CFG_INTERNAL_IP6_SERVER		= 23457  /* MS-IKEE */
+} ikev2_cfg_attr_type_t;
+
+/* MD5 sum of "ILLUMOS_1 2017/08/21 29.718 -95.390" */
+#define	VENDOR_STR_ILLUMOS_1	"6a3b8d3af106854d3a2c56c50df729cf"
+
+/* The vendor types + versions we recognize */
+typedef enum vendor {
+	VENDOR_UNKNOWN			= 0,
+	VENDOR_ILLUMOS_1		= 1
+} vendor_t;
+
+typedef struct ikev2_payload ikev2_payload_t;
+typedef struct ikev2_sa_proposal ikev2_sa_proposal_t;
+typedef struct ikev2_transform ikev2_transform_t;
+typedef struct ikev2_attribute ikev2_attribute_t;
+typedef struct ikev2_ke ikev2_ke_t;
+typedef struct ikev2_notify ikev2_notify_t;
+typedef struct ikev2_delete ikev2_delete_t;
+typedef struct ikev2_id ikev2_id_t;
+typedef struct ikev2_tsp ikev2_tsp_t;
+typedef struct ikev2_ts_hdr ikev2_ts_hdr_t;
+typedef struct ikev2_ts ikev2_ts_t;
+typedef struct ikev2_auth ikev2_auth_t;
+typedef struct ikev2_cp ikev2_cp_t;
+typedef struct ikev2_cfg ikev2_cfg_t;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _IKEV2_H */
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_child_sa.c b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_child_sa.c
new file mode 100644
index 0000000000..293f06d707
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_child_sa.c
@@ -0,0 +1,1975 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017 Joyent, Inc.
+ */
+
+#include <ipsec_util.h>
+#include <strings.h>
+#include <sys/debug.h>
+#include "config.h"
+#include "dh.h"
+#include "ikev2.h"
+#include "ikev2_common.h"
+#include "ikev2_enum.h"
+#include "ikev2_pkt.h"
+#include "ikev2_proto.h"
+#include "ikev2_sa.h"
+#include "pfkey.h"
+#include "pkcs11.h"
+#include "prf.h"
+#include "ts.h"
+#include "worker.h"
+
+#define	IS_AUTH(args) ((args)->i2a_is_auth)
+#define	INITIATOR(args) ((args)->i2a_child[0].csa_child->i2c_initiator)
+#define	TRANSPORT_MODE(args) ((args)->i2a_child[0].csa_child->i2c_transport)
+
+static boolean_t ikev2_create_child_sa_init_common(ikev2_sa_t *restrict,
+    pkt_t *restrict req, ikev2_sa_args_t *restrict);
+static boolean_t ikev2_create_child_sa_resp_common(pkt_t *restrict,
+    pkt_t *restrict, ikev2_sa_args_t *restrict);
+
+static void ikev2_create_child_sa_init_resp(ikev2_sa_t *restrict,
+    pkt_t *restrict, void *restrict);
+static void ikev2_rekey_child_sa_init_resp(ikev2_sa_t *restrict,
+    pkt_t *restrict, void *restrict);
+static void ikev2_create_child_sa_init_resp_common(ikev2_sa_t *restrict,
+    pkt_t *restrict, void *restrict);
+
+static boolean_t ikev2_sa_from_acquire(pkt_t *restrict, parsedmsg_t *restrict,
+    uint32_t, ikev2_dh_t);
+static boolean_t get_resp_policy(pkt_t *restrict, boolean_t,
+    ikev2_sa_args_t *restrict);
+static boolean_t ikev2_sa_select_acq(parsedmsg_t *restrict, ikev2_dh_t,
+    pkt_t *restrict, ikev2_sa_match_t *restrict);
+static boolean_t ikev2_sa_check_acquire(parsedmsg_t *restrict, ikev2_dh_t,
+    pkt_t *restrict, ikev2_sa_match_t *restrict);
+
+static boolean_t add_ts_init(pkt_t *restrict, parsedmsg_t *restrict);
+static boolean_t add_ts_resp(pkt_t *restrict, const ts_t *restrict,
+    const ts_t *restrict);
+static void resp_set_child_addr(ikev2_child_sa_t *restrict,
+    ikev2_child_sa_t *restrict, struct sockaddr_storage *restrict, uint8_t,
+    boolean_t);
+static boolean_t add_ts_resp_one(pkt_payload_t *restrict,
+    sadb_address_t *restrict, pkt_t *restrict,
+    struct sockaddr_storage *restrict, uint8_t *restrict);
+
+static boolean_t generate_keys(ikev2_sa_t *restrict, ikev2_sa_args_t *);
+static boolean_t create_keymat(ikev2_sa_t *restrict, boolean_t,
+    uint8_t *restrict, size_t,
+    uint8_t *restrict, size_t, prfp_t *restrict);
+static boolean_t ikev2_create_child_sas(ikev2_sa_t *restrict,
+    ikev2_sa_args_t *restrict);
+static void ikev2_save_child_results(ikev2_child_sa_state_t *restrict,
+    const ikev2_sa_match_t *restrict);
+static void ikev2_save_child_ts(ikev2_child_sa_state_t *restrict,
+    const ts_t *restrict, const ts_t *restrict);
+static void ikev2_set_child_type(ikev2_child_sa_state_t *restrict, boolean_t,
+    ikev2_spi_proto_t);
+
+static void check_natt_addrs(pkt_t *restrict, boolean_t);
+static sadb_address_t *get_sadb_addr(parsedmsg_t *, boolean_t);
+static void ikev2_rekey_delete_old_kids(ikev2_sa_t *restrict,
+    ikev2_sa_args_t *restrict);
+
+/*
+ * We are the initiator for an IKE_AUTH exchange, and are performing the
+ * child SA creation that occurs during the IKE AUTH exchange.
+ */
+boolean_t
+ikev2_create_child_sa_init_auth(ikev2_sa_t *restrict sa, pkt_t *restrict req)
+{
+	ikev2_sa_args_t *csa = sa->sa_init_args;
+
+	VERIFY(IS_WORKER);
+	VERIFY(!MUTEX_HELD(&sa->i2sa_queue_lock));
+	VERIFY(MUTEX_HELD(&sa->i2sa_lock));
+
+	VERIFY3U(pkt_header(req)->exch_type, ==, IKEV2_EXCH_IKE_AUTH);
+	VERIFY(sa->flags & I2SA_INITIATOR);
+
+	csa->i2a_is_auth = B_TRUE;
+	csa->i2a_dh = IKEV2_DH_NONE;
+
+	return (ikev2_create_child_sa_init_common(sa, req, csa));
+}
+
+/* We are the initiator in a CREATE_CHILD_SA exchange */
+void
+ikev2_create_child_sa_init(ikev2_sa_t *restrict sa, parsedmsg_t *restrict pmsg)
+{
+	ikev2_sa_args_t *csa = NULL;
+	pkt_t *req = NULL;
+
+	VERIFY(IS_WORKER);
+	VERIFY(!MUTEX_HELD(&sa->i2sa_queue_lock));
+	VERIFY(MUTEX_HELD(&sa->i2sa_lock));
+
+	/*
+	 * This entry point into CREATE_CHILD_SA should only be for kernel
+	 * originated ACQUIRES.
+	 */
+	VERIFY(PMSG_FROM_KERNEL(pmsg));
+
+	/*
+	 * We shouldn't try to initiate any other exchanges until we've
+	 * authenticated.
+	 */
+	VERIFY(sa->flags & I2SA_AUTHENTICATED);
+
+	(void) bunyan_debug(log, "Starting CREATE_CHILD_SA exchange",
+	    BUNYAN_T_END);
+
+	if ((csa = ikev2_sa_args_new(B_TRUE)) == NULL) {
+		(void) bunyan_error(log,
+		    "No memory to perform CREATE_CHILD_SA exchange",
+		    BUNYAN_T_END);
+		goto fail;
+	}
+
+	csa->i2a_i2sa = sa;
+	csa->i2a_pmsg = pmsg;
+	csa->i2a_sadb_msg = pmsg->pmsg_samsg;
+	csa->i2a_dh = sa->i2sa_rule->rule_p2_dh;
+
+	req = ikev2_pkt_new_exchange(sa, IKEV2_EXCH_CREATE_CHILD_SA);
+	if (req == NULL)
+		goto fail;
+
+	if (!ikev2_create_child_sa_init_common(sa, req, csa)) {
+		ikev2_pkt_free(req);
+		goto fail;
+	}
+
+	if (!ikev2_send_req(req, ikev2_create_child_sa_init_resp, csa))
+		goto fail;
+
+	return;
+
+fail:
+	pfkey_send_error(pmsg->pmsg_samsg, ENOMEM);
+	ikev2_sa_args_free(csa);
+}
+
+#ifdef notyet
+/* We are the initiator in a CREATE_CHILD_SA exchange to rekey an AH/ESP SA */
+void
+ikev2_rekey_child_sa_init(ikev2_sa_t *restrict sa, parsedmsg_t *restrict pmsg)
+{
+	sadb_msg_t *samsg = pmsg->pmsg_samsg;
+	sadb_sa_t *saext = (sadb_sa_t *)pmsg->pmsg_exts[SADB_EXT_SA];
+	ikev2_sa_args_t *args = NULL;
+	pkt_t *req = NULL;
+	ikev2_child_sa_t *csa = NULL;
+	ikev2_spi_proto_t satype = satype_to_ikev2(samsg->sadb_msg_satype);
+	uint32_t spi = saext->sadb_sa_spi;
+	boolean_t inbound = !!(saext->sadb_sa_flags & SADB_X_SAFLAGS_INBOUND);
+
+	VERIFY(IS_WORKER);
+	VERIFY(!MUTEX_HELD(&sa->i2sa_queue_lock));
+	VERIFY(MUTEX_HELD(&sa->i2sa_lock));
+
+	/*
+	 * We should only initiate a child SA rekey in response to a kernel
+	 * message.
+	 */
+	VERIFY(PMSG_FROM_KERNEL(pmsg));
+
+	/*
+	 * We shouldn't try to initiate any other exchanges until we've
+	 * authenticated.
+	 */
+	VERIFY(sa->flags & I2SA_AUTHENTICATED);
+
+	/* We must use the inbound SPI for the REKEY_SA notification */
+	if ((csa = ikev2_sa_get_child(sa, spi, inbound)) != NULL) {
+		if (!inbound) {
+			if (csa->i2c_pair == NULL) {
+				/* XXX: Log */
+				parsedmsg_free(pmsg);
+				return;
+			}
+			csa = csa->i2c_pair;
+			spi = csa->i2c_spi;
+		}
+	} else {
+		(void) bunyan_info(log,
+		    "Received SADB_EXPIRE message for non-existent child SA; "
+		    "ignoring",
+		    BUNYAN_T_STRING, "satype", ikev2_spi_str(satype),
+		    BUNYAN_T_STRING, "spi", enum_printf("%" PRIx32, spi),
+		    BUNYAN_T_END);
+		parsedmsg_free(pmsg);
+		return;
+	}
+	args->i2a_old_csa = csa;
+
+	(void) bunyan_debug(log, "Starting rekey CREATE_CHILD_SA exchange",
+	    BUNYAN_T_STRING, "satype", ikev2_spi_str(satype),
+	    BUNYAN_T_STRING, "spi", enum_printf("%" PRIx32, spi),
+	    BUNYAN_T_END);
+
+	if ((args = ikev2_sa_args_new(B_TRUE)) == NULL) {
+		(void) bunyan_error(log,
+		    "No memory to perform CREATE_CHILD_SA exchange",
+		    BUNYAN_T_END);
+		goto fail;
+	}
+
+	args->i2a_i2sa = sa;
+	args->i2a_pmsg = pmsg;
+	args->i2a_sadb_msg = pmsg->pmsg_samsg;
+	args->i2a_dh = sa->i2sa_rule->rule_p2_dh;
+	args->i2a_old_csa = csa;
+
+	req = ikev2_pkt_new_exchange(sa, IKEV2_EXCH_CREATE_CHILD_SA);
+	if (req == NULL)
+		goto fail;
+
+	VERIFY(ikev2_add_notify_full(req, satype, spi, IKEV2_N_REKEY_SA,
+	    NULL, 0));
+
+	if (!ikev2_create_child_sa_init_common(sa, req, args)) {
+		ikev2_pkt_free(req);
+		goto fail;
+	}
+
+	if (!ikev2_send_req(req, ikev2_rekey_child_sa_init_resp, args))
+		goto fail;
+
+	return;
+
+fail:
+	/* XXX: Do we need to reply to SADB_EXPIRE messages if we failed? */
+	pfkey_send_error(pmsg->pmsg_samsg, ENOMEM);
+	ikev2_sa_args_free(args);
+}
+#endif
+
+/* We are the initiator, shared bits for IKE_AUTH and CREATE_CHILD_SA */
+static boolean_t
+ikev2_create_child_sa_init_common(ikev2_sa_t *restrict sa, pkt_t *restrict req,
+    ikev2_sa_args_t *restrict csa)
+{
+	parsedmsg_t *pmsg = csa->i2a_pmsg;
+	ikev2_dh_t dh = csa->i2a_dh;
+	ikev2_spi_proto_t proto;
+	uint32_t spi = 0;
+	uint8_t satype = csa->i2a_sadb_msg->sadb_msg_satype;
+	boolean_t transport_mode = PMSG_IS_TRANSPORT(pmsg);
+
+	csa->i2a_child[CSA_IN].csa_child->i2c_transport = transport_mode;
+	csa->i2a_child[CSA_OUT].csa_child->i2c_transport = transport_mode;
+
+	proto = satype_to_ikev2(satype);
+
+	if (!pfkey_getspi(pmsg, satype, &spi)) {
+		goto fail;
+	}
+
+	/* Stash until we get our reply */
+	csa->i2a_spi = spi;
+	csa->i2a_child[CSA_IN].csa_child->i2c_spi = spi;
+
+	/* XXX: IPcomp (when we add support) */
+
+	if (transport_mode && !ikev2_add_notify(req,
+	    IKEV2_N_USE_TRANSPORT_MODE))
+		goto fail;
+
+	if (!ikev2_add_notify(req, IKEV2_N_ESP_TFC_PADDING_NOT_SUPPORTED))
+		goto fail;
+
+	if (!ikev2_add_notify(req, IKEV2_N_NON_FIRST_FRAGMENTS_ALSO))
+		goto fail;
+
+	if (!ikev2_sa_from_acquire(req, pmsg, spi, dh))
+		goto fail;
+
+	/*
+	 * For the piggy-backed child SA in an IKE_AUTH exchange, the original
+	 * nonces and DH keys from the IKE_SA_INIT packet are used instead of
+	 * generating new ones.
+	 */
+	if (!IS_AUTH(csa)) {
+		if (!ikev2_create_nonce(csa, B_TRUE, IKEV2_NONCE_DEFAULT))
+			goto fail;
+		if (!ikev2_add_nonce(req, csa->i2a_nonce_i,
+		    csa->i2a_nonce_i_len))
+			goto fail;
+
+		if (csa->i2a_dh != IKEV2_DH_NONE &&
+		    !ikev2_add_ke(req, csa->i2a_dh, csa->i2a_pubkey))
+			goto fail;
+	}
+
+	if (!add_ts_init(req, pmsg))
+		goto fail;
+
+	return (B_TRUE);
+
+fail:
+	(void) pfkey_delete(satype, spi, pmsg->pmsg_sau, pmsg->pmsg_dau,
+	    B_FALSE);
+	return (B_FALSE);
+}
+
+/*
+ * We are the responder, we are doing the child SA creation that
+ * occurs during an IKE_AUTH exchange.
+ */
+boolean_t
+ikev2_create_child_sa_resp_auth(pkt_t *restrict req, pkt_t *restrict resp)
+{
+	ikev2_sa_args_t *csa = req->pkt_sa->sa_init_args;
+
+	VERIFY3U(pkt_header(resp)->exch_type, ==, IKEV2_EXCH_IKE_AUTH);
+
+	csa->i2a_is_auth = B_TRUE;
+
+	/*
+	 * The create child SA operation within an IKE_AUTH exchange cannot
+	 * do a second DH keyexchange.  Instead the exchanged key from the
+	 * IKE_SA_INIT exchange is re-used only for this child SA.
+	 */
+	csa->i2a_dh = IKEV2_DH_NONE;
+
+	return (ikev2_create_child_sa_resp_common(req, resp, csa));
+}
+
+/* We are the responder in a CREATE_CHILD_SA exchange */
+void
+ikev2_create_child_sa_resp(pkt_t *restrict req)
+{
+	ikev2_sa_t *i2sa = req->pkt_sa;
+	pkt_t *resp = NULL;
+	ikev2_sa_args_t *csa = NULL;
+
+	if (!(i2sa->flags & I2SA_AUTHENTICATED)) {
+		(void) bunyan_info(log,
+		    "Received CREATE_CHILD_SA request on unauthenciated IKE SA;"
+		    " discarding", BUNYAN_T_END);
+		return;
+	}
+
+	if ((resp = ikev2_pkt_new_response(req)) == NULL) {
+		(void) bunyan_error(log,
+		    "No memory to respond to CREATE_CHILD_SA request",
+		    BUNYAN_T_END);
+		return;
+	}
+
+	if ((csa = ikev2_sa_args_new(B_TRUE)) == NULL) {
+		/*
+		 * There's no specific error notification for this situation,
+		 * however NO_PROPOSAL_CHOSEN is despite it's name a general
+		 * catch-all 'error' notification, so we use that.
+		 */
+		(void) bunyan_error(log,
+		    "No memory to perform CREATE_CHILD_SA exchange; "
+		    "sending NO_PROPOSAL_CHOSEN", BUNYAN_T_END);
+
+		VERIFY(ikev2_add_notify(resp, IKEV2_N_NO_PROPOSAL_CHOSEN));
+		(void) ikev2_send_resp(resp);
+		return;
+	}
+
+	/*
+	 * TODO: Check if REKEY_SA notification is present, if so, delete old
+	 * SAs after we send our response back (we get no acknowledgement of
+	 * our reply, so we just have to do it.
+	 *
+	 * Also, check if we have have initiated a rekey request, and do the
+	 * 'lowest nonce wins' bit form RFC7296 2.8.1
+	 */
+	csa->i2a_dh = i2sa->i2sa_rule->rule_p2_dh;
+
+	if (ikev2_create_child_sa_resp_common(req, resp, csa))
+		(void) ikev2_send_resp(resp);
+	else
+		ikev2_pkt_free(resp);
+
+	ikev2_sa_args_free(csa);
+}
+
+/*
+ * We are the responder (shared bits between IKE_AUTH and CREATE_CHILD_SA).
+ * A fatal error (where we cannot continue) return B_FALSE.  Otherwise
+ * return B_TRUE if we should send the response.
+ */
+static boolean_t
+ikev2_create_child_sa_resp_common(pkt_t *restrict req, pkt_t *restrict resp,
+    ikev2_sa_args_t *restrict csa)
+{
+	ikev2_sa_t *sa = req->pkt_sa;
+	parsedmsg_t *pmsg = NULL;
+	ikev2_spi_proto_t satype = IKEV2_PROTO_NONE;
+	uint32_t spi = 0;
+	ikev2_sa_match_t match = { 0 };
+	ts_t ts_i = { 0 };
+	ts_t ts_r = { 0 };
+	boolean_t narrowed = B_FALSE;
+	boolean_t transport_mode = B_FALSE;
+
+	if (pkt_get_notify(req, IKEV2_N_USE_TRANSPORT_MODE, NULL) != NULL)
+		transport_mode = B_TRUE;
+
+	csa->i2a_child[CSA_IN].csa_child->i2c_transport = transport_mode;
+	csa->i2a_child[CSA_OUT].csa_child->i2c_transport = transport_mode;
+
+	if (csa->i2a_is_auth)
+		check_natt_addrs(req, transport_mode);
+
+	if (!get_resp_policy(req, transport_mode, csa))
+		goto fail;
+
+	if ((pmsg = csa->i2a_pmsg) == NULL) {
+		if (!ikev2_add_notify(resp, IKEV2_N_TS_UNACCEPTABLE))
+			goto fail;
+		return (B_TRUE);
+	}
+	csa->i2a_sadb_msg = pmsg->pmsg_samsg;
+
+	if (!ikev2_sa_select_acq(pmsg, csa->i2a_dh, req, &match)) {
+		(void) bunyan_info(log,
+		    "No proposals matched from initiator",
+		    BUNYAN_T_END);
+
+		goto reply_with_fail;
+	}
+	satype = match.ism_satype;
+
+	if (!IS_AUTH(csa) && ikev2_get_dhgrp(req) != match.ism_dh) {
+		if (!ikev2_invalid_ke(resp, match.ism_dh))
+			goto fail;
+		return (B_TRUE);
+	}
+
+	sadb_to_ts(get_sadb_addr(pmsg, B_FALSE), &ts_i);
+	sadb_to_ts(get_sadb_addr(pmsg, B_TRUE), &ts_r);
+
+	if (!ts_negotiate(req, &ts_i, &ts_r, &narrowed)) {
+		if (!ikev2_add_notify(resp, IKEV2_N_TS_UNACCEPTABLE))
+			goto fail;
+		return (B_TRUE);
+	}
+
+	if (!pfkey_getspi(pmsg, satype, &spi))
+		goto reply_with_fail;
+
+	csa->i2a_child[CSA_IN].csa_child->i2c_spi = spi;
+	ikev2_set_child_type(csa->i2a_child, B_FALSE, satype);
+	ikev2_save_child_results(csa->i2a_child, &match);
+	ikev2_save_child_ts(csa->i2a_child, &ts_i, &ts_r);
+
+	if (!IS_AUTH(csa)) {
+		if (!ikev2_create_nonce(csa, B_FALSE, IKEV2_NONCE_DEFAULT))
+			goto reply_with_fail;
+		ikev2_save_nonce(csa, req);
+
+		if (!dh_genpair(csa->i2a_dh, &csa->i2a_pubkey,
+		    &csa->i2a_privkey))
+			goto reply_with_fail;
+		if (!ikev2_ke(csa, req))
+			goto reply_with_fail;
+	}
+
+	if (!generate_keys(sa, csa))
+		goto reply_with_fail;
+
+	if (!ikev2_create_child_sas(sa, csa))
+		goto reply_with_fail;
+
+	if (transport_mode &&
+	    !ikev2_add_notify(resp, IKEV2_N_USE_TRANSPORT_MODE))
+		goto fail;
+
+	/* We currently don't support TFC PADDING */
+	if (!ikev2_add_notify(resp, IKEV2_N_ESP_TFC_PADDING_NOT_SUPPORTED))
+		goto fail;
+
+	/* and we always include non-first fragments */
+	if (!ikev2_add_notify(resp, IKEV2_N_NON_FIRST_FRAGMENTS_ALSO))
+		goto fail;
+
+	if (!ikev2_sa_add_result(resp, &match, spi))
+		goto fail;
+
+	/*
+	 * For the piggy-backed child SA in an IKE_AUTH exchange, the original
+	 * nonces and DH keys from the IKE_SA_INIT packet are used instead of
+	 * generating new ones.
+	 */
+	if (!IS_AUTH(csa)) {
+		if (!ikev2_add_nonce(resp, csa->i2a_nonce_r,
+		    csa->i2a_nonce_r_len))
+			goto fail;
+
+		if (csa->i2a_dh != IKEV2_DH_NONE &&
+		    !ikev2_add_ke(resp, csa->i2a_dh, csa->i2a_pubkey))
+			goto fail;
+	}
+
+	if (!add_ts_resp(resp, &ts_i, &ts_r))
+		goto fail;
+
+	if (narrowed && !ikev2_add_notify(resp, IKEV2_N_ADDITIONAL_TS_POSSIBLE))
+		goto fail;
+
+	/* XXX: Other notifications? */
+
+	return (B_TRUE);
+
+reply_with_fail:
+	(void) bunyan_info(log,
+	    "Sending NO_PROPOSAL_CHOSEN due to error during processing",
+	    BUNYAN_T_END);
+	if (ikev2_add_notify(resp, IKEV2_N_NO_PROPOSAL_CHOSEN))
+		return (B_TRUE);
+
+	(void) bunyan_error(log,
+	    "Could not add NO_PROPOSAL_CHOSEN notification to reply",
+	    BUNYAN_T_END);
+
+fail:
+	(void) pfkey_delete(satype, spi, pmsg->pmsg_sau, pmsg->pmsg_dau,
+	    B_FALSE);
+	return (B_FALSE);
+}
+
+/*
+ * We are initiator, this is the response from the peer.
+ */
+void
+ikev2_create_child_sa_init_resp_auth(ikev2_sa_t *restrict i2sa,
+    pkt_t *restrict resp, void *restrict arg)
+{
+	ikev2_create_child_sa_init_resp_common(i2sa, resp, arg);
+}
+
+static void
+ikev2_create_child_sa_init_resp(ikev2_sa_t *restrict i2sa, pkt_t *restrict resp,
+    void *restrict arg)
+{
+	ikev2_create_child_sa_init_resp_common(i2sa, resp, arg);
+	ikev2_sa_args_free(arg);
+}
+
+#ifdef notyet
+static void
+ikev2_rekey_child_sa_init_resp(ikev2_sa_t *restrict i2sa, pkt_t *restrict resp,
+    void *restrict arg)
+{
+	ikev2_sa_args_t *sa_arg = arg;
+
+	/*
+	 * TODO: Check if peer initiated a rekey on the same pair of SAs,
+	 * check nonce values and if our nonce values were larger, delete
+	 * the pair we created (RFC7296 2.8.1)
+	 */
+	ikev2_create_child_sa_init_resp_common(i2sa, resp, arg);
+	ikev2_sa_args_free(arg);
+}
+#endif
+
+static void
+ikev2_create_child_sa_init_resp_common(ikev2_sa_t *restrict i2sa,
+    pkt_t *restrict resp, void *restrict arg)
+{
+	ikev2_sa_args_t *csa = arg;
+	parsedmsg_t *pmsg = csa->i2a_pmsg;
+	pkt_notify_t *invalid_ke = NULL;
+	ikev2_sa_match_t match = { 0 };
+	ts_t ts_i = { 0 };
+	ts_t ts_r = { 0 };
+	boolean_t narrowed = B_FALSE;
+
+	if (resp == NULL) {
+		uint8_t satype = pmsg->pmsg_samsg->sadb_msg_satype;
+		if (PMSG_FROM_KERNEL(pmsg))
+			pfkey_send_error(pmsg->pmsg_samsg, ETIME);
+
+		(void) pfkey_delete(satype, csa->i2a_spi,
+		    pmsg->pmsg_sau, pmsg->pmsg_dau, B_FALSE);
+
+		return;
+	}
+
+	if (pkt_get_notify(resp, IKEV2_N_NO_PROPOSAL_CHOSEN, NULL) != NULL) {
+		(void) bunyan_info(log,
+		    "Remote peer responded with NO_PROPOSAL_CHOSEN",
+		    BUNYAN_T_END);
+		goto remote_fail;
+	}
+
+	if (pkt_get_notify(resp, IKEV2_N_TS_UNACCEPTABLE, NULL) != NULL) {
+		(void) bunyan_info(log,
+		    "Remote peer responded to TS_UNACCEPTABLE",
+		    BUNYAN_T_END);
+		goto remote_fail;
+	}
+
+	if ((invalid_ke = pkt_get_notify(resp, IKEV2_N_INVALID_KE_PAYLOAD,
+	    NULL)) != NULL) {
+		if (invalid_ke->pn_len < sizeof (uint16_t)) {
+			(void) bunyan_warn(log,
+			    "Received INVALID_KE_PAYLOAD notification with an "
+			    "invalid dhgrp payload", BUNYAN_T_END);
+			goto remote_fail;
+		}
+
+		/*
+		 * Currently, we only support specifying a single DH group
+		 * for additional non-IKE child SAs.  If we allow specifing
+		 * multiple P2 DH groups in a rule, we could optionally
+		 * elect to perform a new CREATE_CHILD_SA exchange on this
+		 * failure if the requested group still complies with our
+		 * policy.
+		 */
+		uint16_t grp = BE_IN16(invalid_ke->pn_ptr);
+
+		(void) bunyan_warn(log,
+		    "Policy mismatch: peer sent INVALID_KE_PAYLOAD "
+		    "notification",
+		    BUNYAN_T_STRING, "dhgrp", ikev2_dh_str(grp),
+		    BUNYAN_T_END);
+		goto remote_fail;
+	}
+
+	if (!ikev2_sa_check_acquire(pmsg, csa->i2a_dh, resp, &match)) {
+		(void) bunyan_warn(log,
+		    "Peer tried to select a transform not in the original"
+		    "proposed set", BUNYAN_T_END);
+		goto fail;
+	}
+
+	/*
+	 * This is not fatal -- the traffic we wanted to send can be sent,
+	 * but the responder has chosen a subset of our policy, so we want
+	 * to log this.
+	 */
+	if (pkt_get_notify(resp,
+	    IKEV2_N_ADDITIONAL_TS_POSSIBLE, NULL) != NULL) {
+		(void) bunyan_warn(log,
+		    "Policy mismatch with peer", BUNYAN_T_END);
+		/* XXX: Log more details */
+	}
+
+	if (csa->i2a_is_auth)
+		check_natt_addrs(resp, TRANSPORT_MODE(csa));
+
+	sadb_to_ts(get_sadb_addr(pmsg, B_TRUE), &ts_i);
+	sadb_to_ts(get_sadb_addr(pmsg, B_FALSE), &ts_r);
+
+	if (!ts_negotiate(resp, &ts_i, &ts_r, &narrowed)) {
+		(void) bunyan_warn(log,
+		    "Responder sent traffic selectors not in our policy",
+		    BUNYAN_T_END);
+		goto fail;
+	}
+
+	ikev2_set_child_type(csa->i2a_child, B_TRUE, match.ism_satype);
+	ikev2_save_child_results(csa->i2a_child, &match);
+	ikev2_save_child_ts(csa->i2a_child, &ts_i, &ts_r);
+
+	if (!IS_AUTH(csa)) {
+		ikev2_save_nonce(csa, resp);
+
+		if (!ikev2_ke(csa, resp))
+			goto fail;
+	}
+
+	if (!generate_keys(i2sa, csa))
+		goto fail;
+
+	if (!ikev2_create_child_sas(i2sa, csa))
+		goto fail;
+
+	return;
+
+fail:
+	/*
+	 * TODO: If the creation of our child SAs fails for some reason, we
+	 * probably want to do an INFORMATIONAL exchange for the peer to delete
+	 * the ones they just created.  While we normally decouple the IPsec
+	 * SAs (so that if in.ikev2d exits, the IPsec SAs can persist through
+	 * the end of their lifetime, or until in.ikev2d is restarted and it
+	 * receives an INITIAL_CONTACT notification), in this situation we
+	 * already know that we will not be able to send traffic, so there
+	 * is no point in the peer keeping their IPsec SAs to us around.
+	 */
+	;
+
+remote_fail:
+	if (PMSG_FROM_KERNEL(pmsg))
+		pfkey_send_error(pmsg->pmsg_samsg, EINVAL);
+}
+
+static void ikev2_hard_expire_reply(ikev2_sa_t *restrict, pkt_t *restrict,
+    void *restrict);
+
+void
+ikev2_hard_expire(ikev2_sa_t *restrict i2sa, parsedmsg_t *pmsg)
+{
+	sadb_sa_t *saext = (sadb_sa_t *)pmsg->pmsg_exts[SADB_EXT_SA];
+	ikev2_child_sa_t *csa = NULL;
+	pkt_t *req = NULL;
+	uint64_t spi = 0;
+	ikev2_spi_proto_t satype;
+
+	if (saext == NULL) {
+		(void) bunyan_info(log,
+		    "Received an SADB_EXPIRE message without an SA extension",
+		    BUNYAN_T_END);
+		goto fail;
+	}
+
+	/*
+	 * Since we control the lifetimes on our end, we always set both
+	 * SAs in a pair to the same lifetime, so they should expire at
+	 * effectively the same time (since each SA is created in a separate
+	 * pf_key(7P) message, there is possibly a small delay that we can
+	 * ignore).  We must only send the outbound (to us) SPIs in a delete
+	 * request, so we ignore hard expires of inbound SAs
+	 */
+	if (saext->sadb_sa_flags & SADB_X_SAFLAGS_INBOUND) {
+		parsedmsg_free(pmsg);
+		return;
+	}
+
+	satype = satype_to_ikev2(pmsg->pmsg_samsg->sadb_msg_satype);
+	spi = saext->sadb_sa_spi;
+
+	csa = ikev2_sa_get_child(i2sa, spi, B_FALSE);
+	if (csa == NULL) {
+		/*
+		 * It (for now at least) appears possible there could be a small
+		 * race where the peer causes us to delete an SA, but a hard
+		 * expire message still ends up being queued.  There's no harm
+		 * if it's already deleted, so we just log it.
+		 */
+		(void) bunyan_info(log,
+		    "Received an SADB_EXPIRE message for a non-existent SA",
+		    BUNYAN_T_STRING, "satype", ikev2_spi_str(satype),
+		    BUNYAN_T_STRING, "spi", enum_printf("%" PRIx64, spi),
+		    BUNYAN_T_END);
+
+		goto fail;
+	}
+	csa->i2c_moribund = B_TRUE;
+
+	req = ikev2_pkt_new_exchange(i2sa, IKEV2_EXCH_INFORMATIONAL);
+	if (req == NULL)
+		goto fail;
+
+	/* This is the second payload, it should fit */
+	VERIFY(ikev2_add_delete(req, satype, &spi, 1));
+
+	parsedmsg_free(pmsg);
+	pmsg = NULL;
+
+	if (!ikev2_send_req(req, ikev2_hard_expire_reply, csa))
+		goto fail;
+
+	return;
+
+fail:
+	ikev2_pkt_free(req);
+	parsedmsg_free(pmsg);
+}
+
+void
+ikev2_handle_delete(ikev2_sa_t *restrict i2sa, pkt_payload_t *restrict delpay,
+    pkt_t *restrict resp)
+{
+	VERIFY3U(delpay->pp_type, ==, IKEV2_PAYLOAD_DELETE);
+	ikev2_delete_t *del = (ikev2_delete_t *)delpay->pp_ptr;
+	uint32_t *spiptr = (uint32_t *)(del + 1);
+	uint64_t *spiresp = NULL;
+	struct sockaddr_storage src = { 0 };
+	struct sockaddr_storage dst = { 0 };
+	sockaddr_u_t srcu = { .sau_ss = &src };
+	sockaddr_u_t dstu = { .sau_ss = &dst };
+	ikev2_spi_proto_t i2satype = del->del_protoid;
+	uint16_t nspi = BE_IN16(&del->del_nspi);
+	uint16_t nspiresp = 0;
+	uint8_t satype = 0;
+	uint8_t spilen = del->del_spisize;
+
+	switch (i2satype) {
+	case IKEV2_PROTO_NONE:
+	case IKEV2_PROTO_FC_ESP_HEADER:
+	case IKEV2_PROTO_FC_CT_AUTH:
+	case IKEV2_PROTO_IKE:
+		(void) bunyan_info(log,
+		    "Unsupported SA type in DELETE payload",
+		    BUNYAN_T_STRING, "satype", ikev2_spi_str(i2satype),
+		    BUNYAN_T_END);
+		return;
+	case IKEV2_PROTO_AH:
+	case IKEV2_PROTO_ESP:
+		if (spilen != sizeof (uint32_t)) {
+			(void) bunyan_error(log,
+			    "Unexpected SPI size in DELETE payload",
+			    BUNYAN_T_UINT32, "spisize", (uint32_t)spilen,
+			    BUNYAN_T_UINT32, "expected",
+			    (uint32_t)sizeof (uint32_t), BUNYAN_T_END);
+			return;
+		}
+		satype = ikev2_to_satype(del->del_protoid);
+		break;
+	}
+
+	spiresp = umem_calloc(nspi, sizeof (uint64_t), UMEM_DEFAULT);
+	if (spiresp == NULL) {
+		(void) bunyan_error(log, "No memory for DELETE response",
+		    BUNYAN_T_END);
+		(void) ikev2_add_notify(resp, IKEV2_N_TEMPORARY_FAILURE);
+		return;
+	}
+
+	/* The SPIs in DELETE payloads are always inbound */
+	sockaddr_copy(SSTOSA(&i2sa->raddr), &src, B_FALSE);
+	sockaddr_copy(SSTOSA(&i2sa->laddr), &dst, B_FALSE);
+
+	for (uint16_t i = 0; i < nspi; i++, spiptr++) {
+		ikev2_child_sa_t *csa = NULL;
+		uint32_t spi = BE_IN32(spiptr);
+
+		csa = ikev2_sa_get_child(i2sa, spi, B_TRUE);
+		if (csa == NULL) {
+			(void) ikev2_add_notify_full(resp, i2satype, spi,
+			    IKEV2_N_CHILD_SA_NOT_FOUND, NULL, 0);
+			(void) bunyan_info(log,
+			    "SPI not found in DELETE payload",
+			    BUNYAN_T_STRING, "spi",
+			    enum_printf("%" PRIx32, spi), BUNYAN_T_END);
+			continue;
+		}
+
+		/*
+		 * RFC7296 1.4.1 If we've already sent a DELETE request
+		 * (which from our perspective be the outbound aka paired
+		 * SPI), we don't send the SPI back in a delete payload
+		 */
+		if (csa->i2c_pair != NULL && !csa->i2c_moribund) {
+			ikev2_child_sa_t *pair = csa->i2c_pair;
+
+			spiresp[nspiresp++] = pair->i2c_spi;
+			ikev2_sa_delete_child(i2sa, pair);
+		}
+
+		ikev2_sa_delete_child(i2sa, csa);
+		(void) pfkey_delete(satype, spi, srcu, dstu, B_TRUE);
+	}
+
+	(void) ikev2_add_delete(resp, i2satype, spiresp, nspiresp);
+	umem_cfree(spiresp, nspiresp, sizeof (uint64_t));
+}
+
+static void
+ikev2_hard_expire_reply(ikev2_sa_t *restrict i2sa, pkt_t *restrict reply,
+    void *restrict arg)
+{
+	ikev2_child_sa_t *csa = arg;
+
+	/*
+	 * The reply should at best only send back the SPI of the pairs we
+	 * sent.  Since we already link our SPIs via the pair extension
+	 * we really don't care about the SPIs sent back.
+	 */
+	if (csa->i2c_pair != NULL)
+		ikev2_sa_delete_child(i2sa, csa->i2c_pair);
+	ikev2_sa_delete_child(i2sa, csa);
+
+	if (reply == NULL)
+		return;
+
+	/* There's no action we can do on an error, just log it */
+	for (size_t i = 0; i < reply->pkt_notify_count; i++) {
+		pkt_notify_t *n = pkt_notify(reply, i);
+
+		if (IKEV2_NOTIFY_ERROR(n->pn_type)) {
+			char msg[128] = { 0 };
+
+			(void) snprintf(msg, sizeof (msg),
+			    "Received %s error from a DELETE request",
+			    ikev2_notify_str(n->pn_type));
+
+			(void) bunyan_info(log, msg, BUNYAN_T_END);
+		}
+	}
+
+}
+
+/*
+ * Generate an SA payload from a regular SADB_ACQUIRE message.
+ *	pkt	The packet the payload is being added to
+ *	pmsg	The parsed SADB_ACQUIRE message
+ *	spi	The outbound SPI to include in each proposal in the SA payload
+ *	dh	The DH group to include in each proposal (or IKEV2_DH_NONE to
+ *		not request a new DH key exchange.
+ *
+ * Returns B_TRUE if payload as successfully added, B_FALSE on error.
+ */
+static boolean_t
+ikev2_sa_from_acquire(pkt_t *restrict pkt, parsedmsg_t *restrict pmsg,
+    uint32_t spi, ikev2_dh_t dh)
+{
+	sadb_msg_t *samsg = pmsg->pmsg_samsg;
+	sadb_prop_t *prop;
+	sadb_comb_t *comb, *end;
+	size_t propnum = 0;
+	ikev2_spi_proto_t spi_type = IKEV2_PROTO_NONE;
+	boolean_t ok;
+	pkt_sa_state_t pss;
+
+	VERIFY3U(samsg->sadb_msg_type, ==, SADB_ACQUIRE);
+
+	switch (samsg->sadb_msg_satype) {
+	case SADB_SATYPE_AH:
+		spi_type = IKEV2_PROTO_AH;
+		break;
+	case SADB_SATYPE_ESP:
+		spi_type = IKEV2_PROTO_ESP;
+		break;
+	default:
+		(void) bunyan_error(log,
+		    "Unknown/unexpected SA type received from kernel; aborting "
+		    "IPsec SA creation",
+		    BUNYAN_T_UINT32, "satype",
+		    (uint32_t)samsg->sadb_msg_satype);
+		return (B_FALSE);
+	}
+
+	prop = (sadb_prop_t *)pmsg->pmsg_exts[SADB_EXT_PROPOSAL];
+	VERIFY3U(prop->sadb_prop_exttype, ==, SADB_EXT_PROPOSAL);
+
+	ok = ikev2_add_sa(pkt, &pss);
+
+	end = (sadb_comb_t *)((uint64_t *)prop + prop->sadb_prop_len);
+	for (comb = (sadb_comb_t *)(prop + 1); comb < end; comb++) {
+		/* RFC7296 3.3.1 proposal numbers start with 1 */
+		ok &= ikev2_add_prop(&pss, ++propnum, spi_type, spi);
+
+		if (comb->sadb_comb_encrypt != SADB_EALG_NONE) {
+			ikev2_xf_encr_t encr;
+			uint16_t minbits, maxbits;
+
+			encr = ikev2_pfkey_to_encr(comb->sadb_comb_encrypt);
+			minbits = comb->sadb_comb_encrypt_minbits;
+			maxbits = comb->sadb_comb_encrypt_maxbits;
+			ok &= ikev2_add_xf_encr(&pss, encr, minbits, maxbits);
+		}
+
+		if (comb->sadb_comb_auth != SADB_AALG_NONE) {
+			ikev2_xf_auth_t xf_auth;
+			size_t keylen;
+
+			xf_auth = ikev2_pfkey_to_auth(comb->sadb_comb_auth);
+			VERIFY3S(xf_auth, <=, IKEV2_XF_AUTH_MAX);
+
+			keylen = SADB_8TO1(auth_data(xf_auth)->ad_keylen);
+			VERIFY3U(comb->sadb_comb_auth_minbits, ==, keylen);
+			VERIFY3U(comb->sadb_comb_auth_maxbits, ==, keylen);
+
+			ok &= ikev2_add_xform(&pss, IKEV2_XF_AUTH, xf_auth);
+		}
+
+		if (dh != IKEV2_DH_NONE)
+			ok &= ikev2_add_xform(&pss, IKEV2_XF_DH, dh);
+
+		/* We currently don't support ESNs */
+		ok &= ikev2_add_xform(&pss, IKEV2_XF_ESN, IKEV2_ESN_NONE);
+	}
+
+	return (ok);
+}
+
+static boolean_t ikev2_sa_select_ecomb(sadb_x_ecomb_t *restrict, ikev2_dh_t,
+    pkt_payload_t *restrict, uint_t, ikev2_sa_match_t *restrict);
+static boolean_t ikev2_sa_select_prop(sadb_x_ecomb_t *restrict, ikev2_dh_t,
+    ikev2_sa_proposal_t *restrict, uint_t, ikev2_sa_match_t *restrict);
+static boolean_t ikev2_sa_select_encr_attr(sadb_x_algdesc_t *restrict,
+    ikev2_transform_t *restrict, ikev2_sa_match_t *restrict);
+
+/*
+ * Select an SA proposal from the initiator.
+ *	pmsg	Our local policy (an extended SADB_ACQUIRE message)
+ *	req	The initiator's request packet
+ *	m	Where the matching parameters are written
+ *
+ * Returns B_TRUE if a match was found, B_FALSE otherwise.
+ *
+ * An SA payload contains one or more proposals.  Each proposal contains a
+ * protocol (SA type -- AH, ESP, etc.) and SPI value followed by the list of
+ * allowable transforms for the proposal.  While unusual, there doesn't appear
+ * to be anything in RFC7296 that forbids an initiator from proposing different
+ * protocols in an SA payload.  As it happens, when we query the kernel for
+ * the local policy using an SADB_X_INVERSE_ACQUIRE, it returns extended
+ * ACQUIRE messages (which will contain the policy for all SA types between
+ * the given addresses), but we can only choose a single proposal (or none),
+ * thus must also potentially decide on what type of SA to create.
+ *
+ * To solve these issues, we check for matches for all supported SA types
+ * (AH and ESP).  If only one SA type has a match, it is used.  If multiple
+ * SA types match, we use an ESP match over an AH match.  If none match, we
+ * fail and nothing is chosen.
+ */
+static boolean_t
+ikev2_sa_select_acq(parsedmsg_t *restrict pmsg, ikev2_dh_t dh,
+    pkt_t *restrict req, ikev2_sa_match_t *restrict m)
+{
+	/* In order of preference */
+	static const uint_t sa_types[] = { SADB_SATYPE_ESP, SADB_SATYPE_AH };
+
+	pkt_payload_t *sa_pay = pkt_get_payload(req, IKEV2_PAYLOAD_SA, NULL);
+	sadb_prop_t *eprop = (sadb_prop_t *)pmsg->pmsg_exts[SADB_X_EXT_EPROP];
+	sadb_x_ecomb_t *ecomb = NULL;
+
+	if (sa_pay == NULL) {
+		(void) bunyan_warn(log,
+		    "CREATE_CHILD_SA request is missing an SA payload; "
+		    "cannot create IPsec SA", BUNYAN_T_END);
+		return (B_FALSE);
+	}
+
+	/* get_resp_policy fails if an SADB_X_EXT_EPROP extension is missing */
+	VERIFY3P(eprop, !=, NULL);
+
+	ecomb = (sadb_x_ecomb_t *)(eprop + 1);
+
+	for (size_t i = 0; i < eprop->sadb_x_prop_numecombs; i++) {
+		sadb_x_algdesc_t *alg = (sadb_x_algdesc_t *)(ecomb + 1);
+
+		(void) bunyan_debug(log, "Checking extended combination",
+		    BUNYAN_T_UINT32, "idx", (uint32_t)i,
+		    BUNYAN_T_END);
+
+		for (size_t j = 0; j < ARRAY_SIZE(sa_types); j++) {
+			if (ikev2_sa_select_ecomb(ecomb, dh, sa_pay,
+			    sa_types[j], m))
+				return (B_TRUE);
+		}
+
+		ecomb = (sadb_x_ecomb_t *)(alg + ecomb->sadb_x_ecomb_numalgs);
+	}
+
+	return (B_FALSE);
+}
+
+static boolean_t
+ikev2_sa_select_ecomb(sadb_x_ecomb_t *restrict ecomb, ikev2_dh_t dh,
+    pkt_payload_t *restrict sa, uint_t satype, ikev2_sa_match_t *restrict m)
+{
+	sadb_x_algdesc_t *alg = NULL;
+	ikev2_sa_proposal_t *i2prop = NULL;
+
+	(void) bunyan_debug(log, "Checking proposals for satype",
+	    BUNYAN_T_STRING, "satype", ikev2_spi_str(satype),
+	    BUNYAN_T_END);
+
+	FOREACH_PROP(i2prop, sa) {
+		if (i2prop->proto_protoid != satype)
+			continue;
+
+		bzero(m, sizeof (*m));
+
+		m->ism_spi = ikev2_prop_spi(i2prop);
+		m->ism_satype = satype;
+		m->ism_propnum = i2prop->proto_proposalnr;
+
+		(void) bunyan_debug(log, "Checking proposal",
+		    BUNYAN_T_UINT32, "proposal_num", (uint32_t)m->ism_propnum,
+		    BUNYAN_T_STRING, "protocol", ikev2_spi_str(m->ism_satype),
+		    BUNYAN_T_STRING, "spi", enum_printf("0x%08x", m->ism_spi),
+		    BUNYAN_T_END);
+
+		/* Found a proposal with the SA type we're interested in */
+		if (ikev2_sa_select_prop(ecomb, dh, i2prop, satype, m))
+			return (B_TRUE);
+	}
+
+	return (B_FALSE);
+}
+
+static boolean_t
+ikev2_sa_select_prop(sadb_x_ecomb_t *restrict ecomb, ikev2_dh_t dh,
+    ikev2_sa_proposal_t *restrict i2prop, uint_t satype,
+    ikev2_sa_match_t *restrict m)
+{
+	sadb_x_algdesc_t *alg = (sadb_x_algdesc_t *)(ecomb + 1);
+	ikev2_transform_t *xf = NULL;
+
+	VERIFY3U(i2prop->proto_protoid, ==, satype);
+
+	for (size_t i = 0; i < ecomb->sadb_x_ecomb_numalgs; i++, alg++) {
+		ikev2_xf_type_t algtype = 0;
+		uint16_t sadb_id = 0;
+
+		if (alg->sadb_x_algdesc_satype != satype)
+			continue;
+
+		/* Odd, but treat 'no alg' the same as if it wasn't present */
+		if (alg->sadb_x_algdesc_alg == 0)
+			continue;
+
+		switch (alg->sadb_x_algdesc_algtype) {
+		case SADB_X_ALGTYPE_CRYPT:
+			algtype = IKEV2_XF_ENCR;
+			sadb_id = ikev2_pfkey_to_encr(alg->sadb_x_algdesc_alg);
+			break;
+		case SADB_X_ALGTYPE_AUTH:
+			algtype = IKEV2_XF_AUTH;
+			sadb_id = ikev2_pfkey_to_auth(alg->sadb_x_algdesc_alg);
+			break;
+		default:
+			(void) bunyan_warn(log,
+			    "Received an extended proposal from the kernel "
+			    " with an unknown algtype; discarding",
+			    BUNYAN_T_UINT32, "algtype",
+			    (uint32_t)alg->sadb_x_algdesc_alg, BUNYAN_T_END);
+			return (B_FALSE);
+		}
+
+		m->ism_have |= SEEN(algtype);
+
+		FOREACH_XF(xf, i2prop) {
+			uint16_t xfid = BE_IN16(&xf->xf_id);
+
+			/*
+			 * Make note of the types of transforms seen in the
+			 * IKEv2 proposal.  Any unknown transform types
+			 * cause us to reject the proposal (RFC7296 3.3.6)
+			 */
+			switch ((ikev2_xf_type_t)xf->xf_type) {
+			case IKEV2_XF_DH:
+			case IKEV2_XF_ESN:
+				/*
+				 * SADB proposals do not support indicating a
+				 * DH group or the use of ESNs.  These
+				 * transforms are handled after the rest.
+				 */
+				continue;
+			case IKEV2_XF_PRF:
+				/* Never valid for a child SA creation */
+				(void) bunyan_warn(log,
+				    "Proposal contained PRF transform",
+				    BUNYAN_T_END);
+				return (B_FALSE);
+			default:
+				(void) bunyan_debug(log,
+				    "Unknown transform type",
+				    BUNYAN_T_UINT32, "xftype",
+				    (uint32_t)xf->xf_type, BUNYAN_T_END);
+				break;
+			case IKEV2_XF_ENCR:
+			case IKEV2_XF_AUTH:
+				/* Ignore 'none' ids */
+				if (xfid != 0)
+					m->ism_seen |= SEEN(xf->xf_type);
+				break;
+			}
+
+			if (xf->xf_type != algtype)
+				continue;
+
+			(void) bunyan_debug(log, "Checking transform",
+			    BUNYAN_T_STRING, "xftype",
+			    ikev2_xf_type_str(xf->xf_type),
+			    BUNYAN_T_STRING, "xfval",
+			    ikev2_xf_str(xf->xf_type, xfid), BUNYAN_T_END);
+
+			/*
+			 * Use the first match found for a given transform
+			 * type.  The mechanisms given to us by the kernel
+			 * are in the same order the policies were added
+			 * via ipsecconf(1M), so this allows the operator
+			 * supplied order to act as the preference in which
+			 * to pick mechanisms.
+			 */
+			if (SA_MATCHES(m, xf->xf_type))
+				continue;
+
+			if (sadb_id != xfid)
+				continue;
+
+			switch ((ikev2_xf_type_t)xf->xf_type) {
+			case IKEV2_XF_ENCR: {
+				const encr_data_t *ed = NULL;
+
+				if ((ed = encr_data(xfid)) == NULL)
+					return (B_FALSE);
+				if (!ikev2_sa_select_encr_attr(alg, xf, m))
+					return (B_FALSE);
+
+				m->ism_encr = xfid;
+				m->ism_encr_saltlen =
+				    alg->sadb_x_algdesc_reserved;
+				if (m->ism_encr_keylen == 0)
+					m->ism_encr_keylen = ed->ed_keydefault;
+
+				m->ism_match |= SEEN(xf->xf_type);
+				break;
+			}
+			case IKEV2_XF_PRF:
+				/*
+				 * Our local policy should NEVER allow us to
+				 * have a PRF match on an IPsec SA.  PRFs are
+				 * only neogitated for IKE SAs.
+				 */
+				INVALID(xf->xf_type);
+				break;
+			case IKEV2_XF_AUTH:
+				if (auth_data(xfid) == NULL)
+					return (B_FALSE);
+				if (XF_HAS_ATTRS(xf))
+					return (B_FALSE);
+
+				m->ism_auth = xfid;
+				m->ism_match |= SEEN(xf->xf_type);
+				break;
+			case IKEV2_XF_DH:
+			case IKEV2_XF_ESN:
+				continue;
+			}
+
+			(void) bunyan_debug(log, "Transform match",
+			    BUNYAN_T_STRING, "xftype",
+			    ikev2_xf_type_str(xf->xf_type),
+			    BUNYAN_T_STRING, "xfval",
+			    ikev2_xf_str(xf->xf_type, xfid), BUNYAN_T_END);
+		}
+	}
+
+	/* Check DH and ESN if everything else has matched */
+	if (!SA_MATCH(m))
+		return (B_FALSE);
+
+	/* ESN transform is always required for AH and ESN */
+	m->ism_have |= SEEN(IKEV2_XF_ESN);
+
+	if (dh != IKEV2_DH_NONE)
+		m->ism_have |= SEEN(IKEV2_XF_DH);
+
+	FOREACH_XF(xf, i2prop) {
+		uint16_t id = BE_IN16(&xf->xf_id);
+
+		if (xf->xf_type != IKEV2_XF_DH && xf->xf_type != IKEV2_XF_ESN)
+			continue;
+
+		(void) bunyan_debug(log, "Checking transform",
+		    BUNYAN_T_STRING, "xftype", ikev2_xf_type_str(xf->xf_type),
+		    BUNYAN_T_STRING, "xfval", ikev2_xf_str(xf->xf_type, id),
+		    BUNYAN_T_END);
+
+		if (SA_MATCHES(m, xf->xf_type))
+			continue;
+
+		switch (xf->xf_type) {
+		case IKEV2_XF_DH:
+			/* Ignore a none transform */
+			if (id != IKEV2_DH_NONE)
+				m->ism_seen |= SEEN(IKEV2_XF_DH);
+
+			if (id != dh)
+				continue;
+
+			m->ism_match |= SEEN(IKEV2_XF_DH);
+			m->ism_dh = id;
+			break;
+		case IKEV2_XF_ESN:
+			m->ism_seen |= SEEN(IKEV2_XF_ESN);
+
+			if (id != IKEV2_ESN_NONE)
+				continue;
+
+			m->ism_match |= SEEN(IKEV2_XF_ESN);
+			m->ism_esn = B_FALSE;
+			break;
+		}
+
+		if (SA_MATCH_HAS(m, xf->xf_type)) {
+			(void) bunyan_debug(log, "Transform match",
+			    BUNYAN_T_STRING, "xftype",
+			    ikev2_xf_type_str(xf->xf_type),
+			    BUNYAN_T_STRING, "xfval",
+			    ikev2_xf_str(xf->xf_type, id),
+			    BUNYAN_T_END);
+		}
+	}
+
+	if (SA_MATCH(m)) {
+		(void) bunyan_debug(log, "Propsal match",
+		    BUNYAN_T_UINT32, "proposal_num", (uint32_t)m->ism_propnum,
+		    BUNYAN_T_STRING, "protocol", ikev2_spi_str(m->ism_satype),
+		    BUNYAN_T_STRING, "spi", enum_printf("0x%08x", m->ism_spi),
+		    BUNYAN_T_STRING, "encr", ikev2_xf_encr_str(m->ism_encr),
+		    BUNYAN_T_UINT32, "encr_keylen",
+		    (uint32_t)m->ism_encr_keylen,
+		    BUNYAN_T_STRING, "auth", ikev2_xf_auth_str(m->ism_auth),
+		    BUNYAN_T_STRING, "dh", ikev2_dh_str(m->ism_dh),
+		    BUNYAN_T_STRING, "esn", m->ism_esn ? "YES" : "NO",
+		    BUNYAN_T_END);
+		return (B_TRUE);
+	}
+
+	return (B_FALSE);
+}
+
+static boolean_t
+ikev2_sa_select_encr_attr(sadb_x_algdesc_t *restrict alg,
+    ikev2_transform_t *restrict xf, ikev2_sa_match_t *restrict m)
+{
+	ikev2_attribute_t *attr = NULL;
+	const encr_data_t *ed = NULL;
+	uint16_t xfid = BE_IN16(&xf->xf_id);
+
+	ed = encr_data(xfid);
+	VERIFY3U(alg->sadb_x_algdesc_algtype, ==, SADB_X_ALGTYPE_CRYPT);
+
+	/*
+	 * Currently, only a single attribute (IKEV2_XF_ATTR_KEYLEN) is
+	 * defined.  It is only defined for encryption transforms.
+	 * Unfortunately, encryption mechanism keylenghts are somewhat
+	 * complicated.  Some mechanisms (e.g. AES) always require a
+	 * keylength attribute, some (e.g. blowfish) can optionally specify a
+	 * keylength while others (e.g. 3DES) have a fixed key size and should
+	 * not include * a keylength attribute.
+	 */
+
+	/* Should there be a keylength included? */
+	if (!XF_HAS_ATTRS(xf) && encr_keylen_req(ed)) {
+		(void) bunyan_warn(log,
+		    "Transform missing required key length attribute",
+		    BUNYAN_T_STRING, "xftype", ikev2_xf_type_str(xf->xf_type),
+		    BUNYAN_T_STRING, "xfid", ikev2_xf_str(xf->xf_type, xfid),
+		    BUNYAN_T_END);
+		return (B_FALSE);
+	}
+
+	FOREACH_ATTR(attr, xf) {
+		uint16_t attr_type = BE_IN16(&attr->attr_type);
+		uint16_t attr_len = BE_IN16(&attr->attr_length);
+		boolean_t tv = B_FALSE;
+
+		if (IKE_ATTR_GET_TYPE(attr_type) == IKE_ATTR_TV)
+			tv = B_TRUE;
+
+		attr_type = IKE_ATTR_GET_TYPE(attr_type);
+
+		/* Unsupported attributes cause the transform to be rejected */
+		if (attr_type != IKEV2_XF_ATTR_KEYLEN)
+			return (B_FALSE);
+
+		/*
+		 * IKEV2_XF_ATTR_KEYLEN is a TV style attribute, so the length
+		 * field contains the value instead of the length of the
+		 * attribute.
+		 */
+		if (attr_len < alg->sadb_x_algdesc_minbits ||
+		    attr_len > alg->sadb_x_algdesc_maxbits)
+			return (B_FALSE);
+
+		m->ism_encr_keylen = attr_len;
+		(void) bunyan_debug(log, "Encryption keylength match",
+		    BUNYAN_T_STRING, "xftype", ikev2_xf_type_str(xf->xf_type),
+		    BUNYAN_T_STRING, "xfval", ikev2_xf_str(xf->xf_type, xfid),
+		    BUNYAN_T_UINT32, "keylen", (uint32_t)attr_len,
+		    BUNYAN_T_END);
+	}
+
+	return (B_TRUE);
+}
+
+/*
+ * Verify that the chosen proposal from the responder conforms to our policy.
+ *
+ *	pmsg	The parsed SADB_ACQUIRE message with our policy
+ *	dh	The DH group (if any) proposed to the responder
+ *	resp	The responder's response packet
+ *	m	The match structure.  Contents will be set to value of the
+ *		responder's chosen proposal.
+ *
+ * Returns B_TRUE if the SA response was valid, B_FALSE otherwise.
+ */
+static boolean_t
+ikev2_sa_check_acquire(parsedmsg_t *restrict pmsg, ikev2_dh_t dh,
+    pkt_t *restrict resp, ikev2_sa_match_t *restrict m)
+{
+	const encr_data_t *ed = NULL;
+
+	pkt_payload_t *sa_pay = pkt_get_payload(resp, IKEV2_PAYLOAD_SA, NULL);
+	sadb_prop_t *prop = NULL;
+	sadb_comb_t *comb = NULL, *end = NULL;
+	ikev2_sa_proposal_t *i2prop = NULL;
+	ikev2_transform_t *i2xf = NULL;
+	ikev2_attribute_t *xfattr = NULL;
+
+	bzero(m, sizeof (*m));
+
+	prop = (sadb_prop_t *)pmsg->pmsg_exts[SADB_EXT_PROPOSAL];
+	comb = (sadb_comb_t *)(prop + 1);
+	end = (sadb_comb_t *)((uint64_t *)prop + prop->sadb_prop_len);
+
+	i2prop = ikev2_prop_first(sa_pay);
+
+	/*
+	 * Responders MUST only send back one response with the proposal
+	 * number set the proposal chosen, which for proposals we generate
+	 * is just the position of the sadb_comb_t in the SADB_EXT_PROPOSAL
+	 * extension (starting with 1 -- as proposal numbers MUST start with
+	 * 1).  We can therefore just check that single sadb_comb_t (as long
+	 * as it exists), and not have to check the entire SADB_EXT_PROPOSAL.
+	 */
+	for (size_t i = 1; i < i2prop->proto_proposalnr; i++, comb++) {
+		if (comb < end)
+			continue;
+
+		(void) bunyan_warn(log,
+		    "Responder sent an SA reply with an invalid proposal "
+		    "number; aborting IPsec SA creation",
+		    BUNYAN_T_UINT32, "proposal_num",
+		    (uint32_t)i2prop->proto_proposalnr, BUNYAN_T_END);
+
+		return (B_FALSE);
+	}
+
+	if (pmsg->pmsg_samsg->sadb_msg_satype != i2prop->proto_protoid) {
+		(void) bunyan_warn(log,
+		    "SA reply contains a different SA type than what was sent; "
+		    "aborting IPsec SA creation",
+		    BUNYAN_T_STRING, "satype",
+		    ikev2_spi_str(i2prop->proto_protoid), BUNYAN_T_END);
+		return (B_FALSE);
+	}
+
+	m->ism_propnum = i2prop->proto_proposalnr;
+	m->ism_satype = i2prop->proto_protoid;
+	m->ism_spi = ikev2_prop_spi(i2prop);
+
+	if (comb->sadb_comb_auth != SADB_AALG_NONE)
+		m->ism_seen |= SEEN(IKEV2_XF_AUTH);
+	if (comb->sadb_comb_auth != SADB_EALG_NONE)
+		m->ism_seen |= SEEN(IKEV2_XF_ENCR);
+
+	FOREACH_XF(i2xf, i2prop) {
+		uint16_t id = BE_IN16(&i2xf->xf_id);
+
+		switch (i2xf->xf_type) {
+		case IKEV2_XF_PRF:
+			goto invalid_xf;
+		case IKEV2_XF_ESN:
+			if (id != IKEV2_ESN_NONE)
+				goto invalid_xf;
+
+			m->ism_esn = B_FALSE;
+			break;
+		case IKEV2_XF_AUTH:
+			if (id != ikev2_pfkey_to_auth(comb->sadb_comb_auth))
+				goto invalid_xf;
+
+			m->ism_auth = id;
+			break;
+		case IKEV2_XF_DH:
+			if (id != dh)
+				goto invalid_xf;
+
+			m->ism_dh = id;
+			break;
+		case IKEV2_XF_ENCR:
+			if (id != comb->sadb_comb_encrypt)
+				goto invalid_xf;
+
+			m->ism_encr = id;
+			ed = encr_data(id);
+#ifdef notyet
+			m->ism_encr_saltlen = comb->sadb_comb_saltlen;
+#else
+			/*
+			 * Typically, the same mechanisms for use in ESP/AH
+			 * are also defined for IKEv2, and are used in a
+			 * similar manner, so using the IKEv2 defined salt
+			 * length for mechanisms works.  However, the definition
+			 * of a mechanism for IKEv2 use tends to lag that of
+			 * AH/ESP, and it is also possible in the future that
+			 * the use in IKEv2 might differ, so using our value
+			 * is not a good long term solution.  Once OS-6525
+			 * is fixed, the kernel will include the salt length
+			 * for the mechanism in an SADB_ACQUIRE message, so
+			 * we will use that instead.
+			 */
+			m->ism_encr_saltlen = ed->ed_saltlen;
+#endif
+
+			FOREACH_ATTR(xfattr, i2xf) {
+				uint16_t type = BE_IN16(&xfattr->attr_type);
+				uint16_t len = BE_IN16(&xfattr->attr_length);
+
+				type = IKE_ATTR_GET_TYPE(type);
+				if (type != IKEV2_XF_ATTR_KEYLEN) {
+					(void) bunyan_error(log,
+					    "Responder replied with an unknown "
+					    "encryption attribute",
+					    BUNYAN_T_UINT32, "attrtype",
+					    (uint32_t)type, BUNYAN_T_END);
+					return (B_FALSE);
+				}
+
+				if (!encr_keylen_allowed(ed)) {
+					(void) bunyan_error(log,
+					    "Responder replied with an invalid "
+					    "keysize", BUNYAN_T_END);
+					return (B_FALSE);
+				}
+
+				if (len < comb->sadb_comb_encrypt_minbits ||
+				    len > comb->sadb_comb_encrypt_maxbits) {
+					uint32_t min, max;
+					min = comb->sadb_comb_encrypt_minbits;
+					max = comb->sadb_comb_encrypt_maxbits;
+
+					(void) bunyan_error(log,
+					    "Responder replied with a keysize "
+					    "outside the allowed range",
+					    BUNYAN_T_UINT32, "keylen",
+					    (uint32_t)len,
+					    BUNYAN_T_UINT32, "keymin", min,
+					    BUNYAN_T_UINT32, "keymax", max,
+					    BUNYAN_T_END);
+
+					return (B_FALSE);
+				}
+
+				m->ism_encr_keylen = len;
+			}
+
+			if (!XF_HAS_ATTRS(i2xf) && encr_keylen_req(ed)) {
+				(void) bunyan_error(log,
+				    "Responder reply is missing a required "
+				    "keysize", BUNYAN_T_END);
+
+				return (B_FALSE);
+			}
+
+			if (m->ism_encr_keylen == 0)
+				m->ism_encr_keylen = ed->ed_keydefault;
+
+			break;
+		}
+		m->ism_match |= SEEN(i2xf->xf_type);
+	}
+
+	return (SA_MATCH(m));
+
+invalid_xf:
+	(void) bunyan_warn(log,
+	    "SA reply contains a transform that was not in the proposed set; "
+	    "aborting IPsec SA creation",
+	    BUNYAN_T_STRING, "satype", ikev2_spi_str(i2prop->proto_protoid),
+	    BUNYAN_T_UINT32, "proposal_num", (uint32_t)i2prop->proto_proposalnr,
+	    BUNYAN_T_STRING, "xftype", ikev2_xf_type_str(i2xf->xf_type),
+	    BUNYAN_T_STRING, "xfid",
+	    ikev2_xf_str(i2xf->xf_type, BE_IN16(&i2xf->xf_id)),
+	    BUNYAN_T_END);
+	return (B_FALSE);
+}
+
+/*
+ * Translate the addresses from our ACQUIRE message into IKEv2 traffic
+ * selectors and add them to our request.
+ */
+static boolean_t
+add_ts_init(pkt_t *restrict req, parsedmsg_t *restrict pmsg)
+{
+	ikev2_pkt_ts_state_t tstate = { 0 };
+	ts_t ts = { 0 };
+	sadb_address_t *addr = NULL;
+
+	if (!ikev2_add_ts_i(req, &tstate))
+		return (B_FALSE);
+
+#ifdef notyet
+	/*
+	 * RFC7296  2.9 -- If we know the source/dest IP of the packet that
+	 * triggered the SA creation requests (i.e. ACQUIRE), we include
+	 * those IPs as the first traffic selector in the TS{i,r} payloads.
+	 * Followed the the traffic selectors for our policy.
+	 */
+	addr = (sadb_address_t *)pmsg->pmsg_exts[SADB_X_EXT_ADDRESS_OPS];
+	if (addr != NULL && !ts_add(&tstate, sadb_to_ts(addr, &ts)))
+		return (B_FALSE);
+#endif
+
+	addr = get_sadb_addr(pmsg, B_TRUE);
+	if (!ts_add(&tstate, sadb_to_ts(addr, &ts)))
+		return (B_FALSE);
+
+	bzero(&tstate, sizeof (tstate));
+	if (!ikev2_add_ts_r(req, &tstate))
+		return (B_FALSE);
+
+#ifdef notyet
+	addr = (sadb_address_t *)pmsg->pmsg_exts[SADB_X_EXT_ADDRESS_OPD];
+	if (addr != NULL && !ts_add(&tstate, sadb_to_ts(addr, &ts)))
+		return (B_FALSE);
+#endif
+
+	addr = get_sadb_addr(pmsg, B_FALSE);
+	if (!ts_add(&tstate, sadb_to_ts(addr, &ts)))
+		return (B_FALSE);
+
+	return (B_TRUE);
+}
+
+static boolean_t
+add_ts_resp(pkt_t *restrict resp, const ts_t *restrict ts_i,
+    const ts_t *restrict ts_r)
+{
+	ikev2_pkt_ts_state_t tss = { 0 };
+	boolean_t ok = B_FALSE;
+
+	(void) bunyan_trace(log, "add_ts_resp: enter", BUNYAN_T_END);
+
+	if (!ikev2_add_ts_i(resp, &tss) || !ts_add(&tss, ts_i))
+		goto done;
+
+	if (!ikev2_add_ts_r(resp, &tss) || !ts_add(&tss, ts_r))
+		goto done;
+
+	ok = B_TRUE;
+
+done:
+	(void) bunyan_trace(log, "add_ts_resp: exit",
+	    BUNYAN_T_BOOLEAN, "success", ok,
+	    BUNYAN_T_END);
+
+	return (ok);
+}
+
+/*
+ * Queries kernel for IPsec policy for IPs in TS{i,r} payloads from initiator.
+ * Result in saved in csa->i2a_pmsg (set to NULL if no policy found).
+ *
+ * If there was an error looking up the policy (not found is not considered
+ * an error), return B_FALSE, otherwise B_TRUE.
+ */
+static boolean_t
+get_resp_policy(pkt_t *restrict pkt, boolean_t transport_mode,
+    ikev2_sa_args_t *restrict csa)
+{
+	ikev2_sa_t *i2sa = pkt->pkt_sa;
+	pkt_payload_t *ts_ip = pkt_get_payload(pkt, IKEV2_PAYLOAD_TSi, NULL);
+	pkt_payload_t *ts_rp = pkt_get_payload(pkt, IKEV2_PAYLOAD_TSr, NULL);
+	ts_t ts_i = { 0 };
+	ts_t ts_r = { 0 };
+
+	/*
+	 * We should only be called from the responder, so this packet should
+	 * be from the initiator.
+	 */
+	VERIFY(I2P_INITIATOR(pkt));
+
+	ts_first(ts_ip, &ts_i);
+	ts_first(ts_rp, &ts_r);
+
+	if (transport_mode) {
+		if (pfkey_inverse_acquire(&ts_r, &ts_i, NULL, NULL,
+		    &csa->i2a_pmsg)) {
+			return (B_TRUE);
+		}
+	} else {
+		/* IPPROTO_ENCAP is ipip */
+		ts_t src = { .ts_proto = IPPROTO_ENCAP };
+		ts_t dst = { .ts_proto = IPPROTO_ENCAP };
+
+		/* We don't specify ports for the outer address */
+		sockaddr_copy(SSTOSA(&i2sa->laddr), &src.ts_ss, B_FALSE);
+		sockaddr_copy(SSTOSA(&i2sa->raddr), &dst.ts_ss, B_FALSE);
+
+		if (pfkey_inverse_acquire(&src, &dst, &ts_r, &ts_i,
+		    &csa->i2a_pmsg)) {
+			return (B_TRUE);
+		}
+	}
+
+	/* Error handling / logging */
+
+	if (csa->i2a_pmsg == NULL || csa->i2a_pmsg->pmsg_samsg == NULL)
+		return (B_FALSE);
+
+	sadb_msg_t *m = csa->i2a_pmsg->pmsg_samsg;
+
+	switch (m->sadb_msg_errno) {
+	case ENOENT:
+		(void) bunyan_warn(log,
+		    "No policy found for proposed IPsec traffic",
+		    BUNYAN_T_END);
+		parsedmsg_free(csa->i2a_pmsg);
+		csa->i2a_pmsg = NULL;
+		return (B_TRUE);
+
+	/* XXX: Other possible errors to explicitly handle? */
+	default:
+		TSTDERR(m->sadb_msg_errno, warn,
+		    "Error while looking up IPsec policy",
+		    BUNYAN_T_STRING, "diagmsg",
+		    keysock_diag(m->sadb_x_msg_diagnostic),
+		    BUNYAN_T_UINT32, "diagcode",
+		    (uint32_t)m->sadb_x_msg_diagnostic);
+	}
+
+	parsedmsg_free(csa->i2a_pmsg);
+	csa->i2a_pmsg = NULL;
+	return (B_FALSE);
+}
+
+static void
+check_natt_addrs(pkt_t *restrict pkt, boolean_t transport_mode)
+{
+	/*
+	 * TODO: Check TSi[0] and TSr[0] in pkt.  If #TS > 1 (i.e.
+	 * TS{i,r}[0] is the OPS/OPD), compare with ikev2_sa_t->{l,r}addr
+	 * to and save to IKE SA if different (thus we know the NATed address)
+	 */
+}
+
+static void
+ikev2_set_child_type(ikev2_child_sa_state_t *restrict kids, boolean_t initiator,
+    ikev2_spi_proto_t satype)
+{
+	for (size_t i = 0; i < 2; i++) {
+		ikev2_child_sa_t *child = kids[i].csa_child;
+
+		child->i2c_initiator = initiator;
+		child->i2c_satype = satype;
+	}
+}
+
+static void
+ikev2_save_child_results(ikev2_child_sa_state_t *restrict kids,
+    const ikev2_sa_match_t *restrict results)
+{
+	kids[CSA_OUT].csa_child->i2c_spi = results->ism_spi;
+
+	for (size_t i = 0; i < 2; i++) {
+		ikev2_child_sa_t *child = kids[i].csa_child;
+
+		child->i2c_satype = results->ism_satype;
+		child->i2c_encr = results->ism_encr;
+		child->i2c_auth = results->ism_auth;
+		child->i2c_encr_keylen = results->ism_encr_keylen;
+		child->i2c_dh = results->ism_dh;
+	}
+}
+
+static void
+ikev2_save_child_ts(ikev2_child_sa_state_t *restrict kids,
+    const ts_t *restrict ts_i, const ts_t *restrict ts_r)
+{
+	for (size_t i = 0; i < 2; i++) {
+		ikev2_child_sa_t *child = kids[i].csa_child;
+
+		child->i2c_ts_i = *ts_i;
+		child->i2c_ts_r = *ts_r;
+	}
+}
+
+/* Sends the pf_key(7P) messages to establish the IPsec SAs */
+static boolean_t
+ikev2_create_child_sas(ikev2_sa_t *restrict sa, ikev2_sa_args_t *restrict args)
+{
+	ikev2_child_sa_state_t *kid = args->i2a_child;
+
+	/* We always create IPsec SAs in pairs, so there's _always_ 2 */
+	for (size_t i = 0; i < 2; i++, kid) {
+		ikev2_child_sa_t *csa = kid[i].csa_child;
+
+
+		if (!pfkey_sadb_add_update(sa, csa, kid[i].csa_child_encr,
+		    kid[i].csa_child_auth, args->i2a_pmsg))
+			return (B_FALSE);
+
+		ikev2_sa_add_child(sa, csa);
+		kid[i].csa_child_added = B_TRUE;
+		csa->i2c_birth = gethrtime();
+
+		/*
+		 * We want the two IPsec SAs to be paired in the kernel, but
+		 * AFAIK when adding the SADB_X_EXT_PAIR to a SADB_{ADD,UPDATE}
+		 * message, it must reference an existing SA, so we don't
+		 * set i2c_pair until after we've created/added the first SA.
+		 */
+		kid[i ^ 1].csa_child->i2c_pair = kid[i ^ 0].csa_child;
+
+		/* TODO: Log more keys */
+		(void) bunyan_debug(log, "Created IPsec SA",
+		    BUNYAN_T_POINTER, "csa", csa,
+		    BUNYAN_T_STRING, "spi", enum_printf("0x%" PRIx32,
+		    ntohl(csa->i2c_spi)),
+		    BUNYAN_T_BOOLEAN, "inbound", csa->i2c_inbound,
+		    BUNYAN_T_END);
+	}
+
+	return (B_TRUE);
+}
+
+static boolean_t
+generate_keys(ikev2_sa_t *restrict i2sa, ikev2_sa_args_t *restrict csa)
+{
+	/*
+	 * RFC7296 2.17 - If we are doing a DH key exchange, the order of the
+	 * input material is g^ir (new) | Ni | Nr.  If there is no key exchange,
+	 * the input is just Ni | Nr.
+	 */
+	struct {
+		uint8_t *ptr;
+		size_t len;
+	} prfp_args[] = {
+		{ NULL, 0 },		/* g^ir if doing a key exchange */
+		{ csa->i2a_nonce_i, csa->i2a_nonce_i_len },
+		{ csa->i2a_nonce_r, csa->i2a_nonce_r_len },
+		{ NULL, 0 }
+	};
+	size_t idx = 1;		/* index of first arg to prfplus_init */
+	prfp_t prfp = { 0 };
+	ikev2_child_sa_state_t *init = NULL, *resp = NULL;
+	size_t encrlen = 0, authlen = 0;
+	boolean_t ret = B_FALSE;
+
+	init = &csa->i2a_child[INITIATOR(csa) ? CSA_OUT : CSA_IN];
+	resp = &csa->i2a_child[INITIATOR(csa) ? CSA_IN : CSA_OUT];
+
+	(void) bunyan_trace(log, "Generating child SA keys",
+	    BUNYAN_T_END);
+
+	if (csa->i2a_dhkey != CK_INVALID_HANDLE) {
+		CK_RV rv = CKR_OK;
+
+		rv = pkcs11_ObjectToKey(p11h(), csa->i2a_dhkey,
+		    (void **)&prfp_args[0].ptr, &prfp_args[0].len, B_FALSE);
+		if (rv != CKR_OK) {
+			PKCS11ERR(error, "pkcs11_ObjectToKey",
+			    rv, BUNYAN_T_STRING, "objname", "gir");
+			return (B_FALSE);
+		}
+
+		idx = 0;
+	}
+
+	ret = prfplus_init(&prfp, i2sa->prf, i2sa->sk_d,
+	    prfp_args[idx].ptr, prfp_args[idx].len,
+	    prfp_args[idx + 1].ptr, prfp_args[idx + 1].len,
+	    prfp_args[idx + 2].ptr, prfp_args[idx + 2].len,
+	    NULL);
+
+	explicit_bzero(prfp_args[0].ptr, prfp_args[0].len);
+	free(prfp_args[0].ptr);
+
+	if (!ret)
+		return (B_FALSE);
+
+	/* Sanity checks that both pairs agree on algs and key lengths */
+	VERIFY3S(init->csa_child->i2c_encr, ==, resp->csa_child->i2c_encr);
+	VERIFY3S(init->csa_child->i2c_auth, ==, resp->csa_child->i2c_auth);
+	VERIFY3U(init->csa_child->i2c_encr_keylen, ==,
+	    resp->csa_child->i2c_encr_keylen);
+
+	/*
+	 * For all currently defined combined mode mechanisms, the salt
+	 * generation works similar to how IKEv2 generates salt values --
+	 * the appropriate size salt is created immediately after the
+	 * encryption key.  Since in.ikev2d doesn't need to do anything
+	 * with the child SA salt value, and since the kernel expects the
+	 * salt value (when needed) to be appended to the encryption key
+	 * in the pf_key(7P) extension when adding an IPsec SA, we just
+	 * create a single 'key' that's the sum of both sizes so we don't
+	 * need to do any appending of the two ourselves.  For non-combined
+	 * mode ciphers, i2c_encr_saltlen will be 0, so things will work
+	 * as expected.
+	 */
+	encrlen = init->csa_child->i2c_encr_keylen +
+	    init->csa_child->i2c_encr_saltlen;
+	encrlen = SADB_1TO8(encrlen);
+	authlen = auth_data(init->csa_child->i2c_auth)->ad_keylen;
+
+	VERIFY3U(encrlen, <=, ENCR_MAX);
+	VERIFY3U(authlen, <=, AUTH_MAX);
+
+	/*
+	 * We always generate keys in the order of initiator first, then
+	 * responder.  For each side, we always start with encryption keys
+	 * then authentication keys.
+	 */
+	ret = prfplus(&prfp, init->csa_child_encr, encrlen) &&
+	    prfplus(&prfp, init->csa_child_auth, authlen) &&
+	    prfplus(&prfp, resp->csa_child_encr, encrlen) &&
+	    prfplus(&prfp, resp->csa_child_auth, authlen);
+
+done:
+	prfplus_fini(&prfp);
+
+	(void) bunyan_trace(log, "Finished generating keys",
+	    BUNYAN_T_BOOLEAN, "success", ret,
+	    BUNYAN_T_END);
+
+	return (ret);
+}
+
+/*
+ * Get the sadb address from a parsed message that will actually be subjected
+ * to IPsec.  For transport mode, this is the SRC/DST address, for tunnel
+ * mode, this is the inner SRC/DST address.  'src' determines if we want
+ * the appropriate SRC or DST address.
+ */
+static sadb_address_t *
+get_sadb_addr(parsedmsg_t *pmsg, boolean_t src)
+{
+	sadb_ext_t *ext = NULL;
+	uint_t first = src ?
+	    SADB_X_EXT_ADDRESS_INNER_SRC : SADB_X_EXT_ADDRESS_INNER_DST;
+	uint_t alt = src ?  SADB_EXT_ADDRESS_SRC : SADB_EXT_ADDRESS_DST;
+
+	/*
+	 * If the kernel has send an ACQUIRE for a transport mode SA, it
+	 * will not include any INNER_{SRC,DST} addresses.  However for
+	 * tunnel mode, they are required, so we return the INNER addresses
+	 * if present.  Note this is currently the only way AFAIK to
+	 * distinguish between the two scenarios.
+	 */
+	ext = pmsg->pmsg_exts[first];
+	if (ext == NULL) {
+		ext = pmsg->pmsg_exts[alt];
+		VERIFY3P(ext, !=, NULL);
+		VERIFY3U(ext->sadb_ext_type, ==, alt);
+	} else {
+		VERIFY3U(ext->sadb_ext_type, ==, first);
+	}
+
+	return ((sadb_address_t *)ext);
+}
+
+#ifdef notyet
+static void
+ikev2_rekey_delete_old_kids(ikev2_sa_t *restrict i2sa,
+    ikev2_sa_args_t *restrict args)
+{
+	ikev2_child_sa_t *csa = args->i2a_old_csa;
+	uint8_t satype = ikev2_to_satype(csa->i2c_satype);
+
+	(void) pfkey_delete(satype, csa->i2c_spi, src, dst, B_TRUE);
+	ikev2_sa_delete_child(i2sa, csa->i2c_pair);
+	ikev2_sa_delete_child(i2sa,csa);
+}
+#endif
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_common.c b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_common.c
new file mode 100644
index 0000000000..4f98508ebe
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_common.c
@@ -0,0 +1,931 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+#include <alloca.h>
+#include <arpa/inet.h>
+#include <netinet/in.h>
+#include <errno.h>
+#include <string.h>
+#include <strings.h>
+#include <sys/debug.h>
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <net/pfkeyv2.h>
+#include "defs.h"
+#include "dh.h"
+#include "ikev2_sa.h"
+#include "ikev2_pkt.h"
+#include "ikev2_common.h"
+#include "ikev2_enum.h"
+#include "ikev2_proto.h"
+#include "config.h"
+#include "pfkey.h"
+#include "pkcs11.h"
+#include "pkt.h"
+#include "prf.h"
+#include "worker.h"
+
+/*
+ * XXX: IKEv1 selectes the PRF based on the authentication algorithm.
+ * IKEv2 allows the PRF to be negotiated separately.  Eventually, we
+ * should probably add the ability to specify PRFs in the configuration
+ * file.  For now, we just include all the ones we support in decreasing
+ * order of preference.
+ */
+static ikev2_prf_t prf_supported[] = {
+	IKEV2_PRF_HMAC_SHA2_512,
+	IKEV2_PRF_HMAC_SHA2_384,
+	IKEV2_PRF_HMAC_SHA2_256,
+	IKEV2_PRF_HMAC_SHA1,
+	IKEV2_PRF_HMAC_MD5
+};
+
+static void log_acq_match(ikev2_sa_match_t *);
+
+ikev2_xf_auth_t
+ikev2_pfkey_to_auth(int alg)
+{
+	switch (alg) {
+	case SADB_AALG_NONE:
+		return (IKEV2_XF_AUTH_NONE);
+	case SADB_AALG_SHA256HMAC:
+		return (IKEV2_XF_AUTH_HMAC_SHA2_256_128);
+	case SADB_AALG_SHA384HMAC:
+		return (IKEV2_XF_AUTH_HMAC_SHA2_384_192);
+	case SADB_AALG_SHA512HMAC:
+		return (IKEV2_XF_AUTH_HMAC_SHA2_512_256);
+	case SADB_AALG_MD5HMAC:
+		return (IKEV2_XF_AUTH_HMAC_MD5_96);
+	case SADB_AALG_SHA1HMAC:
+		return (IKEV2_XF_AUTH_HMAC_SHA1_96);
+	default:
+		INVALID("alg");
+		/*NOTREACHED*/
+		return (alg);
+	}
+}
+
+ikev2_xf_encr_t
+ikev2_pfkey_to_encr(int alg)
+{
+	switch (alg) {
+	case SADB_EALG_NONE:
+	case SADB_EALG_DESCBC:
+	case SADB_EALG_3DESCBC:
+	case SADB_EALG_BLOWFISH:
+	case SADB_EALG_NULL:
+	case SADB_EALG_AES:	/* CBC */
+	case SADB_EALG_AES_CCM_8:
+	case SADB_EALG_AES_CCM_12:
+	case SADB_EALG_AES_CCM_16:
+	case SADB_EALG_AES_GCM_8:
+	case SADB_EALG_AES_GCM_12:
+	case SADB_EALG_AES_GCM_16:
+		/* These all match up */
+		return (alg);
+	default:
+		INVALID("alg");
+		/*NOTREACHED*/
+		return (alg);
+	}
+}
+
+static boolean_t add_rule_xform(pkt_sa_state_t *restrict,
+    const config_xf_t *restrict);
+
+boolean_t
+ikev2_sa_from_rule(pkt_t *restrict pkt, const config_rule_t *restrict rule,
+    uint64_t spi)
+{
+	boolean_t ok = B_TRUE;
+	pkt_sa_state_t pss;
+
+	if (!ikev2_add_sa(pkt, &pss))
+		return (B_FALSE);
+
+	for (uint8_t i = 0; rule->rule_xf[i] != NULL; i++) {
+		/* RFC 7296 3.3.1 - Proposal numbers start with 1 */
+		ok &= ikev2_add_prop(&pss, i + 1, IKEV2_PROTO_IKE, spi);
+		ok &= add_rule_xform(&pss, rule->rule_xf[i]);
+	}
+	return (ok);
+}
+
+static boolean_t
+add_rule_xform(pkt_sa_state_t *restrict pss, const config_xf_t *restrict xf)
+{
+	encr_modes_t mode = encr_data(xf->xf_encr)->ed_mode;
+	boolean_t ok = B_TRUE;
+
+	ok &= ikev2_add_xf_encr(pss, xf->xf_encr, xf->xf_minbits,
+	    xf->xf_maxbits);
+
+	/*
+	 * For all currently known combined mode ciphers, we can omit an
+	 * integrity transform
+	 */
+	if (!MODE_IS_COMBINED(mode))
+		ok &= ikev2_add_xform(pss, IKEV2_XF_AUTH, xf->xf_auth);
+	ok &= ikev2_add_xform(pss, IKEV2_XF_DH, xf->xf_dh);
+
+	for (size_t i = 0; ok && i < ARRAY_SIZE(prf_supported); i++)
+		ok &= ikev2_add_xform(pss, IKEV2_XF_PRF, prf_supported[i]);
+
+	return (ok);
+}
+
+boolean_t
+ikev2_sa_add_result(pkt_t *restrict pkt, const ikev2_sa_match_t *restrict res,
+    uint64_t spi)
+{
+	boolean_t ok;
+	pkt_sa_state_t pss;
+
+	ok = ikev2_add_sa(pkt, &pss);
+	ok &= ikev2_add_prop(&pss, res->ism_propnum, res->ism_satype, spi);
+
+	if (SA_MATCH_HAS(res, IKEV2_XF_ENCR)) {
+		ok &= ikev2_add_xform(&pss, IKEV2_XF_ENCR, res->ism_encr);
+		if (res->ism_encr_keylen != 0)
+			ok &= ikev2_add_xf_attr(&pss, IKEV2_XF_ATTR_KEYLEN,
+			    res->ism_encr_keylen);
+	}
+	if (SA_MATCH_HAS(res, IKEV2_XF_AUTH))
+		ok &= ikev2_add_xform(&pss, IKEV2_XF_AUTH, res->ism_auth);
+	if (SA_MATCH_HAS(res, IKEV2_XF_DH))
+		ok &= ikev2_add_xform(&pss, IKEV2_XF_DH, res->ism_dh);
+	if (SA_MATCH_HAS(res, IKEV2_XF_PRF))
+		ok &= ikev2_add_xform(&pss, IKEV2_XF_PRF, res->ism_prf);
+	if (SA_MATCH_HAS(res, IKEV2_XF_ESN))
+		ok &= ikev2_add_xform(&pss, IKEV2_XF_ESN, res->ism_esn);
+
+	return (ok);
+}
+
+static boolean_t ikev2_sa_match_prop(config_xf_t *restrict,
+    ikev2_sa_proposal_t *restrict, ikev2_sa_match_t *restrict, boolean_t);
+static boolean_t ikev2_sa_match_encr_attr(config_xf_t *restrict,
+    ikev2_transform_t *restrict, ikev2_sa_match_t *restrict);
+static boolean_t ikev2_sa_match_attr(config_xf_t *restrict,
+    ikev2_transform_t *restrict, ikev2_sa_match_t *restrict);
+
+/*
+ * Try to match a config_xf_t from a config_rule_t to an SA proposal
+ * from a remote peer.
+ *	rule	The rule containing the config_xf_t's used to match
+ *	pkt	The packet with the SA payload to match
+ *	m	The match results
+ *	rekey	B_TRUE if this is part of an IKE SA rekey operation
+ *
+ * Returns B_TRUE if a match was found, B_FALSE otherwise.
+ */
+boolean_t
+ikev2_sa_match_rule(config_rule_t *restrict rule, pkt_t *restrict pkt,
+	ikev2_sa_match_t *restrict m, boolean_t rekey)
+{
+	pkt_payload_t *sa_pay = pkt_get_payload(pkt, IKEV2_PAYLOAD_SA, NULL);
+
+	if (sa_pay == NULL) {
+		(void) bunyan_warn(log, "Packet is missing SA payload",
+		    BUNYAN_T_END);
+		return (B_FALSE);
+	}
+
+	for (size_t i = 0; rule->rule_xf[i] != NULL; i++) {
+		config_xf_t *rxf = rule->rule_xf[i];
+		ikev2_sa_proposal_t *prop = ikev2_prop_first(sa_pay);
+
+		FOREACH_PROP(prop, sa_pay) {
+			if (ikev2_sa_match_prop(rxf, prop, m, rekey))
+				return (B_TRUE);
+		}
+	}
+
+	(void) bunyan_info(log,
+	    "Could not find matching policy to create a new IKE SA",
+	    BUNYAN_T_END);
+
+	return (B_FALSE);
+}
+
+#define	UNKNOWN_XF(_xf, _val) \
+    (void) bunyan_debug(log, "Unknown transform type; rejecting transform", \
+	BUNYAN_T_STRING, "xftype", ikev2_xf_type_str((_xf)->xf_type), \
+	BUNYAN_T_STRING, "xfval", ikev2_xf_str((_xf)->xf_type, (_val)), \
+	BUNYAN_T_END)
+
+/*
+ * Compare the config_xf_t and ikev2_sa_proposal_t.  Return B_TRUE if the
+ * two match (with matching results written to m).  B_FALSE if the two
+ * do not match.
+ */
+static boolean_t
+ikev2_sa_match_prop(config_xf_t *restrict rxf,
+    ikev2_sa_proposal_t *restrict prop, ikev2_sa_match_t *restrict m,
+    boolean_t rekey)
+{
+	ikev2_transform_t *xf = NULL;
+	char spibuf[19] = { 0 };	/* 0x + 16-digit hex + NUL */
+	bzero(m, sizeof (*m));
+
+	if (prop->proto_protoid != IKEV2_PROTO_IKE) {
+		(void) bunyan_warn(log,
+		    "Invalid protocol (SA type) in SA proposal",
+		    BUNYAN_T_UINT32, "proposal_num",
+		    (uint32_t)prop->proto_proposalnr,
+		    BUNYAN_T_STRING, "protocol",
+		    ikev2_spi_str(prop->proto_protoid), BUNYAN_T_END);
+		return (B_FALSE);
+	}
+
+	m->ism_spi = ikev2_prop_spi(prop);
+
+	/*
+	 * During an IKE_SA_INIT exchange, no SPI is included, however during
+	 * an IKE rekey, the remote peer MUST include their SPI in the
+	 * proposal.
+	 */
+	if (rekey && m->ism_spi == 0) {
+		(void) bunyan_warn(log,
+		    "Proposal does not contain a valid SPI value; ignoring",
+		    BUNYAN_T_UINT32, "proposal_num",
+		    (uint32_t)prop->proto_proposalnr, BUNYAN_T_END);
+		return (B_FALSE);
+	}
+
+	if (!rekey && m->ism_spi != 0) {
+		(void) bunyan_warn(log,
+		    "Proposal in IKE_SA_INIT exchange contains an SPI value; "
+		    "ignoring",
+		    BUNYAN_T_UINT32, "proposal_num",
+		    (uint32_t)prop->proto_proposalnr, BUNYAN_T_END);
+		return (B_FALSE);
+	}
+
+	m->ism_propnum = prop->proto_proposalnr;
+	m->ism_satype = prop->proto_protoid;
+	m->ism_authmethod = rxf->xf_authtype;
+	m->ism_lifetime_secs = rxf->xf_lifetime_secs;
+
+	if (m->ism_spi != 0) {
+		(void) snprintf(spibuf, sizeof (spibuf), "0x" PRIx64,
+		    m->ism_spi);
+	} else {
+		(void) strlcpy(spibuf, "0x0", sizeof (spibuf));
+	}
+
+	(void) bunyan_debug(log, "Evaluating proposal",
+	    BUNYAN_T_UINT32, "proposal_num", (uint32_t)m->ism_propnum,
+	    BUNYAN_T_STRING, "protocol", ikev2_spi_str(m->ism_satype),
+	    BUNYAN_T_STRING, "spi", spibuf,
+	    BUNYAN_T_END);
+
+	/*
+	 * IKE SA policies MUST contain an encryption mechanism.  We have
+	 * errored badly if we've successfully parsed a local policy without
+	 * one.
+	 */
+	VERIFY3U(rxf->xf_encr, !=, IKEV2_ENCR_NONE);
+	m->ism_have |= SEEN(IKEV2_XF_ENCR);
+
+	/*
+	 * For non-combined mode encryption mechanisms, we must also have
+	 * an integrity mechism selected.
+	 */
+	if (rxf->xf_auth != IKEV2_XF_AUTH_NONE)
+		m->ism_have |= SEEN(IKEV2_XF_AUTH);
+	else
+		VERIFY(MODE_IS_COMBINED(encr_data(rxf->xf_encr)->ed_mode));
+
+	/*
+	 * config_rule_t's don't include any PRFs, instead every config_rule_t
+	 * implictly includes all of the PRFs in prf_supported[], so we must
+	 * check them separately.
+	 */
+	m->ism_have |= SEEN(IKEV2_XF_PRF);
+	for (size_t i = 0; i < ARRAY_SIZE(prf_supported); i++) {
+		FOREACH_XF(xf, prop) {
+			if (xf->xf_type != IKEV2_XF_PRF)
+				continue;
+
+			m->ism_seen |= SEEN(IKEV2_XF_PRF);
+
+			if (SA_MATCHES(m, IKEV2_XF_PRF))
+				break;
+
+			if (BE_IN16(&xf->xf_id) != prf_supported[i])
+				continue;
+
+			if (!ikev2_sa_match_attr(rxf, xf, m))
+				continue;
+
+			(void) bunyan_debug(log, "Transform match",
+			    BUNYAN_T_STRING, "xftype",
+			    ikev2_xf_type_str(xf->xf_type),
+			    BUNYAN_T_STRING, "xfval", ikev2_prf_str(m->ism_prf),
+			    BUNYAN_T_END);
+
+			m->ism_prf = prf_supported[i];
+			m->ism_match |= SEEN(IKEV2_XF_PRF);
+			break;
+		}
+
+		if (SA_MATCHES(m, IKEV2_XF_PRF))
+			break;
+	}
+
+	/*
+	 * Go through the transforms again, looking at the non-PRF transforms.
+	 * The general advice in RFC7296 is that a proposal that contains
+	 * unknown transform types should be rejected.  A proposal that
+	 * contains unknown transform values cause that specific transform
+	 * to be rejected (but the remaining transforms in the proposal can
+	 * still be evaluated).
+	 */
+	FOREACH_XF(xf, prop) {
+		uint16_t val = BE_IN16(&xf->xf_id);
+
+		(void) bunyan_debug(log, "Evaluating transform",
+		    BUNYAN_T_STRING, "xftype", ikev2_xf_type_str(xf->xf_type),
+		    BUNYAN_T_STRING, "xfval", ikev2_xf_str(xf->xf_type, val),
+		    BUNYAN_T_END);
+
+		switch ((ikev2_xf_type_t)xf->xf_type) {
+		case IKEV2_XF_ENCR:
+		case IKEV2_XF_PRF:
+		case IKEV2_XF_AUTH:
+		case IKEV2_XF_DH:
+			/* Mark what we've seen (as long as it's none none) */
+			if (val != 0)
+				m->ism_seen |= SEEN(xf->xf_type);
+
+			/* But use the first match for a given transform type */
+			if (SA_MATCHES(m, xf->xf_type))
+				continue;
+
+			break;
+		case IKEV2_XF_ESN:
+			/*
+			 * Warn instead of debug as ESN transforms are NEVER
+			 * valid for IKE SAs.
+			 */
+			(void) bunyan_warn(log,
+			    "IKE SA proposal contains an invalid transform",
+			    BUNYAN_T_UINT32, "proposal_num",
+			    (uint32_t)m->ism_propnum,
+			    BUNYAN_T_STRING, "xftype",
+			    ikev2_xf_type_str(xf->xf_type), BUNYAN_T_END);
+			return (B_FALSE);
+		default:
+			/*
+			 * Unknown transform types are ok, but we must reject
+			 * the proposal containing them.
+			 */
+			(void) bunyan_debug(log,
+			    "Unknown transform type; rejecting proposal",
+			    BUNYAN_T_STRING, "xftype",
+			    ikev2_xf_type_str(xf->xf_type), BUNYAN_T_END);
+			return (B_FALSE);
+		}
+
+		switch ((ikev2_xf_type_t)xf->xf_type) {
+		case IKEV2_XF_ENCR:
+			/*
+			 * We can never match an unknown id with our policy,
+			 * however for diagnostic purposes, it seems useful
+			 * to note when we encounter them.
+			 */
+			if (encr_data(val) == NULL) {
+				UNKNOWN_XF(xf, val);
+				continue;
+			}
+
+			if (rxf->xf_encr != val)
+				continue;
+
+			if (!ikev2_sa_match_encr_attr(rxf, xf, m))
+				continue;
+
+			m->ism_encr = val;
+			m->ism_match |= SEEN(IKEV2_XF_ENCR);
+			break;
+		case IKEV2_XF_AUTH:
+			/*
+			 * We can never match an unknown id with our policy,
+			 * however for diagnostic purposes, it seems useful
+			 * to note when we encounter them.
+			 */
+			if (auth_data(val) == NULL) {
+				UNKNOWN_XF(xf, val);
+				continue;
+			}
+
+			if (rxf->xf_auth != val)
+				continue;
+
+			if (!ikev2_sa_match_attr(rxf, xf, m))
+				continue;
+
+			m->ism_auth = val;
+			m->ism_match |= SEEN(IKEV2_XF_AUTH);
+			break;
+		case IKEV2_XF_DH:
+			if (rxf->xf_dh != val)
+				continue;
+
+			if (!ikev2_sa_match_attr(rxf, xf, m))
+				continue;
+
+			m->ism_dh = val;
+			m->ism_match |= SEEN(IKEV2_XF_DH);
+			break;
+		case IKEV2_XF_PRF:
+		case IKEV2_XF_ESN:
+			/* Handled earlier */
+			break;
+		}
+
+		(void) bunyan_debug(log, "Transform match",
+		    BUNYAN_T_STRING, "xftype", ikev2_xf_type_str(xf->xf_type),
+		    BUNYAN_T_STRING, "xfval", ikev2_xf_str(xf->xf_type, val),
+		    BUNYAN_T_END);
+	}
+
+	if (SA_MATCH(m)) {
+		const encr_data_t *ed = encr_data(m->ism_encr);
+		const auth_data_t *ad = auth_data(m->ism_auth);
+
+		/*
+		 * Keylengths can be mandatory, optional, or prohibited
+		 * depending on the specific mechanism.  It is hopefully less
+		 * confusing to only print a value when it is either mandatory
+		 * or optional (with a non-default value).
+		 *
+		 * We do not to set m->ism_encr_keylen to the actual sized
+		 * used since the ikev2_sa_results_t that contains the results
+		 * of the evaluation is used to generate the response SA
+		 * payload (and including a keylength when prohibited would
+		 * cause the exchange to fail).
+		 */
+		if (m->ism_encr_keylen > 0) {
+			(void) bunyan_key_add(log,
+			    BUNYAN_T_UINT32, "encr_keylen",
+			    (uint32_t)m->ism_encr_keylen, BUNYAN_T_END);
+		}
+
+		/*
+		 * Similarly with integrity mechanisms, it is hopefully less
+		 * confusing to omit it's value when using combined mode
+		 * ciphers (vs. logging 'none' or logging the encryption
+		 * mechanism as the integrity mechanism).
+		 */
+		if (!MODE_IS_COMBINED(ed->ed_mode)) {
+			(void) bunyan_key_add(log,
+			    BUNYAN_T_STRING, "auth",
+			    ikev2_xf_auth_str(m->ism_auth), BUNYAN_T_END);
+		}
+
+		if (m->ism_spi != 0) {
+			(void) snprintf(spibuf, sizeof (spibuf), "0x" PRIx64,
+			    m->ism_spi);
+		} else {
+			(void) strlcpy(spibuf, "0x0", sizeof (spibuf));
+		}
+
+		(void) bunyan_debug(log, "Proposal matched",
+		    BUNYAN_T_UINT32, "proposal_num", (uint32_t)m->ism_propnum,
+		    BUNYAN_T_STRING, "protocol", ikev2_spi_str(m->ism_satype),
+		    BUNYAN_T_STRING, "spi", spibuf,
+		    BUNYAN_T_STRING, "encr", ikev2_xf_encr_str(m->ism_encr),
+		    BUNYAN_T_STRING, "prf", ikev2_prf_str(m->ism_prf),
+		    BUNYAN_T_STRING, "dh", ikev2_dh_str(m->ism_dh),
+		    BUNYAN_T_END);
+
+		(void) bunyan_key_remove(log, "auth");
+		(void) bunyan_key_remove(log, "encr_keylen");
+
+		return (B_TRUE);
+	}
+
+	(void) bunyan_debug(log, "Proposal did not match", BUNYAN_T_END);
+	return (B_FALSE);
+}
+
+static boolean_t
+ikev2_sa_match_encr_attr(config_xf_t *restrict rxf,
+    ikev2_transform_t *restrict i2xf, ikev2_sa_match_t *restrict m)
+{
+	const encr_data_t *ed = NULL;
+	ikev2_attribute_t *attr = NULL;
+	uint16_t val = BE_IN16(&i2xf->xf_id);
+
+	ed = encr_data(val);
+
+	if (!XF_HAS_ATTRS(i2xf) && encr_keylen_req(ed)) {
+		(void) bunyan_warn(log,
+		    "Transform is missing required keylength attribute",
+		    BUNYAN_T_STRING, "xftype", ikev2_xf_type_str(i2xf->xf_type),
+		    BUNYAN_T_STRING, "xfval", ikev2_xf_str(i2xf->xf_type, val),
+		    BUNYAN_T_END);
+		return (B_FALSE);
+	}
+
+	FOREACH_ATTR(attr, i2xf) {
+		uint16_t type = BE_IN16(&attr->attr_type);
+		uint16_t len = BE_IN16(&attr->attr_length);
+		boolean_t tv = B_FALSE;
+
+		if (IKE_ATTR_GET_FORMAT(type) == IKE_ATTR_TV)
+			tv = B_TRUE;
+
+		type = IKE_ATTR_GET_TYPE(type);
+
+		if (!tv || type != IKEV2_XF_ATTR_KEYLEN) {
+			(void) bunyan_debug(log,
+			    "Transform contains unknown attribute; "
+			    "ignoring transform",
+			    BUNYAN_T_STRING, "xftype",
+			    ikev2_xf_type_str(i2xf->xf_type),
+			    BUNYAN_T_STRING, "xfval",
+			    ikev2_xf_str(i2xf->xf_type, val),
+			    BUNYAN_T_UINT32, "attrtype", (uint32_t)type,
+			    BUNYAN_T_UINT32,
+			    tv ? "attrval" : "attrlen", (uint32_t)len,
+			    BUNYAN_T_END);
+
+			return (B_FALSE);
+		}
+
+		(void) bunyan_debug(log, "Evaluating keylength",
+		    BUNYAN_T_STRING, "xftype", ikev2_xf_type_str(i2xf->xf_type),
+		    BUNYAN_T_STRING, "xfval", ikev2_xf_str(i2xf->xf_type, val),
+		    BUNYAN_T_UINT32, "keylen", (uint32_t)len,
+		    BUNYAN_T_END);
+
+		/*
+		 * This is arguably an invalid transform rather than merely
+		 * one that does not match, so explicitly log it, and log
+		 * as a warning.
+		 */
+		if (!encr_keylen_allowed(ed)) {
+			(void) bunyan_warn(log,
+			    "Transform included a keylength when none should "
+			    "present; rejecting transform",
+			    BUNYAN_T_STRING, "xftype",
+			    ikev2_xf_type_str(i2xf->xf_type),
+			    BUNYAN_T_STRING, "xfval",
+			    ikev2_xf_str(i2xf->xf_type, val),
+			    BUNYAN_T_UINT32, "keylen", (uint32_t)len,
+			    BUNYAN_T_END);
+			return (B_FALSE);
+		}
+
+		if (!encr_keylen_ok(ed, len))
+			return (B_FALSE);
+
+		m->ism_encr_keylen = len;
+		(void) bunyan_debug(log,
+		    "Encryption keylength matches",
+		    BUNYAN_T_STRING, "xftype", ikev2_xf_type_str(i2xf->xf_type),
+		    BUNYAN_T_STRING, "xfval", ikev2_xf_str(i2xf->xf_type, val),
+		    BUNYAN_T_UINT32, "keylen", (uint32_t)len,
+		    BUNYAN_T_END);
+	}
+
+	return (B_TRUE);
+}
+
+/*
+ * A generic handler for any transform type that does not have any
+ * known/supported attributes.  Returns B_FALSE if any attributes are
+ * present, B_TRUE if no attributes are present.
+ */
+static boolean_t
+ikev2_sa_match_attr(config_xf_t *restrict rxf,
+    ikev2_transform_t *restrict i2xf, ikev2_sa_match_t *restrict m)
+{
+	if (!XF_HAS_ATTRS(i2xf))
+		return (B_TRUE);
+
+	(void) bunyan_debug(log, "Transform contains unknown attribute(s); "
+	    "ignoring transform", BUNYAN_T_END);
+
+	return (B_FALSE);
+}
+
+boolean_t
+ikev2_sa_check_prop(config_rule_t *restrict rule, pkt_t *restrict resp,
+    ikev2_sa_match_t *restrict m, boolean_t rekey)
+{
+	config_xf_t *rxf = NULL;
+	pkt_payload_t *sa_pay = pkt_get_payload(resp, IKEV2_PAYLOAD_SA, NULL);
+	ikev2_sa_proposal_t *prop = NULL;
+
+	if (sa_pay == NULL) {
+		(void) bunyan_warn(log, "SA payload is missing in response",
+		    BUNYAN_T_END);
+		return (B_FALSE);
+	}
+
+	prop = ikev2_prop_first(sa_pay);
+
+	for (size_t i = 0; rule->rule_xf[i] != NULL; i++) {
+		if (i + 1 != prop->proto_proposalnr)
+			continue;
+
+		rxf = rule->rule_xf[i];
+		break;
+	}
+
+	if (rxf == NULL) {
+		(void) bunyan_warn(log,
+		    "SA payload returned an invalid proposal number",
+		    BUNYAN_T_UINT32, "proposal_num",
+		    (uint32_t)prop->proto_proposalnr, BUNYAN_T_END);
+		return (B_FALSE);
+	}
+
+	return (ikev2_sa_match_prop(rxf, prop, m, rekey));
+}
+
+char *
+ikev2_id_str(pkt_payload_t *restrict id, char *restrict buf, size_t buflen)
+{
+	ikev2_id_t *idp = (ikev2_id_t *)id->pp_ptr;
+	ikev2_id_type_t type = idp->id_type;
+	void *data = (idp + 1);
+	size_t datalen = id->pp_len - sizeof (*idp);
+
+	switch (type) {
+	case IKEV2_ID_IPV4_ADDR:
+		(void) inet_ntop(AF_INET, data, buf, buflen);
+		break;
+	case IKEV2_ID_FQDN:
+	case IKEV2_ID_RFC822_ADDR:
+		(void) strlcpy(buf, data, buflen);
+		break;
+	case IKEV2_ID_IPV6_ADDR:
+		(void) inet_ntop(AF_INET6, data, buf, buflen);
+		break;
+	case IKEV2_ID_DER_ASN1_DN:
+	case IKEV2_ID_DER_ASN1_GN:
+		INVALID("not implemented yet");
+		break;
+	case IKEV2_ID_KEY_ID:
+	default:
+		(void) writehex(data, datalen, NULL, buf, buflen);
+		break;
+	case IKEV2_ID_FC_NAME:
+		(void) writehex(data, datalen, ":", buf, buflen);
+		break;
+	}
+
+	return (buf);
+}
+
+boolean_t
+ikev2_create_nonce(ikev2_sa_args_t *restrict i2a, boolean_t initiator,
+    size_t noncelen)
+{
+	uint8_t *restrict buf = initiator ? i2a->i2a_nonce_i : i2a->i2a_nonce_r;
+	size_t *restrict lenp = initiator ?
+	    &i2a->i2a_nonce_i_len : &i2a->i2a_nonce_r_len;
+
+	/*
+	 * A single getentropy(3C) call is limited to 256 bytes in a single
+	 * call.  If further updates to IKEv2 allow for larger nonce sizes,
+	 * we want to catch it at compile time so this can be updated
+	 * appropriately.
+	 */
+	CTASSERT(IKEV2_NONCE_MAX <= 256);
+
+	VERIFY3U(noncelen, >=, IKEV2_NONCE_MIN);
+	VERIFY3U(noncelen, <=, IKEV2_NONCE_MAX);
+
+	/*
+	 * Once set, we don't recreate the nonce for a given exchange, this
+	 * simplifies instances such as encountering an INVALID_KE_PAYLOAD
+	 * where we need to retry and use the same nonce (i.e. during an
+	 * IKE_SA_INIT exchange).
+	 */
+	if (*lenp != 0)
+		return (B_TRUE);
+
+	if (getentropy(buf, noncelen) != 0) {
+		STDERR(error, "getentropy(3C) failed while generating nonce");
+		return (B_FALSE);
+	}
+
+	*lenp = noncelen;
+	return (B_TRUE);
+}
+
+boolean_t
+ikev2_ke(ikev2_sa_args_t *restrict i2a, pkt_t *restrict pkt)
+{
+	pkt_payload_t *ke_pay = NULL;
+	uint8_t *ke = NULL;
+	char *hex = NULL;
+	size_t kelen = 0, hexlen = 0;
+
+	if (i2a->i2a_dh == IKEV2_DH_NONE)
+		return (B_TRUE);
+
+	if ((ke_pay = pkt_get_payload(pkt, IKEV2_PAYLOAD_KE, NULL)) == NULL) {
+		(void) bunyan_warn(log, "Packet is missing KE payload",
+		    BUNYAN_T_END);
+		return (B_FALSE);
+	}
+
+	ke = ke_pay->pp_ptr + sizeof (ikev2_ke_t);
+	kelen = ke_pay->pp_len - sizeof (ikev2_ke_t);
+
+	if (!dh_derivekey(i2a->i2a_privkey, ke, kelen, &i2a->i2a_dhkey))
+		return (B_FALSE);
+
+	if (show_keys) {
+		void *gir = NULL;
+		size_t gir_len = 0;
+		CK_RV rc;
+
+		rc = pkcs11_ObjectToKey(p11h(), i2a->i2a_dhkey, &gir, &gir_len,
+		    B_FALSE);
+
+		hexlen = gir_len * 2 + 1;
+		if (rc == CKR_OK && ((hex = malloc(hexlen)) != NULL)) {
+			bzero(hex, hexlen);
+			writehex(gir, gir_len, "", hex, hexlen);
+		}
+		explicit_bzero(gir, gir_len);
+		free(gir);
+	}
+
+	(void) bunyan_debug(log, "Created g^ir",
+	    show_keys ? BUNYAN_T_STRING : BUNYAN_T_END, "key", hex,
+	    BUNYAN_T_END);
+
+	if (hex != NULL) {
+		explicit_bzero(hex, hexlen);
+		free(hex);
+	}
+
+	return (B_TRUE);
+}
+
+void
+ikev2_save_nonce(ikev2_sa_args_t *restrict i2a, pkt_t *restrict pkt)
+{
+	pkt_payload_t *no_pay = pkt_get_payload(pkt, IKEV2_PAYLOAD_NONCE, NULL);
+
+	VERIFY3U(no_pay->pp_len, <=, IKEV2_NONCE_MAX);
+
+	if (I2P_INITIATOR(pkt)) {
+		bcopy(no_pay->pp_ptr, i2a->i2a_nonce_i, no_pay->pp_len);
+		i2a->i2a_nonce_i_len = no_pay->pp_len;
+	} else {
+		bcopy(no_pay->pp_ptr, i2a->i2a_nonce_r, no_pay->pp_len);
+		i2a->i2a_nonce_r_len = no_pay->pp_len;
+	}
+}
+
+void
+ikev2_save_i2sa_results(ikev2_sa_t *restrict i2sa,
+    ikev2_sa_match_t *restrict result)
+{
+	const encr_data_t *ed = encr_data(result->ism_encr);
+
+	i2sa->encr = result->ism_encr;
+	i2sa->auth = result->ism_auth;
+	i2sa->prf = result->ism_prf;
+	i2sa->dhgrp = result->ism_dh;
+	i2sa->saltlen = ed->ed_saltlen;
+	i2sa->encr_keylen = result->ism_encr_keylen;
+
+	if (i2sa->encr_keylen == 0)
+		i2sa->encr_keylen = ed->ed_keydefault;
+}
+
+boolean_t
+ikev2_create_i2sa_keys(ikev2_sa_t *restrict i2sa, CK_OBJECT_HANDLE skeyseed,
+    uint8_t *restrict ni, size_t ni_len, uint8_t *restrict nr, size_t nr_len)
+{
+	const auth_data_t *ad = auth_data(i2sa->auth);
+
+	uint64_t spis[2] = { i2sa->i_spi, i2sa->r_spi };
+	size_t encrlen = SADB_1TO8(i2sa->encr_keylen);
+	size_t prflen = ikev2_prf_keylen(i2sa->prf);
+	size_t authlen = ad->ad_keylen;
+	CK_MECHANISM_TYPE p11prf = ikev2_prf_to_p11(i2sa->prf);
+	CK_MECHANISM_TYPE p11encr = encr_data(i2sa->encr)->ed_p11id;
+	CK_MECHANISM_TYPE p11auth = ad->ad_p11id;
+	boolean_t ret = B_FALSE;
+	prfp_t prfp = { 0 };
+
+	/*
+	 * RFC7296 2.14:
+	 *
+	 * {SK_d | SK_ai | SK_ar | SK_ei | SK_er | SK_pi | SK_pr}
+	 *			 = prf+ (SKEYSEED, Ni | Nr | SPIi | SPIr)
+	 *
+	 * Note: some encryption mechanisms (e.g. AES-GCM) include a salt
+	 * value (sa->saltlen > 0) as part of their key.  For all currently
+	 * defined mechanisms, these take the form of a cipher key
+	 * (encr_key_len bytes long) followed by the salt bytes.  Since usage
+	 * of these mechanisms requires the salt to be used separate from the
+	 * cipher key, we generate the salt bits in their own operation
+	 * immediately after we've generated the corresponding cipher key.
+	 *
+	 * For more details, see:
+	 *      RFC5282 7.1 for AES-{CCM,GCM}
+	 *      RFC5529 4.1 for Camellia
+	 */
+	if (!prfplus_init(&prfp, i2sa->prf, skeyseed,
+	    ni, ni_len, nr, nr_len, &spis, sizeof (spis), NULL))
+		goto done;
+
+	/*
+	 * If any one of these fail, there's nothing to salvage and the
+	 * functions themselves will log any errors, so take advantage of
+	 * short circuit evaluation.
+	 */
+	ret = prf_to_p11key(&prfp, "SK_d", p11prf, prflen, &i2sa->sk_d) &&
+	    prf_to_p11key(&prfp, "SK_ai", p11auth, authlen, &i2sa->sk_ai) &&
+	    prf_to_p11key(&prfp, "SK_ar", p11auth, authlen, &i2sa->sk_ar) &&
+	    prf_to_p11key(&prfp, "SK_ei", p11encr, encrlen, &i2sa->sk_ei) &&
+	    prfplus(&prfp, i2sa->salt_i, SADB_1TO8(i2sa->saltlen)) &&
+	    prf_to_p11key(&prfp, "SK_er", p11encr, encrlen, &i2sa->sk_er) &&
+	    prfplus(&prfp, i2sa->salt_r, SADB_1TO8(i2sa->saltlen)) &&
+	    prf_to_p11key(&prfp, "SK_pi", p11prf, prflen, &i2sa->sk_pi) &&
+	    prf_to_p11key(&prfp, "SK_pr", p11prf, prflen, &i2sa->sk_pr);
+
+done:
+	prfplus_fini(&prfp);
+	return (ret);
+}
+
+ikev2_sa_args_t *
+ikev2_sa_args_new(boolean_t create_children)
+{
+	ikev2_sa_args_t *args = NULL;
+	ikev2_child_sa_t *in = NULL, *out = NULL;
+
+	if ((args = umem_zalloc(sizeof *args, UMEM_DEFAULT)) == NULL)
+		return (NULL);
+
+	if (create_children) {
+		in = ikev2_child_sa_alloc(B_TRUE);
+		out = ikev2_child_sa_alloc(B_FALSE);
+	}
+
+	if (create_children && (in == NULL || out == NULL)) {
+		ikev2_child_sa_free(NULL, in);
+		ikev2_child_sa_free(NULL, out);
+		umem_free(args, sizeof (*args));
+		return (NULL);
+	}
+
+	args->i2a_child[CSA_IN].csa_child = in;
+	args->i2a_child[CSA_OUT].csa_child = out;
+	return (args);
+}
+
+void
+ikev2_sa_args_free(ikev2_sa_args_t *i2a)
+{
+	if (i2a == NULL)
+		return;
+
+	if (i2a->i2a_pmsg != NULL)
+		parsedmsg_free(i2a->i2a_pmsg);
+
+	if (i2a->i2a_init_i != NULL)
+		umem_free(i2a->i2a_init_i, i2a->i2a_init_i_len);
+	if (i2a->i2a_init_r != NULL)
+		umem_free(i2a->i2a_init_r, i2a->i2a_init_r_len);
+
+	ikev2_child_sa_state_t *kids = i2a->i2a_child;
+	for (int i = 0; i < 2; i++) {
+		if (!kids[i].csa_child_added)
+			ikev2_child_sa_free(i2a->i2a_i2sa, kids[i].csa_child);
+		explicit_bzero(kids[i].csa_child_encr, ENCR_MAX);
+		explicit_bzero(kids[i].csa_child_auth, AUTH_MAX);
+	}
+
+	pkcs11_destroy_obj("dh_pubkey", &i2a->i2a_pubkey);
+	pkcs11_destroy_obj("dh_privkey", &i2a->i2a_privkey);
+	pkcs11_destroy_obj("dh_key", &i2a->i2a_dhkey);
+
+	explicit_bzero(i2a, sizeof (*i2a));
+	umem_free(i2a, sizeof (*i2a));
+}
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_common.h b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_common.h
new file mode 100644
index 0000000000..d4b392fd1d
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_common.h
@@ -0,0 +1,173 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+#ifndef _IKEV2_COMMON_H
+#define	_IKEV2_COMMON_H
+
+#include <net/pfkeyv2.h>
+#include <inttypes.h>
+#include <sys/types.h>
+#include "ikev2.h"
+#include "pkcs11.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct pkt_s;
+struct config_rule_s;
+struct parsedmsg_s;
+struct ikev2_sa_s;
+struct ikev2_child_sa_s;
+struct pkt_payload;
+
+/*
+ * The SA payload is used to describe a host's policy (for both IKE traffic
+ * and when creating IPsec SAs) to a peer.  RFC7296 2.7 has all the details,
+ * but briefly, mechanisms are organized by type (ENCR, AUTH, PRF, etc) and
+ * then grouped into proposals.  Depending on the type of SA being negotiated
+ * (as indicated in the protocol field of the proposal), some types are
+ * required, while others are mandatory.  For example, for an ESP SA,
+ * a proposal MUST specify at least one encryption algorithm and if ESNs can
+ * be used if that proposal is selected.  It can optionally include an
+ * integrity (AUTH) mechanism if one should be used if this proposal is
+ * selected.  A given proposal then loosely means 'any 1 of each type (ENCR,
+ * AUTH, ...) from this list is acceptable.'
+ *
+ * When evaluating proposals, we track which types of mechanisms (transforms)
+ * are present in our policy, which types are present in the peer's policy
+ * we are currently evaluating, as well as which types have found a matching
+ * value.  For a given type, the matching value is then saved in their
+ * respective fields (ism_encr for the matching ENCR mechanism, etc.).  Since
+ * not every transform type is used with a given SA type, this allows us to
+ * make sure we have a match for every type either we or our peer has proposed.
+ *
+ * For convenience, when negotiating IKE SAs, we also include the authentication
+ * method (preshared, RSA sig, etc.) from the matching local policy as well as
+ * the IKE lifetime from the matching local policy.  These are not negotiated
+ * in IKEv2 (i.e. there is no choosing by the responder, each side just uses
+ * whatever is in their local configuration), and are ignored when performing
+ * non-IKE evaluations.
+ */
+typedef struct ikev2_sa_match_s {
+	uint64_t		ism_spi;	/* SPI from matching proposal */
+	uint32_t		ism_match;	/* types that match */
+	uint32_t		ism_have;	/* types in our policy */
+	uint32_t		ism_seen;	/* types from peer */
+	ikev2_spi_proto_t	ism_satype;
+	ikev2_xf_encr_t		ism_encr;
+	ikev2_xf_auth_t		ism_auth;
+	ikev2_prf_t		ism_prf;
+	ikev2_dh_t		ism_dh;
+	uint16_t		ism_encr_keylen;
+	uint16_t		ism_encr_saltlen;
+	boolean_t		ism_esn;
+	uint8_t			ism_propnum;
+	ikev2_auth_type_t	ism_authmethod;	/* auth method for IKE_AUTH */
+	size_t			ism_lifetime_secs;	/* IKE SA lifetime */
+} ikev2_sa_match_t;
+#define	SEEN(which) ((uint32_t)1 << (which))
+#define	SA_MATCH_HAS(m, which) ((m)->ism_have & SEEN(which))
+#define	SA_MATCH_SEEN(m, which) ((m)->ism_seen & SEEN(which))
+#define	SA_MATCHES(m, which) ((m)->ism_match & SEEN(which))
+#define	SA_MATCH(m) \
+    (!!(((m)->ism_match & (m)->ism_seen & (m)->ism_have) == (m)->ism_have))
+
+enum {
+	CSA_IN,
+	CSA_OUT
+};
+
+/* Key length maxes in bytes for array sizing */
+#define	ENCR_MAX SADB_1TO8(IKEV2_ENCR_KEYLEN_MAX + IKEV2_ENCR_SALTLEN_MAX)
+#define	AUTH_MAX SADB_1TO8(IKEV2_AUTH_KEYLEN_MAX)
+
+/* XXX: Needs a better name */
+typedef struct ikev2_child_sa_state_s {
+	struct ikev2_child_sa_s	*csa_child;
+	uint8_t			csa_child_encr[ENCR_MAX];
+	uint8_t			csa_child_auth[AUTH_MAX];
+	boolean_t		csa_child_added;
+} ikev2_child_sa_state_t;
+
+/*
+ * When creating a new IKEv2 SA and/or creating a child SA (either as
+ * part of the IKE_SA_INIT/IKE_AUTH exchanges or as a standalone
+ * CREATE_CHILD_SA exchang), there is a fair amount of transitory state
+ * that needs to be kept, but only until we've either successfully created
+ * the SA in question, or we error out.  That is what is stored here.
+ */
+typedef struct ikev2_sa_args_s {
+	struct ikev2_sa_s	*i2a_i2sa; /* The new IKE SA being created */
+	struct parsedmsg_s	*i2a_pmsg;
+	sadb_msg_t		*i2a_sadb_msg;
+	struct ikev2_child_sa_s *i2a_old_csa; /* Orig Child SA during rekey */
+
+	ikev2_dh_t		i2a_dh;
+
+	CK_OBJECT_HANDLE	i2a_pubkey;
+	CK_OBJECT_HANDLE	i2a_privkey;
+	CK_OBJECT_HANDLE	i2a_dhkey;
+
+	uint8_t			i2a_nonce_i[IKEV2_NONCE_MAX];
+	uint8_t			i2a_nonce_r[IKEV2_NONCE_MAX];
+	size_t			i2a_nonce_i_len;
+	size_t			i2a_nonce_r_len;
+
+	uint8_t			i2a_cookie[IKEV2_COOKIE_MAX];
+	size_t			i2a_cookielen;
+
+	uint8_t			*i2a_init_i;
+	size_t			i2a_init_i_len;
+	uint8_t			*i2a_init_r;
+	size_t			i2a_init_r_len;
+
+	ikev2_child_sa_state_t	i2a_child[2];	/* in, out */
+	uint64_t		i2a_spi;
+	boolean_t		i2a_is_auth;
+} ikev2_sa_args_t;
+
+ikev2_xf_auth_t ikev2_pfkey_to_auth(int);
+ikev2_xf_encr_t ikev2_pfkey_to_encr(int);
+
+boolean_t ikev2_sa_add_result(struct pkt_s *restrict,
+    const ikev2_sa_match_t *restrict, uint64_t);
+boolean_t ikev2_sa_from_rule(struct pkt_s *restrict,
+    const struct config_rule_s *restrict, uint64_t);
+
+boolean_t ikev2_sa_match_rule(struct config_rule_s *restrict,
+    struct pkt_s *restrict, ikev2_sa_match_t *restrict, boolean_t);
+boolean_t ikev2_sa_check_prop(struct config_rule_s *restrict,
+    struct pkt_s *restrict, ikev2_sa_match_t *restrict, boolean_t);
+
+char *ikev2_id_str(struct pkt_payload *restrict, char *restrict, size_t);
+
+boolean_t ikev2_ke(ikev2_sa_args_t *restrict, struct pkt_s *restrict);
+boolean_t ikev2_create_nonce(ikev2_sa_args_t *restrict, boolean_t, size_t);
+void ikev2_save_nonce(ikev2_sa_args_t *restrict, struct pkt_s *restrict);
+
+void ikev2_save_i2sa_results(struct ikev2_sa_s *restrict,
+    ikev2_sa_match_t *restrict);
+boolean_t ikev2_create_i2sa_keys(struct ikev2_sa_s *restrict, CK_OBJECT_HANDLE,
+    uint8_t *restrict, size_t, uint8_t *restrict, size_t);
+
+ikev2_sa_args_t *ikev2_sa_args_new(boolean_t);
+void ikev2_sa_args_free(ikev2_sa_args_t *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _IKEV2_COMMON_H */
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_cookie.c b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_cookie.c
new file mode 100644
index 0000000000..37c3416bea
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_cookie.c
@@ -0,0 +1,310 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+#include <err.h>
+#include <errno.h>
+#include <netinet/in.h>
+#include <libperiodic.h>
+#include <signal.h>
+#include <string.h>
+#include <synch.h>
+#include <sys/debug.h>
+#include <sys/random.h>
+#include <sys/time.h>
+#include <time.h>
+#include <port.h>
+#include "defs.h"
+#include "ikev2_cookie.h"
+#include "ikev2_pkt.h"
+#include "ikev2_proto.h"
+#include "pkcs11.h"
+#include "worker.h"
+
+#define	COOKIE_MECH		CKM_SHA_1
+#define	COOKIE_SECRET_LEN	64
+#define	COOKIE_LEN		(16 + 1)
+#define	COOKIE_SECRET_LIFETIME	60
+#define	COOKIE_GRACE		5
+
+size_t ikev2_cookie_threshold = 128;
+uint_t ikev2_cookie_secret_lifetime = COOKIE_SECRET_LIFETIME;
+uint_t ikev2_cookie_secret_grace = COOKIE_GRACE;
+
+/*
+ * For cookies, we follow the guidance in RFC7296 2.6 and generate cookies
+ * such that:
+ *
+ *	Cookie = <VersionIDofSecret> | Hash(Ni | IPi | SPIi | <secret>)
+ *
+ * where <secret> is a random value of length COOKE_SECRET_LEN bytes,
+ * hash is the hash algorithm designated by COOKIE_MECH (currently CKM_SHA_1),
+ * and <VersionIDofSecret> is a monotonically increasing 8-bit unsigned
+ * value that corresponds to a given value of <secret>.  Note that the remote
+ * peer treats the cookie value as opaque and should not attempt to divine
+ * any structure in the value -- it is merely meant as a reasonably hard to
+ * predict value the remote peer must include in an IKE_SA_INIT exchange
+ * (when we request it) to prevent a remote peer from being able to generate
+ * large amounts of larval (half-open) IKE SAs.
+ *
+ * We create a new secret every COOKIE_SECRET_LIFETIME nanoseconds (currently
+ * once a minute).  We retain the previous secret and allow it's use for up to
+ * COOKIE_GRACE seconds after rotation to minimize excessive IKE_SA_INIT
+ * exchanges if an exchange happens to occur near the end of the current
+ * secret's lifetime.  This rotation is done to minimize the chances a remote
+ * attacker will be able to determine the value of the secret (and thus
+ * defeat it's purpose).  It should be noted that the cookie secret is not
+ * used in deriving any key material -- only as a deterrent, as such having
+ * old values persist in memory for a while after use is not a major concern.
+ *
+ * While we only choose 8 bits to hold the version number, with current the
+ * current lifetime settings, the version number will wrap around about every
+ * 4.5 hours.  Since we only concern ourselves at most with the current and
+ * previous version numbers, the worst (and largely absurd) case is someone
+ * could reply with a cookie derived from a 4.5 old secret.  In this instance,
+ * the cookie check will fail, and things will proceed in the same manner as
+ * if the cookie wasn't present (i.e. an error response with a cookie derived
+ * from the current secret will be sent, and processing will not proceed until
+ * a response with the current cookie is received).  This seems like a
+ * reasonable tradeoff as long as the peers doing the exchange reside on the
+ * same planet.
+ *
+ * We currently only start sending cookies in responses once we hit a threshold
+ * of larval (half-open) IKE SAs (as indicated by the i2c_enabled variable).
+ * However, we are always updating the cookie secret at all times, even while
+ * it is not being used.  The impact is minimal, and it makes things simpler.
+ *
+ * One may note that the threat of a DOS attack from a single host is far
+ * less likely these days than a DDOS, and that cookies are not as effective
+ * in mitigating such attacks.  Such an observer would be correct, however
+ * this is still a SHOULD recommendation in the RFC, it's not particularly
+ * complex, and we MUST support responding to a responder who sends us
+ * cookies -- so it's not really doing much harm.
+ */
+static struct secret_s {
+	uint8_t s_val[COOKIE_SECRET_LEN];
+	hrtime_t s_birth;
+} i2c_secret[2];
+#define	SECRET(v) i2c_secret[(v) & 0x1].s_val
+#define	SECRET_BIRTH(v) i2c_secret[(v) & 0x1].s_birth
+#define	SECRET_AGE(v) (gethrtime() - SECRET_BIRTH(v))
+
+static hrtime_t grace_ns;	/* Only set at startup */
+
+static rwlock_t i2c_lock = DEFAULTRWLOCK;
+static volatile uint8_t i2c_version;
+static boolean_t i2c_enabled;
+static periodic_id_t cookie_timer_id;
+
+static void cookie_update_secret(void *);
+
+void
+ikev2_cookie_enable(void)
+{
+	VERIFY0(rw_wrlock(&i2c_lock));
+	i2c_enabled = B_TRUE;
+	VERIFY0(rw_unlock(&i2c_lock));
+}
+
+void
+ikev2_cookie_disable(void)
+{
+	VERIFY0(rw_wrlock(&i2c_lock));
+	i2c_enabled = B_FALSE;
+	VERIFY0(rw_unlock(&i2c_lock));
+}
+
+static boolean_t
+cookie_calc(uint8_t v, uint8_t *restrict nonce, size_t noncelen,
+    const struct sockaddr *restrict ip, uint64_t spi,
+    uint8_t *out, CK_ULONG outlen)
+{
+	VERIFY(IS_WORKER);
+
+	CK_SESSION_HANDLE h = p11h();
+	CK_MECHANISM mech = { COOKIE_MECH, NULL_PTR, 0 };
+	CK_ULONG iplen = 0;
+	CK_RV rc = CKR_OK;
+
+	rc = C_DigestInit(h, &mech);
+	if (rc != CKR_OK) {
+		PKCS11ERR(error,"C_DigestInit", rc);
+		goto done;
+	}
+
+	rc = C_DigestUpdate(h, nonce, noncelen);
+	if (rc != CKR_OK) {
+		PKCS11ERR(error, "C_DigestUpdate", rc);
+		goto done;
+	}
+
+	iplen = ss_addrlen(ip);
+
+	rc = C_DigestUpdate(h, (CK_BYTE_PTR)ss_addr(ip), iplen);
+	if (rc != CKR_OK) {
+		PKCS11ERR(error, "C_DigestUpdate", rc);
+		goto done;
+	}
+
+	rc = C_DigestUpdate(h, (CK_BYTE_PTR)&spi, sizeof (spi));
+	if (rc != CKR_OK) {
+		PKCS11ERR(error, "C_DigestUpdate", rc);
+		goto done;
+	}
+
+	rc = C_DigestUpdate(h, SECRET(v), COOKIE_SECRET_LEN);
+	if (rc != CKR_OK) {
+		PKCS11ERR(error, "C_DigestUpdate", rc);
+		goto done;
+	}
+
+	rc = C_DigestFinal(h, out, &outlen);
+	if (rc != CKR_OK) {
+		PKCS11ERR(error, "C_DigestFinal", rc);
+		goto done;
+	}
+
+done:
+	return ((rc == CKR_OK) ? B_TRUE : B_FALSE);
+}
+
+static void
+send_cookie(pkt_t *restrict pkt,
+    const struct sockaddr *restrict laddr,
+    const struct sockaddr *restrict raddr)
+{
+	pkt_payload_t *nonce = pkt_get_payload(pkt, IKEV2_PAYLOAD_NONCE, NULL);
+	pkt_t *resp = ikev2_pkt_new_response(pkt);
+	uint8_t buf[COOKIE_LEN] = { 0 };
+
+	if (resp == NULL || nonce == NULL)
+		return;
+
+	buf[0] = i2c_version;
+	if (!cookie_calc(i2c_version, nonce->pp_ptr, nonce->pp_len, raddr,
+	    pkt->pkt_raw[0], buf + 1, sizeof (buf) - 1)) {
+		ikev2_pkt_free(resp);
+		return;
+	}
+
+	if (!ikev2_add_notify_full(resp, IKEV2_PROTO_NONE, 0,
+	    IKEV2_N_COOKIE, buf, sizeof (buf))) {
+		ikev2_pkt_free(resp);
+		return;
+	}
+
+	(void) bunyan_debug(log, "Sending cookie", BUNYAN_T_END);
+
+	(void) ikev2_send_resp_addr(resp, laddr, raddr);
+}
+
+static boolean_t
+cookie_compare(uint8_t *restrict nonce, size_t noncelen,
+    const struct sockaddr *restrict ip, uint64_t spi,
+    uint8_t *restrict cmp, size_t cmplen)
+{
+	uint8_t buf[COOKIE_LEN] = { 0 };
+
+	VERIFY3U(cmplen, ==, sizeof (buf));
+
+	buf[0] = cmp[0];
+	if (!cookie_calc(cmp[0], nonce, noncelen, ip, spi, buf + 1,
+	    sizeof (buf) - 1))
+		return (B_FALSE);
+	return (!!(memcmp(buf, cmp, cmplen) == 0));
+}
+
+/*
+ * If cookies are enabled, perform cookie check and response. Return B_TRUE
+ * if cookie check succeeds.
+ * If cookies aren't enabled, just return B_TRUE to continue processing.
+ */
+boolean_t
+ikev2_cookie_check(pkt_t *restrict pkt,
+    const struct sockaddr *restrict laddr,
+    const struct sockaddr *restrict raddr)
+{
+	pkt_notify_t *cookie = pkt_get_notify(pkt, IKEV2_N_COOKIE, NULL);
+	pkt_payload_t *nonce = pkt_get_payload(pkt, IKEV2_PAYLOAD_NONCE, NULL);
+	boolean_t ok = B_TRUE;
+
+	VERIFY0(rw_rdlock(&i2c_lock));
+	if (!i2c_enabled)
+		goto done;
+
+	if (cookie == NULL) {
+		ok = B_FALSE;
+		send_cookie(pkt, laddr, raddr);
+		goto done;
+	}
+
+	if (cookie->pn_len != COOKIE_LEN) {
+		ok = B_FALSE;
+		goto done;
+	}
+
+	if (cookie->pn_ptr[0] != i2c_version &&
+	    (cookie->pn_ptr[0] != i2c_version - 1 ||
+	    SECRET_AGE(i2c_version - 1) > grace_ns)) {
+		ok = B_FALSE;
+		goto done;
+	}
+
+	ok = cookie_compare(nonce->pp_ptr, nonce->pp_len, raddr,
+	    pkt->pkt_raw[0], cookie->pn_ptr, cookie->pn_len);
+
+done:
+	VERIFY0(rw_unlock(&i2c_lock));
+
+	if (!ok)
+		(void) bunyan_debug(log, "Cookie check failed", BUNYAN_T_END);
+
+	return (ok);
+}
+
+/*ARGSUSED*/
+static void
+cookie_update_secret(void *dummy)
+{
+	uint32_t version = 0;
+
+	VERIFY0(rw_wrlock(&i2c_lock));
+
+	if (SECRET_BIRTH(i2c_version) != 0)
+		i2c_version++;
+
+	version = i2c_version;
+
+	arc4random_buf(SECRET(i2c_version), COOKIE_SECRET_LEN);
+	SECRET_BIRTH(i2c_version) = gethrtime();
+
+	VERIFY0(rw_unlock(&i2c_lock));
+
+	(void) bunyan_debug(log, "Created new cookie secret",
+	    BUNYAN_T_UINT32, "version", version, BUNYAN_T_END);
+}
+
+void
+ikev2_cookie_init(void)
+{
+	hrtime_t interval = SEC2NSEC(ikev2_cookie_secret_lifetime);
+
+	grace_ns = SEC2NSEC(ikev2_cookie_secret_grace);
+	cookie_update_secret(NULL);
+
+	if (periodic_schedule(wk_periodic, interval, 0,
+	    cookie_update_secret, NULL, &cookie_timer_id) != 0) {
+		err(EXIT_FAILURE, "Could not schedule cookie periodic");
+	}
+}
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_cookie.h b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_cookie.h
new file mode 100644
index 0000000000..f675f02086
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_cookie.h
@@ -0,0 +1,48 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+#ifndef _IKEV2_COOKIE_H
+#define	_IKEV2_COOKIE_H
+
+#include <inttypes.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define	IKEV2_COOKIE_OFF_ADJ	(5)	/* XXX: Better name? */
+/* How many larval IKEv2 SAs before enabling cookies */
+extern size_t ikev2_cookie_threshold;
+
+/* Lifetime of cookie secret in seconds */
+extern uint_t ikev2_cookie_secret_lifetime;
+/* How long after a cookie expires do we still accept it in seconds */
+extern uint_t ikev2_cookie_secret_grace;
+
+struct sockaddr;
+struct pkt_s;
+
+void ikev2_cookie_enable(void);
+void ikev2_cookie_disable(void);
+boolean_t ikev2_cookie_check(struct pkt_s *restrict,
+    const struct sockaddr *restrict,
+    const struct sockaddr *restrict);
+void ikev2_cookie_init(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _IKEV2_COOKIE_H */
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_enum.c b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_enum.c
new file mode 100644
index 0000000000..e570fcabcc
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_enum.c
@@ -0,0 +1,476 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017 Joyent, Inc.
+ */
+#include <stdio.h>
+#include <string.h>
+#include "defs.h"
+#include "ikev2_enum.h"
+#include "ikev2.h"
+
+#define	STR(x) case x: return (#x)
+
+/*
+ * NOTE: We intentionally use switch statements instead of arrays for
+ * mapping enumerated constants to strings.  Doing so will allow the
+ * compiler to flag missing conversions for any entries that get added
+ * to enumerated types as long as no default clause is used in the switch.
+ */
+
+const char *
+ikev2_exch_str(ikev2_exch_t id)
+{
+	switch (id) {
+	case IKEV2_EXCH_IKE_SA_INIT:
+		return ("IKE_SA_INIT");
+	case IKEV2_EXCH_IKE_AUTH:
+		return ("IKE_AUTH");
+	case IKEV2_EXCH_CREATE_CHILD_SA:
+		return ("CREATE_CHILD_SA");
+	case IKEV2_EXCH_INFORMATIONAL:
+		return ("INFORMATIONAL");
+	case IKEV2_EXCH_IKE_SESSION_RESUME:
+		return ("IKE_SESSION_RESUME");
+	case IKEV2_EXCH_GSA_AUTH:
+		return ("GSA_AUTH");
+	case IKEV2_EXCH_GSA_REGISTRATION:
+		return ("GSA_REGISTRATION");
+	case IKEV2_EXCH_GSA_REKEY:
+		return ("GSA_REKEY");
+	}
+	return (enum_printf("%hhu", (uint8_t)id));
+}
+
+const char *
+ikev2_pay_str(ikev2_pay_type_t id)
+{
+	switch (id) {
+	STR(IKEV2_PAYLOAD_NONE);
+	STR(IKEV2_PAYLOAD_SA);
+	STR(IKEV2_PAYLOAD_KE);
+	STR(IKEV2_PAYLOAD_IDi);
+	STR(IKEV2_PAYLOAD_IDr);
+	STR(IKEV2_PAYLOAD_CERT);
+	STR(IKEV2_PAYLOAD_CERTREQ);
+	STR(IKEV2_PAYLOAD_AUTH);
+	STR(IKEV2_PAYLOAD_NONCE);
+	STR(IKEV2_PAYLOAD_NOTIFY);
+	STR(IKEV2_PAYLOAD_DELETE);
+	STR(IKEV2_PAYLOAD_VENDOR);
+	STR(IKEV2_PAYLOAD_TSi);
+	STR(IKEV2_PAYLOAD_TSr);
+	STR(IKEV2_PAYLOAD_SK);
+	STR(IKEV2_PAYLOAD_CP);
+	STR(IKEV2_PAYLOAD_EAP);
+	STR(IKEV2_PAYLOAD_GSPM);
+	STR(IKEV2_PAYLOAD_IDg);
+	STR(IKEV2_PAYLOAD_GSA);
+	STR(IKEV2_PAYLOAD_KD);
+	STR(IKEV2_PAYLOAD_SKF);
+	STR(IKEV2_PAYLOAD_PS);
+	}
+
+	return (enum_printf("%hhu", (uint8_t)id));
+}
+
+const char *
+ikev2_pay_short_str(ikev2_pay_type_t id)
+{
+	switch (id) {
+	case IKEV2_PAYLOAD_NONE:
+		return ("NONE");
+	case IKEV2_PAYLOAD_SA:
+		return ("SA");
+	case IKEV2_PAYLOAD_KE:
+		return ("KE");
+	case IKEV2_PAYLOAD_IDi:
+		return ("IDi");
+	case IKEV2_PAYLOAD_IDr:
+		return ("IDr");
+	case IKEV2_PAYLOAD_CERT:
+		return ("CERT");
+	case IKEV2_PAYLOAD_CERTREQ:
+		return ("CERTREQ");
+	case IKEV2_PAYLOAD_AUTH:
+		return ("AUTH");
+	case IKEV2_PAYLOAD_NONCE:
+		return ("No");
+	case IKEV2_PAYLOAD_NOTIFY:
+		return ("N");
+	case IKEV2_PAYLOAD_DELETE:
+		return ("D");
+	case IKEV2_PAYLOAD_VENDOR:
+		return ("V");
+	case IKEV2_PAYLOAD_TSi:
+		return ("TSi");
+	case IKEV2_PAYLOAD_TSr:
+		return ("TSr");
+	case IKEV2_PAYLOAD_SK:
+		return ("SK");
+	case IKEV2_PAYLOAD_CP:
+		return ("CP");
+	case IKEV2_PAYLOAD_EAP:
+		return ("EAP");
+	case IKEV2_PAYLOAD_GSPM:
+		return ("GSPM");
+	case IKEV2_PAYLOAD_IDg:
+		return ("IDg");
+	case IKEV2_PAYLOAD_GSA:
+		return ("GSA");
+	case IKEV2_PAYLOAD_KD:
+		return ("KD");
+	case IKEV2_PAYLOAD_SKF:
+		return ("SKF");
+	case IKEV2_PAYLOAD_PS:
+		return ("PS");
+	}
+	return (enum_printf("%hhu", (uint8_t)id));
+}
+
+const char *
+ikev2_spi_str(ikev2_spi_proto_t id)
+{
+	switch (id) {
+	case IKEV2_PROTO_NONE:
+		return ("NONE");
+	case IKEV2_PROTO_IKE:
+		return ("IKE");
+	case IKEV2_PROTO_AH:
+		return ("AH");
+	case IKEV2_PROTO_ESP:
+		return ("ESP");
+	case IKEV2_PROTO_FC_ESP_HEADER:
+		return ("FC_ESP_HEADER");
+	case IKEV2_PROTO_FC_CT_AUTH:
+		return ("FC_CT_AUTH");
+	}
+	return (enum_printf("%hhu", (uint8_t)id));
+}
+
+const char *
+ikev2_xf_type_str(ikev2_xf_type_t id)
+{
+	switch (id) {
+	case IKEV2_XF_ENCR:
+		return ("ENCR");
+	case IKEV2_XF_PRF:
+		return ("PRF");
+	case IKEV2_XF_AUTH:
+		return ("AUTH");
+	case IKEV2_XF_DH:
+		return ("DH");
+	case IKEV2_XF_ESN:
+		return ("ESN");
+	}
+	return (enum_printf("%hhu", (uint8_t)id));
+}
+
+const char *
+ikev2_xf_encr_str(ikev2_xf_encr_t id)
+{
+	switch (id) {
+	STR(IKEV2_ENCR_NONE);
+	STR(IKEV2_ENCR_DES_IV64);
+	STR(IKEV2_ENCR_DES);
+	STR(IKEV2_ENCR_3DES);
+	STR(IKEV2_ENCR_RC5);
+	STR(IKEV2_ENCR_IDEA);
+	STR(IKEV2_ENCR_CAST);
+	STR(IKEV2_ENCR_BLOWFISH);
+	STR(IKEV2_ENCR_3IDEA);
+	STR(IKEV2_ENCR_DES_IV32);
+	STR(IKEV2_ENCR_RC4);
+	STR(IKEV2_ENCR_NULL);
+	STR(IKEV2_ENCR_AES_CBC);
+	STR(IKEV2_ENCR_AES_CTR);
+	STR(IKEV2_ENCR_AES_CCM_8);
+	STR(IKEV2_ENCR_AES_CCM_12);
+	STR(IKEV2_ENCR_AES_CCM_16);
+	STR(IKEV2_ENCR_AES_GCM_8);
+	STR(IKEV2_ENCR_AES_GCM_12);
+	STR(IKEV2_ENCR_AES_GCM_16);
+	STR(IKEV2_ENCR_NULL_AES_GMAC);
+	STR(IKEV2_ENCR_XTS_AES);
+	STR(IKEV2_ENCR_CAMELLIA_CBC);
+	STR(IKEV2_ENCR_CAMELLIA_CTR);
+	STR(IKEV2_ENCR_CAMELLIA_CCM_8);
+	STR(IKEV2_ENCR_CAMELLIA_CCM_12);
+	STR(IKEV2_ENCR_CAMELLIA_CCM_16);
+	}
+	return (enum_printf("%hhu", (uint8_t)id));
+}
+
+const char *
+ikev2_xf_auth_str(ikev2_xf_auth_t id)
+{
+	switch (id) {
+	STR(IKEV2_XF_AUTH_NONE);
+	STR(IKEV2_XF_AUTH_HMAC_MD5_96);
+	STR(IKEV2_XF_AUTH_HMAC_SHA1_96);
+	STR(IKEV2_XF_AUTH_DES_MAC);
+	STR(IKEV2_XF_AUTH_KPDK_MD5);
+	STR(IKEV2_XF_AUTH_AES_XCBC_96);
+	STR(IKEV2_XF_AUTH_HMAC_MD5_128);
+	STR(IKEV2_XF_AUTH_HMAC_SHA1_160);
+	STR(IKEV2_XF_AUTH_AES_CMAC_96);
+	STR(IKEV2_XF_AUTH_AES_128_GMAC);
+	STR(IKEV2_XF_AUTH_AES_192_GMAC);
+	STR(IKEV2_XF_AUTH_AES_256_GMAC);
+	STR(IKEV2_XF_AUTH_HMAC_SHA2_256_128);
+	STR(IKEV2_XF_AUTH_HMAC_SHA2_384_192);
+	STR(IKEV2_XF_AUTH_HMAC_SHA2_512_256);
+	}
+	return (enum_printf("%hhu", (uint8_t)id));
+}
+
+const char *
+ikev2_auth_type_str(ikev2_auth_type_t id)
+{
+	switch (id) {
+	STR(IKEV2_AUTH_NONE);
+	STR(IKEV2_AUTH_RSA_SIG);
+	STR(IKEV2_AUTH_SHARED_KEY_MIC);
+	STR(IKEV2_AUTH_DSS_SIG);
+	STR(IKEV2_AUTH_ECDSA_256);
+	STR(IKEV2_AUTH_ECDSA_384);
+	STR(IKEV2_AUTH_ECDSA_512);
+	STR(IKEV2_AUTH_GSPM);
+	}
+	return (enum_printf("%hhu", (uint8_t)id));
+}
+
+const char *
+ikev2_dh_str(ikev2_dh_t id)
+{
+	switch (id) {
+	STR(IKEV2_DH_NONE);
+	STR(IKEV2_DH_MODP_768);
+	STR(IKEV2_DH_MODP_1024);
+	STR(IKEV2_DH_EC2N_155);
+	STR(IKEV2_DH_EC2N_185);
+	STR(IKEV2_DH_MODP_1536);
+	STR(IKEV2_DH_MODP_2048);
+	STR(IKEV2_DH_MODP_3072);
+	STR(IKEV2_DH_MODP_4096);
+	STR(IKEV2_DH_MODP_6144);
+	STR(IKEV2_DH_MODP_8192);
+	STR(IKEV2_DH_ECP_256);
+	STR(IKEV2_DH_ECP_384);
+	STR(IKEV2_DH_ECP_521);
+	STR(IKEV2_DH_MODP_1024_160);
+	STR(IKEV2_DH_MODP_2048_224);
+	STR(IKEV2_DH_MODP_2048_256);
+	STR(IKEV2_DH_ECP_192);
+	STR(IKEV2_DH_ECP_224);
+	STR(IKEV2_DH_BRAINPOOL_P224R1);
+	STR(IKEV2_DH_BRAINPOOL_P256R1);
+	STR(IKEV2_DH_BRAINPOOL_P384R1);
+	STR(IKEV2_DH_BRAINPOOL_P512R1);
+	}
+	return (enum_printf("%hhu", (uint8_t)id));
+}
+
+const char *
+ikev2_prf_str(ikev2_prf_t id)
+{
+	switch (id) {
+	STR(IKEV2_PRF_HMAC_MD5);
+	STR(IKEV2_PRF_HMAC_SHA1);
+	STR(IKEV2_PRF_HMAC_TIGER);
+	STR(IKEV2_PRF_AES128_XCBC);
+	STR(IKEV2_PRF_HMAC_SHA2_256);
+	STR(IKEV2_PRF_HMAC_SHA2_384);
+	STR(IKEV2_PRF_HMAC_SHA2_512);
+	STR(IKEV2_PRF_AES128_CMAC);
+	}
+	return (enum_printf("%hhu", (uint8_t)id));
+}
+
+const char *
+ikev2_xf_str(ikev2_xf_type_t type, uint16_t val)
+{
+	switch (type) {
+	case IKEV2_XF_ENCR:
+		return (ikev2_xf_encr_str(val));
+	case IKEV2_XF_PRF:
+		return (ikev2_prf_str(val));
+	case IKEV2_XF_AUTH:
+		return (ikev2_xf_auth_str(val));
+	case IKEV2_XF_DH:
+		return (ikev2_dh_str(val));
+	case IKEV2_XF_ESN:
+		switch (val) {
+		case 0:
+			return ("NO");
+		case 1:
+			return ("YES");
+		}
+		/* Let default print numeric value */
+		break;
+	}
+	return (enum_printf("%hhu", val));
+}
+
+const char *
+ikev2_notify_str(ikev2_notify_type_t id)
+{
+	switch (id) {
+	case IKEV2_N_UNSUPPORTED_CRITICAL_PAYLOAD:
+		return ("UNSUPPORTED_CRITICAL_PAYLOAD");
+	case IKEV2_N_INVALID_IKE_SPI:
+		return ("INVALID_IKE_SPI");
+	case IKEV2_N_INVALID_MAJOR_VERSION:
+		return ("INVALID_MAJOR_VERSION");
+	case IKEV2_N_INVALID_SYNTAX:
+		return ("INVALID_SYNTAX");
+	case IKEV2_N_INVALID_MESSAGE_ID:
+		return ("INVALID_MESSAGE_ID");
+	case IKEV2_N_INVALID_SPI:
+		return ("INVALID_SPI");
+	case IKEV2_N_NO_PROPOSAL_CHOSEN:
+		return ("NO_PROPOSAL_CHOSEN");
+	case IKEV2_N_INVALID_KE_PAYLOAD:
+		return ("INVALID_KE_PAYLOAD");
+	case IKEV2_N_AUTHENTICATION_FAILED:
+		return ("AUTHENTICATION_FAILED");
+	case IKEV2_N_SINGLE_PAIR_REQUIRED:
+		return ("SINGLE_PAIR_REQUIRED");
+	case IKEV2_N_NO_ADDITIONAL_SAS:
+		return ("NO_ADDITIONAL_SAS");
+	case IKEV2_N_INTERNAL_ADDRESS_FAILURE:
+		return ("INTERNAL_ADDRESS_FAILURE");
+	case IKEV2_N_FAILED_CP_REQUIRED:
+		return ("FAILED_CP_REQUIRED");
+	case IKEV2_N_TS_UNACCEPTABLE:
+		return ("TS_UNACCEPTABLE");
+	case IKEV2_N_INVALID_SELECTORS:
+		return ("INVALID_SELECTORS");
+	case IKEV2_N_UNACCEPTABLE_ADDRESSES:
+		return ("UNACCEPTABLE_ADDRESSES");
+	case IKEV2_N_UNEXPECTED_NAT_DETECTED:
+		return ("UNEXPECTED_NAT_DETECTED");
+	case IKEV2_N_USE_ASSIGNED_HoA:
+		return ("USE_ASSIGNED_HoA");
+	case IKEV2_N_TEMPORARY_FAILURE:
+		return ("TEMPORARY_FAILURE");
+	case IKEV2_N_CHILD_SA_NOT_FOUND:
+		return ("CHILD_SA_NOT_FOUND");
+	case IKEV2_N_INITIAL_CONTACT:
+		return ("INITIAL_CONTACT");
+	case IKEV2_N_SET_WINDOW_SIZE:
+		return ("SET_WINDOW_SIZE");
+	case IKEV2_N_ADDITIONAL_TS_POSSIBLE:
+		return ("ADDITIONAL_TS_POSSIBLE");
+	case IKEV2_N_IPCOMP_SUPPORTED:
+		return ("IPCOMP_SUPPORTED");
+	case IKEV2_N_NAT_DETECTION_SOURCE_IP:
+		return ("NAT_DETECTION_SOURCE_IP");
+	case IKEV2_N_NAT_DETECTION_DESTINATION_IP:
+		return ("NAT_DETECTION_DESTINATION_IP");
+	case IKEV2_N_COOKIE:
+		return ("COOKIE");
+	case IKEV2_N_USE_TRANSPORT_MODE:
+		return ("USE_TRANSPORT_MODE");
+	case IKEV2_N_HTTP_CERT_LOOKUP_SUPPORTED:
+		return ("HTTP_CERT_LOOKUP_SUPPORTED");
+	case IKEV2_N_REKEY_SA:
+		return ("REKEY_SA");
+	case IKEV2_N_ESP_TFC_PADDING_NOT_SUPPORTED:
+		return ("ESP_TFC_PADDING_NOT_SUPPORTED");
+	case IKEV2_N_NON_FIRST_FRAGMENTS_ALSO:
+		return ("NON_FIRST_FRAGMENTS_ALSO");
+	case IKEV2_N_MOBIKE_SUPPORTED:
+		return ("MOBIKE_SUPPORTED");
+	case IKEV2_N_ADDITIONAL_IP4_ADDRESS:
+		return ("ADDITIONAL_IP4_ADDRESS");
+	case IKEV2_N_ADDITIONAL_IP6_ADDRESS:
+		return ("ADDITIONAL_IP6_ADDRESS");
+	case IKEV2_N_NO_ADDITIONAL_ADDRESSES:
+		return ("NO_ADDITIONAL_ADDRESSES");
+	case IKEV2_N_UPDATE_SA_ADDRESSES:
+		return ("UPDATE_SA_ADDRESSES");
+	case IKEV2_N_COOKIE2:
+		return ("COOKIE2");
+	case IKEV2_N_NO_NATS_ALLOWED:
+		return ("NO_NATS_ALLOWED");
+	case IKEV2_N_AUTH_LIFETIME:
+		return ("AUTH_LIFETIME");
+	case IKEV2_N_MULTIPLE_AUTH_SUPPORTED:
+		return ("MULTIPLE_AUTH_SUPPORTED");
+	case IKEV2_N_ANOTHER_AUTH_FOLLOWS:
+		return ("ANOTHER_AUTH_FOLLOWS");
+	case IKEV2_N_REDIRECT_SUPPORTED:
+		return ("REDIRECT_SUPPORTED");
+	case IKEV2_N_REDIRECT:
+		return ("REDIRECT");
+	case IKEV2_N_REDIRECTED_FROM:
+		return ("REDIRECTED_FROM");
+	case IKEV2_N_TICKET_LT_OPAQUE:
+		return ("TICKET_LT_OPAQUE");
+	case IKEV2_N_TICKET_REQUEST:
+		return ("TICKET_REQUEST");
+	case IKEV2_N_TICKET_ACK:
+		return ("TICKET_ACK");
+	case IKEV2_N_TICKET_NACK:
+		return ("TICKET_NACK");
+	case IKEV2_N_TICKET_OPAQUE:
+		return ("TICKET_OPAQUE");
+	case IKEV2_N_LINK_ID:
+		return ("LINK_ID");
+	case IKEV2_N_USE_WESP_MODE:
+		return ("USE_WESP_MODE");
+	case IKEV2_N_ROHC_SUPPORTED:
+		return ("ROHC_SUPPORTED");
+	case IKEV2_N_EAP_ONLY_AUTHENTICATION:
+		return ("EAP_ONLY_AUTHENTICATION");
+	case IKEV2_N_CHILDLESS_IKEV2_SUPPORTED:
+		return ("CHILDLESS_IKEV2_SUPPORTED");
+	case IKEV2_N_QUICK_CRASH_DETECTION:
+		return ("QUICK_CRASH_DETECTION");
+	case IKEV2_N_IKEV2_MESSAGE_ID_SYNC_SUPPORTED:
+		return ("IKEV2_MESSAGE_ID_SYNC_SUPPORTED");
+	case IKEV2_N_IPSEC_REPLAY_CTR_SYNC_SUPPORTED:
+		return ("IPSEC_REPLAY_CTR_SYNC_SUPPORTED");
+	case IKEV2_N_IKEV2_MESSAGE_ID_SYNC:
+		return ("IKEV2_MESSAGE_ID_SYNC");
+	case IKEV2_N_IPSEC_REPLAY_CTR_SYNC:
+		return ("IPSEC_REPLAY_CTR_SYNC");
+	case IKEV2_N_SECURE_PASSWORD_METHODS:
+		return ("SECURE_PASSWORD_METHODS");
+	case IKEV2_N_PSK_PERSIST:
+		return ("PSK_PERSIST");
+	case IKEV2_N_PSK_CONFIRM:
+		return ("PSK_CONFIRM");
+	case IKEV2_N_ERX_SUPPORTED:
+		return ("ERX_SUPPORTED");
+	case IKEV2_N_IFOM_CAPABILITY:
+		return ("IFOM_CAPABILITY");
+	}
+	return (enum_printf("%hu", (uint16_t)id));
+}
+
+const char *
+ikev2_id_type_str(ikev2_id_type_t id)
+{
+	switch (id) {
+	STR(IKEV2_ID_IPV4_ADDR);
+	STR(IKEV2_ID_FQDN);
+	STR(IKEV2_ID_RFC822_ADDR);
+	STR(IKEV2_ID_IPV6_ADDR);
+	STR(IKEV2_ID_DER_ASN1_DN);
+	STR(IKEV2_ID_DER_ASN1_GN);
+	STR(IKEV2_ID_KEY_ID);
+	STR(IKEV2_ID_FC_NAME);
+	}
+	return (enum_printf("%hhu", (uint8_t)id));
+}
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_enum.h b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_enum.h
new file mode 100644
index 0000000000..4fe8d79256
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_enum.h
@@ -0,0 +1,44 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2017 Joyent, Inc.
+ */
+
+#ifndef _IKEV2_ENUM_H
+#define	_IKEV2_ENUM_H
+
+#include <inttypes.h>
+#include "ikev2.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+const char *ikev2_exch_str(ikev2_exch_t);
+const char *ikev2_pay_str(ikev2_pay_type_t);
+const char *ikev2_pay_short_str(ikev2_pay_type_t);
+const char *ikev2_spi_str(ikev2_spi_proto_t);
+const char *ikev2_xf_str(ikev2_xf_type_t, uint16_t);
+const char *ikev2_xf_type_str(ikev2_xf_type_t);
+const char *ikev2_xf_encr_str(ikev2_xf_encr_t);
+const char *ikev2_xf_auth_str(ikev2_xf_auth_t);
+const char *ikev2_dh_str(ikev2_dh_t);
+const char *ikev2_prf_str(ikev2_prf_t);
+const char *ikev2_auth_type_str(ikev2_auth_type_t);
+const char *ikev2_notify_str(ikev2_notify_type_t);
+const char *ikev2_id_type_str(ikev2_id_type_t);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _IKEV2_ENUM_H */
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_ike_auth.c b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_ike_auth.c
new file mode 100644
index 0000000000..52cd2310e6
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_ike_auth.c
@@ -0,0 +1,895 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017 Joyent, Inc.
+ */
+
+#include <bunyan.h>
+#include <errno.h>
+#include <strings.h>
+#include <synch.h>
+#include <sys/debug.h>
+#include <sys/sha2.h>	/* For digest sizes */
+#include "config.h"
+#include "defs.h"
+#include "ikev2.h"
+#include "ikev2_common.h"
+#include "ikev2_enum.h"
+#include "ikev2_pkt.h"
+#include "ikev2_proto.h"
+#include "ikev2_sa.h"
+#include "pkcs11.h"
+#include "pkt.h"
+#include "preshared.h"
+#include "prf.h"
+#include "worker.h"
+
+static void ikev2_ike_auth_init_resp(ikev2_sa_t *restrict, pkt_t *restrict,
+    void *restrict);
+static boolean_t ikev2_auth_failed(ikev2_sa_t *);
+static boolean_t create_psk(ikev2_sa_t *);
+static boolean_t calc_auth(ikev2_sa_t *restrict, boolean_t,
+    pkt_payload_t *restrict, uint8_t *restrict, size_t);
+static boolean_t add_id(pkt_t *, const config_id_t *id, boolean_t);
+static boolean_t add_auth(pkt_t *);
+static boolean_t check_auth(pkt_t *);
+static boolean_t check_remote_id(pkt_t *, config_id_t **);
+
+static config_id_t *i2id_to_cid(pkt_payload_t *);
+static size_t get_authlen(const ikev2_sa_t *);
+
+void
+ikev2_ike_auth_init(ikev2_sa_t *restrict sa)
+{
+	VERIFY(IS_WORKER);
+	VERIFY(!MUTEX_HELD(&sa->i2sa_queue_lock));
+	VERIFY(MUTEX_HELD(&sa->i2sa_lock));
+
+	ikev2_sa_args_t *sa_args = sa->sa_init_args;
+	config_rule_t *rule = sa->i2sa_rule;
+	pkt_t *req = ikev2_pkt_new_exchange(sa, IKEV2_EXCH_IKE_AUTH);
+
+	/*
+	 * Once we start the IKE_AUTH exchange, we no longer need the
+	 * DH keys used during the IKE_SA_INIT exchange
+	 */
+	pkcs11_destroy_obj("dh_pubkey", &sa_args->i2a_pubkey);
+	pkcs11_destroy_obj("dh_privkey", &sa_args->i2a_privkey);
+	pkcs11_destroy_obj("dh_key", &sa_args->i2a_dhkey);
+
+	(void) bunyan_debug(log, "Starting IKE_AUTH exchange", BUNYAN_T_END);
+
+	if (req == NULL)
+		goto fail;
+
+	if (!add_id(req, rule->rule_local_id, B_TRUE))
+		goto fail;
+
+	/* XXX: CERT */
+
+	if (!ikev2_add_notify(req, IKEV2_N_INITIAL_CONTACT))
+		goto fail;
+
+	/* XXX: HTTP_CERT_LOOKUP_SUPPORTED */
+
+	/* XXX: CERTREQ */
+
+	/*
+	 * XXX: We can optionally add _1_ IDr payload to indicate a preferred
+	 * ID for the responder to use.  Since we currently support multiple
+	 * remote ids in a rule, not sure there's any benefit to do this.
+	 * For now, we elect not to do this.
+	 */
+
+	if (!add_auth(req))
+		goto fail;
+
+	if (!ikev2_create_child_sa_init_auth(sa, req))
+		goto fail;
+
+	if (!ikev2_send_req(req, ikev2_ike_auth_init_resp, sa_args)) {
+		req = NULL;
+		goto fail;
+	}
+
+	return;
+
+fail:
+	(void) bunyan_error(log, "Cound not send IKE_AUTH request",
+	    BUNYAN_T_END);
+	sa->flags |= I2SA_CONDEMNED;
+	ikev2_pkt_free(req);
+}
+
+/* We are the responder */
+void
+ikev2_ike_auth_resp(pkt_t *req)
+{
+	VERIFY(IS_WORKER);
+	VERIFY(MUTEX_HELD(&req->pkt_sa->i2sa_lock));
+
+	ikev2_sa_t *sa = req->pkt_sa;
+	ikev2_sa_args_t *sa_args = sa->sa_init_args;
+	config_rule_t *rule = sa->i2sa_rule;
+	pkt_t *resp = NULL;
+	pkt_payload_t *id_r = NULL;
+	config_id_t *cid_i = NULL;
+	const char *mstr = NULL;
+
+	resp = ikev2_pkt_new_response(req);
+
+	/*
+	 * If we're out of memory, instead of just condemning the IKE SA
+	 * we'll wait for the P1 timeout.  It may be possible we can
+	 * proceed upon receiving a retransmit.
+	 */
+	if (resp == NULL)
+		goto fail;
+
+	/*
+	 * This is possible, but strange -- we've authenticated
+	 * (IKE_AUTH messages always start with msgid 1, but could go higher
+	 * if/when we support EAP, so it must be > 1 or else we should have
+	 * already handled it as a duplicate), but are receiving another
+	 * IKE_AUTH request.  RFC7296 says nothing about this, however the
+	 * peer is expecting a response, the only good candidates are
+	 * AUTHENTICATION_FAILED or INVALID_SYNTAX.  The latter seems better
+	 * since we've already authenticated.
+	 */
+	if (sa->flags & I2SA_AUTHENTICATED) {
+		VERIFY3U(ntohl(pkt_header(req)->msgid), >, 1);
+		(void) bunyan_warn(log,
+		    "Received an IKE_AUTH request to an already authenticated "
+		    "IKE SA;", BUNYAN_T_END);
+
+		/* This is the 2nd payload (after SK) -- it should always fit */
+		VERIFY(ikev2_add_notify(resp, IKEV2_N_INVALID_SYNTAX));
+		(void) ikev2_send_resp(resp);
+		return;
+	}
+
+	/*
+	 * Once we start the IKE_AUTH exchange, we no longer need the
+	 * DH keys used during the IKE_SA_INIT exchange
+	 */
+	pkcs11_destroy_obj("dh_pubkey", &sa_args->i2a_pubkey);
+	pkcs11_destroy_obj("dh_privkey", &sa_args->i2a_privkey);
+	pkcs11_destroy_obj("dh_key", &sa_args->i2a_dhkey);
+
+	(void) bunyan_debug(log, "Responding to IKE_AUTH request",
+	    BUNYAN_T_END);
+
+	if (!check_remote_id(req, &cid_i))
+		goto authfail;
+	key_add_id(LOG_KEY_REMOTE_ID, LOG_KEY_REMOTE_ID_TYPE, cid_i);
+
+	mstr = ikev2_auth_type_str(sa->authmethod);
+
+	/*
+	 * RFC7296 2.21.2 - We must first authenticate before we can
+	 * possibly send errors related to the piggybacked child SA
+	 * creation.
+	 */
+	if (!check_auth(req)) {
+		(void) bunyan_warn(log, "Authentication failed",
+		    BUNYAN_T_STRING, "authmethod", mstr,
+		    BUNYAN_T_END);
+
+		goto authfail;
+	}
+
+	sa->remote_id = cid_i;
+	sa->flags |= I2SA_AUTHENTICATED;
+	(void) ikev2_sa_disarm_timer(sa, I2SA_EVT_P1_EXPIRE);
+
+	(void) bunyan_info(log, "Authentication successful",
+	    BUNYAN_T_STRING, "authmethod", mstr,
+	    BUNYAN_T_END);
+
+	/*
+	 * XXX: Check for INITIAL_CONTACT, if there delete any existing
+	 * IPsec SAs between the two hosts.
+	 */
+
+	/* The initiator may optionally request we send a specific ID */
+	if ((id_r = pkt_get_payload(req, IKEV2_PAYLOAD_IDr, NULL)) != NULL) {
+		/*
+		 * If the initiator is requesting an ID that is not the one
+		 * specified in the rule, for now we'll note the difference
+		 * and still respond, using our configured id.
+		 */
+		config_id_t *cid_r = NULL;
+
+		/* If this fails, we just ignore the whole payload */
+		if ((cid_r = i2id_to_cid(id_r)) != NULL &&
+		    config_id_cmp(cid_r, rule->rule_local_id) != 0) {
+			uint8_t idtype = *id_r->pp_ptr;
+			char idbuf[256] = { 0 };
+
+			(void) bunyan_info(log,
+			    "Initiator requested ID other than ours",
+			    BUNYAN_T_STRING, "idtype",
+			    ikev2_id_type_str(idtype),
+			    BUNYAN_T_STRING, "id",
+			    ikev2_id_str(id_r, idbuf, sizeof (idbuf)),
+			    BUNYAN_T_END);
+		}
+		config_id_free(cid_r);
+	}
+
+	if (!add_id(resp, rule->rule_local_id, B_FALSE))
+		goto fail;
+
+	/* XXX: Add CERT payloads */
+
+	if (!add_auth(resp))
+		goto fail;
+
+	if (!ikev2_create_child_sa_resp_auth(req, resp))
+		goto fail;
+
+	if (!ikev2_send_resp(resp)) {
+		resp = NULL;
+		goto fail;
+	}
+
+	ikev2_sa_args_free(sa->sa_init_args);
+	sa->sa_init_args = NULL;
+	return;
+
+fail:
+	(void) bunyan_error(log, "Cound not send IKE_AUTH response",
+	    BUNYAN_T_END);
+
+	ikev2_sa_args_free(sa->sa_init_args);
+	sa->sa_init_args = NULL;
+	sa->flags |= I2SA_CONDEMNED;
+	ikev2_pkt_free(resp);
+	return;
+
+authfail:
+	config_id_free(cid_i);
+	ikev2_sa_args_free(sa->sa_init_args);
+	sa->sa_init_args = NULL;
+	sa->flags |= I2SA_CONDEMNED;
+
+	VERIFY(ikev2_add_notify(resp, IKEV2_N_AUTHENTICATION_FAILED));
+	(void) ikev2_send_resp(resp);
+}
+
+/*
+ * We are the initiator, this is the response
+ */
+static void
+ikev2_ike_auth_init_resp(ikev2_sa_t *restrict sa, pkt_t *restrict resp,
+    void *restrict arg)
+{
+	ikev2_sa_args_t *sa_args = arg;
+	config_id_t *cid_r = NULL;
+	const char *mstr = NULL;
+
+	VERIFY(IS_WORKER);
+	VERIFY(MUTEX_HELD(&sa->i2sa_lock));
+
+	(void) bunyan_debug(log, "Received IKE_AUTH response",
+	    BUNYAN_T_END);
+
+	/* ikev2_retransmit() will condemn the IKE SA if we timeout */
+	if (resp == NULL) {
+		/* Let the piggy-backed child SA cleanup */
+		ikev2_create_child_sa_init_resp_auth(sa, NULL, arg);
+		return;
+	}
+
+	/*
+	 * RFC 7296 2.21.2 -- If authentication fails, the IKE SA is not
+	 * established.  However, authentication can successfully complete
+	 * while the included child SA request can fail, which does not
+	 * necessairly cause the IKE SA to be deleted -- if we wish to
+	 * delete the IKE SA, or if we (the initiator) reject the IKE SA
+	 * (as opposed to the responder), it all must be done in a separate
+	 * exchange.  All of that is to say, that this is the only notification
+	 * we check for doing the authentication portion of the processing.
+	 */
+	if (pkt_get_notify(resp, IKEV2_N_AUTHENTICATION_FAILED, NULL) != NULL) {
+		(void) bunyan_warn(log,
+		    "Remote rejected our authentication attempt",
+		    BUNYAN_T_END);
+
+		ikev2_create_child_sa_init_resp_auth(sa, NULL, arg);
+		sa->flags |= I2SA_CONDEMNED;
+		return;
+	}
+
+	if (!check_remote_id(resp, &cid_r))
+		goto fail;
+
+	mstr = ikev2_auth_type_str(sa->authmethod);
+
+	key_add_id(LOG_KEY_REMOTE_ID, LOG_KEY_REMOTE_ID_TYPE, cid_r);
+
+	if (!check_auth(resp)) {
+		(void) bunyan_warn(log, "Authentication failed",
+		    BUNYAN_T_STRING, "authmethod", mstr,
+		    BUNYAN_T_END);
+		goto fail;
+	}
+
+	(void) bunyan_info(log, "Authentication successful",
+	    BUNYAN_T_STRING, "authmethod", mstr,
+	    BUNYAN_T_END);
+
+	sa->remote_id = cid_r;
+	sa->flags |= I2SA_AUTHENTICATED;
+	(void) ikev2_sa_disarm_timer(sa, I2SA_EVT_P1_EXPIRE);
+
+	ikev2_create_child_sa_init_resp_auth(sa, resp, arg);
+	ikev2_sa_args_free(sa->sa_init_args);
+	sa->sa_init_args = NULL;
+	return;
+
+fail:
+	ikev2_create_child_sa_init_resp_auth(sa, NULL, arg);
+	ikev2_sa_args_free(sa->sa_init_args);
+	sa->sa_init_args = NULL;
+	ikev2_auth_failed(sa);
+}
+
+static boolean_t
+add_auth(pkt_t *pkt)
+{
+	ikev2_sa_t *sa = pkt->pkt_sa;
+	pkt_payload_t *payid = NULL;
+	config_id_t *cid = NULL;
+	size_t authlen = get_authlen(sa);
+	boolean_t initiator = I2P_INITIATOR(pkt);
+	boolean_t ret = B_FALSE;
+	/* This is at most 64 bytes */
+	uint8_t auth[authlen];
+
+	payid = pkt_get_payload(pkt,
+	    initiator ? IKEV2_PAYLOAD_IDi : IKEV2_PAYLOAD_IDr, NULL);
+
+	/* We're constructing the pkt, so we've messed up badly if missing */
+	VERIFY3P(payid, !=, NULL);
+
+	if (!calc_auth(sa, initiator, payid, auth, authlen))
+		goto done;
+
+	(void) bunyan_trace(log, "Adding AUTH payload to packet", BUNYAN_T_END);
+
+	if (!ikev2_add_auth(pkt, sa->authmethod, auth, authlen)) {
+		(void) bunyan_error(log, "No space for AUTH payload in packet",
+		    BUNYAN_T_END);
+		goto done;
+	}
+	ret = B_TRUE;
+
+done:
+	explicit_bzero(auth, authlen);
+	return (ret);
+}
+
+static boolean_t
+check_auth(pkt_t *pkt)
+{
+	ikev2_sa_t *sa = pkt->pkt_sa;
+	pkt_payload_t *payid = NULL;
+	pkt_payload_t *payauth = NULL;
+	uint8_t *auth = NULL;
+	size_t authlen = 0;
+	size_t buflen = get_authlen(sa);
+	boolean_t initiator = I2P_INITIATOR(pkt);
+	boolean_t ret = B_FALSE;
+	/* This is at most 64 bytes each */
+	uint8_t buf[buflen];
+
+	(void) bunyan_trace(log, "Checking AUTH payload", BUNYAN_T_END);
+
+	payauth = pkt_get_payload(pkt, IKEV2_PAYLOAD_AUTH, NULL);
+
+	/* XXX: Move these to inbound packet checks? */
+	payid = pkt_get_payload(pkt,
+	    initiator ? IKEV2_PAYLOAD_IDi : IKEV2_PAYLOAD_IDr, NULL);
+
+	if (payid == NULL) {
+		(void) bunyan_warn(log, "Packet is missing it's ID payload",
+		    BUNYAN_T_END);
+		return (B_FALSE);
+	}
+
+	if (payauth == NULL) {
+		(void) bunyan_warn(log, "Packet is missing AUTH payload",
+		    BUNYAN_T_END);
+		return (B_FALSE);
+	}
+
+	/* Our packet checks should catch this */
+	VERIFY3U(payauth->pp_len, >, sizeof (ikev2_auth_t));
+
+	/*
+	 * XXX: It seems that in theory (at least) we could support different
+	 * authentication methods in each direction.  It seems like this
+	 * could invite troubleshooting headaches though. For now at least,
+	 * we will require both ends to use the same method.
+	 */
+	if (payauth->pp_ptr[0] != sa->authmethod) {
+		const char *l_meth = NULL, *r_meth = NULL;
+
+		l_meth = ikev2_auth_type_str(sa->authmethod);
+		r_meth = ikev2_auth_type_str(payauth->pp_ptr[0]);
+
+		(void) bunyan_warn(log,
+		    "Authentication method mismatch with remote peer",
+		    BUNYAN_T_STRING, "local_method", l_meth,
+		    BUNYAN_T_STRING, "remote_method", r_meth,
+		    BUNYAN_T_END);
+		return (B_FALSE);
+	}
+
+	auth = payauth->pp_ptr + sizeof (ikev2_auth_t);
+	authlen = payauth->pp_len - sizeof (ikev2_auth_t);
+
+	if (authlen != buflen) {
+		(void) bunyan_warn(log,
+		    "AUTH size mismatch",
+		    BUNYAN_T_UINT32, "authlen", (uint32_t)authlen,
+		    BUNYAN_T_UINT32, "expected", (uint32_t)buflen,
+		    BUNYAN_T_END);
+		return (B_FALSE);
+	}
+
+	if (!calc_auth(sa, initiator, payid, buf, buflen))
+		goto done;
+
+	/* We previously verified authlen == buflen */
+	if (memcmp(auth, buf, buflen) == 0)
+		ret = B_TRUE;
+
+done:
+	explicit_bzero(buf, buflen);
+	return (ret);
+}
+
+static boolean_t
+calc_auth(ikev2_sa_t *restrict sa, boolean_t initiator,
+    pkt_payload_t *restrict id, uint8_t *restrict out, size_t outlen)
+{
+	ikev2_sa_args_t *sa_args = sa->sa_init_args;
+	uint8_t *nonce = NULL, *init = NULL;
+	size_t noncelen = 0, initlen = 0;
+	size_t maclen = ikev2_prf_outlen(sa->prf);
+	CK_OBJECT_HANDLE mackey;
+	CK_RV rc;
+	boolean_t ret = B_FALSE;
+	/* This is at most 64 bytes */
+	uint8_t mac[maclen];
+
+	VERIFY(MUTEX_HELD(&sa->i2sa_lock));
+
+	/*
+	 * Gather the data to be signed for the given side.  The detailed
+	 * explanation can be read in RFC7296 2.15.  The summarized version is
+	 * we sign using the method specified in the IKE rule (e.g. preshared
+	 * key, RSA, etc -- this is not negotiated, but must be pre-agreed to
+	 * by both peers).
+	 *
+	 * Note that while we include our IKE_SA_INIT and MACed ID as part of
+	 * the data to sign, we use the nonce of our peer.
+	 */
+	if (initiator) {
+		nonce = sa_args->i2a_nonce_r;
+		noncelen = sa_args->i2a_nonce_r_len;
+		mackey = sa->sk_pi;
+		init = sa_args->i2a_init_i;
+		initlen = sa_args->i2a_init_i_len;
+	} else {
+		nonce = sa_args->i2a_nonce_i;
+		noncelen = sa_args->i2a_nonce_r_len;
+		mackey = sa->sk_pr;
+		init = sa_args->i2a_init_r;
+		initlen = sa_args->i2a_init_r_len;
+	}
+
+	/* MACedIDFor{R|I} */
+	if (!prf(sa->prf, mackey, mac, maclen, id->pp_ptr, id->pp_len, NULL))
+		goto done;
+
+	switch (sa->authmethod) {
+	case IKEV2_AUTH_SHARED_KEY_MIC:
+		if (sa->psk == CK_INVALID_HANDLE && !create_psk(sa))
+			goto done;
+
+		ret = prf(sa->prf, sa->psk, out, outlen,
+		    init, initlen,			/* RealMessage{1|2} */
+		    nonce, noncelen,			/* Nonce{R|I}Data */
+		    mac, maclen, NULL);			/* MACedIDFor{I|R} */
+		break;
+	case IKEV2_AUTH_RSA_SIG:
+	case IKEV2_AUTH_DSS_SIG:
+	case IKEV2_AUTH_ECDSA_256:
+	case IKEV2_AUTH_ECDSA_384:
+	case IKEV2_AUTH_ECDSA_512:
+	case IKEV2_AUTH_GSPM:
+		(void) bunyan_info(log,
+		    "IKE SA Authentication method not yet implemented",
+		    BUNYAN_T_END);
+		goto done;
+	case IKEV2_AUTH_NONE:
+		INVALID(sa->authmethod);
+		break;
+	}
+
+done:
+	explicit_bzero(mac, maclen);
+	return (ret);
+}
+
+/*
+ * Find the PSK for these addresses,
+ * compute prf(<preshared secret>, IKEV2_KEYPAD), store as PKCS#11 object,
+ * and save as sa->psk so it's ready for to use when creating/validating the
+ * AUTH payloads.
+ */
+static boolean_t
+create_psk(ikev2_sa_t *sa)
+{
+	preshared_entry_t *pe = NULL;
+	sockaddr_u_t laddr = { .sau_ss = &sa->laddr };
+	sockaddr_u_t raddr = { .sau_ss = &sa->raddr };
+	CK_SESSION_HANDLE h = p11h();
+	CK_MECHANISM_TYPE mechtype = ikev2_prf_to_p11(sa->prf);
+	CK_OBJECT_HANDLE psktemp = CK_INVALID_HANDLE;
+	CK_RV rc;
+	size_t outlen = ikev2_prf_outlen(sa->prf);
+	boolean_t ret = B_FALSE;
+	uint8_t buf[outlen];
+
+	switch (sa->raddr.ss_family) {
+	case AF_INET:
+		pe = lookup_ps_by_in_addr(&laddr.sau_sin->sin_addr,
+		    &raddr.sau_sin->sin_addr);
+		break;
+	case AF_INET6:
+		pe = lookup_ps_by_in6_addr(&laddr.sau_sin6->sin6_addr,
+		    &raddr.sau_sin6->sin6_addr);
+		break;
+	default:
+		INVALID("ss_family");
+	}
+
+	if (pe == NULL) {
+		(void) bunyan_error(log,
+		    "No matching preshared key found", BUNYAN_T_END);
+		return (B_FALSE);
+	}
+
+	/*
+	 * First need to convert the preshared secret into a PKCS#11 object
+	 * XXX: We could potentially do this when we load the secrets.
+	 */
+	rc = SUNW_C_KeyToObject(h, mechtype, pe->pe_keybuf, pe->pe_keybuf_bytes,
+	    &psktemp);
+	if (rc != CKR_OK) {
+		PKCS11ERR(error, "SUNW_C_KeyToObject", rc,
+		    BUNYAN_T_STRING, "objname", "psktemp", BUNYAN_T_END);
+		goto done;
+	}
+
+	if (!prf(sa->prf, psktemp, buf, outlen,
+	    IKEV2_KEYPAD, sizeof (IKEV2_KEYPAD), NULL))
+		goto done;
+
+	rc = SUNW_C_KeyToObject(h, mechtype, buf, outlen, &sa->psk);
+	if (rc != CKR_OK) {
+		PKCS11ERR(error, "SUNW_C_KeyToObject", rc,
+		    BUNYAN_T_STRING, "objname", "psk", BUNYAN_T_END);
+		goto done;
+	}
+	ret = B_TRUE;
+
+done:
+	pkcs11_destroy_obj("psktemp", &psktemp);
+	explicit_bzero(buf, outlen);
+	return (ret);
+}
+
+static boolean_t
+add_id(pkt_t *pkt, const config_id_t *id, boolean_t initiator)
+{
+	ikev2_sa_t *sa = pkt->pkt_sa;
+	config_auth_id_t cid_type = 0;
+	ikev2_id_type_t id_type = IKEV2_ID_FQDN; /* set default to quiet GCC */
+	const void *ptr = NULL;
+	size_t idlen = 0;
+
+	/* Default to IP if no id was specified */
+	if (id == NULL) {
+		switch (sa->laddr.ss_family) {
+		case AF_INET:
+			cid_type = CFG_AUTH_ID_IPV4;
+			id_type = IKEV2_ID_IPV4_ADDR;
+			break;
+		case AF_INET6:
+			cid_type = CFG_AUTH_ID_IPV6;
+			id_type = IKEV2_ID_IPV6_ADDR;
+			break;
+		default:
+			INVALID("ss_family");
+		}
+		ptr = ss_addr(SSTOSA(&sa->laddr));
+		idlen = ss_addrlen(SSTOSA(&sa->laddr));
+	} else if (id->cid_len == 0) {
+		/* parsing should prevent this */
+		INVALID(id->cid_len);
+	} else {
+		idlen = id->cid_len;
+		ptr = id->cid_data;
+
+		switch (id->cid_type) {
+		case CFG_AUTH_ID_DN:
+			id_type = IKEV2_ID_DER_ASN1_DN;
+			break;
+		case CFG_AUTH_ID_DNS:
+			id_type = IKEV2_ID_FQDN;
+			/* Exclude trailing NUL */
+			idlen--;
+			break;
+		case CFG_AUTH_ID_GN:
+			id_type = IKEV2_ID_DER_ASN1_GN;
+			break;
+		case CFG_AUTH_ID_IPV4:
+		case CFG_AUTH_ID_IPV4_PREFIX:
+		case CFG_AUTH_ID_IPV4_RANGE:
+			id_type = IKEV2_ID_IPV4_ADDR;
+			break;
+		case CFG_AUTH_ID_IPV6:
+		case CFG_AUTH_ID_IPV6_PREFIX:
+		case CFG_AUTH_ID_IPV6_RANGE:
+			id_type = IKEV2_ID_IPV6_ADDR;
+			break;
+		case CFG_AUTH_ID_EMAIL:
+			id_type = IKEV2_ID_RFC822_ADDR;
+			/* Exclude trailing NUL */
+			idlen--;
+			break;
+		}
+		cid_type = id->cid_type;
+	}
+
+	/* If we're adding our own (local) id, save it to the IKEv2 SA */
+	if ((initiator && (sa->flags & I2SA_INITIATOR)) ||
+	    (!initiator && !(sa->flags & I2SA_INITIATOR))) {
+		sa->local_id = config_id_new(cid_type, ptr, idlen);
+		if (sa->local_id == NULL) {
+			(void) bunyan_error(log, "No memory to create IKE id",
+			    BUNYAN_T_END);
+			return (B_FALSE);
+		}
+		key_add_id(LOG_KEY_LOCAL_ID, LOG_KEY_LOCAL_ID_TYPE,
+		    sa->local_id);
+	}
+
+	(void) bunyan_trace(log, "Setting IKEv2 ID", BUNYAN_T_END);
+
+	return (ikev2_add_id(pkt, initiator, id_type, ptr, idlen));
+}
+
+static boolean_t
+check_remote_id(pkt_t *pkt, config_id_t **pcid)
+{
+	config_id_t **remote_ids = NULL;
+	pkt_payload_t *pid = NULL;
+	boolean_t match = B_FALSE;
+
+	*pcid = NULL;
+
+	pid = pkt_get_payload(pkt,
+	    I2P_INITIATOR(pkt) ? IKEV2_PAYLOAD_IDi : IKEV2_PAYLOAD_IDr, NULL);
+	if (pid == NULL) {
+		(void) bunyan_warn(log, "IKE_AUTH packet is missing ID",
+		    BUNYAN_T_END);
+		return (B_FALSE);
+	}
+
+	if ((*pcid = i2id_to_cid(pid)) == NULL)
+		return (B_FALSE);
+
+	/* If no remote id given, accept all IDs */
+	remote_ids = pkt->pkt_sa->i2sa_rule->rule_remote_id;
+	if (remote_ids == NULL)
+		return (B_TRUE);
+
+	for (size_t i = 0; remote_ids[i] != NULL; i++) {
+		if (config_id_cmp(*pcid, remote_ids[i]) == 0) {
+			match = B_TRUE;
+			break;
+		}
+	}
+
+	return (match);
+}
+
+/*
+ * Convert an IKEv2 ID to a config_id_t and return the config_id_t.
+ * Returns NULL on failure.
+ */
+static config_id_t *
+i2id_to_cid(pkt_payload_t *i2id)
+{
+	config_id_t *cid = NULL;
+	config_auth_id_t cidtype = 0;
+	void *data = NULL;
+	uint32_t datalen = 0;
+	char *buf = NULL;
+	const char *idtstr = NULL;
+
+	if (i2id->pp_len <= sizeof (ikev2_id_t)) {
+		(void) bunyan_error(log, "ID payload is truncated",
+		    BUNYAN_T_UINT32, "len",
+		    (uint32_t)(i2id->pp_len + sizeof (ikev2_payload_t)),
+		    BUNYAN_T_UINT32, "expected",
+		    (uint32_t)(sizeof (ikev2_payload_t) + sizeof (ikev2_id_t)),
+		    BUNYAN_T_END);
+		return (NULL);
+	}
+
+	idtstr = ikev2_id_type_str(i2id->pp_ptr[0]);
+
+	data = i2id->pp_ptr + sizeof (ikev2_id_t);
+	datalen = i2id->pp_len - sizeof (ikev2_id_t);
+
+	switch ((ikev2_id_type_t)i2id->pp_ptr[0]) {
+	case IKEV2_ID_IPV4_ADDR:
+		cidtype = CFG_AUTH_ID_IPV4;
+		if (datalen != sizeof (in_addr_t)) {
+			(void) bunyan_warn(log, "ID payload length mismatch",
+			    BUNYAN_T_STRING, "idtype", idtstr,
+			    BUNYAN_T_UINT32, "len", datalen,
+			    BUNYAN_T_UINT32, "expected",
+			    (uint32_t)sizeof (in_addr_t), BUNYAN_T_END);
+			return (NULL);
+		}
+		break;
+	case IKEV2_ID_FQDN:
+		cidtype = CFG_AUTH_ID_DNS;
+		if ((buf = umem_zalloc(datalen + 1, UMEM_DEFAULT)) == NULL) {
+			(void) bunyan_error(log, "No memory for IKE ID",
+			    BUNYAN_T_END);
+			return (NULL);
+		}
+		(void) memcpy(buf, data, datalen++);
+		data = buf;
+		break;
+	case IKEV2_ID_RFC822_ADDR:
+		cidtype = CFG_AUTH_ID_EMAIL;
+		if ((buf = umem_zalloc(datalen + 1, UMEM_DEFAULT)) == NULL) {
+			(void) bunyan_error(log, "No memory for IKE ID",
+			    BUNYAN_T_END);
+			return (NULL);
+		}
+		(void) memcpy(buf, data, datalen++);
+		data = buf;
+		break;
+	case IKEV2_ID_IPV6_ADDR:
+		cidtype = CFG_AUTH_ID_IPV6;
+		if (datalen != sizeof (in6_addr_t)) {
+			(void) bunyan_warn(log, "ID payload length mismatch",
+			    BUNYAN_T_STRING, "idtype", idtstr,
+			    BUNYAN_T_UINT32, "len", datalen,
+			    BUNYAN_T_UINT32, "expected",
+			    (uint32_t)sizeof (in6_addr_t), BUNYAN_T_END);
+			return (NULL);
+		}
+		break;
+	case IKEV2_ID_DER_ASN1_DN:
+		cidtype = CFG_AUTH_ID_DN;
+		break;
+	case IKEV2_ID_DER_ASN1_GN:
+		cidtype = CFG_AUTH_ID_GN;
+		break;
+	case IKEV2_ID_KEY_ID:
+	case IKEV2_ID_FC_NAME:
+		(void) bunyan_warn(log, "Unsupported IKE ID type",
+		    BUNYAN_T_STRING, "idtype", idtstr,
+		    BUNYAN_T_END);
+		return (NULL);
+	}
+
+	cid = config_id_new(cidtype, data, datalen);
+	if (buf != NULL)
+		umem_free(buf, datalen);
+
+	return (cid);
+}
+
+/*
+ * If we are the initiator and the responder failed to authenticate, we
+ * must immediately start a new INFORMATIONAL exchange with the
+ * AUTHENTICATION_FAILED notification as it's contents (RFC7296 2.21.2).
+ */
+
+/* Nothing to process with the acknowledgement */
+static void
+ikev2_auth_failed_reply(ikev2_sa_t *restrict i2sa __unused,
+    pkt_t *restrict resp __unused, void *arg __unused)
+{
+}
+
+/* Kick off the INFORMATINOAL exchange */
+static boolean_t
+ikev2_auth_failed(ikev2_sa_t *i2sa)
+{
+	pkt_t *msg = ikev2_pkt_new_exchange(i2sa, IKEV2_EXCH_INFORMATIONAL);
+
+	i2sa->flags |= I2SA_CONDEMNED;
+
+	if (msg == NULL) {
+		(void) bunyan_error(log,
+		    "No memory to send AUTHENTICATION_FAILED notification",
+		    BUNYAN_T_END);
+		return (B_FALSE);
+	}
+
+	VERIFY(ikev2_add_notify(msg, IKEV2_N_AUTHENTICATION_FAILED));
+	return (ikev2_send_req(msg, ikev2_auth_failed_reply, NULL));
+}
+
+/*
+ * We've received an AUTHENTICATION_FAILED notification in an INFORMATIONAL
+ * exchange
+ */
+boolean_t
+ikev2_auth_failed_resp(pkt_t *restrict req, pkt_t *restrict resp)
+{
+	ikev2_sa_t *i2sa = req->pkt_sa;
+
+	(void) bunyan_warn(log,
+	    "Peer rejected our authentication attempt", BUNYAN_T_END);
+
+	ikev2_sa_delete_children(i2sa);
+	req->pkt_sa->flags |= I2SA_CONDEMNED;
+
+	/* Send an empty response to acknowledge we received the message */
+	return (B_TRUE);
+}
+
+static size_t
+get_authlen(const ikev2_sa_t *sa)
+{
+	const char *authstr = ikev2_auth_type_str(sa->authmethod);
+
+	switch (sa->authmethod) {
+	case IKEV2_AUTH_NONE:
+		return (0);
+	case IKEV2_AUTH_SHARED_KEY_MIC:
+		return (ikev2_prf_outlen(sa->prf));
+	case IKEV2_AUTH_RSA_SIG:
+		/* XXX: This may need to vary based on the cert used */
+		return (SHA1_DIGEST_LENGTH);
+	case IKEV2_AUTH_DSS_SIG:
+		return (SHA1_DIGEST_LENGTH);
+	case IKEV2_AUTH_ECDSA_256:
+		return (SHA256_DIGEST_LENGTH);
+	case IKEV2_AUTH_ECDSA_384:
+		return (SHA384_DIGEST_LENGTH);
+	case IKEV2_AUTH_ECDSA_512:
+		return (SHA512_DIGEST_LENGTH);
+	case IKEV2_AUTH_GSPM:
+		(void) bunyan_error(log,
+		    "IKE SA authentication method not yet implemented",
+		    BUNYAN_T_STRING, "authmethod", authstr,
+		    BUNYAN_T_END);
+		return (0);
+	}
+	return (0);
+}
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_pkt.c b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_pkt.c
new file mode 100644
index 0000000000..f5dc360408
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_pkt.c
@@ -0,0 +1,1441 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2017 Jason King.
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+#include <stddef.h>
+#include <alloca.h>
+#include <assert.h>
+#include <umem.h>
+#include <string.h>
+#include <strings.h>
+#include <errno.h>
+#include <libcmdutils.h> /* for custr_ */
+#include <netinet/in.h>
+#include <security/cryptoki.h>
+#include <errno.h>
+#include <sys/byteorder.h>
+#include <sys/debug.h>
+#include <sys/random.h>
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <note.h>
+#include <stdarg.h>
+#include "defs.h"
+#include "pkt_impl.h"
+#include "ikev2.h"
+#include "ikev2_sa.h"
+#include "ikev2_pkt.h"
+#include "ikev2_pkt_check.h"
+#include "ikev2_proto.h"
+#include "ikev2_enum.h"
+#include "pkcs11.h"
+#include "worker.h"
+
+/* Allocate an outbound IKEv2 pkt for a new exchange */
+pkt_t *
+ikev2_pkt_new_exchange(ikev2_sa_t *i2sa, ikev2_exch_t exch_type)
+{
+	pkt_t *pkt = NULL;
+	uint32_t msgid = 0;
+	uint8_t flags = 0;
+	const char *exchstr = NULL;
+
+	VERIFY(MUTEX_HELD(&i2sa->i2sa_lock));
+
+	msgid = i2sa->outmsgid++;
+
+	if (i2sa->flags & I2SA_INITIATOR)
+		flags |= IKEV2_FLAG_INITIATOR;
+
+	(void) bunyan_key_add(log,
+	    BUNYAN_T_STRING, LOG_KEY_EXCHTYPE, ikev2_exch_str(exch_type),
+	    BUNYAN_T_END);
+
+	pkt = pkt_out_alloc(I2SA_LOCAL_SPI(i2sa),
+	    I2SA_REMOTE_SPI(i2sa),
+	    IKEV2_VERSION,
+	    exch_type, msgid, flags);
+
+	if (pkt == NULL) {
+		(void) bunyan_error(log, "No memory for new exchange",
+		    BUNYAN_T_END);
+		i2sa->outmsgid--;
+		return (NULL);
+	}
+
+	(void) bunyan_key_add(log,
+	    BUNYAN_T_POINTER, LOG_KEY_REQ, pkt,
+	    BUNYAN_T_UINT32, LOG_KEY_MSGID, msgid,
+	    BUNYAN_T_END);
+	(void) bunyan_key_remove(log, LOG_KEY_RESP);
+
+	pkt->pkt_sa = i2sa;
+
+	/*
+	 * Every non-IKE_SA_INIT exchange requires the SK payload as it's
+	 * first payload (i.e. everything should be encrypted), so go
+	 * ahead and add it now
+	 */
+	if (exch_type != IKEV2_EXCH_IKE_SA_INIT)
+		VERIFY(ikev2_add_sk(pkt));
+
+	return (pkt);
+}
+
+/* Allocate a ikev2_pkt_t for an IKEv2 outbound response */
+pkt_t *
+ikev2_pkt_new_response(const pkt_t *init)
+{
+	pkt_t *pkt;
+	ike_header_t *hdr = pkt_header(init);
+	uint8_t flags = IKEV2_FLAG_RESPONSE;
+
+	VERIFY3U(IKE_GET_MAJORV(hdr->version), ==,
+	    IKE_GET_MAJORV(IKEV2_VERSION));
+	VERIFY(MUTEX_HELD(&init->pkt_sa->i2sa_lock));
+
+	if (init->pkt_sa->flags & I2SA_INITIATOR)
+		flags |= IKEV2_FLAG_INITIATOR;
+
+	pkt = pkt_out_alloc(hdr->initiator_spi,
+	    hdr->responder_spi,
+	    IKEV2_VERSION,
+	    hdr->exch_type,
+	    ntohl(hdr->msgid), flags);
+	if (pkt == NULL) {
+		(void) bunyan_error(log, "No memory for response packet",
+		    BUNYAN_T_END);
+		return (NULL);
+	}
+
+	/*
+	 * The other packet keys should already be set from the initiating
+	 * packet.
+	 */
+	(void) bunyan_key_add(log,
+	    BUNYAN_T_POINTER, LOG_KEY_RESP, pkt,
+	    BUNYAN_T_END);
+
+	pkt->pkt_sa = init->pkt_sa;
+
+	/*
+	 * Every non-IKE_SA_INIT exchange requires the SK payload as it's
+	 * first payload (i.e. everything should be encrypted), so go
+	 * ahead and add it now
+	 */
+	if (hdr->exch_type != IKEV2_EXCH_IKE_SA_INIT)
+		VERIFY(ikev2_add_sk(pkt));
+
+	return (pkt);
+}
+
+/* Allocate a ikev2_pkt_t for an inbound datagram in raw */
+pkt_t *
+ikev2_pkt_new_inbound(void *restrict buf, size_t buflen)
+{
+	const char		*pktkey = NULL;
+	const ike_header_t	*hdr = NULL;
+	pkt_t			*pkt = NULL;
+	size_t			i = 0;
+
+	VERIFY(IS_WORKER);
+
+	(void) bunyan_trace(log, "Creating new inbound IKEv2 packet",
+	    BUNYAN_T_END);
+
+	VERIFY(IS_P2ALIGNED(buf, sizeof (uint64_t)));
+
+	hdr = (const ike_header_t *)buf;
+
+	VERIFY3U(IKE_GET_MAJORV(hdr->version), ==,
+	    IKE_GET_MAJORV(IKEV2_VERSION));
+
+	pktkey = (hdr->flags & IKEV2_FLAG_RESPONSE) ?
+	    LOG_KEY_RESP : LOG_KEY_REQ;
+
+	/* These are added early in case there is an error */
+	(void) bunyan_key_add(log,
+	    BUNYAN_T_STRING, LOG_KEY_EXCHTYPE, ikev2_exch_str(hdr->exch_type),
+	    BUNYAN_T_END);
+	key_add_ike_spi(LOG_KEY_LSPI, ntohll(INBOUND_LOCAL_SPI(hdr)));
+	key_add_ike_spi(LOG_KEY_RSPI, ntohll(INBOUND_REMOTE_SPI(hdr)));
+
+	switch ((ikev2_exch_t)hdr->exch_type) {
+	case IKEV2_EXCH_IKE_SA_INIT:
+	case IKEV2_EXCH_IKE_AUTH:
+	case IKEV2_EXCH_CREATE_CHILD_SA:
+	case IKEV2_EXCH_INFORMATIONAL:
+		break;
+	case IKEV2_EXCH_IKE_SESSION_RESUME:
+	case IKEV2_EXCH_GSA_AUTH:
+	case IKEV2_EXCH_GSA_REGISTRATION:
+	case IKEV2_EXCH_GSA_REKEY:
+	default:
+		(void) bunyan_info(log, "Unknown/unsupported exchange type",
+		    BUNYAN_T_END);
+		return (NULL);
+	}
+
+	/* pkt_in_alloc() will log any error messages */
+	if ((pkt = pkt_in_alloc(buf, buflen, ikev2_pkt_checklen)) == NULL)
+		return (NULL);
+
+	(void) bunyan_key_add(log, BUNYAN_T_POINTER, pktkey, pkt, BUNYAN_T_END);
+
+	if (!ikev2_pkt_check_payloads(pkt)) {
+		ikev2_pkt_free(pkt);
+		return (NULL);
+	}
+
+	/*
+	 * Since these aren't encrypted or decrypted, once received it's
+	 * contents are treated as immutable.
+	 */
+	if (hdr->exch_type == IKEV2_EXCH_IKE_SA_INIT)
+		pkt->pkt_done = B_TRUE;
+
+	return (pkt);
+}
+
+void
+ikev2_pkt_free(pkt_t *pkt)
+{
+	if (pkt == NULL)
+		return;
+
+	pkt_free(pkt);
+}
+
+/*
+ * All of the usage and caveats of pkt_add_payload() apply here as well.
+ * For detailed information, see comments in pkt.c
+ */
+static boolean_t
+ikev2_add_payload(pkt_t *pkt, ikev2_pay_type_t ptype, boolean_t critical,
+    size_t len)
+{
+	uint8_t *payptr;
+	uint8_t resv = 0;
+
+	ASSERT(IKEV2_VALID_PAYLOAD(ptype));
+
+	if (critical)
+		resv |= IKEV2_CRITICAL_PAYLOAD;
+
+	return (pkt_add_payload(pkt, ptype, resv, len));
+}
+
+boolean_t
+ikev2_add_sa(pkt_t *restrict pkt, pkt_sa_state_t *restrict pss)
+{
+	return (pkt_add_sa(pkt, pss));
+}
+
+boolean_t
+ikev2_add_prop(pkt_sa_state_t *pss, uint8_t propnum, ikev2_spi_proto_t proto,
+    uint64_t spi)
+{
+	size_t spilen = ikev2_spilen(proto);
+
+	if (proto == IKEV2_PROTO_IKE && spi == 0)
+		spilen = 0;
+
+	return (pkt_add_prop(pss, propnum, proto, spilen, spi));
+}
+
+boolean_t
+ikev2_add_xform(pkt_sa_state_t *pss, ikev2_xf_type_t xftype, int xfid)
+{
+	return (pkt_add_xform(pss, xftype, xfid));
+}
+
+boolean_t
+ikev2_add_xf_attr(pkt_sa_state_t *pss, ikev2_xf_attr_type_t xf_attr_type,
+    uintptr_t arg)
+{
+	switch (xf_attr_type) {
+	case IKEV2_XF_ATTR_KEYLEN:
+		ASSERT3U(arg, <, 0x10000);
+		return (pkt_add_xform_attr_tv(pss, IKEV2_XF_ATTR_KEYLEN,
+		    (uint16_t)arg));
+	}
+
+	return (B_FALSE);
+}
+
+boolean_t
+ikev2_add_xf_encr(pkt_sa_state_t *pss, ikev2_xf_encr_t encr, uint16_t minbits,
+    uint16_t maxbits)
+{
+	const encr_data_t *ed = encr_data(encr);
+	uint16_t incr = 0;
+	boolean_t ok = B_TRUE;
+
+	if (encr == IKEV2_ENCR_NONE || encr == IKEV2_ENCR_NULL) {
+		INVALID("encr");
+		/*NOTREACHED*/
+		return (B_FALSE);
+	}
+
+	if (!encr_keylen_allowed(ed)) {
+		VERIFY3U(minbits, ==, 0);
+		VERIFY3U(maxbits, ==, 0);
+		return (ikev2_add_xform(pss, IKEV2_XF_ENCR, encr));
+	}
+
+	if (minbits == 0 && maxbits == 0 && !encr_keylen_req(ed))
+		return (ikev2_add_xform(pss, IKEV2_XF_ENCR, encr));
+
+	VERIFY3U(minbits, >=, ed->ed_keymin);
+	VERIFY3U(maxbits, <=, ed->ed_keymax);
+
+	if (ed->ed_keyincr == 1) {
+		/*
+		 * For encryption methods that allow arbitrary key sizes,
+		 * instead of adding a transform with every key length
+		 * between the minimum and maximum values, we just add the
+		 * minimum and maximum values.
+		 */
+		if (minbits != maxbits) {
+			ok &= ikev2_add_xform(pss, IKEV2_XF_ENCR, encr);
+			ok &= ikev2_add_xf_attr(pss, IKEV2_XF_ATTR_KEYLEN,
+			    minbits);
+		}
+		ok &= ikev2_add_xform(pss, IKEV2_XF_ENCR, encr);
+		ok &= ikev2_add_xf_attr(pss, IKEV2_XF_ATTR_KEYLEN, maxbits);
+		return (ok);
+	}
+
+	for (size_t bits = minbits; bits <= maxbits; bits += ed->ed_keyincr) {
+		ok &= ikev2_add_xform(pss, IKEV2_XF_ENCR, encr);
+		ok &= ikev2_add_xf_attr(pss, IKEV2_XF_ATTR_KEYLEN, bits);
+	}
+
+	return (ok);
+}
+
+boolean_t
+ikev2_add_ke(pkt_t *restrict pkt, ikev2_dh_t group, CK_OBJECT_HANDLE key)
+{
+	ikev2_ke_t		ke = { 0 };
+	CK_SESSION_HANDLE	h = p11h();
+	CK_ULONG		keylen = 0;
+	CK_ATTRIBUTE		template = {
+		.type = CKA_VALUE,
+		.pValue = NULL_PTR,
+		.ulValueLen = 0
+	};
+	CK_RV			rc = CKR_OK;
+
+	rc = C_GetAttributeValue(h, key, &template, 1);
+	if (rc != CKR_OK) {
+		PKCS11ERR(error, "C_GetAttributeValue", rc);
+		return (B_FALSE);
+	}
+	keylen = template.ulValueLen;
+
+	if (!ikev2_add_payload(pkt, IKEV2_PAYLOAD_KE, B_FALSE,
+	    sizeof (ke) + keylen)) {
+		(void) bunyan_error(log,
+		    "Not enough space in packet for DH pubkey",
+		    BUNYAN_T_UINT64, "keylen", (uint64_t)keylen,
+		    BUNYAN_T_END);
+		return (B_FALSE);
+	}
+
+	ke.kex_dhgroup = htons((uint16_t)group);
+	PKT_APPEND_STRUCT(pkt, ke);
+
+	template.type = CKA_VALUE;
+	template.pValue = pkt->pkt_ptr;
+	template.ulValueLen = pkt_write_left(pkt);
+
+	rc = C_GetAttributeValue(h, key, &template, 1);
+	if (rc != CKR_OK) {
+		PKCS11ERR(error, "C_GetAttributeValue", rc);
+		return (B_FALSE);
+	}
+	pkt->pkt_ptr += keylen;
+
+	return (B_TRUE);
+}
+
+static boolean_t
+ikev2_add_id_common(pkt_t *restrict pkt, boolean_t id_i, ikev2_id_type_t idtype,
+    va_list ap)
+{
+	ikev2_id_t		id = { 0 };
+	ikev2_pay_type_t	paytype =
+	    (id_i) ? IKEV2_PAYLOAD_IDi : IKEV2_PAYLOAD_IDr;
+	const uint8_t		*data;
+	size_t			len = 0;
+
+	data = va_arg(ap, const uint8_t *);
+
+	switch (idtype) {
+	case IKEV2_ID_IPV4_ADDR:
+		len = sizeof (in_addr_t);
+		break;
+	case IKEV2_ID_FQDN:
+	case IKEV2_ID_RFC822_ADDR:
+		len = strlen((const char *)data);
+		break;
+	case IKEV2_ID_IPV6_ADDR:
+		len = sizeof (in6_addr_t);
+		break;
+	case IKEV2_ID_DER_ASN1_DN:
+	case IKEV2_ID_DER_ASN1_GN:
+	case IKEV2_ID_KEY_ID:
+		len = va_arg(ap, size_t);
+		break;
+	case IKEV2_ID_FC_NAME:
+		INVALID("idtype");
+		break;
+	}
+
+	if (!ikev2_add_payload(pkt, paytype, B_FALSE, sizeof (id) + len))
+		return (B_FALSE);	/* XXX: log? */
+
+	id.id_type = (uint8_t)idtype;
+	PKT_APPEND_STRUCT(pkt, id);
+	VERIFY(pkt_append_data(pkt, data, len));
+	return (B_TRUE);
+}
+
+boolean_t
+ikev2_add_id(pkt_t *restrict pkt, boolean_t initiator, ikev2_id_type_t idtype,
+    ...)
+{
+	va_list ap;
+	boolean_t ret;
+
+	va_start(ap, idtype);
+	ret = ikev2_add_id_common(pkt, initiator, idtype, ap);
+	va_end(ap);
+
+	return (ret);
+}
+
+boolean_t
+ikev2_add_id_i(pkt_t *restrict pkt, ikev2_id_type_t idtype, ...)
+{
+	va_list ap;
+	boolean_t ret;
+
+	va_start(ap, idtype);
+	ret = ikev2_add_id_common(pkt, B_TRUE, idtype, ap);
+	va_end(ap);
+	return (ret);
+}
+
+boolean_t
+ikev2_add_id_r(pkt_t *restrict pkt, ikev2_id_type_t idtype, ...)
+{
+	va_list ap;
+	boolean_t ret;
+
+	va_start(ap, idtype);
+	ret = ikev2_add_id_common(pkt, B_FALSE, idtype, ap);
+	va_end(ap);
+	return (ret);
+}
+
+boolean_t
+ikev2_add_cert(pkt_t *restrict pkt, ikev2_cert_t cert_type, const uint8_t *cert,
+    size_t len)
+{
+	return (pkt_add_cert(pkt, IKEV2_PAYLOAD_CERT, cert_type, cert, len));
+}
+
+boolean_t
+ikev2_add_certreq(pkt_t *restrict pkt, ikev2_cert_t cert_type,
+    const uint8_t *cert, size_t len)
+{
+	return (pkt_add_cert(pkt, IKEV2_PAYLOAD_CERTREQ, cert_type, cert, len));
+}
+
+boolean_t
+ikev2_add_auth(pkt_t *restrict pkt, ikev2_auth_type_t auth_method,
+    const uint8_t *restrict data, size_t len)
+{
+	ikev2_auth_t auth = { 0 };
+
+	if (!ikev2_add_payload(pkt, IKEV2_PAYLOAD_AUTH, B_FALSE,
+	    sizeof (auth) + len))
+		return (B_FALSE);
+
+	auth.auth_method = (uint8_t)auth_method;
+	PKT_APPEND_STRUCT(pkt, auth);
+	VERIFY(pkt_append_data(pkt, data, len));
+	return (B_TRUE);
+}
+
+boolean_t
+ikev2_add_nonce(pkt_t *restrict pkt, uint8_t *restrict nonce, size_t len)
+{
+	VERIFY3U(len, <=, IKEV2_NONCE_MAX);
+	VERIFY3U(len, >=, IKEV2_NONCE_MIN);
+
+	if (!ikev2_add_payload(pkt, IKEV2_PAYLOAD_NONCE, B_FALSE, len))
+		return (B_FALSE);
+
+	VERIFY(pkt_append_data(pkt, nonce, len));
+	return (B_TRUE);
+}
+
+boolean_t
+ikev2_add_notify_full(pkt_t *restrict pkt, ikev2_spi_proto_t proto,
+    uint64_t spi, ikev2_notify_type_t type, const void *restrict data,
+    size_t len)
+{
+	size_t spisize = (spi == 0) ? 0 : ikev2_spilen(proto);
+
+	return (pkt_add_notify(pkt, 0, proto, spisize, spi, type, data, len));
+}
+
+boolean_t
+ikev2_add_notify(pkt_t *restrict pkt, ikev2_notify_type_t type)
+{
+	return (ikev2_add_notify_full(pkt, IKEV2_PROTO_NONE, 0, type, NULL, 0));
+}
+
+static boolean_t delete_finish(pkt_t *restrict, uint8_t *restrict, uintptr_t,
+    size_t);
+
+boolean_t
+ikev2_add_delete(pkt_t *restrict pkt, ikev2_spi_proto_t proto,
+    uint64_t *restrict spis, size_t nspi)
+{
+	ikev2_delete_t del = { 0 };
+	size_t len = sizeof (del);
+
+	VERIFY(proto != IKEV2_PROTO_IKE || nspi == 0);
+	VERIFY3U(nspi, <=, UINT16_MAX);
+
+	del.del_protoid = (uint8_t)proto;
+	del.del_spisize = (proto == IKEV2_PROTO_IKE) ? 0 : ikev2_spilen(proto);
+	del.del_nspi = htons(nspi);
+
+	len += del.del_spisize * nspi;
+	if (!ikev2_add_payload(pkt, IKEV2_PAYLOAD_DELETE, B_FALSE, len))
+		return (B_FALSE);
+
+	PKT_APPEND_STRUCT(pkt, del);
+	for (size_t i = 0; i < nspi; i++)
+		VERIFY(pkt_add_spi(pkt, del.del_spisize, spis[i]));
+
+	return (B_TRUE);
+}
+
+boolean_t
+ikev2_add_vendor(pkt_t *restrict pkt, const void *restrict vid, size_t len)
+{
+	if (!ikev2_add_payload(pkt, IKEV2_PAYLOAD_VENDOR, B_FALSE, len))
+		return (B_FALSE);
+	VERIFY(pkt_append_data(pkt, vid, len));
+	return (B_TRUE);
+}
+
+static boolean_t add_ts_common(pkt_t *restrict, ikev2_pkt_ts_state_t *restrict,
+    boolean_t);
+
+boolean_t
+ikev2_add_ts_i(pkt_t *restrict pkt, ikev2_pkt_ts_state_t *restrict tstate)
+{
+	return (add_ts_common(pkt, tstate, B_TRUE));
+}
+
+boolean_t
+ikev2_add_ts_r(pkt_t *restrict pkt, ikev2_pkt_ts_state_t *restrict tstate)
+{
+	return (add_ts_common(pkt, tstate, B_FALSE));
+}
+
+static boolean_t
+add_ts_common(pkt_t *restrict pkt, ikev2_pkt_ts_state_t *restrict tstate,
+    boolean_t ts_i)
+{
+	ikev2_tsp_t *tsp = NULL;
+	ikev2_payload_t *payp = (ikev2_payload_t *)pkt->pkt_ptr;
+	ikev2_pay_type_t ptype;
+
+	ptype = ts_i ? IKEV2_PAYLOAD_TSi : IKEV2_PAYLOAD_TSr;
+
+	if (!ikev2_add_payload(pkt, ptype, B_FALSE, sizeof (*tsp)))
+		return (B_FALSE);
+	tsp = (ikev2_tsp_t *)pkt->pkt_ptr;
+
+	tstate->i2ts_pkt = pkt;
+	tstate->i2ts_len = sizeof (ikev2_payload_t);
+	tstate->i2ts_lenp = &payp->pld_length;
+	tstate->i2ts_idx = pkt_get_payload(pkt, ptype, NULL);
+	tstate->i2ts_countp = &tsp->tsp_count;
+
+	VERIFY3P(tstate->i2ts_idx, !=, NULL);
+
+	/* Skip over the TS header -- we update the count as we add TSes */
+	pkt->pkt_ptr += sizeof (*tsp);
+	tstate->i2ts_len += sizeof (*tsp);
+	tstate->i2ts_idx->pp_len += sizeof (*tsp);
+	BE_OUT16(tstate->i2ts_lenp, tstate->i2ts_len);
+
+	return (B_TRUE);
+}
+
+boolean_t
+ikev2_add_ts(ikev2_pkt_ts_state_t *restrict tstate, uint8_t ip_proto,
+    const struct sockaddr *restrict start, const struct sockaddr *restrict end)
+{
+	ikev2_ts_t ts = { 0 };
+	const void *startptr = NULL;
+	const void *endptr = NULL;
+	size_t len = 0;
+	size_t addrlen = 0;
+	uint32_t start_port = 0, end_port = 0;
+
+	VERIFY3U(start->sa_family, ==, end->sa_family);
+
+	if (*tstate->i2ts_countp == UINT8_MAX) {
+		(void) bunyan_error(log,
+		    "Tried to add >255 traffic selectors in packet",
+		    BUNYAN_T_END);
+		return (B_FALSE);
+	}
+
+	ts.ts_protoid = ip_proto;
+
+	startptr = ss_addr(start);
+	endptr = ss_addr(end);
+	addrlen = ss_addrlen(start);
+
+	start_port = ss_port(start);
+	end_port = ss_port(end);
+
+	ts.ts_startport = htons((uint16_t)start_port);
+	ts.ts_endport = htons((uint16_t)end_port);
+
+	switch (start->sa_family) {
+	case AF_INET:
+		ts.ts_type = IKEV2_TS_IPV4_ADDR_RANGE;
+		break;
+	case AF_INET6:
+		ts.ts_type = IKEV2_TS_IPV6_ADDR_RANGE;
+		break;
+	default:
+		INVALID(start->sa_family);
+	}
+
+	len = sizeof (ts) + 2 * addrlen;
+
+	ts.ts_protoid = ip_proto;
+	ts.ts_length = htons(len);
+
+	if (pkt_write_left(tstate->i2ts_pkt) < len ||
+	    tstate->i2ts_len + len > UINT16_MAX) {
+		(void) bunyan_error(log,
+		    "Ran out of space to write traffic selectors",
+		    BUNYAN_T_END);
+		return (B_FALSE);
+	}
+
+	PKT_APPEND_STRUCT(tstate->i2ts_pkt, ts);
+	VERIFY(pkt_append_data(tstate->i2ts_pkt, startptr, addrlen));
+	VERIFY(pkt_append_data(tstate->i2ts_pkt, endptr, addrlen));
+
+	tstate->i2ts_len += len;
+
+	/* Update TS count in payload */
+	(*tstate->i2ts_countp)++;
+
+	/* Update payload index length */
+	tstate->i2ts_idx->pp_len += len;
+
+	/* Update payload length in packet */
+	BE_OUT16(tstate->i2ts_lenp, tstate->i2ts_len);
+
+	return (B_TRUE);
+}
+
+static void
+ts_get_addrs(ikev2_ts_t *restrict ts, struct sockaddr_storage *restrict start,
+    struct sockaddr_storage *restrict end)
+{
+	uint8_t *startp = NULL, *endp = NULL, *addrp = NULL;
+	size_t len = 0, port_offset = 0;
+
+	bzero(start, sizeof (*start));
+	bzero(end, sizeof (*end));
+
+	switch (ts->ts_type) {
+	case IKEV2_TS_IPV4_ADDR_RANGE:
+		len = sizeof (in_addr_t);
+		start->ss_family = end->ss_family = AF_INET;
+		port_offset = offsetof(struct sockaddr_in, sin_port);
+		break;
+	case IKEV2_TS_IPV6_ADDR_RANGE:
+		len = sizeof (in6_addr_t);
+		start->ss_family = end->ss_family = AF_INET;
+		port_offset = offsetof(struct sockaddr_in6, sin6_port);
+		break;
+	case IKEV2_TS_FC_ADDR_RANGE:
+		break;
+	}
+
+	addrp = (uint8_t *)(ts + 1);
+	startp = (uint8_t *)ss_addr(SSTOSA(start));
+	endp = (uint8_t *)ss_addr(SSTOSA(end));
+
+	bcopy(addrp, startp, len);
+	bcopy(addrp + len, endp, len);
+	bcopy(&ts->ts_startport, startp + port_offset, sizeof (uint16_t));
+	bcopy(&ts->ts_endport, endp + port_offset, sizeof (uint16_t));
+}
+
+static boolean_t
+ts_type_is_supported(ikev2_ts_type_t type)
+{
+	/*
+	 * We avoid having a default case so that any new TS types that are
+	 * defined but unhandled here will trigger a compilation error instead
+	 * of potentially cause runtime problems.
+	 */
+	switch (type) {
+	case IKEV2_TS_IPV4_ADDR_RANGE:
+	case IKEV2_TS_IPV6_ADDR_RANGE:
+		return (B_TRUE);
+	case IKEV2_TS_FC_ADDR_RANGE:
+		return (B_FALSE);
+	}
+	return (B_FALSE);
+}
+
+ikev2_ts_t *
+ikev2_ts_iter(pkt_payload_t *restrict tsp, ikev2_ts_iter_t *restrict iter,
+    struct sockaddr_storage *restrict start,
+    struct sockaddr_storage *restrict end)
+{
+	iter->i2ti_tsp = (ikev2_tsp_t *)tsp->pp_ptr;
+	iter->i2ti_ts = (ikev2_ts_t *)(iter->i2ti_tsp + 1);
+	iter->i2ti_n = 0;
+
+	if (iter->i2ti_n >= iter->i2ti_tsp->tsp_count)
+		return (NULL);
+
+	/*
+	 * RFC7296 2.9 -- Unknown TS types should be skipped.
+	 * We also skip unsupported TS types
+	 */
+	if (!ts_type_is_supported(iter->i2ti_ts->ts_type))
+		return (ikev2_ts_iter_next(iter, start, end));
+
+	ts_get_addrs(iter->i2ti_ts, start, end);
+	return (iter->i2ti_ts);
+}
+
+ikev2_ts_t *
+ikev2_ts_iter_next(ikev2_ts_iter_t *restrict iter,
+    struct sockaddr_storage *restrict start,
+    struct sockaddr_storage *restrict end)
+{
+	boolean_t known = B_FALSE;
+
+	/*
+	 * RFC7296 2.9 -- Unknown TS types should be skipped.
+	 * We also skip unsupported TS types.
+	 */
+	do {
+		if (++iter->i2ti_n > iter->i2ti_tsp->tsp_count)
+			return (NULL);
+
+		uint8_t *p = (uint8_t *)iter->i2ti_ts;
+
+		p += BE_IN16(&iter->i2ti_ts->ts_length);
+		iter->i2ti_ts = (ikev2_ts_t *)p;
+		known = ts_type_is_supported(iter->i2ti_ts->ts_type);
+	} while (!known);
+
+	ts_get_addrs(iter->i2ti_ts, start, end);
+	return (iter->i2ti_ts);
+}
+
+static boolean_t add_iv(pkt_t *restrict pkt);
+
+boolean_t
+ikev2_add_sk(pkt_t *restrict pkt)
+{
+	ikev2_sa_t *sa = pkt->pkt_sa;
+	ikev2_payload_t *payp = (ikev2_payload_t *)pkt->pkt_ptr;
+
+	if (!ikev2_add_payload(pkt, IKEV2_PAYLOAD_SK, B_FALSE, 0))
+		return (B_FALSE);
+
+	return (add_iv(pkt));
+}
+
+/*
+ * Add the IV to the packet.  It should be noted that the packet
+ * buffer is always zero-filled to start, and we never shift data around
+ * in the packet buffer, so anywhere we skip over a section and fill in later,
+ * any untouched bytes will be zero.
+ */
+static boolean_t
+add_iv(pkt_t *restrict pkt)
+{
+	ikev2_sa_t *sa = pkt->pkt_sa;
+	const encr_data_t *ed = encr_data(sa->encr);
+	size_t len = ed->ed_blocklen;
+
+	if (pkt_write_left(pkt) < len)
+		return (B_FALSE);
+
+	switch (ed->ed_mode) {
+	case MODE_CCM:
+	case MODE_GCM: {
+		uint32_t msgid = ntohl(pkt_header(pkt)->msgid);
+		/*
+		 * For these modes, it's sufficient that the IV + key
+		 * is unique.  The packet message id satisifies these
+		 * requirements.
+		 */
+		VERIFY(put32(pkt, msgid));
+		pkt->pkt_ptr += (len - sizeof (msgid));
+		return (B_TRUE);
+	}
+	case MODE_CTR:
+		/* TODO */
+		return (B_FALSE);
+	case MODE_CBC:
+		/* Done below */
+		break;
+	case MODE_NONE:
+		INVALID("mode");
+		break;
+	}
+
+	/*
+	 * NIST 800-38A, Appendix C indicates that encrypting a counter
+	 * should be acceptable to produce a unique, unpredictable IV.
+	 */
+	CK_SESSION_HANDLE h = p11h();
+	CK_MECHANISM mech;
+	CK_OBJECT_HANDLE key;
+	CK_ULONG blocklen = ed->ed_blocklen;
+	CK_RV rc = CKR_OK;
+	uint32_t msgid = ntohl(pkt_header(pkt)->msgid);
+
+	if (sa->flags & I2SA_INITIATOR)
+		key = sa->sk_ei;
+	else
+		key = sa->sk_er;
+
+	switch (sa->encr) {
+	case IKEV2_ENCR_AES_CBC:
+		mech.mechanism = CKM_AES_ECB;
+		mech.pParameter = NULL_PTR;
+		mech.ulParameterLen = 0;
+		break;
+	case IKEV2_ENCR_CAMELLIA_CBC:
+		mech.mechanism = CKM_CAMELLIA_ECB;
+		mech.pParameter = NULL_PTR;
+		mech.ulParameterLen = 0;
+		break;
+	default:
+		INVALID(sa->encr);
+		/*NOTREACHED*/
+		return (B_FALSE);
+	}
+	CK_BYTE buf[blocklen];
+
+	bzero(buf, blocklen);
+	bcopy(&msgid, buf, sizeof (msgid));
+
+	rc = C_EncryptInit(h, &mech, key);
+	if (rc != CKR_OK) {
+		PKCS11ERR(error, "C_EncryptInit", rc);
+		return (B_FALSE);
+	}
+
+	rc = C_Encrypt(h, buf, blocklen, buf, &blocklen);
+	if (rc != CKR_OK) {
+		PKCS11ERR(error, "C_Encrypt", rc);
+		return (B_FALSE);
+	}
+
+	bcopy(buf, pkt->pkt_ptr, MIN(len, blocklen));
+	explicit_bzero(buf, blocklen);
+	pkt->pkt_ptr += MIN(len, blocklen);
+	return (B_TRUE);
+}
+
+boolean_t
+ikev2_add_config(pkt_t *pkt, ikev2_cfg_type_t cfg_type)
+{
+	/* TODO */
+	return (B_FALSE);
+}
+
+boolean_t
+ikev2_add_config_attr(pkt_t *restrict pkt,
+    ikev2_cfg_attr_type_t cfg_attr_type, const void *restrict data)
+{
+	/* TODO */
+	return (B_FALSE);
+}
+
+boolean_t
+ikev2_pkt_encryptdecrypt(pkt_t *pkt, boolean_t encrypt)
+{
+	ikev2_sa_t *sa = pkt->pkt_sa;
+	const encr_data_t *ed = encr_data(sa->encr);
+	pkt_payload_t *sk = pkt_get_payload(pkt, IKEV2_PAYLOAD_SK, NULL);
+	const char *fn = NULL;
+	CK_SESSION_HANDLE h = p11h();
+	CK_MECHANISM mech;
+	CK_OBJECT_HANDLE key;
+	union {
+		CK_AES_CTR_PARAMS	aes_ctr;
+		CK_CAMELLIA_CTR_PARAMS	cam_ctr;
+		CK_GCM_PARAMS		gcm;
+		CK_CCM_PARAMS		ccm;
+	} params;
+	CK_BYTE_PTR salt = NULL, iv = NULL, data = NULL, icv = NULL;
+	CK_ULONG ivlen = ed->ed_blocklen;
+	CK_ULONG icvlen = ikev2_auth_icv_size(sa->encr, sa->auth);
+	CK_ULONG blocklen = ed->ed_blocklen;
+	CK_ULONG noncelen = ivlen + SADB_1TO8(sa->saltlen);
+	CK_ULONG datalen = 0, outlen = 0;
+	CK_BYTE nonce[noncelen];
+	CK_RV rc = CKR_OK;
+	encr_modes_t mode = ed->ed_mode;
+	uint8_t padlen = 0;
+
+	VERIFY(IS_WORKER);
+	VERIFY(MUTEX_HELD(&sa->i2sa_lock));
+
+	if (pkt_header(pkt)->flags & IKEV2_FLAG_INITIATOR) {
+		key = sa->sk_ei;
+		salt = sa->salt_i;
+	} else {
+		key = sa->sk_er;
+		salt = sa->salt_r;
+	}
+
+	outlen = pkt_write_left(pkt) + icvlen;
+	iv = sk->pp_ptr;
+	data = iv + ivlen;
+
+	if (encrypt) {
+		datalen = (CK_ULONG)(pkt->pkt_ptr - data) - icvlen;
+		/* If we're creating it, lengths should match */
+		VERIFY3U(sk->pp_len, ==, ivlen + datalen + icvlen);
+	} else if (sk->pp_len > ivlen + icvlen) {
+		datalen = sk->pp_len - ivlen - icvlen;
+	} else {
+		(void) bunyan_info(log,
+		    "Encrypted payload invalid length",
+		    BUNYAN_T_UINT32, "paylen", (uint32_t)sk->pp_len,
+		    BUNYAN_T_UINT32, "ivlen", (uint32_t)ivlen,
+		    BUNYAN_T_UINT32, "datalen", (uint32_t)datalen,
+		    BUNYAN_T_UINT32, "icvlen", (uint32_t)icvlen,
+		    BUNYAN_T_END);
+		return (B_FALSE);
+	}
+
+	icv = data + datalen;
+
+	bcopy(iv, nonce, ivlen);
+	if (sa->saltlen > 0)
+		bcopy(salt, nonce + ivlen, SADB_1TO8(sa->saltlen));
+
+	mech.mechanism = ed->ed_p11id;
+	switch (mode) {
+	case MODE_NONE:
+		break;
+	case MODE_CBC:
+		mech.pParameter = nonce;
+		mech.ulParameterLen = noncelen;
+		break;
+	case MODE_CTR:
+		/* TODO */
+		break;
+	case MODE_CCM:
+		params.ccm.pAAD = pkt_start(pkt);
+		params.ccm.ulAADLen = (CK_ULONG)(iv - pkt_start(pkt));
+		params.ccm.ulMACLen = icvlen;
+		params.ccm.pNonce = nonce;
+		params.ccm.ulNonceLen = noncelen;
+		mech.pParameter = &params.ccm;
+		mech.ulParameterLen = sizeof (CK_CCM_PARAMS);
+		break;
+	case MODE_GCM:
+		params.gcm.pIv = nonce;
+		params.gcm.ulIvLen = noncelen;
+		/*
+		 * There is a 'ulIvBits' field in CK_GCM_PARAMS.  This is from
+		 * the pkcs11t.h file published from OASIS.  However, it does
+		 * not appear to actually be used for anything, and looks to
+		 * be a leftover from the unpublished PKCS#11 v2.30 standard.
+		 * It is currently not set and ignored.
+		 */
+		params.gcm.pAAD = pkt_start(pkt);
+		params.gcm.ulAADLen = (CK_ULONG)(iv - params.gcm.pAAD);
+		params.gcm.ulTagBits = icvlen * 8;
+		mech.pParameter = &params.gcm;
+		mech.ulParameterLen = sizeof (CK_GCM_PARAMS);
+		break;
+	}
+
+	/*
+	 * As nice as it would be, it appears the combined mode functions
+	 * (e.g. C_SignEncrypt) both operate on the plaintext.  However
+	 * we must sign the encrypted text, so must do it in different
+	 * operations.
+	 */
+	if (encrypt) {
+		fn = "C_EncryptInit";
+		rc = C_EncryptInit(h, &mech, key);
+	} else {
+		fn = "C_DecryptInit";
+		rc = C_DecryptInit(h, &mech, key);
+	}
+	if (rc != CKR_OK) {
+		PKCS11ERR(error, fn, rc);
+		return (B_FALSE);
+	}
+
+	if (encrypt) {
+		fn = "C_Encrypt";
+		rc = C_Encrypt(h, data, datalen, data, &outlen);
+	} else {
+		fn = "C_Decrypt";
+		rc = C_Decrypt(h, data, datalen, data, &outlen);
+	}
+	if (rc != CKR_OK) {
+		PKCS11ERR(error, "C_Encrypt", rc,
+		    BUNYAN_T_UINT64, "outlen", (uint64_t)outlen,
+		    BUNYAN_T_END);
+		return (B_FALSE);
+	}
+
+	if (encrypt)
+		return (B_TRUE);
+
+	/*
+	 * As described in ikev2_pkt_done(), we choose to use PKCS#7 style
+	 * padding, however our peer can use arbitrary values for padding.
+	 * When we know we are communicating with another illumos peer, we
+	 * explicity verify the padding.  This is due to the lessons learned
+	 * from exploits from TLS, etc. that exploit lack of padding checks.
+	 */
+	if (sa->vendor == VENDOR_ILLUMOS_1) {
+		uint8_t *pad;
+
+		padlen = icv[-1];
+		pad = icv - padlen - 1;
+
+		for (size_t i = 0; i <= padlen; i++) {
+			if (pad[i] == padlen)
+				continue;
+
+			(void) bunyan_warn(log,
+			    "Padding validation failed",
+			    BUNYAN_T_UINT32, "padlen", (uint32_t)padlen,
+			    BUNYAN_T_UINT32, "offset", (uint32_t)i,
+			    BUNYAN_T_END);
+			return (B_FALSE);
+		}
+	}
+	datalen -= padlen + 1;
+	pkt->pkt_decrypted = B_TRUE;
+
+	ike_payload_t *skpay = pkt_idx_to_payload(sk);
+
+	if (!pkt_check_payloads(skpay->pay_next, data, datalen,
+	    ikev2_pkt_checklen))
+		return (B_FALSE);
+	if (!pkt_index_payloads(pkt, data, datalen, skpay->pay_next))
+		return (B_FALSE);
+
+	/* Indicate packet contents is now treated immutable */
+	pkt->pkt_done = B_TRUE;
+	return (B_TRUE);
+}
+
+boolean_t
+ikev2_pkt_signverify(pkt_t *pkt, boolean_t sign)
+{
+	ikev2_sa_t *sa = pkt->pkt_sa;
+	const encr_data_t *ed = encr_data(sa->encr);
+	const auth_data_t *ad = auth_data(sa->auth);
+
+	if (MODE_IS_COMBINED(ed->ed_mode))
+		return (B_TRUE);
+
+	const char *fn = NULL;
+	pkt_payload_t *sk = pkt_get_payload(pkt, IKEV2_PAYLOAD_SK, NULL);
+	CK_SESSION_HANDLE h = p11h();
+	CK_OBJECT_HANDLE key;
+	CK_MECHANISM mech = {
+		.mechanism = ad->ad_p11id,
+		.pParameter = NULL_PTR,
+		.ulParameterLen = 0
+	};
+	CK_BYTE_PTR icv;
+	CK_ULONG signlen, icvlen;
+	CK_ULONG outlen = ad->ad_outlen;
+	CK_BYTE outbuf[outlen];
+	CK_RV rc;
+
+	if (pkt_header(pkt)->flags & IKEV2_FLAG_INITIATOR)
+		key = sa->sk_ai;
+	else
+		key = sa->sk_ar;
+
+	icvlen = ikev2_auth_icv_size(sa->encr, sa->auth);
+	if (sizeof (ike_header_t) + sizeof (ikev2_payload_t) + icvlen >
+	    pkt_len(pkt)) {
+		(void) bunyan_warn(log, "SK payload is truncated",
+		    BUNYAN_T_END);
+		return (B_FALSE);
+	}
+
+	signlen = pkt_len(pkt) - icvlen;
+	icv = pkt->pkt_ptr - icvlen;
+
+	VERIFY3U(icvlen, <=, outlen);
+
+	rc = C_SignInit(h, &mech, key);
+	if (rc != CKR_OK) {
+		PKCS11ERR(error, "C_SignInit", rc);
+		return (B_FALSE);
+	}
+
+	rc = C_Sign(h, pkt_start(pkt), signlen, outbuf, &outlen);
+	if (rc != CKR_OK) {
+		PKCS11ERR(error, "C_Sign", rc);
+		explicit_bzero(outbuf, outlen);
+		return (B_FALSE);
+	}
+
+	if (sign) {
+		bcopy(outbuf, icv, icvlen);
+		explicit_bzero(outbuf, outlen);
+		return (B_TRUE);
+	} else if (memcmp(icv, outbuf, icvlen) == 0) {
+		explicit_bzero(outbuf, outlen);
+		return (B_TRUE);
+	}
+
+	(void) bunyan_warn(log, "Payload signature validation failed",
+	    BUNYAN_T_END);
+
+	explicit_bzero(outbuf, outlen);
+	return (B_FALSE);
+}
+
+boolean_t
+ikev2_pkt_done(pkt_t *pkt)
+{
+	if (pkt->pkt_done)
+		return (B_TRUE);
+
+	pkt_payload_t *sk = pkt_get_payload(pkt, IKEV2_PAYLOAD_SK, NULL);
+
+	if (pkt_header(pkt)->exch_type == IKEV2_EXCH_IKE_SA_INIT) {
+		VERIFY3P(sk, ==, NULL);
+		return (pkt_done(pkt));
+	}
+
+	VERIFY3P(sk, !=, NULL);
+
+	ike_payload_t *skpay = pkt_idx_to_payload(sk);
+	ikev2_sa_t *sa = pkt->pkt_sa;
+	const encr_data_t *ed = encr_data(sa->encr);
+	CK_ULONG datalen = (CK_ULONG)(pkt->pkt_ptr - sk->pp_ptr);
+	CK_ULONG icvlen = ikev2_auth_icv_size(sa->encr, sa->auth);
+	CK_ULONG blocklen = ed->ed_blocklen;
+	uint16_t sklen = 0;
+	boolean_t ok = B_TRUE;
+	uint8_t padlen = 0;
+
+	/*
+	 * Per RFC7296 3.14, the sender can choose any value for the padding.
+	 * We elect to use PKCS#7 style padding (repeat the pad value as the
+	 * padding).  This is well studied and appears to work.
+	 */
+	if ((datalen + 1) % blocklen != 0)
+		padlen = blocklen - ((datalen + 1) % blocklen);
+
+	if (pkt_write_left(pkt) < padlen + 1 + icvlen) {
+		(void) bunyan_info(log, "Not enough space for packet",
+		    BUNYAN_T_END);
+		goto done;
+	}
+
+	/*
+	 * Since we are writing out pad length as the padding value, and
+	 * the pad length field is immediately after the padding, we
+	 * can just write padlen + 1 bytes of data whose value is padlen
+	 */
+	for (size_t i = 0; i <= padlen; i++)
+		pkt->pkt_ptr[i] = padlen;
+	pkt->pkt_ptr += padlen + 1;
+
+	/*
+	 * Skip over the space for the ICV.  This is necessary so that all
+	 * the lengths (packet, payload) are updated with the final values
+	 * prior to encryption and signing.
+	 */
+	pkt->pkt_ptr += icvlen;
+
+	sklen = (uint16_t)(pkt->pkt_ptr - sk->pp_ptr);
+	sk->pp_len = sklen;
+	BE_OUT16(&skpay->pay_length, sklen + sizeof (ike_payload_t));
+
+	ok = pkt_done(pkt);
+	ok &= ikev2_pkt_encryptdecrypt(pkt, B_TRUE);
+	ok &= ikev2_pkt_signverify(pkt, B_TRUE);
+
+done:
+	return (ok);
+}
+
+/*
+ * Create a abbreviated string listing the payload types (in order).
+ * Mostly for diagnostic purposes.
+ *
+ * Example: 'N(COOKIE), SA, KE, No'
+ */
+custr_t *
+ikev2_pkt_desc(pkt_t *pkt)
+{
+	custr_t *cstr = NULL;
+	uint16_t i;
+	uint16_t j;
+
+	if (custr_alloc(&cstr) != 0)
+		return (NULL);
+
+	for (i = j = 0; i < pkt->pkt_payload_count; i++) {
+		pkt_payload_t *pay = pkt_payload(pkt, i);
+		const char *paystr =
+		    ikev2_pay_short_str((ikev2_pay_type_t)pay->pp_type);
+
+		if (i > 0 && custr_appendc(cstr, ',') != 0 &&
+		    custr_appendc(cstr, ' ') != 0)
+			goto fail;
+
+		if (custr_append(cstr, paystr) != 0)
+			goto fail;
+
+		if (pay->pp_type == IKEV2_PAYLOAD_NOTIFY) {
+			pkt_notify_t *n = pkt_notify(pkt, j++);
+			const char *nstr =
+			    ikev2_notify_str((ikev2_notify_type_t)n->pn_type);
+
+			if (custr_appendc(cstr, '(') != 0)
+				goto fail;
+			if (custr_append(cstr, nstr) != 0)
+				goto fail;
+			if (custr_appendc(cstr, ')') != 0)
+				goto fail;
+		}
+	}
+
+	return (cstr);
+
+fail:
+	custr_free(cstr);
+	return (NULL);
+}
+
+static struct {
+	const char *str;
+	uint8_t val;
+} flagtbl[] = {
+	{ "RESPONSE", IKEV2_FLAG_RESPONSE },
+	{ "VERSION", IKEV2_FLAG_VERSION },
+	{ "INITIATOR", IKEV2_FLAG_INITIATOR }
+};
+
+void
+ikev2_pkt_log(pkt_t *restrict pkt, bunyan_level_t level, const char *msg)
+{
+	ike_header_t *hdr = pkt_header(pkt);
+	custr_t *desc = ikev2_pkt_desc(pkt);
+	char ispi[19];
+	char rspi[19];
+	char flag[30];
+
+	(void) snprintf(ispi, sizeof (ispi), "0x%" PRIX64,
+	    ntohll(hdr->initiator_spi));
+	(void) snprintf(rspi, sizeof (rspi), "0x%" PRIX64,
+	    ntohll(hdr->responder_spi));
+	(void) snprintf(flag, sizeof (flag), "0x%" PRIx8, hdr->flags);
+
+	if (hdr->flags != 0) {
+		size_t count = 0;
+
+		(void) strlcat(flag, "<", sizeof (flag));
+		for (size_t i = 0; i < ARRAY_SIZE(flagtbl); i++) {
+			if (hdr->flags & flagtbl[i].val) {
+				if (count > 0) {
+					(void) strlcat(flag, ",",
+					    sizeof (flag));
+				}
+				(void) strlcat(flag, flagtbl[i].str,
+				    sizeof (flag));
+				count++;
+			}
+		}
+		(void) strlcat(flag, ">", sizeof (flag));
+	}
+
+	getlog(level)(log, msg,
+	    BUNYAN_T_POINTER, "pkt", pkt,
+	    BUNYAN_T_STRING, "initiator_spi", ispi,
+	    BUNYAN_T_STRING, "responder_spi", rspi,
+	    BUNYAN_T_STRING, "exch_type", ikev2_exch_str(hdr->exch_type),
+	    BUNYAN_T_UINT32, "msgid", ntohl(pkt_header(pkt)->msgid),
+	    BUNYAN_T_UINT32, "msglen", ntohl(pkt_header(pkt)->length),
+	    BUNYAN_T_STRING, "flags", flag,
+	    BUNYAN_T_UINT32, "nxmit", (uint32_t)pkt->pkt_xmit,
+	    BUNYAN_T_STRING, "payloads", (desc != NULL) ? custr_cstr(desc) : "",
+	    BUNYAN_T_END);
+	custr_free(desc);
+}
+
+ikev2_sa_proposal_t *
+ikev2_prop_first(pkt_payload_t *sapay)
+{
+	VERIFY3U(sapay->pp_type, ==, IKEV2_PAYLOAD_SA);
+	return ((ikev2_sa_proposal_t *)sapay->pp_ptr);
+}
+
+ikev2_sa_proposal_t *
+ikev2_prop_end(pkt_payload_t *sapay)
+{
+	VERIFY3U(sapay->pp_type, ==, IKEV2_PAYLOAD_SA);
+	return ((ikev2_sa_proposal_t *)(sapay->pp_ptr + sapay->pp_len));
+}
+
+ikev2_sa_proposal_t *
+ikev2_prop_next(ikev2_sa_proposal_t *prop)
+{
+	uint16_t len = BE_IN16(&prop->proto_length);
+	return ((ikev2_sa_proposal_t *)((uint8_t *)prop + len));
+}
+
+uint64_t
+ikev2_prop_spi(ikev2_sa_proposal_t *prop)
+{
+	uint8_t *addr = (uint8_t *)(prop + 1);
+	uint64_t spi = 0;
+
+	if (!pkt_get_spi(&addr, prop->proto_spisize, &spi))
+		return (0);
+	return (spi);
+}
+
+ikev2_transform_t *
+ikev2_xf_first(ikev2_sa_proposal_t *prop)
+{
+	uint8_t *p = (uint8_t *)(prop + 1) + prop->proto_spisize;
+	return ((ikev2_transform_t *)p);
+}
+
+ikev2_transform_t *
+ikev2_xf_next(ikev2_transform_t *xf)
+{
+	uint16_t len = BE_IN16(&xf->xf_length);
+	return ((ikev2_transform_t *)((uint8_t *)xf + len));
+}
+
+ikev2_transform_t *
+ikev2_xf_end(ikev2_sa_proposal_t *prop)
+{
+	return ((ikev2_transform_t *)ikev2_prop_next(prop));
+}
+
+ikev2_attribute_t *
+ikev2_attr_first(ikev2_transform_t *xf)
+{
+	return ((ikev2_attribute_t *)(xf + 1));
+}
+
+ikev2_attribute_t *
+ikev2_attr_end(ikev2_transform_t *xf)
+{
+	return ((ikev2_attribute_t *)ikev2_xf_next(xf));
+}
+
+ikev2_attribute_t *
+ikev2_attr_next(ikev2_attribute_t *attr)
+{
+	uint16_t type = BE_IN16(&attr->attr_type);
+	uint16_t len = BE_IN16(&attr->attr_length);
+
+	if (type & IKEV2_ATTRAF_TV)
+		return (attr + 1);
+	return ((ikev2_attribute_t *)((uint8_t *)attr + len));
+}
+
+/* Retrieve the DH group value from a key exchange payload */
+ikev2_dh_t
+ikev2_get_dhgrp(pkt_t *pkt)
+{
+	pkt_payload_t *ke = pkt_get_payload(pkt, IKEV2_PAYLOAD_KE, NULL);
+	uint16_t val = 0;
+
+	if (ke == NULL)
+		return (IKEV2_DH_NONE);
+
+	VERIFY3U(ke->pp_len, >, sizeof (val));
+	return (BE_IN16(ke->pp_ptr));
+}
+
+size_t
+ikev2_spilen(ikev2_spi_proto_t proto)
+{
+	switch (proto) {
+	case IKEV2_PROTO_NONE:
+		return (0);
+	case IKEV2_PROTO_AH:
+	case IKEV2_PROTO_ESP:
+	case IKEV2_PROTO_FC_ESP_HEADER:
+	case IKEV2_PROTO_FC_CT_AUTH:
+		return (sizeof (uint32_t));
+	case IKEV2_PROTO_IKE:
+		return (sizeof (uint64_t));
+	}
+
+	/*NOTREACHED*/
+	return (0);
+}
+
+boolean_t
+ikev2_invalid_ke(pkt_t *resp, ikev2_dh_t dh)
+{
+	uint16_t val = htons(dh);
+
+	/* This notification can only appear in a response */
+	VERIFY(I2P_RESPONSE(resp));
+
+	if (!ikev2_add_notify_full(resp, IKEV2_PROTO_NONE, 0,
+	    IKEV2_N_INVALID_KE_PAYLOAD, &val, sizeof (val)))
+		return (B_FALSE);
+
+	return (B_TRUE);
+}
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_pkt.h b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_pkt.h
new file mode 100644
index 0000000000..919b73f565
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_pkt.h
@@ -0,0 +1,163 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2017 Jason King.
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+#ifndef _IKEV2_PKT_H
+#define	_IKEV2_PKT_H
+
+#include <sys/types.h>
+#include <bunyan.h>
+#include <security/cryptoki.h>
+#include "ikev2.h"
+#include "pkt.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct ikev2_sa_s;
+struct bunyan_logger;
+struct sockaddr;
+
+#define	I2P_RESPONSE(p) (!!(pkt_header(p)->flags & IKEV2_FLAG_RESPONSE))
+#define	I2P_INITIATOR(p) (pkt_header(p)->flags & IKEV2_FLAG_INITIATOR)
+
+#define	INBOUND_LOCAL_SPI(hdr) \
+	(((hdr)->flags == IKEV2_FLAG_INITIATOR) ? \
+	    (hdr)->responder_spi : (hdr)->initiator_spi)
+
+#define	INBOUND_REMOTE_SPI(hdr) \
+	(((hdr)->flags == IKEV2_FLAG_INITIATOR) ? \
+	    (hdr)->initiator_spi : (hdr)->responder_spi)
+
+typedef struct ikev2_pkt_ts_state {
+	pkt_t		*i2ts_pkt;
+	uint16_t	*i2ts_lenp;
+	pkt_payload_t	*i2ts_idx;
+	uint8_t		*i2ts_countp;
+	uint16_t	i2ts_len;
+} ikev2_pkt_ts_state_t;
+
+typedef struct ikev2_ts_iter_s {
+	ikev2_tsp_t	*i2ti_tsp;
+	ikev2_ts_t	*i2ti_ts;
+	size_t		i2ti_n;
+} ikev2_ts_iter_t;
+
+pkt_t *ikev2_pkt_new_inbound(void *restrict, size_t);
+pkt_t *ikev2_pkt_new_exchange(struct ikev2_sa_s *, ikev2_exch_t);
+pkt_t *ikev2_pkt_new_response(const pkt_t *);
+void ikev2_pkt_free(pkt_t *);
+
+boolean_t ikev2_add_sa(pkt_t *restrict, pkt_sa_state_t *restrict);
+boolean_t ikev2_add_prop(pkt_sa_state_t *, uint8_t, ikev2_spi_proto_t,
+    uint64_t);
+boolean_t ikev2_add_xform(pkt_sa_state_t *, ikev2_xf_type_t, int);
+boolean_t ikev2_add_xf_attr(pkt_sa_state_t *, ikev2_xf_attr_type_t, uintptr_t);
+boolean_t ikev2_add_xf_encr(pkt_sa_state_t *, ikev2_xf_encr_t, uint16_t,
+    uint16_t);
+boolean_t ikev2_add_ke(pkt_t *restrict, ikev2_dh_t, CK_OBJECT_HANDLE);
+boolean_t ikev2_add_id(pkt_t *restrict, boolean_t, ikev2_id_type_t, ...);
+boolean_t ikev2_add_id_i(pkt_t *restrict, ikev2_id_type_t, ...);
+boolean_t ikev2_add_id_r(pkt_t *restrict, ikev2_id_type_t, ...);
+boolean_t ikev2_add_cert(pkt_t *restrict, ikev2_cert_t,
+    const uint8_t *restrict, size_t);
+boolean_t ikev2_add_certreq(pkt_t *restrict, ikev2_cert_t,
+    const uint8_t *restrict, size_t);
+boolean_t ikev2_add_auth(pkt_t *restrict, ikev2_auth_type_t,
+    const uint8_t *restrict, size_t);
+boolean_t ikev2_add_nonce(pkt_t *restrict, uint8_t *restrict, size_t);
+boolean_t ikev2_add_notify(pkt_t *restrict, ikev2_notify_type_t);
+boolean_t ikev2_add_notify_full(pkt_t *restrict, ikev2_spi_proto_t, uint64_t,
+    ikev2_notify_type_t, const void *restrict, size_t);
+
+boolean_t ikev2_add_delete(pkt_t *, ikev2_spi_proto_t, uint64_t *restrict,
+    size_t);
+boolean_t ikev2_add_delete_spi(pkt_t *, uint64_t);
+
+boolean_t ikev2_add_vendor(pkt_t *restrict, const void *restrict,
+    size_t);
+
+/*
+ * The usage of 'struct sockaddr *' vs 'struct sockaddr_storage *'
+ * reflects the assumptions about the side of the struct pointed to --
+ * functions that take 'struct sockaddr' are assumed to be sized according
+ * to the value of sa_family (i.e. AF_INET implies 'struct sockaddr_in'
+ * while AF_INET6 implies 'struct sockaddr_in6'), while 'sockaddr_storage'
+ * implies it must be large enough to hold any possible address.
+ */
+boolean_t ikev2_add_ts_i(pkt_t *restrict, ikev2_pkt_ts_state_t *restrict);
+boolean_t ikev2_add_ts_r(pkt_t *restrict, ikev2_pkt_ts_state_t *restrict);
+boolean_t ikev2_add_ts(ikev2_pkt_ts_state_t *restrict, uint8_t,
+    const struct sockaddr *restrict, const struct sockaddr *restrict);
+
+ikev2_ts_t *ikev2_ts_iter(pkt_payload_t *restrict, ikev2_ts_iter_t *restrict,
+    struct sockaddr_storage *restrict, struct sockaddr_storage *restrict);
+ikev2_ts_t *ikev2_ts_iter_next(ikev2_ts_iter_t *restrict,
+    struct sockaddr_storage *restrict, struct sockaddr_storage *restrict);
+
+boolean_t ikev2_add_sk(pkt_t *);
+
+boolean_t ikev2_add_config(pkt_t *restrict, ikev2_cfg_type_t);
+boolean_t ikev2_add_config_attr(pkt_t *restrict, ikev2_cfg_attr_type_t,
+    const void *restrict);
+
+boolean_t ikev2_pkt_done(pkt_t *);
+boolean_t ikev2_pkt_signverify(pkt_t *, boolean_t);
+boolean_t ikev2_pkt_encryptdecrypt(pkt_t *, boolean_t);
+
+ikev2_sa_proposal_t *ikev2_prop_first(pkt_payload_t *);
+ikev2_sa_proposal_t *ikev2_prop_end(pkt_payload_t *);
+ikev2_sa_proposal_t *ikev2_prop_next(ikev2_sa_proposal_t *);
+uint64_t ikev2_prop_spi(ikev2_sa_proposal_t *);
+#define	FOREACH_PROP(_prop, _pay)		\
+    for ((_prop) = ikev2_prop_first(_pay);	\
+	(_prop) < ikev2_prop_end(_pay);		\
+	(_prop) = ikev2_prop_next(_prop))
+
+ikev2_transform_t *ikev2_xf_first(ikev2_sa_proposal_t *);
+ikev2_transform_t *ikev2_xf_end(ikev2_sa_proposal_t *);
+ikev2_transform_t *ikev2_xf_next(ikev2_transform_t *);
+#define	FOREACH_XF(_xf, _prop)		\
+    for ((_xf) = ikev2_xf_first(_prop);	\
+	(_xf) < ikev2_xf_end(_prop);	\
+	(_xf) = ikev2_xf_next(_xf))
+
+
+ikev2_attribute_t *ikev2_attr_first(ikev2_transform_t *);
+ikev2_attribute_t *ikev2_attr_end(ikev2_transform_t *);
+ikev2_attribute_t *ikev2_attr_next(ikev2_attribute_t *);
+#define	FOREACH_ATTR(_attr, _xf)		\
+    for ((_attr) = ikev2_attr_first(_xf);	\
+	(_attr) < ikev2_attr_end(_xf);		\
+	(_attr) = ikev2_attr_next(_attr))
+
+#define	XF_HAS_ATTRS(xf) (ikev2_attr_first(xf) < ikev2_attr_end(xf))
+
+boolean_t ikev2_invalid_ke(pkt_t *, ikev2_dh_t);
+
+void ikev2_pkt_log(pkt_t *restrict, bunyan_level_t, const char *);
+
+struct custr;
+struct custr *ikev2_pkt_desc(pkt_t *);
+
+ikev2_dh_t ikev2_get_dhgrp(pkt_t *);
+size_t ikev2_spilen(ikev2_spi_proto_t);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _IKEV2_PKT_H */
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_pkt_check.c b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_pkt_check.c
new file mode 100644
index 0000000000..f0df4a6f1c
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_pkt_check.c
@@ -0,0 +1,720 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+#include <inttypes.h>
+#include <bunyan.h>
+#include <note.h>
+#include <netinet/in.h>
+#include <strings.h>
+#include <sys/debug.h>
+#include "defs.h"
+#include "ikev2.h"
+#include "ikev2_enum.h"
+#include "ikev2_pkt.h"
+#include "ikev2_pkt_check.h"
+#include "pkt.h"
+#include "pkt_impl.h"
+
+extern __thread bunyan_logger_t *log;
+
+/*
+ * All the payload checks take a pointer and length to the payload data i.e.
+ * they exclude the payload header.  Though to (hopefully) be less confusing,
+ * we report sizes including the payload header to reflect the value seen
+ * or expected in the payload header.  We use size_t's so that we can
+ * perform addition on any payload sizes without fear of overflow.
+ */
+
+/* Cast to uint32_t so bunyan logging isn't full of casts */
+#define	L(_len)	((uint32_t)((_len) + sizeof (ikev2_payload_t)))
+
+static boolean_t
+check_payload_size(const char *name, size_t buflen, size_t min, size_t max)
+{
+	char msg[128] = { 0 };
+
+	/*
+	 * The IKEv2 wire format only allows 16 bits for the length of a
+	 * payload, so it is impossible for a user-supplied datagram to
+	 * contain a length > UINT16_MAX.  If we encounter such a value, it
+	 * indicates a programming error, hence the VERIFY check instead of
+	 * merely returning B_FALSE.
+	 */
+	VERIFY3U(buflen, <=, UINT16_MAX);
+
+	if (buflen < min) {
+		(void) snprintf(msg, sizeof (msg),
+		    "%s payload is smaller than minimum required", name);
+		(void) bunyan_warn(log, msg,
+		    BUNYAN_T_UINT32, "buflen", L(buflen),
+		    BUNYAN_T_UINT32, "minimum", L(min),
+		    BUNYAN_T_END);
+		return (B_FALSE);
+	}
+
+	if (max > 0 && buflen > max) {
+		(void) snprintf(msg, sizeof (msg),
+		    "%s payload is larger than maximum allowed", name);
+		(void) bunyan_warn(log, msg,
+		    BUNYAN_T_UINT32, "buflen", L(buflen),
+		    BUNYAN_T_UINT32, "maximum", L(max),
+		    BUNYAN_T_END);
+		return (B_FALSE);
+	}
+	return (B_TRUE);
+}
+
+static boolean_t
+ikev2_checklen_xfattr(const uint8_t *buf, size_t buflen)
+{
+	const uint8_t *end = buf + buflen;
+
+	while (buf < end) {
+		const ikev2_attribute_t *attr = (const ikev2_attribute_t *)buf;
+		size_t attr_len = 0;
+		uint16_t attr_type;
+
+		if (buf + sizeof (*attr) > end)
+			goto truncated;
+
+		attr_type = BE_IN16(&attr->attr_type);
+		if (attr_type & IKEV2_ATTRAF_TV) {
+			attr_len = sizeof (*attr);
+		} else {
+			attr_len = BE_IN16(&attr->attr_length);
+		}
+
+		if (buf + attr_len > end)
+			goto truncated;
+
+		buf += attr_len;
+	}
+
+	return (B_TRUE);
+
+truncated:
+	(void) bunyan_warn(log, "SA transform attribute is truncated",
+	    BUNYAN_T_END);
+	return (B_FALSE);
+}
+
+static boolean_t
+ikev2_checklen_prop(const uint8_t *buf, size_t buflen)
+{
+	const ikev2_sa_proposal_t *propp = (const ikev2_sa_proposal_t *)buf;
+	const uint8_t *ptr = buf;
+	const uint8_t *end = buf + buflen;
+
+	ptr += sizeof (*propp) + propp->proto_spisize;
+	for (uint32_t i = 0; i < propp->proto_transforms; i++) {
+		const ikev2_transform_t *xf = (const ikev2_transform_t *)ptr;
+		const uint8_t *attrp;
+		uint32_t xflen = 0, attrlen = 0;
+
+		if (ptr + sizeof (*xf) > end) {
+			(void) bunyan_warn(log, "Transform header truncated",
+			    BUNYAN_T_END);
+			return (B_FALSE);
+		}
+
+		xflen = BE_IN16(&xf->xf_length);
+		if (xflen < sizeof (*xf)) {
+			(void) bunyan_warn(log, "Transform length mismatch",
+			    BUNYAN_T_UINT32, "xflen", xflen,
+			    BUNYAN_T_UINT32, "minlen", (uint32_t)sizeof (*xf),
+			    BUNYAN_T_END);
+			return (B_FALSE);
+		}
+
+		if (ptr + xflen > end) {
+			(void) bunyan_warn(log,
+			    "Transform overruns end of SA payload",
+			    BUNYAN_T_UINT32, "proposal_num",
+			    (uint32_t)propp->proto_proposalnr,
+			    BUNYAN_T_UINT32, "xfnum", i,
+			    BUNYAN_T_UINT32, "overrun_amt",
+			    (uint32_t)(end - ptr) - xflen,
+			    BUNYAN_T_END);
+			return (B_FALSE);
+		}
+
+		attrp = ptr + sizeof (*xf);
+		attrlen = xflen - sizeof (*xf);
+
+		if ((attrlen > 0) && !ikev2_checklen_xfattr(attrp, attrlen))
+			return (B_FALSE);
+
+		ptr += xflen;
+	}
+
+	if (ptr < end) {
+		(void) bunyan_warn(log, "SA payload has trailing data after "
+		    "proposal",
+		    BUNYAN_T_UINT32, "amt", (uint32_t)(end - ptr),
+		    BUNYAN_T_END);
+		return (B_FALSE);
+	}
+
+	return (B_TRUE);
+}
+
+static boolean_t
+ikev2_checklen_sa(const uint8_t *buf, size_t buflen)
+{
+	const uint8_t *end = buf + buflen;
+	const uint8_t *saptr = buf;
+	uint32_t propcnt = 0;
+
+	while (saptr < end) {
+		const ikev2_sa_proposal_t *prop =
+		    (const ikev2_sa_proposal_t *)saptr;
+		size_t proplen = 0;
+
+		if ((const uint8_t *)(prop + 1) > end) {
+			(void) bunyan_warn(log, "Proposal header truncated",
+			    /* propcnt + 1 to match expected proposal num */
+			    BUNYAN_T_UINT32, "propnum", propcnt + 1,
+			    BUNYAN_T_END);
+			return (B_FALSE);
+		}
+
+		proplen = BE_IN16(&prop->proto_length);
+		if (saptr + proplen > end) {
+			(void) bunyan_warn(log,
+			    "Proposal overruns end of SA payload",
+			    BUNYAN_T_UINT32, "amt",
+			    (uint32_t)(end - saptr) - proplen,
+			    BUNYAN_T_END);
+			return (B_FALSE);
+		}
+
+		if (!ikev2_checklen_prop(saptr, proplen))
+			return (B_FALSE);
+
+		saptr += proplen;
+	}
+
+	return (B_TRUE);
+}
+
+#define	IKEV2_KE_MIN	((uint32_t)(sizeof (ikev2_ke_t) + 1))
+static boolean_t
+ikev2_checklen_ke(const uint8_t *buf __unused, size_t buflen)
+{
+	return (check_payload_size("KE", buflen, IKEV2_KE_MIN, 0));
+}
+
+static boolean_t
+ikev2_checklen_id(const char *name, const uint8_t *buf, size_t buflen)
+{
+	const ikev2_id_t *id = (const ikev2_id_t *)buf;
+	size_t min = sizeof (ikev2_id_t);
+	size_t max = 0;
+
+	/* Make sure the ID header is present */
+	if (!check_payload_size(name, buflen, min, max))
+		return (B_FALSE);
+
+	/* id_type is 8 bits, so it is always safe to deference */
+	switch ((ikev2_id_type_t)id->id_type) {
+	case IKEV2_ID_IPV4_ADDR:
+		min += sizeof (in_addr_t);
+		max = min;
+		break;
+	case IKEV2_ID_FQDN:
+	case IKEV2_ID_RFC822_ADDR:
+		/* These are just non-NUL terminated ASCII strings */
+		min++;
+		break;
+	case IKEV2_ID_IPV6_ADDR:
+		min += sizeof (in6_addr_t);
+		max = min;
+		break;
+	case IKEV2_ID_DER_ASN1_DN:
+	case IKEV2_ID_DER_ASN1_GN:
+	case IKEV2_ID_KEY_ID:
+	case IKEV2_ID_FC_NAME:
+		min++;
+		break;
+	}
+	return (check_payload_size(name, buflen, min, max));
+}
+
+static boolean_t
+ikev2_checklen_idi(const uint8_t *buf, size_t buflen)
+{
+	return (ikev2_checklen_id("IDi", buf, buflen));
+}
+
+static boolean_t
+ikev2_checklen_idr(const uint8_t *buf, size_t buflen)
+{
+	return (ikev2_checklen_id("IDr", buf, buflen));
+}
+
+#define	IKEV2_CERT_MIN 1
+static boolean_t
+ikev2_checklen_cert(const uint8_t *buf __unused, size_t buflen)
+{
+	return (check_payload_size("CERT", buflen, IKEV2_CERT_MIN, 0));
+}
+
+static boolean_t
+ikev2_checklen_certreq(const uint8_t *buf __unused, size_t buflen)
+{
+	return (check_payload_size("CERTREQ", buflen, IKEV2_CERT_MIN, 0));
+}
+
+static boolean_t
+ikev2_checklen_auth(const uint8_t *buf, size_t buflen)
+{
+	return (check_payload_size("AUTH", buflen, sizeof (ikev2_auth_t), 0));
+}
+
+static boolean_t
+ikev2_checklen_nonce(const uint8_t *buf __unused, size_t buflen)
+{
+	return (check_payload_size("NONCE", buflen, IKEV2_NONCE_MIN,
+	    IKEV2_NONCE_MAX));
+}
+
+static boolean_t
+ikev2_checklen_ts(const char *name, const uint8_t *buf, size_t buflen)
+{
+	char msg[128] = { 0 };
+	const ikev2_tsp_t *tsp = (const ikev2_tsp_t *)buf;
+	const uint8_t *end = buf + buflen;
+	const uint8_t *ts_ptr = (const uint8_t *)(tsp + 1);
+	uint32_t len = sizeof (ikev2_tsp_t);
+	size_t count = 0;
+
+	if (!check_payload_size(name, buflen, sizeof (ikev2_tsp_t), 0))
+		return (B_FALSE);
+
+	for (size_t i = 0; i < tsp->tsp_count; i++) {
+		const ikev2_ts_hdr_t *tsh = (const ikev2_ts_hdr_t *)ts_ptr;
+		uint32_t ts_len;
+		uint8_t ts_type;
+
+		if (ts_ptr + sizeof (ikev2_ts_hdr_t) > end)
+			goto overrun;
+
+		/*
+		 * Both the IPv4/IPv6 traffic selectors consist of the fields
+		 * of ikev2_ts_t followed by two addresses (start/stop) of
+		 * their respective type
+		 */
+		switch ((ikev2_ts_type_t)tsh->tsh_type) {
+		case IKEV2_TS_IPV4_ADDR_RANGE:
+			len = sizeof (ikev2_ts_t) + 2 * sizeof (in_addr_t);
+			break;
+		case IKEV2_TS_IPV6_ADDR_RANGE:
+			len = sizeof (ikev2_ts_t) + 2 * sizeof (in6_addr_t);
+			break;
+		case IKEV2_TS_FC_ADDR_RANGE:
+			/* We don't support this, so just ignore it */
+			break;
+		}
+
+		ts_len = BE_IN16(&tsh->tsh_length);
+		if (ts_len < len) {
+			(void) snprintf(msg, sizeof (msg),
+			    "Traffic selector length in %s payload smaller "
+			    "than required", name);
+			(void) bunyan_warn(log, msg,
+			    BUNYAN_T_UINT32, "tslen", ts_len,
+			    BUNYAN_T_UINT32, "expectedlen", len,
+			    BUNYAN_T_END);
+			return (B_FALSE);
+		}
+		if (ts_ptr + ts_len > end)
+			goto overrun;
+
+		ts_ptr += ts_len;
+	}
+
+	if (ts_ptr != end) {
+		(void) snprintf(msg, sizeof (msg),
+		    "%s payload has trailing bytes", name);
+		(void) bunyan_warn(log, msg,
+		    BUNYAN_T_UINT32, "buflen", L(buflen),
+		    BUNYAN_T_UINT32, "trailing_amt", (uint32_t)(end - ts_ptr),
+		    BUNYAN_T_END);
+		return (B_FALSE);
+	}
+
+	return (B_TRUE);
+
+overrun:
+	(void) snprintf(msg, sizeof (msg),
+	   "Traffic selector in %s payload overruns end of payload", name);
+	(void) bunyan_warn(log, msg, BUNYAN_T_END);
+	return (B_FALSE);
+}
+
+static boolean_t
+ikev2_checklen_tsi(const uint8_t *buf, size_t buflen)
+{
+	return (ikev2_checklen_ts("TSi", buf, buflen));
+}
+
+static boolean_t
+ikev2_checklen_tsr(const uint8_t *buf, size_t buflen)
+{
+	return (ikev2_checklen_ts("TSr", buf, buflen));
+}
+
+static boolean_t
+ikev2_checklen_notify(const uint8_t *buf, size_t buflen)
+{
+	char name[] = "N";
+	ikev2_notify_t ntfy = { 0 };
+	size_t min = sizeof (ntfy);
+	size_t max = 0;
+
+	if (!check_payload_size(name, buflen, min, max))
+		return (B_FALSE);
+
+	bcopy(buf, &ntfy, sizeof (ntfy));
+
+	min += ntfy.n_spisize;
+	return (check_payload_size(name, buflen, min, max));
+}
+
+static boolean_t
+ikev2_checklen_delete(const uint8_t *buf, size_t buflen)
+{
+	const char name[] = "DELETE";
+	ikev2_delete_t del = { 0 };
+	size_t len = sizeof (del);
+
+	if (!check_payload_size(name, buflen, len, 0))
+		return (B_FALSE);
+
+	bcopy(buf, &del, sizeof (del));
+	if (del.del_spisize == 0)
+		return (check_payload_size(name, buflen, len, len));
+
+	len += del.del_spisize * ntohs(del.del_nspi);
+	return (check_payload_size(name, buflen, len, len));
+}
+
+boolean_t
+ikev2_pkt_checklen(uint8_t type, const uint8_t *buf, size_t len)
+{
+	switch ((ikev2_pay_type_t)type) {
+        case IKEV2_PAYLOAD_NONE:
+		/* This is never valid for a payload */
+		return (B_FALSE);
+	case IKEV2_PAYLOAD_SA:
+		return (ikev2_checklen_sa(buf, len));
+	case IKEV2_PAYLOAD_KE:
+		return (ikev2_checklen_ke(buf, len));
+	case IKEV2_PAYLOAD_IDi:
+		return (ikev2_checklen_idi(buf, len));
+	case IKEV2_PAYLOAD_IDr:
+		return (ikev2_checklen_idr(buf, len));
+	case IKEV2_PAYLOAD_CERT:
+		return (ikev2_checklen_cert(buf, len));
+	case IKEV2_PAYLOAD_CERTREQ:
+		return (ikev2_checklen_certreq(buf, len));
+	case IKEV2_PAYLOAD_AUTH:
+		return (ikev2_checklen_auth(buf, len));
+	case IKEV2_PAYLOAD_NONCE:
+		return (ikev2_checklen_nonce(buf, len));
+	case IKEV2_PAYLOAD_NOTIFY:
+		return (ikev2_checklen_notify(buf, len));
+	case IKEV2_PAYLOAD_DELETE:
+		return (ikev2_checklen_delete(buf, len));
+	case IKEV2_PAYLOAD_VENDOR:
+		/* Contents are completely arbitrary */
+		break;
+	case IKEV2_PAYLOAD_TSi:
+		return (ikev2_checklen_tsi(buf, len));
+	case IKEV2_PAYLOAD_TSr:
+		return (ikev2_checklen_tsr(buf, len));
+	case IKEV2_PAYLOAD_SK:
+		/*
+		 * Validating the size here is heavily dependent
+		 * on the algs in use, so we defer to the actual
+		 * decrypt code
+		 */
+		break;
+	case IKEV2_PAYLOAD_CP:
+		/* TODO once we implement remote-access VPNs */
+		break;
+	case IKEV2_PAYLOAD_EAP:
+	case IKEV2_PAYLOAD_GSPM:
+	case IKEV2_PAYLOAD_IDg:
+	case IKEV2_PAYLOAD_GSA:
+	case IKEV2_PAYLOAD_KD:
+	case IKEV2_PAYLOAD_SKF:
+	case IKEV2_PAYLOAD_PS:
+		/* not currently supported, ignored */
+		break;
+	}
+
+	return (B_TRUE);
+}
+
+/*
+ * For protected exchanges (i.e. anything not IKE_SA_INIT), the packets
+ * should consist of a single payload (SK) that contains the encrypted and
+ * signed payloads.  If there any unprotected payloads in addition to the SK
+ * payload, we ignore them by removing them from pkt->pkt_payloads.
+ */
+static boolean_t
+ikev2_pkt_check_predecrypt(pkt_t *pkt)
+{
+	pkt_payload_t *sk = NULL;
+	size_t idx = 0;
+
+	VERIFY(!pkt->pkt_decrypted);
+
+	for (idx = 0; idx < pkt->pkt_payload_count; idx++) {
+		sk = pkt_payload(pkt, idx);
+		if (sk->pp_type == IKEV2_PAYLOAD_SK)
+			break;
+	}
+
+	if (sk == NULL || sk->pp_type != IKEV2_PAYLOAD_SK) {
+		(void) bunyan_warn(log, "Packet is missing an SK payload",
+		    BUNYAN_T_END);
+		return (B_FALSE);
+	}
+
+	if (idx == 0)
+		return (B_TRUE);
+
+	pkt_payload_t *first = &pkt->pkt_payloads[0];
+	pkt_payload_t *pay = NULL;
+
+	*first = *sk;
+	for (size_t i = 1; i < pkt->pkt_payload_count; i++) {
+		pay = pkt_payload(pkt, idx);
+		bzero(pay, sizeof (*pay));
+	}
+	pkt->pkt_payload_count = 1;
+
+	return (B_TRUE);
+}
+
+#define	PAYIDX(type) ((type) - IKEV2_PAYLOAD_MIN)
+static void
+ikev2_count_payloads(pkt_t *restrict pkt, size_t *restrict count)
+{
+	for (size_t i = 0; i < pkt->pkt_payload_count; i++) {
+		pkt_payload_t *pay = pkt_payload(pkt, i);
+
+		if (!IKEV2_VALID_PAYLOAD(pay->pp_type))
+			continue;
+
+		count[PAYIDX(pay->pp_type)]++;
+	}
+}
+
+static boolean_t
+check_count(ikev2_pay_type_t type, size_t min, size_t max, size_t *count)
+{
+	size_t val = count[PAYIDX(type)];
+
+	if (val >= min && val <= max)
+		return (B_TRUE);
+
+	char msg[128] = { 0 };
+
+	(void) snprintf(msg, sizeof (msg), "Packet %s payload %s",
+	    ikev2_pay_short_str(type),
+	    (val < min) ? "is missing" : "defined multiple times");
+
+	(void) bunyan_warn(log, msg, BUNYAN_T_END);
+	return (B_FALSE);
+}
+
+boolean_t
+ikev2_pkt_has_nerror(pkt_t *pkt)
+{
+	for (size_t i = 0; i < pkt->pkt_notify_count; i++) {
+		pkt_notify_t *n = pkt_notify(pkt, i);
+
+		if (IKEV2_NOTIFY_ERROR(n->pn_type))
+			return (B_TRUE);
+	}
+	return (B_FALSE);
+}
+
+static boolean_t
+ikev2_pkt_check_ike_sa_init(pkt_t *pkt)
+{
+	/*
+	 * While not a notification error, like notification errors, it's
+	 * presence means the expected payloads may not be present.
+	 */
+	static const ikev2_notify_type_t errors[] = {
+		IKEV2_N_COOKIE,
+	};
+	size_t paycount[IKEV2_NUM_PAYLOADS] = { 0 };
+	uint32_t msgid = ntohl(pkt_header(pkt)->msgid);
+	boolean_t ok = B_TRUE;
+
+	if (msgid != 0) {
+		(void) bunyan_warn(log,
+		    "Message id is not zero on IKE_SA_INIT exchange",
+		    BUNYAN_T_END);
+		return (B_FALSE);
+	}
+
+	if (ikev2_pkt_has_nerror(pkt))
+		return (B_TRUE);
+
+	ikev2_count_payloads(pkt, paycount);
+
+	if (I2P_RESPONSE(pkt)) {
+		for (size_t i = 0; i < ARRAY_SIZE(errors); i++) {
+			if (pkt_get_notify(pkt, errors[i], NULL) != NULL)
+				return (B_TRUE);
+		}
+	}
+
+	ok &= check_count(IKEV2_PAYLOAD_SA, 1, 1, paycount);
+	ok &= check_count(IKEV2_PAYLOAD_KE, 1, 1, paycount);
+	ok &= check_count(IKEV2_PAYLOAD_NONCE, 1, 1, paycount);
+
+	return (ok);
+}
+
+static boolean_t ikev2_pkt_check_create_child_sa(pkt_t *);
+
+static boolean_t
+ikev2_pkt_check_ike_auth(pkt_t *pkt)
+{
+	if (!pkt->pkt_decrypted)
+		return (ikev2_pkt_check_predecrypt(pkt));
+
+	size_t paycount[IKEV2_NUM_PAYLOADS] = { 0 };
+	boolean_t ok = B_TRUE;
+
+	if (pkt_get_notify(pkt, IKEV2_N_AUTHENTICATION_FAILED, NULL) != NULL)
+		return (B_TRUE);
+
+	if (!ikev2_pkt_check_create_child_sa(pkt))
+		return (B_FALSE);
+
+	ikev2_count_payloads(pkt, paycount);
+
+	if (I2P_RESPONSE(pkt)) {
+		ok &= check_count(IKEV2_PAYLOAD_IDr, 1, 1, paycount);
+	} else {
+		ok &= check_count(IKEV2_PAYLOAD_IDi, 1, 1, paycount);
+		ok &= check_count(IKEV2_PAYLOAD_IDr, 0, 1, paycount);
+	}
+
+	ok &= check_count(IKEV2_PAYLOAD_AUTH, 1, 1, paycount);
+
+	if (!ok)
+		return (B_FALSE);
+
+	return (ikev2_pkt_check_create_child_sa(pkt));
+}
+
+static boolean_t
+ikev2_pkt_check_create_child_sa(pkt_t *pkt)
+{
+	if (!pkt->pkt_decrypted)
+		return (ikev2_pkt_check_predecrypt(pkt));
+
+	size_t paycount[IKEV2_NUM_PAYLOADS] = { 0 };
+	boolean_t ok = B_TRUE;
+
+	if (ikev2_pkt_has_nerror(pkt))
+		return (B_TRUE);
+
+	ikev2_count_payloads(pkt, paycount);
+
+	ok &= check_count(IKEV2_PAYLOAD_SA, 1, 1, paycount);
+	ok &= check_count(IKEV2_PAYLOAD_TSi, 1, 1, paycount);
+	ok &= check_count(IKEV2_PAYLOAD_TSr, 1, 1, paycount);
+
+	ok &= check_count(IKEV2_PAYLOAD_KE, 0, 1, paycount);
+	return (ok);
+}
+
+static boolean_t
+ikev2_pkt_check_informational(pkt_t *pkt)
+{
+	if (!pkt->pkt_decrypted)
+		return (ikev2_pkt_check_predecrypt(pkt));
+
+	/* Can have a bunch of things, so don't worry about it */
+	return (B_TRUE);
+}
+#undef	PAYIDX
+
+boolean_t
+ikev2_pkt_check_payloads(pkt_t *pkt)
+{
+	ikev2_exch_t exch_type = pkt_header(pkt)->exch_type;
+
+	switch (exch_type) {
+	case IKEV2_EXCH_IKE_SA_INIT:
+		return (ikev2_pkt_check_ike_sa_init(pkt));
+	case IKEV2_EXCH_IKE_AUTH:
+		return (ikev2_pkt_check_ike_auth(pkt));
+	case IKEV2_EXCH_CREATE_CHILD_SA:
+		return (ikev2_pkt_check_create_child_sa(pkt));
+	case IKEV2_EXCH_INFORMATIONAL:
+		return (ikev2_pkt_check_informational(pkt));
+	case IKEV2_EXCH_IKE_SESSION_RESUME:
+	case IKEV2_EXCH_GSA_AUTH:
+	case IKEV2_EXCH_GSA_REGISTRATION:
+	case IKEV2_EXCH_GSA_REKEY:
+		/*
+		 * ikev2_pkt_new_inbound() should discard unsupported
+		 * exchanges before we're ever called
+		 */
+		INVALID(exch_type);
+		break;
+	}
+
+	/*NOTREACHED*/
+	return (B_FALSE);
+}
+
+uint8_t
+ikev2_pkt_check_critical(pkt_t *pkt)
+{
+	pkt_payload_t *pay = NULL;
+	ike_payload_t *payhdr = NULL;
+
+	for (size_t i = 0; i < pkt->pkt_payload_count; i++) {
+		pay = pkt_payload(pkt, i);
+
+		/* XXX: Maybe change to IKEV2_KNOWN_PAYLOAD? */
+		if (IKEV2_VALID_PAYLOAD(pay->pp_type))
+			continue;
+
+		payhdr = pkt_idx_to_payload(pay);
+		if (!(payhdr->pay_reserved & IKEV2_CRITICAL_PAYLOAD))
+			continue;
+
+		(void) bunyan_info(log,
+		    "Packet contains unsupported critical payload",
+		    BUNYAN_T_UINT32, "paytype", (uint32_t)pay->pp_type,
+		    BUNYAN_T_END);
+		return (pay->pp_type);
+	}
+
+	return (IKEV2_PAYLOAD_NONE);
+}
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_pkt_check.h b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_pkt_check.h
new file mode 100644
index 0000000000..4a151ed0df
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_pkt_check.h
@@ -0,0 +1,35 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+#ifndef _IKEV2_PKT_CHECK_H
+#define	_IKEV2_PKT_CHECK_H
+
+#include <inttypes.h>
+#include "ikev2.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct pkt_s;
+
+boolean_t ikev2_pkt_checklen(uint8_t, const uint8_t *, size_t);
+boolean_t ikev2_pkt_check_payloads(struct pkt_s *);
+uint8_t ikev2_pkt_check_critical(struct pkt_s *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _IKEV2_PKT_CHECK_H */
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_proto.c b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_proto.c
new file mode 100644
index 0000000000..8f5b8cb232
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_proto.c
@@ -0,0 +1,1227 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the "License").
+ * You may not use this file except in compliance with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ */
+
+/*
+ * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ *
+ * Copyright 2017 Jason King.
+ * Copyright (c) 2017, Joyent, Inc
+ */
+
+#include <errno.h>
+#include <ipsec_util.h>
+#include <libcmdutils.h>
+#include <libperiodic.h>
+#include <note.h>
+#include <string.h>
+#include <sys/debug.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include "config.h"
+#include "defs.h"
+#include "fromto.h"
+#include "inbound.h"
+#include "ikev2_cookie.h"
+#include "ikev2_enum.h"
+#include "ikev2_pkt.h"
+#include "ikev2_pkt_check.h"
+#include "ikev2_proto.h"
+#include "ikev2_sa.h"
+#include "pfkey.h"
+#include "pkt.h"
+#include "worker.h"
+
+static void ikev2_dispatch_pkt(pkt_t *);
+static void ikev2_dispatch_pfkey(ikev2_sa_t *restrict, parsedmsg_t *restrict);
+static void ikev2_informational(pkt_t *);
+
+static int select_socket(const struct sockaddr *, boolean_t);
+
+static ikev2_sa_t *ikev2_try_new_sa(pkt_t *restrict,
+    const struct sockaddr *restrict,
+    const struct sockaddr *restrict);
+
+static ikev2_sa_t *
+get_i2sa_inbound(uint64_t local_spi, uint64_t remote_spi,
+    const struct sockaddr *src, const struct sockaddr *dst,
+    pkt_t *restrict pkt)
+{
+	ikev2_sa_t *i2sa = NULL;
+
+	/*
+	 * We always use the local SPI when present (!= 0) to lookup an IKEv2
+	 * SA.  The only time the local SPI is missing is during an IKE_SA_INIT
+	 * exchange where we are the responder (as we have not yet allocated
+	 * our ikev2_sa_t yet and thus haven't generated our SPI).   If such
+	 * a packet is a retransmit (which could be due to packet loss of our
+	 * reply, or due to us requesting a COOKIE or now KE group), we must
+	 * still be able to find the ikev2_sa_t instance for this connection
+	 * in progress.  Since the remote SPI is (as the term suggests) is
+	 * picked by the remote peer, we have no control over it, and it is
+	 * possible two peers could choose the same value.  To disambiguate, we
+	 * have to not only look at the local and remote addresses, we must
+	 * also look at the original remote packet that triggered the creation
+	 * of our IKEv2 SA.
+	 */
+	if (local_spi != 0 &&
+	    (i2sa = ikev2_sa_getbylspi(local_spi, !I2P_INITIATOR(pkt))) != NULL)
+		return (i2sa);
+	if (pkt_header(pkt)->exch_type != IKEV2_EXCH_IKE_SA_INIT)
+		return (NULL);
+	return (ikev2_sa_getbyrspi(remote_spi, dst, src, pkt));
+}
+
+/*
+ * Find the IKEv2 SA for a given inbound packet (or create a new one if
+ * an IKE_SA_INIT exchange) and either process or add to the IKEv2 SA queue.
+ */
+void
+ikev2_inbound(pkt_t *restrict pkt, const struct sockaddr *restrict src,
+    const struct sockaddr *restrict dest)
+{
+	ikev2_sa_t *i2sa = NULL;
+	ike_header_t *hdr = pkt_header(pkt);
+	uint64_t local_spi = INBOUND_LOCAL_SPI(hdr);
+	uint64_t remote_spi = INBOUND_REMOTE_SPI(hdr);
+
+	VERIFY(IS_WORKER);
+
+	ikev2_pkt_log(pkt, BUNYAN_L_TRACE, "Received packet");
+
+	i2sa = get_i2sa_inbound(local_spi, remote_spi, dest, src, pkt);
+	if (i2sa == NULL) {
+		if (local_spi != 0) {
+			/*
+			 * If the local SPI is set, we should be able to find it
+			 * in our hash.  This may be a packet destined for a
+			 * condemned or recently deleted IKE SA.
+			 *
+			 * RFC7296 2.21.4 we may send an INVALID_IKE_SPI
+			 * notification if we wish, but it is suggested the
+			 * responses be rate limited.
+			 *
+			 * For now, discard.
+			 */
+			ikev2_pkt_log(pkt, BUNYAN_L_DEBUG,
+			    "Cannot find IKE SA for packet; discarding");
+			ikev2_pkt_free(pkt);
+			return;
+		}
+
+		/*
+		 * XXX: This might require special processing.
+		 * Discard for now.
+		 */
+		if (remote_spi == 0) {
+			ikev2_pkt_log(pkt, BUNYAN_L_DEBUG,
+			    "Received packet with a 0 remote SPI; discarding");
+			ikev2_pkt_free(pkt);
+			return;
+		}
+
+		/*
+		 * If we received a response, we should either have an IKE SA
+		 * or discard it, but shouldn't try to create a larval IKE SA.
+		 */
+		if (I2P_RESPONSE(pkt)) {
+			ikev2_pkt_log(pkt, BUNYAN_L_DEBUG,
+			    "Received response to non-existant IKE SA; "
+			    "discarding");
+			ikev2_pkt_free(pkt);
+			return;
+		}
+
+		/* On success, returns with i2sa_queue_lock held */
+		i2sa = ikev2_try_new_sa(pkt, dest, src);
+		if (i2sa == NULL) {
+			ikev2_pkt_free(pkt);
+			return;
+		}
+	} else {
+		mutex_enter(&i2sa->i2sa_queue_lock);
+	}
+
+	/* These never change once set */
+	if (i2sa->local_id != NULL) {
+		key_add_id(LOG_KEY_LOCAL_ID, LOG_KEY_LOCAL_ID_TYPE,
+		    i2sa->local_id);
+	}
+	if (i2sa->remote_id != NULL) {
+		key_add_id(LOG_KEY_REMOTE_ID, LOG_KEY_REMOTE_ID_TYPE,
+		    i2sa->remote_id);
+	}
+
+	VERIFY(MUTEX_HELD(&i2sa->i2sa_queue_lock));
+
+	pkt->pkt_sa = i2sa;
+	ikev2_sa_queuemsg(i2sa, I2SA_MSG_PKT, pkt);
+
+	I2SA_REFRELE(i2sa);
+}
+
+/*
+ * Determine if this pkt is an request for a new IKE SA.  If so, create
+ * a larval IKE SA and return it, otherwise return NULL.  It is assumed
+ * caller will discard packet when NULL is returned.
+ */
+static ikev2_sa_t *
+ikev2_try_new_sa(pkt_t *restrict pkt,
+    const struct sockaddr *restrict l_addr,
+    const struct sockaddr *restrict r_addr)
+{
+	ikev2_sa_t *i2sa = NULL;
+	ike_header_t *hdr = pkt_header(pkt);
+	const char *errmsg = NULL;
+
+	/* ikev2_dispatch() should guarantee this */
+	VERIFY3U(INBOUND_LOCAL_SPI(hdr), ==, 0);
+
+	/*
+	 * RFC7296 2.2 - The only exchange where our SPI is zero is when
+	 * the remote peer has started an IKE_SA_INIT exchange.  All others
+	 * must have both SPIs set (non-zero).
+	 */
+	if (hdr->exch_type != IKEV2_EXCH_IKE_SA_INIT) {
+		errmsg = "Received a non-IKE_SA_INIT message with a local "
+		    "SPI of 0; discarding";
+		goto fail;
+	}
+
+	/*
+	 * RFC7296 2.2 -- IKE_SA_INIT exchanges always have msgids == 0
+	 */
+	if (hdr->msgid != 0) {
+		errmsg = "Received an IKE_SA_INIT message with a non-zero "
+		    "message id; discarding";
+		goto fail;
+	}
+
+	/*
+	 * It also means it must be the initiator and not a response
+	 */
+	if ((hdr->flags & IKEV2_FLAG_INITIATOR) != hdr->flags) {
+		errmsg = "Invalid flags on packet; discarding";
+		goto fail;
+	}
+
+	/*
+	 * XXX: Since cookies are enabled in high traffic situations,
+	 * might we want to silently discard these?
+	 */
+	if (!ikev2_cookie_check(pkt, l_addr, r_addr))
+		goto fail;
+
+	/* otherwise create a larval SA */
+	i2sa = ikev2_sa_alloc(pkt, l_addr, r_addr);
+	if (i2sa == NULL) {
+		errmsg = "Could not create larval IKEv2 SA; discarding";
+		goto fail;
+	}
+
+	return (i2sa);
+
+fail:
+	if (errmsg != NULL)
+		ikev2_pkt_log(pkt, BUNYAN_L_DEBUG, errmsg);
+
+	return (NULL);
+}
+
+/*
+ * Take a parsed pfkey message, and either locate an existing IKE SA and
+ * add to it's queue, or create a larval IKE SA and kickoff the
+ * IKE_SA_INIT exchange.
+ */
+void
+ikev2_pfkey(parsedmsg_t *pmsg)
+{
+	ikev2_sa_t *i2sa = NULL;
+	sadb_x_kmc_t *kmc = NULL;
+	sadb_sa_t *sadb_sa = NULL;
+	sockaddr_u_t laddr;
+	sockaddr_u_t raddr;
+
+	laddr = pmsg->pmsg_sau;
+	raddr = pmsg->pmsg_dau;
+
+	kmc = (sadb_x_kmc_t *)pmsg->pmsg_exts[SADB_X_EXT_KM_COOKIE];
+	sadb_sa = (sadb_sa_t *)pmsg->pmsg_exts[SADB_EXT_SA];
+
+	if (kmc != NULL && sadb_sa != NULL) {
+		uint64_t local_spi = 0;
+		boolean_t initiator = B_FALSE;
+
+		VERIFY3U(kmc->sadb_x_kmc_exttype, ==, SADB_X_EXT_KM_COOKIE);
+		local_spi = kmc->sadb_x_kmc_cookie64;
+
+		if (sadb_sa->sadb_sa_flags & IKEV2_SADB_INITIATOR)
+			initiator = B_TRUE;
+
+		i2sa = ikev2_sa_getbylspi(local_spi, initiator);
+	} else {
+		/*
+		 * XXX: Since we set the KMC on every IPsec SA we create,
+		 * can this situation ever be anything other than an
+		 * SADB_ACQUIRE from the kernel?
+		 */
+		i2sa = ikev2_sa_getbyaddr(laddr.sau_sa, raddr.sau_sa);
+	}
+
+	if (i2sa == NULL) {
+		config_rule_t *rule = NULL;
+
+		/*
+		 * The KM cookie (kmc) is what links an IPsec SA to an IKE
+		 * SA.  If we receive a message with a kmc, we should have
+		 * a corresponding IKE SA.  If we receive a message without
+		 * a kmc, the only message that makes any sense is an
+		 * ACQUIRE (kernel requesting keys for an IPsec SA).  Any
+		 * others we drop and log (since it shouldn't happen).
+		 */
+		if (kmc != NULL ||
+		    pmsg->pmsg_samsg->sadb_msg_type != SADB_ACQUIRE) {
+			sadb_log(BUNYAN_L_ERROR, "Received a pfkey "
+			    "message for a non-existant IKE SA",
+			    pmsg->pmsg_samsg);
+
+			/*
+			 * XXX: Should we try to send an error reply back
+			 * to the kernel?  My guess is no, but need to confirm.
+			 */
+			parsedmsg_free(pmsg);
+			return;
+		}
+
+		rule = config_get_rule(laddr, raddr);
+		if (rule == NULL) {
+			/*
+			 * The kernel currently only cares that sadb_msg_errno
+			 * (set by the 2nd parameter to pfkey_send_error()) is
+			 * != 0.  However we still pick an error code that is
+			 * hopefully somewhat accurate to the reason for the
+			 * failure.
+			 */
+			pfkey_send_error(pmsg->pmsg_samsg, ENOENT);
+			sadb_log(BUNYAN_L_ERROR,
+			    "Could not find a matching IKE rule for the "
+			    "SADB ACQUIRE request", pmsg->pmsg_samsg);
+			parsedmsg_free(pmsg);
+			return;
+		}
+
+		/* On success, returns sa with i2sa_queue_lock held */
+		i2sa = ikev2_sa_alloc(NULL, laddr.sau_sa, raddr.sau_sa);
+		if (i2sa == NULL) {
+			/*
+			 * The kernel currently only cares that sadb_msg_errno
+			 * (set by the 2nd parameter to pfkey_send_error()) is
+			 * != 0.  To try to be at least somewhat accurate in
+			 * the reason for the failure, we use whatever error
+			 * was returned by ikev2_sa_alloc().
+			 */
+			VERIFY3S(errno, !=, 0);
+			pfkey_send_error(pmsg->pmsg_samsg, errno);
+			sadb_log(BUNYAN_L_ERROR,
+			    "Failed to create larval IKE SA: out of memory",
+			    pmsg->pmsg_samsg);
+			parsedmsg_free(pmsg);
+			return;
+		}
+
+		mutex_enter(&i2sa->i2sa_lock);
+		key_add_ike_spi(LOG_KEY_LSPI, I2SA_LOCAL_SPI(i2sa));
+		i2sa->i2sa_rule = rule;
+		mutex_exit(&i2sa->i2sa_lock);
+	} else {
+		key_add_ike_spi(LOG_KEY_LSPI, I2SA_LOCAL_SPI(i2sa));
+		(void) bunyan_trace(log, "Found IKEv2 SA", BUNYAN_T_END);
+		mutex_enter(&i2sa->i2sa_queue_lock);
+	}
+
+	ikev2_sa_queuemsg(i2sa, I2SA_MSG_PFKEY, pmsg);
+	I2SA_REFRELE(i2sa);
+}
+
+/*
+ * Attempt to create an IKEv2 SA  and start an IKE_SA_INIT exchange
+ * from the given rule.
+ *
+ * XXX: This currently only works for transport mode IKE SAs.  The main problem
+ * with being able to support tunnel mode is figuring what addresses to
+ * use to query the inner src/dst addresses.
+ */
+void
+ikev2_sa_init_cfg(config_rule_t *rule)
+{
+	ikev2_sa_t *i2sa = NULL;
+	parsedmsg_t *pmsg = NULL;
+	ts_t src = { .ts_proto = IPPROTO_IP };
+	ts_t dst = { .ts_proto = IPPROTO_IP };
+	size_t len = 0;
+
+	if (!config_addr_to_ss(&rule->rule_local_addr[0], &src.ts_ss))
+		goto fail;
+	if (!config_addr_to_ss(&rule->rule_remote_addr[0], &dst.ts_ss))
+		goto fail;
+
+	if (!pfkey_inverse_acquire(&src, &dst, NULL, NULL, &pmsg)) {
+		if (pmsg == NULL) {
+			STDERR(error, "Inverse acquire failed");
+			goto fail;
+		}
+
+		int errval = pmsg->pmsg_samsg->sadb_msg_errno;
+		uint32_t diag = pmsg->pmsg_samsg->sadb_x_msg_diagnostic;
+
+		if (errval == ENOENT) {
+			char *label = rule->rule_label;
+
+			if (RULE_IS_DEFAULT(rule))
+				label = "<default rule>";
+
+			/* XXX: Add addresses to message? */
+			(void) bunyan_error(log,
+			    "Cannot create IKEV2 SA for host: No IPsec "
+			    "configuration found",
+			    BUNYAN_T_STRING, "ike_rule", label,
+			    BUNYAN_T_END);
+			goto fail;
+		}
+
+		TSTDERR(errval, error,
+		    "Inverse acquire failed",
+		    (diag > 0) ? BUNYAN_T_UINT32 : BUNYAN_T_END,
+		    "code", diag,
+		    BUNYAN_T_STRING, "diagmsg", keysock_diag(diag),
+		    BUNYAN_T_END);
+		goto fail;
+	}
+
+	i2sa = ikev2_sa_alloc(NULL, &src.ts_sa, &dst.ts_sa);
+	if (i2sa == NULL) {
+		STDERR(error, "Failed to allocate larval IKE SA");
+		goto fail;
+	}
+
+	mutex_enter(&i2sa->i2sa_lock);
+	i2sa->i2sa_rule = rule;
+	mutex_exit(&i2sa->i2sa_lock);
+
+	ikev2_sa_queuemsg(i2sa, I2SA_MSG_PFKEY, pmsg);
+	I2SA_REFRELE(i2sa);
+	return;
+
+fail:
+	if (i2sa != NULL) {
+		VERIFY(MUTEX_HELD(&i2sa->i2sa_queue_lock));
+		mutex_enter(&i2sa->i2sa_lock);
+		i2sa->flags |= I2SA_CONDEMNED;
+		ikev2_sa_condemn(i2sa);
+		mutex_exit(&i2sa->i2sa_lock);
+		mutex_exit(&i2sa->i2sa_queue_lock);
+
+		I2SA_REFRELE(i2sa);
+	}
+
+	parsedmsg_free(pmsg);
+	CONFIG_REFRELE(rule->rule_config);
+}
+
+static boolean_t
+ikev2_send_common(pkt_t *restrict pkt,
+    const struct sockaddr *restrict laddr,
+    const struct sockaddr *restrict raddr,
+    boolean_t nat_is_known)
+{
+	ikev2_sa_t *sa = pkt->pkt_sa;
+	ike_header_t *hdr = pkt_header(pkt);
+	custr_t *desc = NULL;
+	ssize_t len = 0;
+	int s = -1;
+
+	if (!ikev2_pkt_done(pkt)) {
+		ikev2_pkt_free(pkt);
+		return (B_FALSE);
+	}
+
+	s = select_socket(laddr, nat_is_known);
+
+	desc = ikev2_pkt_desc(pkt);
+	(void) bunyan_debug(log, "Sending packet",
+	    BUNYAN_T_UINT32, "msgid", ntohll(hdr->msgid),
+	    BUNYAN_T_BOOLEAN, "response", I2P_RESPONSE(pkt),
+	    BUNYAN_T_STRING, "pktdesc", (desc != NULL) ? custr_cstr(desc) : "",
+	    BUNYAN_T_UINT32, "nxmit", (uint32_t)pkt->pkt_xmit,
+	    BUNYAN_T_END);
+	custr_free(desc);
+
+	len = sendfromto(s, pkt_start(pkt), pkt_len(pkt), laddr, raddr);
+	return ((len == -1) ? B_FALSE : B_TRUE);
+}
+
+/*
+ * Send a request (i.e. initiate the exchange).  All requests MUST include
+ * a callback function.  When a response is received (see
+ * ikev2_handle_response), the callback given here is invoked with the IKEv2 SA,
+ * the response packet, and the value of arg given here.  arg is merely an
+ * opaque pointer that can be used to pass context/state from the initiating
+ * function to the request callback (and may be NULL if not needed).
+ * If the request times out, or the IKEv2 SA is condemned, the callback will be
+ * invokved with the response packet parameter set to NULL (to allow for any
+ * cleanup -- include of 'arg' if necessary).
+ */
+boolean_t
+ikev2_send_req(pkt_t *restrict req, ikev2_send_cb_t cb, void *restrict arg)
+{
+	ikev2_sa_t *i2sa = req->pkt_sa;
+	i2sa_req_t *i2req = &i2sa->last_req;
+	config_t *cfg = config_get();
+	hrtime_t retry = cfg->cfg_retry_init;
+	int s = -1;
+
+	VERIFY(IS_WORKER);
+	VERIFY(!MUTEX_HELD(&i2sa->i2sa_queue_lock));
+	VERIFY(MUTEX_HELD(&i2sa->i2sa_lock));
+	VERIFY(!I2P_RESPONSE(req));
+	VERIFY3P(cb, !=, NULL);
+
+	CONFIG_REFRELE(cfg);
+
+	/*
+	 * Shouldn't try to start a new exchange when one is already in
+	 * progress.
+	 */
+	VERIFY3P(i2req->i2r_pkt, ==, NULL);
+
+	if (!ikev2_send_common(req, SSTOSA(&i2sa->laddr), SSTOSA(&i2sa->raddr),
+	    I2SA_IS_NAT(i2sa))) {
+		/*
+		 * XXX: For now at least, we don't bother with attempting to
+		 * retransmit a packet if the original transmission failed.
+		 *
+		 * We might want to instead still return 'success' and
+		 * let the retransmit timer attempt to send + only 'fail'
+		 * if it times out, or not return any status (i.e. change
+		 * return to 'void') and condemn the IKEv2 SA if we
+		 * can't arm the PKT_XMIT timer.
+		 */
+		ikev2_pkt_free(req);
+		return (B_FALSE);
+	}
+
+	i2req->i2r_pkt = req;
+	i2req->i2r_msgid = ntohl(pkt_header(req)->msgid);
+	i2req->i2r_cb = cb;
+	i2req->i2r_arg = arg;
+
+	if (!ikev2_sa_arm_timer(i2sa, retry, I2SA_EVT_PKT_XMIT, i2req)) {
+		STDERR(error, "Could not arm packet retransmit timer");
+		ikev2_pkt_free(req);
+		return (B_FALSE);
+	}
+
+	return (B_TRUE);
+}
+
+/* Send a response */
+boolean_t
+ikev2_send_resp(pkt_t *restrict resp)
+{
+	ikev2_sa_t *i2sa = resp->pkt_sa;
+	ike_header_t *hdr = pkt_header(resp);
+
+	VERIFY(IS_WORKER);
+	VERIFY(!MUTEX_HELD(&i2sa->i2sa_queue_lock));
+	VERIFY(MUTEX_HELD(&i2sa->i2sa_lock));
+	VERIFY(I2P_RESPONSE(resp));
+
+	if (!ikev2_send_common(resp, SSTOSA(&i2sa->laddr),
+	    SSTOSA(&i2sa->raddr), I2SA_IS_NAT(i2sa))) {
+		ikev2_pkt_free(resp);
+		return (B_FALSE);
+	}
+
+        /*
+	 * Normally, we save the last response packet we've sent in order to
+	 * re-send the last response in case the remote system retransmits
+	 * the last exchange it initiated.  However for IKE_SA_INIT exchanges,
+	 * _responses_ of the form HDR(A,0) are not saved for retransmission.
+	 * These responses should be either a request for cookies, a new DH
+	 * group, or a failed exchange (no proposal chosen), and we will
+	 * want to process the resulting reply (which, if it happens, should
+	 * be a restart of the IKE_SA_INIT exchange with the updated
+	 * parameters).  The msgid in these instances will also still be 0,
+	 * so we don't want to bump the expected next inbound msgid.
+	 *
+	 * We also want to wait to update i2sa->last_resp_sent and
+	 * i2sa->inmsgid until after we've successfully sent a reply to a
+	 * request.  If we bump it immediately upon receiving a new request,
+	 * if we fail to generate a reply for some reason, the peer
+	 * retransmitting the response will trigger an out of sequence message
+	 * and we'll never attempt to respond again, all of which would lead
+	 * to confusion.
+         */
+	if (hdr->exch_type != IKEV2_EXCH_IKE_SA_INIT ||
+	    hdr->responder_spi != 0) {
+		ikev2_pkt_free(i2sa->last_resp_sent);
+		i2sa->inmsgid++;
+		i2sa->last_resp_sent = resp;
+	}
+
+	return (B_TRUE);
+}
+
+/* Used for sending responses outside of an IKEv2 SA */
+boolean_t
+ikev2_send_resp_addr(pkt_t *restrict resp,
+    const struct sockaddr *restrict laddr,
+    const struct sockaddr *restrict raddr)
+{
+	ike_header_t *hdr = pkt_header(resp);
+	custr_t *desc = NULL;
+	ssize_t len = 0;
+	int s = -1;
+
+	VERIFY(IS_WORKER);
+	VERIFY(I2P_RESPONSE(resp));
+	VERIFY3P(resp->pkt_sa, ==, NULL);
+
+	return (ikev2_send_common(resp, laddr, raddr, B_FALSE));
+}
+
+/*
+ * Trigger a resend of our last request due to timeout waiting for a
+ * response.
+ */
+void
+ikev2_retransmit_cb(void *data)
+{
+	VERIFY(IS_WORKER);
+
+	i2sa_req_t *i2req = data;
+	ikev2_sa_t *i2sa = i2req->i2r_pkt->pkt_sa;
+
+	I2SA_REFHOLD(i2sa);
+
+	mutex_enter(&i2sa->i2sa_queue_lock);
+	i2req->i2r_fired = B_TRUE;
+	i2req->i2r_timer = 0;
+	mutex_exit(&i2sa->i2sa_queue_lock);
+
+	ikev2_sa_post_event(i2sa, I2SA_EVT_PKT_XMIT);
+
+	I2SA_REFRELE(i2sa);
+}
+
+/*
+ * Resend our last request.
+ */
+static void
+ikev2_retransmit(ikev2_sa_t *restrict sa, i2sa_req_t *restrict req)
+{
+	pkt_t *pkt = req->i2r_pkt;
+	hrtime_t retry = 0, retry_init = 0, retry_max = 0;
+	size_t limit = 0;
+
+	VERIFY(IS_WORKER);
+	VERIFY(!MUTEX_HELD(&sa->i2sa_queue_lock));
+	VERIFY(MUTEX_HELD(&sa->i2sa_lock));
+
+	req->i2r_fired = B_FALSE;
+
+	if (pkt == NULL) {
+		/* already acknowledged */
+		return;
+	}
+
+	config_t *cfg = config_get();
+	retry_init = cfg->cfg_retry_init;
+	retry_max = cfg->cfg_retry_max;
+	limit = cfg->cfg_retry_limit;
+	CONFIG_REFRELE(cfg);
+	cfg = NULL;
+
+	retry = retry_init * (1ULL << ++pkt->pkt_xmit);
+	if (retry > retry_max)
+		retry = retry_max;
+
+	if (pkt->pkt_xmit > limit) {
+		ikev2_send_cb_t cb = req->i2r_cb;
+
+		cb(sa, NULL, req->i2r_arg);
+
+		(void) bunyan_debug(log,
+		    "Transmit timeout on packet",
+		    BUNYAN_T_END);
+
+		sa->flags |= I2SA_CONDEMNED;
+		ikev2_sa_clear_req(sa, req);
+		return;
+	}
+
+	/*
+	 * If sendfromto() errors, it will log the error, however there's not
+	 * much that can be done if it fails, other than just wait to try
+	 * again, so we ignore the return value.
+	 */
+	(void) ikev2_send_common(pkt, SSTOSA(&sa->laddr), SSTOSA(&sa->raddr),
+	    I2SA_IS_NAT(sa));
+
+	if (!ikev2_sa_arm_timer(sa, retry, I2SA_EVT_PKT_XMIT, req)) {
+		(void) bunyan_error(log,
+		    "No memory to reschedule packet retransmit; "
+			    "deleting IKE SA", BUNYAN_T_END);
+		sa->flags |= I2SA_CONDEMNED;
+	}
+}
+
+/*
+ * Dispatches any queued messages and services any events that have fired.
+ * Function must be called with sa->i2sa_queue_lock held.  If another thread
+ * is already processing the queue for this IKE SA, the function will return
+ * without doing any processing.  In all instances, the function returns with
+ * sa->i2sa_queue_lock held.
+ */
+void
+ikev2_dispatch(ikev2_sa_t *sa)
+{
+	VERIFY(IS_WORKER);
+	int rc;
+
+	VERIFY(MUTEX_HELD(&sa->i2sa_queue_lock));
+
+	/*
+	 * The first thread that acquires i2sa_lock for this SA will pin
+	 * the SA to itself by setting i2sa_tid to it's tid (whole holding
+	 * i2sa_lock).  Outside of IKE SA creation and destruction, this
+	 * should be the only other path to acquiring i2sa_lock for this SA.
+	 * If we cannot immediately acquire i2sa_lock, it's either being
+	 * condemned (in which case we don't care about dispatching any
+	 * pending items), or another thread has already started processing
+	 * (in which case we let it do the processing).  In either instance,
+	 * we can just exit.
+	 */
+	switch ((rc = mutex_trylock(&sa->i2sa_lock))) {
+	case 0:
+		if (sa->i2sa_tid != 0 && sa->i2sa_tid != thr_self()) {
+			/*
+			 * It is possible we've acquired i2sa_lock between
+			 * iterations of the queue processing loop below
+			 * that is running on another thread.  If that happens,
+			 * just release the lock to allow the other thread to
+			 * proceed, and we return.
+			 */
+			mutex_exit(&sa->i2sa_lock);
+			return;
+		}
+
+		/*
+		 * However, if we have acquired the lock, and i2sa_tid has
+		 * already been set to us, we somehow failed to unpin this SA
+		 * in a previous call to ikev2_dispatch(), and indicates a
+		 * code error somewhere.
+		 */
+		VERIFY3U(sa->i2sa_tid, ==, 0);
+		break;
+	case EBUSY:
+		return;
+	default:
+		TSTDERR(rc, fatal, "Unexpected mutex_tryenter() failure");
+		abort();
+	}
+
+	/* Pin the IKE SA to us */
+	sa->i2sa_tid = thr_self();
+
+	/*
+	 * TODO: Cap how long we spend in the loop by either time or iterations
+	 * and defer processing for some amount of time if we spend too much
+	 * time dealing with one IKEv2 SA
+	 */
+	while (sa->i2sa_events != 0 || !I2SA_QUEUE_EMPTY(sa)) {
+		i2sa_msg_type_t type = I2SA_MSG_NONE;
+		void *data = NULL;
+
+		/* Grab any pending events and a queue item if available */
+
+		i2sa_evt_t events = sa->i2sa_events;
+		sa->i2sa_events = I2SA_EVT_NONE;
+
+		/*
+		 * All of these are oneshot periodics.  If they've fired,
+		 * clear the id while we hold both the queue lock and
+		 * the SA lock to indicate they're not armed while no other
+		 * thread can rearm them (since we hold i2sa_lock).
+		 */
+		if (events & I2SA_EVT_P1_EXPIRE)
+			sa->i2sa_p1_timer = 0;
+		if (events & I2SA_EVT_HARD_EXPIRE)
+			sa->i2sa_hardlife_timer = 0;
+		if (events & I2SA_EVT_SOFT_EXPIRE)
+			sa->i2sa_softlife_timer = 0;
+
+		if (!I2SA_QUEUE_EMPTY(sa)) {
+
+			/* Pick off a message and release the queue for now */
+			type = sa->i2sa_queue[sa->i2sa_queue_end].i2m_type;
+			data = sa->i2sa_queue[sa->i2sa_queue_end].i2m_data;
+
+			/*
+			 * If we see an empty message, the queue is corrupt.
+			 * Abort to get a snapshot of the process.
+			 */
+			VERIFY3S(type, !=, I2SA_MSG_NONE);
+
+			sa->i2sa_queue[sa->i2sa_queue_end].i2m_type =
+			    I2SA_MSG_NONE;
+			sa->i2sa_queue[sa->i2sa_queue_end].i2m_data = NULL;
+			sa->i2sa_queue_end++;
+			sa->i2sa_queue_end %= I2SA_QUEUE_DEPTH;
+		}
+
+		/*
+		 * Release the queue so other threads can queue messages for
+		 * this IKE SA.  Since we retain i2sa_lock while processing
+		 * the messages, we release i2sa_lock and reacquire the
+		 * queue lock and then i2sa_lock before starting another
+		 * iteration.  The i2sa_tid check prevents another thread
+		 * from doing anything beyond adding messages to the queue
+		 * while we're still running.
+		 */
+		mutex_exit(&sa->i2sa_queue_lock);
+
+		if (events & I2SA_EVT_P1_EXPIRE) {
+			events &= ~(I2SA_EVT_P1_EXPIRE);
+
+			sa->flags |= I2SA_CONDEMNED;
+		}
+		if (events & I2SA_EVT_HARD_EXPIRE) {
+			events &= ~(I2SA_EVT_HARD_EXPIRE);
+			/* TODO: ikev2_sa_hard_expire(sa); */
+		}
+		if (events & I2SA_EVT_SOFT_EXPIRE) {
+			events &= ~(I2SA_EVT_SOFT_EXPIRE);
+			/* TODO: ikev2_sa_soft_expire(sa); */
+		}
+		if (events & I2SA_EVT_PKT_XMIT) {
+			events &= ~(I2SA_EVT_PKT_XMIT);
+
+			/*
+			 * XXX: When WINDOW_SIZE is added, scan through all
+			 * i2sa_req_t's and call ikev2_retransmit for each
+			 * where i2r_fired == B_TRUE, and remove VERIFY
+			 */
+			VERIFY(sa->last_req.i2r_fired);
+			ikev2_retransmit(sa, &sa->last_req);
+		}
+
+		if (type != I2SA_MSG_NONE) {
+			(void) bunyan_debug(log,
+			    "Processing IKE SA message",
+			    BUNYAN_T_STRING, "msgtype", i2sa_msgtype_str(type),
+			    BUNYAN_T_POINTER, "msgdata", data,
+			    BUNYAN_T_END);
+		}
+
+		switch (type) {
+		case I2SA_MSG_NONE:
+			break;
+		case I2SA_MSG_PKT:
+			VERIFY3P(((pkt_t *)data)->pkt_sa, !=, NULL);
+			ikev2_dispatch_pkt(data);
+			break;
+		case I2SA_MSG_PFKEY:
+			ikev2_dispatch_pfkey(sa, data);
+			break;
+		}
+
+		mutex_exit(&sa->i2sa_lock);
+		mutex_enter(&sa->i2sa_queue_lock);
+		mutex_enter(&sa->i2sa_lock);
+	}
+
+	VERIFY(MUTEX_HELD(&sa->i2sa_lock));
+	VERIFY(MUTEX_HELD(&sa->i2sa_queue_lock));
+
+	/* Once all the outstanding requests are done, we can do it */
+	if ((sa->flags & I2SA_CONDEMNED) && !ikev2_sa_has_requests(sa)) {
+		ikev2_sa_condemn(sa);
+		return;
+	}
+
+	/* We're done for now, release IKEv2 SA for use with other threads */
+	sa->i2sa_tid = 0;
+	mutex_exit(&sa->i2sa_lock);
+
+	/*
+	 * We enter with i2sa->i2sa_queue_lock held, exit with it held
+	 */
+}
+
+/*
+ * Handle the instance where an inbound request is a retransmit by sending
+ * out last response.  Returns B_TRUE if packet was processed.
+ */
+static boolean_t
+ikev2_handle_retransmit(pkt_t *req)
+{
+	ikev2_sa_t *i2sa = req->pkt_sa;
+	pkt_t *resp = NULL;
+	uint32_t msgid = ntohl(pkt_header(req)->msgid);
+
+	VERIFY(!MUTEX_HELD(&i2sa->i2sa_queue_lock));
+	VERIFY(MUTEX_HELD(&i2sa->i2sa_lock));
+
+	if (I2P_RESPONSE(req))
+		return (B_FALSE);
+
+	if ((resp = ikev2_sa_get_response(i2sa, req)) == NULL)
+		return (B_FALSE);
+
+	(void) bunyan_debug(log, "Resending last response", BUNYAN_T_END);
+	ikev2_send_common(resp, SSTOSA(&i2sa->laddr), SSTOSA(&i2sa->raddr),
+	    I2SA_IS_NAT(i2sa));
+	ikev2_pkt_free(req);
+	return (B_TRUE);
+}
+
+/* Returns B_TRUE if resp was processed */
+static boolean_t
+ikev2_handle_response(pkt_t *resp)
+{
+	ikev2_sa_t *i2sa = resp->pkt_sa;
+	i2sa_req_t *i2req = &i2sa->last_req;
+	pkt_t *last = i2req->i2r_pkt;
+	ikev2_send_cb_t cb = i2req->i2r_cb;
+	void *arg = i2req->i2r_arg;
+	uint32_t msgid = ntohl(pkt_header(resp)->msgid);
+	ikev2_exch_t exch_type;
+
+	VERIFY(!MUTEX_HELD(&i2sa->i2sa_queue_lock));
+	VERIFY(MUTEX_HELD(&i2sa->i2sa_lock));
+
+	if (!I2P_RESPONSE(resp))
+		return (B_FALSE);
+
+	if (msgid != i2req->i2r_msgid) {
+		/*
+		 * Not a response to an outstanding request.
+		 *
+		 * XXX: Send INVALID_MESSAGE_ID notification in certain
+		 * circumstances.  For now, drop.
+		 */
+		goto discard;
+	}
+
+	exch_type = pkt_header(resp)->exch_type;
+
+	if (exch_type != IKEV2_EXCH_IKE_SA_INIT &&
+	    !ikev2_pkt_encryptdecrypt(resp, B_FALSE))
+		goto discard;
+
+	/*
+	 * RFC7296 is fairly clear that problems with response traffic should
+	 * not themselves generate additional traffic except in specific
+	 * circumstances.  Additionally section 2.5 specifically states that
+	 * the critical bit MUST NOT be set in responses.  Therefore we
+	 * just discard these packets without generating another exchange.
+	 */
+	if (!ikev2_pkt_check_payloads(resp) ||
+	    ikev2_pkt_check_critical(resp) != IKEV2_PAYLOAD_NONE)
+		goto discard;
+
+	/*
+	 * Since IKE_SA_INIT exchanges are unprotected, it's possible that
+	 * certain replies may be ignored, so we cannot dispose of our
+	 * request packet or cancel the retransmit timer here.  Instead
+	 * the callback function (it's always ikev2_sa_init_init_resp for
+	 * an IKE_SA_INIT exchange), must determine if it can do this.
+	 *
+	 * For everything else, we can get rid of the request.
+	 */
+	if (exch_type != IKEV2_EXCH_IKE_SA_INIT)
+		ikev2_sa_clear_req(i2sa, i2req);
+
+	cb(i2sa, resp, arg);
+	ikev2_pkt_free(resp);
+	return (B_TRUE);
+
+discard:
+	ikev2_pkt_free(resp);
+	return (B_TRUE);
+}
+
+static void
+ikev2_dispatch_pkt(pkt_t *pkt)
+{
+	ikev2_sa_t *i2sa = pkt->pkt_sa;
+	uint32_t msgid = ntohl(pkt_header(pkt)->msgid);
+	ikev2_exch_t exch_type = pkt_header(pkt)->exch_type;
+	uint8_t crit_pay = IKEV2_PAYLOAD_NONE;
+
+	VERIFY(!MUTEX_HELD(&i2sa->i2sa_queue_lock));
+	VERIFY(MUTEX_HELD(&i2sa->i2sa_lock));
+
+	if (exch_type != IKEV2_EXCH_IKE_SA_INIT &&
+	    !ikev2_pkt_signverify(pkt, B_FALSE))
+		goto discard;
+
+	if (!I2P_RESPONSE(pkt) && i2sa->inmsgid != msgid) {
+		(void) bunyan_info(log,
+		    "IKEv2 packet message ID out of sequence", BUNYAN_T_END);
+
+		/*
+		 * TODO: Send INVALID_MESSAGE_ID in a new informational
+		 * exchange if authentiated (RFC7296 2.3) w/ rate limiting.
+		 *
+		 * For now, discard.
+		 */
+		goto discard;
+	}
+
+	if (ikev2_handle_response(pkt))
+		return;
+
+	/*
+	 * Once we are condemned, we only want to process replies to our
+	 * outstanding requests.
+	 */
+	if (i2sa->flags & I2SA_CONDEMNED) {
+		ikev2_pkt_free(pkt);
+		return;
+	}
+
+	if (ikev2_handle_retransmit(pkt))
+		return;
+
+	/* Decyption will also index the encrypted payloads */
+	if (exch_type != IKEV2_EXCH_IKE_SA_INIT &&
+	    !ikev2_pkt_encryptdecrypt(pkt, B_FALSE))
+		goto discard;
+
+	if (!ikev2_pkt_check_payloads(pkt)) {
+		if (exch_type == IKEV2_EXCH_IKE_SA_INIT)
+			goto discard;
+
+		/* TODO: send INVALID_SYNTAX notification */
+		goto discard;
+	}
+
+	crit_pay = ikev2_pkt_check_critical(pkt);
+	if (crit_pay != IKEV2_PAYLOAD_NONE) {
+		pkt_t *resp = NULL;
+
+		/*
+		 * Since IKE_SA_INIT exchanges are unprotected, we ignore any
+		 * errors, and let the P1 timer expire if we never receive
+		 * a valid request.
+		 */
+		if (exch_type == IKEV2_EXCH_IKE_SA_INIT)
+			goto discard;
+
+		/* Any other exchange is protected, so respond with an error */
+		if ((resp = ikev2_pkt_new_response(pkt)) == NULL)
+			goto discard;
+
+		/* This is the 2nd payload, it should fit */
+		VERIFY(ikev2_add_notify_full(resp, IKEV2_PROTO_NONE, 0,
+		    IKEV2_N_UNSUPPORTED_CRITICAL_PAYLOAD,
+		    &crit_pay, sizeof (crit_pay)));
+
+		(void) ikev2_send_resp(resp);
+		goto discard;
+	}
+
+	switch (pkt_header(pkt)->exch_type) {
+	case IKEV2_EXCH_IKE_SA_INIT:
+		ikev2_sa_init_resp(pkt);
+		break;
+	case IKEV2_EXCH_IKE_AUTH:
+		ikev2_ike_auth_resp(pkt);
+		break;
+	case IKEV2_EXCH_CREATE_CHILD_SA:
+		ikev2_create_child_sa_resp(pkt);
+		break;
+	case IKEV2_EXCH_INFORMATIONAL:
+		ikev2_informational(pkt);
+		break;
+	}
+
+discard:
+	ikev2_pkt_free(pkt);
+}
+
+static void
+ikev2_dispatch_pfkey(ikev2_sa_t *restrict sa, parsedmsg_t *restrict pmsg)
+{
+	sadb_msg_t *samsg = pmsg->pmsg_samsg;
+
+	VERIFY(!MUTEX_HELD(&sa->i2sa_queue_lock));
+	VERIFY(MUTEX_HELD(&sa->i2sa_lock));
+
+	/* Is there a request already in progress? */
+	if (sa->last_req.i2r_pkt != NULL) {
+		(void) bunyan_debug(log, "Discarding sadb message",
+		    BUNYAN_T_END);
+
+		parsedmsg_free(pmsg);
+		return;
+	}
+
+	switch (samsg->sadb_msg_type) {
+	case SADB_ACQUIRE:
+		/*
+		 * If we've already authenticated, we need to do a
+		 * CREATE_CHILD_SA exchange, otherwise we need to start
+		 * an IKE_SA_INIT exchange.  If we've already started an
+		 * IKE_SA_INIT exchange, that request will be in progress,
+		 * and the sadb message will be discarded before getting here
+		 * with the above checks.
+		 */
+		if (sa->flags & I2SA_AUTHENTICATED)
+			ikev2_create_child_sa_init(sa, pmsg);
+		else
+			ikev2_sa_init_init(sa, pmsg);
+		return;
+	case SADB_EXPIRE: {
+		const char *exptype = NULL;
+		char msg[128] = { 0 };
+
+		if (pmsg->pmsg_exts[SADB_EXT_LIFETIME_HARD] != NULL) {
+			exptype = "HARD";
+		} else if (pmsg->pmsg_exts[SADB_EXT_LIFETIME_SOFT] != NULL) {
+			exptype = "SOFT";
+		} else if (pmsg->pmsg_exts[SADB_X_EXT_LIFETIME_IDLE] != NULL) {
+			exptype = "IDLE";
+		} else {
+			(void) bunyan_error(log, "Unknown SADB_EXPIRE message",
+			    BUNYAN_T_END);
+			parsedmsg_free(pmsg);
+			return;
+		}
+
+		if (pmsg->pmsg_exts[SADB_EXT_LIFETIME_HARD] != NULL) {
+			ikev2_hard_expire(sa, pmsg);
+			return;
+		}
+
+		/* TODO: Soft expire (rekey), idle (?) */
+		(void) snprintf(msg, sizeof (msg),
+		    "%s SADB_EXPIRE support not implemented yet; discarding",
+		    exptype);
+
+		sadb_log(BUNYAN_L_INFO, msg, samsg);
+		parsedmsg_free(pmsg);
+		return;
+	}
+	default:
+		sadb_log(BUNYAN_L_ERROR,
+		    "Unexpected SADB request from kernel", samsg);
+		parsedmsg_free(pmsg);
+	}
+}
+
+/*
+ * XXX:The handling of INFORMATIONAL exchanges is still in it's infancy, so this
+ * is just an initial stab at it, and it's form may change as support for
+ * more features are added.
+ */
+
+/* Since n is reachable from req, we can't mark them as restricted */
+static boolean_t
+ikev2_handle_notification(pkt_notify_t *n, pkt_t *req, pkt_t *restrict resp)
+{
+	switch (n->pn_type) {
+	case IKEV2_N_AUTHENTICATION_FAILED:
+		/*
+		 * XXX: We may want to track the last inbound IKE_AUTH msgid
+		 * (normally would be 1, but could be higher if EAP is used)
+		 * and only act on this if the inbound msgid is
+		 * last_auth_msgid + 1 (i.e. the next exchange after the
+		 * IKE_AUTH exchange).
+		 */
+		return (ikev2_auth_failed_resp(req, resp));
+	break;
+	/* XXX: Any other notifications? */
+	}
+
+	return (B_TRUE);
+}
+
+static void
+ikev2_informational(pkt_t *req)
+{
+	pkt_t *resp = ikev2_pkt_new_response(req);
+	pkt_payload_t *pay = NULL;
+	pkt_notify_t *n = NULL;
+	size_t payidx = 0, nidx = 0;
+
+	if (resp == NULL) {
+		(void) bunyan_error(log,
+		    "No memory to respond to an INFORMATIONL request",
+		    BUNYAN_T_END);
+		return;
+	}
+
+	for (payidx = 0; payidx < req->pkt_payload_count; payidx++) {
+		n = NULL;
+		pay = pkt_payload(req, payidx);
+
+		if (pay->pp_type == IKEV2_PAYLOAD_NOTIFY) {
+			VERIFY3U(nidx, <=, req->pkt_notify_count);
+			n = pkt_notify(req, nidx++);
+			if (!ikev2_handle_notification(n, req, resp))
+				goto fail;
+			continue;
+		}
+
+		if (pay->pp_type == IKEV2_PAYLOAD_DELETE)
+			ikev2_handle_delete(req->pkt_sa, pay, resp);
+
+		/* TODO: Handle other payloads */
+	}
+
+	ikev2_send_resp(resp);
+	return;
+
+fail:
+	ikev2_pkt_free(resp);
+}
+
+/* Picks the socket to use for sending based on our local address. */
+static int
+select_socket(const struct sockaddr *laddr, boolean_t nat_is_known)
+{
+	if (laddr->sa_family == AF_INET6)
+		return (ikesock6);
+
+	/*
+	 * If our local port is IPPORT_IKE_NATT (4500), we always use the
+	 * NATT (NAT-traversal) socket.  If our IKEv2 SA determines either end
+	 * is behind a NAT, we also use the NATT socket for any subsequent
+	 * transmissions.
+	 */
+	if (nat_is_known || ss_port(laddr) == IPPORT_IKE_NATT)
+		return (nattsock);
+
+	return (ikesock4);
+}
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_proto.h b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_proto.h
new file mode 100644
index 0000000000..bbf3d6a0c2
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_proto.h
@@ -0,0 +1,79 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+#ifndef _IKEV2_PROTO_H
+#define	_IKEV2_PROTO_H
+
+#include <inttypes.h>
+#include "ikev2.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+struct pkt_s;
+struct pkt_payload;
+struct ikev2_sa_s;
+struct sockaddr_storage;
+struct config_rule_s;
+struct parsedmsg_s;
+
+void ikev2_inbound(struct pkt_s *restrict, const struct sockaddr *restrict,
+    const struct sockaddr *restrict);
+void ikev2_pfkey(struct parsedmsg_s *);
+void ikev2_sa_init_cfg(struct config_rule_s *);
+
+typedef void (*ikev2_send_cb_t)(struct ikev2_sa_s *restrict,
+    struct pkt_s *restrict, void *restrict);
+boolean_t ikev2_send_req(struct pkt_s *restrict, ikev2_send_cb_t,
+    void *restrict);
+boolean_t ikev2_send_resp(struct pkt_s *restrict);
+boolean_t ikev2_send_resp_addr(struct pkt_s *restrict,
+    const struct sockaddr *restrict,
+    const struct sockaddr *restrict);
+
+void ikev2_dispatch(struct ikev2_sa_s *);
+void ikev2_retransmit_cb(void *);
+
+void ikev2_sa_init_init(struct ikev2_sa_s *restrict,
+    struct parsedmsg_s *restrict);
+void ikev2_sa_init_resp(struct pkt_s *);
+
+void ikev2_ike_auth_init(struct ikev2_sa_s *restrict);
+void ikev2_ike_auth_resp(struct pkt_s *);
+boolean_t ikev2_auth_failed_resp(struct pkt_s *restrict, struct pkt_s *restrict);
+
+boolean_t ikev2_create_child_sa_init_auth(struct ikev2_sa_s *restrict,
+    struct pkt_s *restrict);
+boolean_t ikev2_create_child_sa_resp_auth(struct pkt_s *restrict,
+    struct pkt_s *restrict);
+void ikev2_create_child_sa_init_resp_auth(struct ikev2_sa_s *restrict,
+    struct pkt_s *restrict, void *restrict);
+
+void ikev2_create_child_sa_init(struct ikev2_sa_s *restrict,
+    struct parsedmsg_s *restrict);
+void ikev2_create_child_sa_resp(struct pkt_s *restrict);
+
+void ikev2_hard_expire(struct ikev2_sa_s *restrict,
+    struct parsedmsg_s *restrict);
+void ikev2_handle_delete(struct ikev2_sa_s *restrict,
+    struct pkt_payload *restrict, struct pkt_s *restrict);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _IKEV2_PROTO_H */
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_sa.c b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_sa.c
new file mode 100644
index 0000000000..ca66084f4a
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_sa.c
@@ -0,0 +1,1381 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the "License").
+ * You may not use this file except in compliance with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ */
+
+/*
+ * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ *
+ * Copyright 2017 Jason King.
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+/*
+ * Manipulation and storage of IKEv2 Security Associations (SAs).
+ */
+#include <umem.h>
+#include <errno.h>
+#include <ipsec_util.h>
+#include <libperiodic.h>
+#include <limits.h>
+#include <locale.h>
+#include <note.h>
+#include <stdarg.h>
+#include <stddef.h>
+#include <strings.h>
+#include <sys/debug.h>
+#include <sys/list.h>
+#include <sys/random.h>
+#include <sys/sysmacros.h>
+#include <sys/types.h>
+#include <umem.h>
+#include "config.h"
+#include "defs.h"
+#include "ike.h"
+#include "ikev2_common.h"
+#include "ikev2_cookie.h"
+#include "ikev2_pkt.h"
+#include "ikev2_proto.h"
+#include "ikev2_sa.h"
+#include "pfkey.h"
+#include "pkcs11.h"
+#include "pkt.h"
+#include "worker.h"
+
+/*
+ * An arbitrary prime number pulled from the ether
+ */
+#define	I2SA_NBUCKETS	73
+
+static volatile uint_t	half_open;	/* # of larval/half open IKEv2 SAs */
+static uint64_t		remote_noise;	/* random noise for rspi hash */
+static uint64_t		addr_noise;	/* random noise for the addr hash */
+
+			/* protects all 3 hashes */
+static rwlock_t		i2sa_hash_lock = DEFAULTRWLOCK;
+static refhash_t	*i2sa_lspi_refhash;
+static refhash_t	*i2sa_rspi_refhash;
+static refhash_t	*i2sa_addr_refhash;
+
+static umem_cache_t	*i2sa_cache;
+static umem_cache_t	*i2c_cache;
+
+static uint64_t	i2sa_lspi_hash(const void *);
+static uint64_t i2sa_rspi_hash(const void *);
+static uint64_t i2sa_addr_hash(const void *);
+
+static int i2sa_lspi_cmp(const void *, const void *);
+static int i2sa_rspi_cmp(const void *, const void *);
+static int i2sa_addr_cmp(const void *, const void *);
+
+static void i2sa_unlink(ikev2_sa_t *);
+static void i2sa_p1_expire(void *);
+
+static boolean_t i2sa_key_add_addr(ikev2_sa_t *, const char *, const char *,
+    const struct sockaddr_storage *);
+static int i2sa_ctor(void *, void *, int);
+static void i2sa_dtor(void *, void *);
+
+static void inc_half_open(void);
+static void dec_half_open(void);
+
+ikev2_sa_t *
+ikev2_sa_getbylspi(uint64_t spi, boolean_t initiator)
+{
+	ikev2_sa_t *i2sa = NULL;
+	ikev2_sa_t cmp_sa = {
+		.flags = initiator ? I2SA_INITIATOR : 0,
+		.i_spi = initiator ? spi : 0,
+		.r_spi = initiator ? 0 : spi
+	};
+
+	VERIFY0(rw_rdlock(&i2sa_hash_lock));
+	if ((i2sa = refhash_lookup(i2sa_lspi_refhash, &cmp_sa)) != NULL)
+		I2SA_REFHOLD(i2sa);
+	VERIFY0(rw_unlock(&i2sa_hash_lock));
+
+	if (i2sa != NULL) {
+		(void) bunyan_key_add(log,
+		    BUNYAN_T_POINTER, LOG_KEY_I2SA, i2sa,
+		    BUNYAN_T_END);
+	}
+
+	return (i2sa);
+}
+
+ikev2_sa_t *
+ikev2_sa_getbyrspi(uint64_t spi,
+    const struct sockaddr *restrict laddr,
+    const struct sockaddr *restrict raddr,
+    pkt_t *restrict init_pkt)
+{
+	ikev2_sa_t *i2sa = NULL;
+	pkt_payload_t *nonce = NULL;
+	ikev2_sa_args_t cmp_sa_args = { 0 };
+	ikev2_sa_t cmp_sa = {
+		.i_spi = spi,
+		.sa_init_args = &cmp_sa_args,
+	};
+
+	nonce = pkt_get_payload(init_pkt, IKEV2_PAYLOAD_NONCE, NULL);
+	if (nonce == NULL)
+		return (NULL);
+
+	/* Inbound packet checks should prevent this */
+	VERIFY3U(nonce->pp_len, <=, sizeof (cmp_sa_args.i2a_nonce_i));
+	bcopy(nonce->pp_ptr, cmp_sa_args.i2a_nonce_i, nonce->pp_len);
+	cmp_sa_args.i2a_nonce_i_len = nonce->pp_len;
+
+	sockaddr_copy(laddr, &cmp_sa.laddr, B_FALSE);
+	sockaddr_copy(raddr, &cmp_sa.raddr, B_FALSE);
+
+	VERIFY0(rw_rdlock(&i2sa_hash_lock));
+	if ((i2sa = refhash_lookup(i2sa_rspi_refhash, &cmp_sa)) != NULL)
+		I2SA_REFHOLD(i2sa);
+	VERIFY0(rw_unlock(&i2sa_hash_lock));
+
+	if (i2sa != NULL) {
+		(void) bunyan_key_add(log,
+		    BUNYAN_T_POINTER, LOG_KEY_I2SA, i2sa,
+		    BUNYAN_T_END);
+	}
+
+	return (i2sa);
+}
+
+ikev2_sa_t *
+ikev2_sa_getbyaddr(const struct sockaddr *restrict src,
+   const struct sockaddr *restrict dst)
+{
+	ikev2_sa_t *i2sa = NULL;
+	ikev2_sa_t cmp_sa = { 0 };
+
+	sockaddr_copy(src, &cmp_sa.laddr, B_FALSE);
+	sockaddr_copy(dst, &cmp_sa.raddr, B_FALSE);
+
+	VERIFY0(rw_rdlock(&i2sa_hash_lock));
+	if ((i2sa = refhash_lookup(i2sa_addr_refhash, &cmp_sa)) != NULL)
+		I2SA_REFHOLD(i2sa);
+	VERIFY0(rw_unlock(&i2sa_hash_lock));
+
+	if (i2sa != NULL) {
+		(void) bunyan_key_add(log,
+		    BUNYAN_T_POINTER, LOG_KEY_I2SA, i2sa,
+		    BUNYAN_T_END);
+	}
+
+	return (i2sa);
+}
+
+/*
+ * Allocate a larval IKEv2 SA.
+ *
+ * Obtains a unique local SPI and assigns it to the SA and adds the SA to
+ * the local SPI hash.  If the packet used to trigger the creation of the SA
+ * is given, take over management of it.  Also create an SA expiration timer.
+ *
+ * If we initiated the SA creation, the remote SPI will not be known initially.
+ * Once the protocol has proceeded enough to determine the remote SPI,
+ * ikev2_sa_set_rspi() should be called.
+ *
+ * Parameters:
+ *	init_pkt	The packet that trigged the creation of the SA or NULL
+ *			if we initiated.
+ *	laddr,
+ *	raddr		The local and remote addresses of this SA.
+ *
+ * On successful create, the refheld larval IKEv2 SA is returned.  In addition,
+ * the IKEv2 SA queue is locked on return.
+ *
+ * On failure, NULL is returned.  Caller maintains responsibility for
+ * init_pkt in this instance.
+ */
+ikev2_sa_t *
+ikev2_sa_alloc(pkt_t *restrict init_pkt,
+    const struct sockaddr *restrict laddr,
+    const struct sockaddr *restrict raddr)
+{
+	ikev2_sa_t	*i2sa = NULL;
+	config_t	*cfg = NULL;
+	hrtime_t	expire = 0;
+	boolean_t	initiator = (init_pkt == NULL) ? B_TRUE : B_FALSE;
+
+	(void) bunyan_trace(log, "Attempting to create new larval IKE SA",
+	    BUNYAN_T_BOOLEAN, LOG_KEY_INITIATOR, initiator,
+	    ss_bunyan(laddr), LOG_KEY_LADDR, ss_addr(laddr),
+	    ss_bunyan(raddr), LOG_KEY_RADDR, ss_addr(raddr),
+	    BUNYAN_T_END);
+
+	cfg = config_get();
+	expire = cfg->cfg_expire_timer;
+	CONFIG_REFRELE(cfg);
+
+	if ((i2sa = umem_cache_alloc(i2sa_cache, UMEM_DEFAULT)) == NULL) {
+		STDERR(error, "No memory to create IKEv2 SA");
+		return (NULL);
+	}
+
+	if ((i2sa->sa_init_args = ikev2_sa_args_new(B_TRUE)) == NULL) {
+		STDERR(error, "No memory to create IKEv2 SA");
+		umem_cache_free(i2sa_cache, i2sa);
+		return (NULL);
+	}
+	i2sa->sa_init_args->i2a_i2sa = i2sa;
+
+	/* Keep anyone else out while we initialize */
+	mutex_enter(&i2sa->i2sa_queue_lock);
+	mutex_enter(&i2sa->i2sa_lock);
+
+	i2sa->i2sa_tid = thr_self();
+
+	i2sa->flags |= initiator ? I2SA_INITIATOR : 0;
+
+	sockaddr_copy(laddr, &i2sa->laddr, B_TRUE);
+	sockaddr_copy(raddr, &i2sa->raddr, B_TRUE);
+
+	/*
+	 * Use the port given to us if specified, otherwise use the default.
+	 * Take advantage of port being at the same offset for IPv4/v6
+	 */
+	VERIFY(laddr->sa_family == AF_INET || laddr->sa_family == AF_INET6);
+	if (ss_port(laddr) == 0) {
+		((struct sockaddr_in *)&i2sa->laddr)->sin_port =
+		    htons(IPPORT_IKE);
+	}
+	if (ss_port(raddr) == 0) {
+		((struct sockaddr_in *)&i2sa->raddr)->sin_port =
+		    htons(IPPORT_IKE);
+	}
+
+	/*
+	 * Generate a random local SPI and try to add it.  Almost always this
+	 * will succeed on the first attempt.  However if on the rare occasion
+	 * we generate a duplicate (or even far, far, rarer chance 0 is
+	 * returned), just retry until we pick a value that's not in use.
+	 */
+	NOTE(CONSTCOND)
+	while (1) {
+		uint64_t spi = 0;
+
+		arc4random_buf(&spi, sizeof (spi));
+
+		/*
+		 * Incredibly unlikely we'll ever randomly generate 0, but
+		 * if we do, just try again.
+		 */
+		if (spi == 0)
+			continue;
+
+		if (initiator)
+			i2sa->i_spi = spi;
+		else
+			i2sa->r_spi = spi;
+
+		VERIFY0(rw_wrlock(&i2sa_hash_lock));
+		if (refhash_lookup(i2sa_lspi_refhash, i2sa) != NULL) {
+			VERIFY0(rw_unlock(&i2sa_hash_lock));
+			continue;
+		}
+
+		refhash_insert(i2sa_lspi_refhash, i2sa);
+		I2SA_REFHOLD(i2sa);
+
+		refhash_insert(i2sa_addr_refhash, i2sa);
+		I2SA_REFHOLD(i2sa);
+
+		/* refhold for caller */
+		I2SA_REFHOLD(i2sa);
+
+		VERIFY3U(i2sa->refcnt, ==, 3);
+
+		VERIFY0(rw_unlock(&i2sa_hash_lock));
+		break;
+	};
+
+	key_add_ike_spi(LOG_KEY_LSPI, I2SA_LOCAL_SPI(i2sa));
+	(void) bunyan_trace(log, "Allocated local SPI", BUNYAN_T_END);
+
+	/*
+	 * If we're the initiator, we don't know the remote SPI until after
+	 * the remote peer responds.  However if we are the responder,
+	 * we know what it is and can set it now.  We also want to bump the
+	 * half open count to enable cookies if too many half-open inbound
+	 * connections are out there.
+	 */
+	if (!initiator) {
+		inc_half_open();
+		ikev2_sa_set_remote_spi(i2sa,
+		    pkt_header(init_pkt)->initiator_spi);
+	}
+
+	mutex_exit(&i2sa->i2sa_queue_lock);
+
+	if (!ikev2_sa_arm_timer(i2sa, expire, I2SA_EVT_P1_EXPIRE)) {
+		STDERR(error, "Cannot create IKEv2 SA P1 expiration timer");
+
+		/* Gets rid of the refhash holds */
+		i2sa_unlink(i2sa);
+		i2sa->i2sa_tid = 0;
+		mutex_exit(&i2sa->i2sa_lock);
+
+		/* Get rid of the caller hold (will also free it) */
+		I2SA_REFRELE(i2sa);
+
+		(void) bunyan_debug(log, "Larval IKE SA creation failed",
+		    BUNYAN_T_END);
+		return (NULL);
+	}
+
+	mutex_exit(&i2sa->i2sa_lock);
+
+	mutex_enter(&i2sa->i2sa_queue_lock);
+	mutex_enter(&i2sa->i2sa_lock);
+	i2sa->i2sa_tid = 0;
+	mutex_exit(&i2sa->i2sa_lock);
+
+	/*
+	 * Leave i2sa_queue_lock held so caller has exclusive access to SA
+	 * upon return.
+	 */
+	(void) bunyan_debug(log, "New larval IKE SA created",
+	    BUNYAN_T_POINTER, LOG_KEY_I2SA, i2sa,
+	    BUNYAN_T_END);
+
+	return (i2sa);
+}
+
+/*
+ * Invoked when an SA has expired.  REF from timer is passed to this
+ * function.
+ */
+static void
+i2sa_p1_expire(void *data)
+{
+	ikev2_sa_t *i2sa = data;
+	int rc;
+
+	I2SA_REFHOLD(i2sa);
+
+	key_add_ike_spi(LOG_KEY_LSPI, I2SA_LOCAL_SPI(i2sa));
+	key_add_ike_spi(LOG_KEY_RSPI, I2SA_REMOTE_SPI(i2sa));
+
+	(void) bunyan_info(log, "Larval IKE SA (P1) timeout",
+	    BUNYAN_T_POINTER, LOG_KEY_I2SA, i2sa,
+	    BUNYAN_T_END);
+	ikev2_sa_post_event(i2sa, I2SA_EVT_P1_EXPIRE);
+
+	(void) bunyan_key_remove(log, LOG_KEY_LSPI);
+	(void) bunyan_key_remove(log, LOG_KEY_RSPI);
+
+	I2SA_REFRELE(i2sa);
+}
+
+void
+ikev2_sa_flush(void)
+{
+	/* TODO: implement me */
+}
+
+/*
+ * Arm an IKEv2 SA timer to fire the given event reltime nanoseconds from now.
+ * This is intended to be called during normal IKEv2 SA processing (hence
+ * the VERIFY checks) with only the i2sa_lock held.  Returns B_TRUE if
+ * timer was successfully armed.
+ */
+boolean_t
+ikev2_sa_arm_timer(ikev2_sa_t *i2sa, hrtime_t reltime, i2sa_evt_t event, ...)
+{
+	VERIFY(!MUTEX_HELD(&i2sa->i2sa_queue_lock));
+	VERIFY(MUTEX_HELD(&i2sa->i2sa_lock));
+	VERIFY3U(i2sa->i2sa_tid, ==, thr_self());
+
+	periodic_id_t *idp = NULL;
+	periodic_func_t *cb = NULL;
+	void *arg = i2sa;
+	va_list ap;
+
+	va_start(ap, event);
+
+	switch (event) {
+	case I2SA_EVT_NONE:
+		INVALID(event);
+		/*NOTREACHED*/
+		break;
+	case I2SA_EVT_PKT_XMIT: {
+		i2sa_req_t *i2r = va_arg(ap, i2sa_req_t *);
+
+		idp = &i2r->i2r_timer;
+		cb = ikev2_retransmit_cb;
+		arg = i2r;
+		break;
+	}
+	case I2SA_EVT_P1_EXPIRE:
+		idp = &i2sa->i2sa_p1_timer;
+		cb = i2sa_p1_expire;
+		break;
+	case I2SA_EVT_SOFT_EXPIRE:
+		idp = &i2sa->i2sa_softlife_timer;
+		INVALID("not yet");
+		break;
+	case I2SA_EVT_HARD_EXPIRE:
+		idp = &i2sa->i2sa_hardlife_timer;
+		INVALID("not yet");
+		break;
+	}
+
+	va_end(ap);
+
+	mutex_exit(&i2sa->i2sa_lock);
+	mutex_enter(&i2sa->i2sa_queue_lock);
+	mutex_enter(&i2sa->i2sa_lock);
+
+	int rc = periodic_schedule(wk_periodic, reltime, PERIODIC_ONESHOT,
+	    cb, arg, idp);
+	if (rc != 0)
+		VERIFY3S(errno, ==, ENOMEM);
+
+	mutex_exit(&i2sa->i2sa_queue_lock);
+	return ((rc == 0) ? B_TRUE : B_FALSE);
+}
+
+/*
+ * Disarm the given timer.  If the particular timer happened to fire prior to
+ * us disarming it (but before it's been processed), the event will also
+ * be cleared.
+ */
+void
+ikev2_sa_disarm_timer(ikev2_sa_t *i2sa, i2sa_evt_t event, ...)
+{
+	VERIFY(!MUTEX_HELD(&i2sa->i2sa_queue_lock));
+	VERIFY(MUTEX_HELD(&i2sa->i2sa_lock));
+	VERIFY3U(i2sa->i2sa_tid, ==, thr_self());
+
+	periodic_id_t *idp = NULL;
+	i2sa_req_t *i2r = NULL;
+	periodic_id_t id = 0;
+	i2sa_evt_t pkt_events = 0;
+	int rc = 0;
+	va_list ap;
+
+	va_start(ap, event);
+
+	switch (event) {
+	case I2SA_EVT_NONE:
+		INVALID(event);
+		/*NOTREACHED*/
+		break;
+	case I2SA_EVT_PKT_XMIT:
+		i2r = va_arg(ap, i2sa_req_t *);
+		idp = &i2r->i2r_timer;
+		break;
+	case I2SA_EVT_P1_EXPIRE:
+		idp = &i2sa->i2sa_p1_timer;
+		break;
+	case I2SA_EVT_SOFT_EXPIRE:
+		idp = &i2sa->i2sa_softlife_timer;
+		break;
+	case I2SA_EVT_HARD_EXPIRE:
+		idp = &i2sa->i2sa_hardlife_timer;
+		break;
+	}
+
+	va_end(ap);
+
+	/*
+	 * If the timer callback is executing on another thread while
+	 * periodic_cancel() is called, the periodic_cancel() call will block
+	 * until the callback completes.  Since every callback function needs
+	 * to acquire i2sa_queue_lock to post the event, we must call
+	 * periodic_cancel() without holding i2sa_queue_lock.
+	 *
+	 * Unfortunately, if the timer fires and is serviced on another thread
+	 * between the time we grab the id then drop the queue lock and then
+	 * attempt to cancel it, there is a very small and unavoidable chance
+	 * the id value we saved could be recycled causing us to  cancel the
+	 * wrong event.
+	 *
+	 * As the the libperiodic id space can contain up to 2^32 - 1 ids,
+	 * and each IKEv2 SA consumes fewer than 10 ids, it seems highly
+	 * unlikely this can ever happen in practice.  The only potential
+	 * solution would be to increate the side of the id space.
+	 */
+	mutex_exit(&i2sa->i2sa_lock);
+
+	mutex_enter(&i2sa->i2sa_queue_lock);
+	id = *idp;
+	mutex_exit(&i2sa->i2sa_queue_lock);
+
+	if (id != 0 && (rc = periodic_cancel(wk_periodic, id)) != 0)
+		VERIFY3S(errno, ==, ENOENT);
+
+	mutex_enter(&i2sa->i2sa_queue_lock);
+
+	/*
+	 * If the timer happened to fire while we were trying to clear it,
+	 * clear the indicator.
+	 */
+	if (i2r != NULL) {
+		i2r->i2r_fired = B_FALSE;
+
+		/*
+		 * XXX: Once WINDOW_SIZE support is finished, an IKEv2 SA will
+		 * have multiple i2sa_req_t's, so we will need something
+		 * along the lines of:
+		 *
+		 * foreach (i2sa_evt_t evt in i2sa)
+		 *	pkt_events |= evt->i2r_fired;
+		 *
+		 * here (after clearing the i2r_fired for the request whose
+		 * timer we are cancelling).  This will allow
+		 * i2sa->i2sa_events & I2SA_EVT_PKT_XMIT to indicate that
+		 * we need to check the i2r_fired of each in-progress
+		 * outbound request to see which one needs to be
+		 * retransmitted (we are unlikely to ever need to support
+		 * very large window sizes with the IKEv2 protocol as it
+		 * currently stands, so this shouldn't present any scaling
+		 * issues).
+		 */
+	}
+
+	i2sa->i2sa_events &= (~event | pkt_events);
+	*idp = 0;
+
+	mutex_enter(&i2sa->i2sa_lock);
+	mutex_exit(&i2sa->i2sa_queue_lock);
+}
+
+/*
+ * Post that an event has fired.  Should be called by a callback handler
+ * without any IKE SA locks held.  It will attempt to dispatch the event after
+ * posting it (which may fail and the event merely queued if the IKEv2 SA has
+ * already been pinned to a thread).
+ */
+void
+ikev2_sa_post_event(ikev2_sa_t *i2sa, i2sa_evt_t event)
+{
+	VERIFY(!MUTEX_HELD(&i2sa->i2sa_lock));
+
+	mutex_enter(&i2sa->i2sa_queue_lock);
+
+	i2sa->i2sa_events |= event;
+	switch (event) {
+	case I2SA_EVT_NONE:
+		INVALID(event);
+		/*NOTREACHED*/
+		break;
+	case I2SA_EVT_PKT_XMIT:
+		break;
+	case I2SA_EVT_P1_EXPIRE:
+		i2sa->i2sa_p1_timer = 0;
+		break;
+	case I2SA_EVT_SOFT_EXPIRE:
+		i2sa->i2sa_softlife_timer = 0;
+		break;
+	case I2SA_EVT_HARD_EXPIRE:
+		i2sa->i2sa_hardlife_timer = 0;
+		break;
+	}
+
+	ikev2_dispatch(i2sa);
+	mutex_exit(&i2sa->i2sa_queue_lock);
+}
+
+/*
+ * Get the existing response for this packet if we have it, otherwise
+ * return NULL
+ */
+pkt_t *
+ikev2_sa_get_response(ikev2_sa_t *restrict i2sa, const pkt_t *req)
+{
+	VERIFY(MUTEX_HELD(&i2sa->i2sa_lock));
+	VERIFY(!I2P_RESPONSE(req));
+
+	/*
+	 * While msgid's are stored in network byte order, since we're just
+	 * checking equality, we don't need to bother to convert them to local
+	 * byte order.
+	 */
+	uint32_t req_id = pkt_header(req)->msgid;
+
+	if (i2sa->last_resp_sent == NULL)
+		return (NULL);
+
+	if (pkt_header(i2sa->last_resp_sent)->msgid == req_id)
+		return (i2sa->last_resp_sent);
+
+	return (NULL);
+}
+
+/*
+ * Returns B_TRUE if any requests are currently in progress (i.e. waiting
+ * for a response).
+ *
+ * XXX: Currently there is at most 1 possible request in progress, but that
+ * will change when SET_WINDOW_SIZE support is added.
+ */
+boolean_t
+ikev2_sa_has_requests(const ikev2_sa_t *i2sa)
+{
+	VERIFY(MUTEX_HELD((mutex_t *)&i2sa->i2sa_lock));
+
+	return (I2REQ_ACTIVE(&i2sa->last_req));
+}
+
+/*
+ * To condemn an IKEv2 SA, the I2SA_CONDEMNED flag is set on the IKEv2 SA.
+ * Once set, its is never unset for the remainder of the lifetime of the
+ * IKEv2 SA.  We cannot immediately teardown the IKEv2 SA once we wish to
+ * condemn it unfortunately.  For example, if we fail to authenticate the
+ * responder, we cannot reply to a reply.  Instead we must initiate a new
+ * INFORMATIONAL exchange w/ the AUTHENTICATION_FAILED notification and
+ * send it to the original responder.  To deal with this, once the
+ * I2SA_CONDEMNED flag is set, new requests (whether they are pf_key(7P)
+ * messages or requests from our peer) are dropped.  Once all of our
+ * outstanding requests either complete or time out, ikev2_sa_condemn
+ * is then called which starts the teardown process.
+ *
+ */
+void
+ikev2_sa_condemn(ikev2_sa_t *i2sa)
+{
+	VERIFY(i2sa->flags & I2SA_CONDEMNED);
+	VERIFY(MUTEX_HELD(&i2sa->i2sa_queue_lock));
+	VERIFY(MUTEX_HELD(&i2sa->i2sa_lock));
+	VERIFY3U(i2sa->i2sa_tid, ==, thr_self());
+
+	(void) bunyan_info(log, "Condemning IKE SA", BUNYAN_T_END);
+
+	i2sa_unlink(i2sa);
+
+	/* Must drop the queue lock before disarming the timers */
+	mutex_exit(&i2sa->i2sa_queue_lock);
+
+	/* Once these return, we know none of the callbacks are running */
+	(void) ikev2_sa_disarm_timer(i2sa, I2SA_EVT_PKT_XMIT, &i2sa->last_req);
+	(void) ikev2_sa_disarm_timer(i2sa, I2SA_EVT_P1_EXPIRE);
+	(void) ikev2_sa_disarm_timer(i2sa, I2SA_EVT_SOFT_EXPIRE);
+	(void) ikev2_sa_disarm_timer(i2sa, I2SA_EVT_HARD_EXPIRE);
+
+	ikev2_pkt_free(i2sa->last_resp_sent);
+	i2sa->last_resp_sent = NULL;
+
+	ikev2_pkt_free(i2sa->last_recvd);
+	i2sa->last_recvd = NULL;
+
+	if (i2sa->last_req.i2r_pkt != NULL) {
+		ikev2_pkt_free(i2sa->last_req.i2r_pkt);
+		i2sa->last_req.i2r_pkt = NULL;
+	}
+
+	ikev2_child_sa_t *i2c = refhash_first(i2sa->i2sa_child_sas);
+
+	while (i2c != NULL) {
+		ikev2_child_sa_t *i2c_next;
+
+		i2c_next = refhash_next(i2sa->i2sa_child_sas, i2c);
+		refhash_remove(i2sa->i2sa_child_sas, i2c);
+		i2c = i2c_next;
+	}
+
+	mutex_exit(&i2sa->i2sa_lock);
+
+	mutex_enter(&i2sa->i2sa_queue_lock);
+	mutex_enter(&i2sa->i2sa_lock);
+
+	for (size_t i = 0; i < I2SA_QUEUE_DEPTH; i++) {
+		parsedmsg_t *pmsg = NULL;
+		sadb_msg_t *samsg = NULL;
+
+		switch (i2sa->i2sa_queue[i].i2m_type) {
+		case I2SA_MSG_NONE:
+			break;
+		case I2SA_MSG_PKT:
+			ikev2_pkt_free(i2sa->i2sa_queue[i].i2m_data);
+			break;
+		case I2SA_MSG_PFKEY:
+			pmsg = i2sa->i2sa_queue[i].i2m_data;
+			samsg = pmsg->pmsg_samsg;
+			break;
+		}
+		i2sa->i2sa_queue[i].i2m_type = I2SA_MSG_NONE;
+		i2sa->i2sa_queue[i].i2m_data = NULL;
+
+		if (samsg != NULL && samsg->sadb_msg_pid == 0 &&
+		    samsg->sadb_msg_type == SADB_ACQUIRE) {
+			/*
+			 * The kernel currently only cares that errno != 0,
+			 * but this seems like the closest error code to
+			 * what's happening, just to be as informative as
+			 * possible.
+			 */
+			pfkey_send_error(samsg, ECANCELED);
+		}
+
+		parsedmsg_free(pmsg);
+	}
+}
+
+/*
+ * Should normally only be called as a result of I2SA_REFRELE()
+ */
+void
+ikev2_sa_free(ikev2_sa_t *i2sa)
+{
+	if (i2sa == NULL)
+		return;
+
+	VERIFY3U(i2sa->refcnt, ==, 0);
+	VERIFY3P(i2sa->last_resp_sent, ==, NULL);
+	VERIFY3P(i2sa->last_recvd, ==, NULL);
+
+	if (i2sa->i2sa_rule != NULL)
+		CONFIG_REFRELE(i2sa->i2sa_rule->rule_config);
+
+	config_id_free(i2sa->local_id);
+	config_id_free(i2sa->remote_id);
+
+	/* All unauthenticated IKEv2 SAs are considered larval */
+	if ((i2sa->flags & (I2SA_AUTHENTICATED|I2SA_INITIATOR)) !=
+	    (I2SA_AUTHENTICATED|I2SA_INITIATOR))
+		dec_half_open();
+
+#define	DESTROY(x, y) pkcs11_destroy_obj(#y, &(x)->y)
+	DESTROY(i2sa, sk_d);
+	DESTROY(i2sa, sk_ai);
+	DESTROY(i2sa, sk_ar);
+	DESTROY(i2sa, sk_ei);
+	DESTROY(i2sa, sk_er);
+	DESTROY(i2sa, sk_pi);
+	DESTROY(i2sa, sk_pr);
+	DESTROY(i2sa, psk);
+#undef  DESTROY
+
+	ikev2_sa_args_free(i2sa->sa_init_args);
+
+	/*
+	 * This is likely redundant with the bzero of everything a few lines
+	 * down, but would rather be safe than sorry.
+	 */
+	explicit_bzero(i2sa->salt_i, sizeof (i2sa->salt_i));
+	explicit_bzero(i2sa->salt_r, sizeof (i2sa->salt_r));
+
+	/* Return it to it's initial constructed state */
+	refhash_t *refhash = i2sa->i2sa_child_sas;
+
+	VERIFY0(mutex_destroy(&i2sa->i2sa_queue_lock));
+	VERIFY0(mutex_destroy(&i2sa->i2sa_lock));
+
+	bzero(i2sa, sizeof (*i2sa));
+	i2sa->i2sa_child_sas = refhash;
+	VERIFY0(mutex_init(&i2sa->i2sa_queue_lock, USYNC_THREAD|LOCK_ERRORCHECK,
+	    NULL));
+	VERIFY0(mutex_init(&i2sa->i2sa_lock, USYNC_THREAD|LOCK_ERRORCHECK,
+	    NULL));
+	i2sa->msgwin = 1;
+
+	umem_cache_free(i2sa_cache, i2sa);
+}
+
+/*
+ * Set the remote SPI of an IKEv2 SA and add to the rhash
+ */
+void
+ikev2_sa_set_remote_spi(ikev2_sa_t *i2sa, uint64_t remote_spi)
+{
+	VERIFY(IS_WORKER);
+	VERIFY(MUTEX_HELD(&i2sa->i2sa_lock));
+
+	/* Never a valid SPI value */
+	VERIFY3U(remote_spi, !=, 0);
+
+	/*
+	 * A bit confusing at times, but if we are the initiator of the
+	 * SA, the responder (ikev2_sa_t->remote_spi) is the remote spi,
+	 * otherwise we are the responder, so the remote spi is the
+	 * initiator (ikev2_sa_t->i_spi)
+	 */
+	if (i2sa->flags & I2SA_INITIATOR) {
+		/* Should not be set already */
+		VERIFY3U(i2sa->r_spi, ==, 0);
+		i2sa->r_spi = remote_spi;
+	} else {
+		/* Should not be set already */
+		VERIFY3U(i2sa->i_spi, ==, 0);
+		i2sa->i_spi = remote_spi;
+	}
+
+	VERIFY0(rw_wrlock(&i2sa_hash_lock));
+	refhash_insert(i2sa_rspi_refhash, i2sa);
+	VERIFY0(rw_unlock(&i2sa_hash_lock));
+
+	key_add_ike_spi(LOG_KEY_RSPI, remote_spi);
+
+	(void) bunyan_trace(log, "Set remote SPI", BUNYAN_T_END);
+}
+
+static void
+i2sa_unlink(ikev2_sa_t *i2sa)
+{
+	VERIFY(MUTEX_HELD(&i2sa->i2sa_lock));
+
+	VERIFY0(rw_wrlock(&i2sa_hash_lock));
+
+	refhash_remove(i2sa_lspi_refhash, i2sa);
+	I2SA_REFRELE(i2sa);
+
+	refhash_remove(i2sa_addr_refhash, i2sa);
+	I2SA_REFRELE(i2sa);
+
+	if (refhash_obj_valid(i2sa_rspi_refhash, i2sa)) {
+		refhash_remove(i2sa_rspi_refhash, i2sa);
+		I2SA_REFRELE(i2sa);
+	}
+
+	VERIFY0(rw_unlock(&i2sa_hash_lock));
+}
+
+/*
+ * Increase the count of larval SAs.  If we reach our threshold for larval SAs,
+ * enable the use of cookies.
+ */
+static void
+inc_half_open(void)
+{
+	if (atomic_inc_uint_nv(&half_open) == ikev2_cookie_threshold)
+		ikev2_cookie_enable();
+}
+
+/*
+ * Decrease the count of larval SAs.  Disable cookies if the count falls
+ * below the threshold
+ */
+static void
+dec_half_open(void)
+{
+	/*
+	 * Instead of merely disabling cookies once we're below
+	 * ikev2_cookie_threshold half-open IKE SAs, we wait for
+	 * IKEV2_COOKIE_OFF_ADD additional half-open IKE SAs to
+	 * disappear to add a small amount of hysteresis and prevent
+	 * constantly flopping on and off once we're at the threshold.
+	 */
+	if (atomic_dec_uint_nv(&half_open) ==
+	    ikev2_cookie_threshold - IKEV2_COOKIE_OFF_ADJ)
+		ikev2_cookie_disable();
+}
+
+/*
+ * Add a message to the queue of the given IKEv2 SA.  Must be called
+ * with sa->i2sa_queue_lock held.  Discards any non-replies for condemned
+ * IKEv2 SAs as well as any requests when the queue is full.
+ * Returns with i2sa_queue_lock released.
+ *
+ * Caller should treat function as if it consumes the message and should not
+ * reference it after function returns.
+ */
+void
+ikev2_sa_queuemsg(ikev2_sa_t *sa, i2sa_msg_type_t type, void *data)
+{
+	VERIFY(IS_WORKER);
+	VERIFY(MUTEX_HELD(&sa->i2sa_queue_lock));
+
+	if (I2SA_QUEUE_FULL(sa)) {
+		(void) bunyan_info(log, "Queue full; discarding packet",
+		    BUNYAN_T_END);
+		goto discard;
+	}
+
+	if ((sa->flags & I2SA_CONDEMNED) &&
+	    ((type != I2SA_MSG_PKT) || !I2P_RESPONSE((pkt_t *)data)))
+		goto discard;
+
+	i2sa_msg_t *msg = &sa->i2sa_queue[sa->i2sa_queue_start];
+
+	/*
+	 * XXX: A possible improvement might be to scan the queue and drop
+	 * duplicate messages
+	 */
+	msg->i2m_type = type;
+	msg->i2m_data = data;
+	sa->i2sa_queue_start++;
+	sa->i2sa_queue_start %= I2SA_QUEUE_DEPTH;
+	ikev2_dispatch(sa);
+	mutex_exit(&sa->i2sa_queue_lock);
+
+	return;
+
+discard:
+	switch (type) {
+	case I2SA_MSG_PKT:
+		ikev2_pkt_free(data);
+		break;
+	case I2SA_MSG_PFKEY:
+		/* XXX: Send a pf_key reply w/ error if this is an ACQUIRE? */
+		parsedmsg_free(data);
+		break;
+	case I2SA_MSG_NONE:
+		INVALID(type);
+		break;
+	}
+
+	mutex_exit(&sa->i2sa_queue_lock);
+}
+
+ikev2_child_sa_t *
+ikev2_child_sa_alloc(boolean_t inbound)
+{
+	ikev2_child_sa_t *csa = NULL;
+
+	if ((csa = umem_cache_alloc(i2c_cache, UMEM_DEFAULT)) == NULL)
+		return (NULL);
+
+	csa->i2c_inbound = inbound;
+	return (csa);
+}
+
+void
+ikev2_child_sa_free(ikev2_sa_t *restrict i2sa, ikev2_child_sa_t *restrict csa)
+{
+	if (csa == NULL)
+		return;
+
+	if (i2sa != NULL)
+		VERIFY(!refhash_obj_valid(i2sa->i2sa_child_sas, csa));
+
+	if (csa->i2c_pair != NULL)
+		csa->i2c_pair->i2c_pair = NULL;
+	csa->i2c_pair = NULL;
+
+	bzero(csa, sizeof (*csa));
+	umem_cache_free(i2c_cache, csa);
+}
+
+ikev2_child_sa_t *
+ikev2_sa_get_child(ikev2_sa_t *i2sa, uint32_t spi, boolean_t inbound)
+{
+	ikev2_child_sa_t cmp = {
+		.i2c_inbound = inbound,
+		.i2c_spi = spi
+	};
+
+	return (refhash_lookup(i2sa->i2sa_child_sas, &cmp));
+}
+
+void
+ikev2_sa_add_child(ikev2_sa_t *restrict i2sa, ikev2_child_sa_t *restrict i2c)
+{
+	refhash_insert(i2sa->i2sa_child_sas, i2c);
+}
+
+void
+ikev2_sa_delete_child(ikev2_sa_t *restrict i2sa, ikev2_child_sa_t *restrict csa)
+{
+	if (csa->i2c_pair != NULL)
+		csa->i2c_pair->i2c_pair = NULL;
+	csa->i2c_pair = NULL;
+	refhash_remove(i2sa->i2sa_child_sas, csa);
+}
+
+void
+ikev2_sa_delete_children(ikev2_sa_t *restrict i2sa)
+{
+	ikev2_child_sa_t *csa = NULL;
+	struct sockaddr_storage src = { 0 };
+	struct sockaddr_storage dst = { 0 };
+	sockaddr_u_t srcu = { .sau_ss = &src };
+	sockaddr_u_t dstu = { .sau_ss = &dst };
+
+	/*
+	 * XXX: This is assuming we don't want to include the protocol or
+	 * port values in the src/dst addresses passed along in the
+	 * SADB_{DELETE,DELPAIR} message.  Need to verify this.
+	 */
+	sockaddr_copy(SSTOSA(&i2sa->laddr), &src, B_FALSE);
+	sockaddr_copy(SSTOSA(&i2sa->raddr), &dst, B_FALSE);
+
+	csa = refhash_first(i2sa->i2sa_child_sas);
+	while (csa != NULL) {
+		ikev2_child_sa_t *next;
+		uint8_t satype = ikev2_to_satype(csa->i2c_satype);
+
+		(void) pfkey_delete(satype, csa->i2c_spi,
+		    csa->i2c_inbound ? dstu : srcu,
+		    csa->i2c_inbound ? srcu : dstu,
+		    (csa->i2c_pair != NULL) ? B_TRUE : B_FALSE);
+
+		if (csa->i2c_pair != NULL) {
+			refhash_remove(i2sa->i2sa_child_sas, csa->i2c_pair);
+			csa->i2c_pair = NULL;
+		}
+
+		next = refhash_next(i2sa->i2sa_child_sas, csa);
+		refhash_remove(i2sa->i2sa_child_sas, csa);
+		csa = next;
+	}
+}
+
+void
+ikev2_sa_clear_req(ikev2_sa_t *restrict i2sa, i2sa_req_t *restrict i2req)
+{
+	pkt_t *pkt = i2req->i2r_pkt;
+
+        (void) ikev2_sa_disarm_timer(i2sa, I2SA_EVT_PKT_XMIT, i2req);
+
+        i2req->i2r_fired = B_FALSE;
+        i2req->i2r_pkt = NULL;
+        i2req->i2r_arg = NULL;
+
+        ikev2_pkt_free(pkt);
+}
+
+static uint64_t
+i2c_hash(const void *arg)
+{
+	const ikev2_child_sa_t *i2c = arg;
+	uint64_t val = i2c->i2c_spi;
+
+	if (i2c->i2c_inbound)
+		val |= (1ULL << 32);
+	return (val);
+}
+
+static int
+i2c_cmp(const void *larg, const void *rarg)
+{
+	const ikev2_child_sa_t *l = larg;
+	const ikev2_child_sa_t *r = rarg;
+
+	if (l->i2c_spi < r->i2c_spi)
+		return (-1);
+	if (l->i2c_spi > r->i2c_spi)
+		return (1);
+
+	if (l->i2c_inbound && !r->i2c_inbound)
+		return (-1);
+	if (!l->i2c_inbound && r->i2c_inbound)
+		return (1);
+
+	return (0);
+}
+
+static void
+i2c_refdtor(void *arg)
+{
+	ikev2_child_sa_t *i2c = arg;
+
+	bzero(i2c, sizeof (*i2c));
+	umem_cache_free(i2c_cache, i2c);
+}
+
+static int
+i2sa_ctor(void *buf, void *dummy __unused, int flags __unused)
+{
+	NOTE(ARGUNUSED(dummy, flags))
+
+	ikev2_sa_t *i2sa = buf;
+
+	bzero(i2sa, sizeof (*i2sa));
+	i2sa->msgwin = 1;
+
+	VERIFY0(mutex_init(&i2sa->i2sa_lock, USYNC_THREAD|LOCK_ERRORCHECK,
+	    NULL));
+	VERIFY0(mutex_init(&i2sa->i2sa_queue_lock, USYNC_THREAD|LOCK_ERRORCHECK,
+	    NULL));
+
+	i2sa->i2sa_child_sas = refhash_create(I2SA_NBUCKETS, i2c_hash, i2c_cmp,
+	    i2c_refdtor, sizeof (ikev2_child_sa_t),
+	    offsetof(ikev2_child_sa_t, i2c_link), 0, UMEM_DEFAULT);
+
+	return ((i2sa->i2sa_child_sas == NULL) ? 1 : 0);
+}
+
+static void
+i2sa_dtor(void *buf, void *dummy __unused)
+{
+	NOTE(ARGUNUSED(dummy))
+
+	ikev2_sa_t *i2sa = (ikev2_sa_t *)buf;
+
+	VERIFY0(mutex_destroy(&i2sa->i2sa_lock));
+	VERIFY0(mutex_destroy(&i2sa->i2sa_queue_lock));
+	refhash_destroy(i2sa->i2sa_child_sas);
+	i2sa->i2sa_child_sas = NULL;
+}
+
+static int
+i2c_ctor(void *buf, void *dummy __unused, int flags __unused)
+{
+	NOTE(ARGUNUSED(dummy, flags))
+
+	ikev2_child_sa_t *i2c = buf;
+
+	bzero(i2c, sizeof (*i2c));
+	return (0);
+}
+
+static boolean_t
+i2sa_key_add_addr(ikev2_sa_t *i2sa, const char *addr_key, const char *port_key,
+    const struct sockaddr_storage *addr)
+{
+	sockaddr_u_t sau;
+	sau.sau_ss = (struct sockaddr_storage *)addr;
+	int rc = 0;
+
+	switch (addr->ss_family) {
+	case AF_INET:
+		rc = bunyan_key_add(log,
+		    BUNYAN_T_IP, addr_key, &sau.sau_sin->sin_addr,
+		    BUNYAN_T_UINT32, port_key, (uint32_t)sau.sau_sin->sin_port,
+		    BUNYAN_T_END);
+		break;
+	case AF_INET6:
+		rc = bunyan_key_add(log,
+		    BUNYAN_T_IP6, addr_key, &sau.sau_sin6->sin6_addr,
+		    BUNYAN_T_UINT32, port_key,
+		    (uint32_t)sau.sau_sin6->sin6_port,
+		    BUNYAN_T_END);
+		break;
+	default:
+		INVALID("addr->ss_family");
+	}
+
+	return ((rc == 0) ? B_TRUE : B_FALSE);
+}
+
+const char *
+i2sa_msgtype_str(i2sa_msg_type_t type)
+{
+#define	STR(x)	case x: return (#x);
+	switch (type) {
+	STR(I2SA_MSG_NONE);
+	STR(I2SA_MSG_PKT);
+	STR(I2SA_MSG_PFKEY);
+	}
+#undef STR
+
+	INVALID(type);
+	/*NOTREACHED*/
+	return (NULL);
+}
+
+static uint64_t
+i2sa_lspi_hash(const void *arg)
+{
+	const ikev2_sa_t *i2sa = arg;
+
+	return (I2SA_LOCAL_SPI(i2sa));
+}
+
+static int
+i2sa_lspi_cmp(const void *larg, const void *rarg)
+{
+	const ikev2_sa_t *l = larg;
+	const ikev2_sa_t *r = rarg;
+	uint64_t l_lspi = I2SA_LOCAL_SPI(l);
+	uint64_t r_lspi = I2SA_LOCAL_SPI(r);
+
+	if (l_lspi < r_lspi)
+		return (-1);
+	if (l_lspi > r_lspi)
+		return (1);
+	return (0);
+}
+
+/*
+ * For hashing/lookup based on the remote spi, it is possible multiple peers
+ * could choose the same SPI value.  In addition, it is also possible peers
+ * could be behind the same NAT address.  To disambiguate, we follow
+ * RFC7296 2.1 and look at the remote SPI, the addresses, and the init packet
+ * to locate an IKEv2 SA.
+ *
+ * We only ever have to use this on a retransmit of the IKE_SA_INIT packet from
+ * an remotely initiated IKE SA (due to packet loss, new KE group requested,
+ * COOKIE request, etc) as that is the only instance where our local spi is
+ * not included in the IKEv2 header -- we always prefer to lookup on the
+ * local spi when present.
+ *
+ * Specifically we use the remote peer's nonce value as it should be randomly
+ * generated, and at least 16 bytes long, so the chances of a collision
+ * here are even smaller than with the remote SPI.  It should be noted that
+ * this is all done in an effort to minimize the amount of processing that
+ * is done and discarded.  If these fail, we'll just end up with some larval
+ * ikev2_sa_t's (and some of the IKE_SA_INIT processing that goes with them)
+ * that will eventually time out.
+ */
+static uint64_t
+i2sa_rspi_hash(const void *arg)
+{
+	const ikev2_sa_t *i2sa = arg;
+	const uint8_t *addrp[2] = { 0 };
+	uint64_t hash = remote_noise;
+	uint8_t *hashp = (uint8_t *)&hash;
+	uint8_t *ni = NULL;
+	size_t addrlen = 0, hashidx = 0, ni_len = 0;
+
+	hash ^= I2SA_REMOTE_SPI(i2sa);
+
+	addrlen = ss_addrlen(SSTOSA(&i2sa->laddr));
+	addrp[0] = ss_addr(SSTOSA(&i2sa->laddr));
+	addrp[1] = ss_addr(SSTOSA(&i2sa->raddr));
+
+	for (size_t i = 0; i < 2; i++) {
+		for (size_t j = 0; j < addrlen; j++) {
+			hashp[hashidx++] ^= addrp[i][j];
+			hashidx %= sizeof (hash);
+		}
+	}
+
+	ni = i2sa->sa_init_args->i2a_nonce_i;
+	ni_len = i2sa->sa_init_args->i2a_nonce_i_len;
+
+	for (size_t i = 0; i < ni_len; i++) {
+		hashp[hashidx++] ^= ni[i];
+		hashidx %= sizeof (hash);
+	}
+
+	return (hash);
+}
+
+static int
+i2sa_rspi_cmp(const void *larg, const void *rarg)
+{
+	const ikev2_sa_t *l = larg;
+	const ikev2_sa_t *r = rarg;
+	uint64_t l_rspi = I2SA_REMOTE_SPI(l);
+	uint64_t r_rspi = I2SA_REMOTE_SPI(r);
+	int cmp = 0;
+
+	if (l_rspi < r_rspi)
+		return (-1);
+	if (l_rspi > r_rspi)
+		return (1);
+
+	if ((cmp = sockaddr_cmp(SSTOSA(&l->laddr), SSTOSA(&r->laddr))) != 0)
+		return (cmp);
+
+	if ((cmp = sockaddr_cmp(SSTOSA(&r->raddr), SSTOSA(&r->raddr))) != 0)
+		return (cmp);
+
+	if (l->sa_init_args == NULL && r->sa_init_args == NULL)
+		return (0);
+
+	if (l->sa_init_args == NULL)
+		return (-1);
+	if (r->sa_init_args == NULL)
+		return (1);
+
+	uint8_t *ni_l = l->sa_init_args->i2a_nonce_i;
+	uint8_t *ni_r = r->sa_init_args->i2a_nonce_r;
+	size_t ni_l_len = l->sa_init_args->i2a_nonce_i_len;
+	size_t ni_r_len = r->sa_init_args->i2a_nonce_r_len;
+
+	if (ni_l_len == 0 && ni_r_len == 0)
+		return (0);
+
+	if ((cmp = memcmp(ni_l, ni_r, MIN(ni_l_len, ni_r_len))) != 0)
+		return (cmp);
+
+	if (ni_l_len < ni_r_len)
+		return (-1);
+	if (ni_r_len > ni_r_len)
+		return (1);
+	return (0);
+}
+
+static uint64_t
+i2sa_addr_hash(const void *arg)
+{
+	const ikev2_sa_t *i2sa = arg;
+	const uint8_t *addrp[2] = { 0 };
+	uint64_t hash = addr_noise;
+	uint8_t *hashp = (uint8_t *)&hash;
+	size_t addrlen = 0, hashidx = 0;
+
+	VERIFY3U(i2sa->laddr.ss_family, ==, i2sa->raddr.ss_family);
+
+	addrlen = ss_addrlen(SSTOSA(&i2sa->laddr));
+	addrp[0] = ss_addr(SSTOSA(&i2sa->laddr));
+	addrp[1] = ss_addr(SSTOSA(&i2sa->raddr));
+
+	for (size_t i = 0; i < 2; i++) {
+		for (size_t j = 0; j < addrlen; j++) {
+			hashp[hashidx++] ^= addrp[i][j];
+			hashidx %= sizeof (hash);
+		}
+	}
+
+	return (hash);
+}
+
+static int
+i2sa_addr_cmp(const void *larg, const void *rarg)
+{
+	const ikev2_sa_t *l = larg;
+	const ikev2_sa_t *r = rarg;
+	int cmp;
+
+	cmp = sockaddr_cmp(SSTOSA(&l->laddr), SSTOSA(&r->laddr));
+	if (cmp != 0)
+		return (cmp);
+	return (sockaddr_cmp(SSTOSA(&l->raddr), SSTOSA(&r->raddr)));
+}
+
+static void
+dummy_dtor(void *arg __unused)
+{
+}
+
+void
+ikev2_sa_init(void)
+{
+	if ((i2sa_cache = umem_cache_create("IKEv2 SAs", sizeof (ikev2_sa_t),
+	    0, i2sa_ctor, i2sa_dtor, NULL, NULL, NULL, 0)) == NULL)
+		err(EXIT_FAILURE, "Unable to create IKEv2 SA cache");
+
+	if ((i2c_cache = umem_cache_create("IKEv2 Child SAs",
+	    sizeof (ikev2_child_sa_t), 0, i2c_ctor, NULL, NULL, NULL, NULL,
+	    0)) == NULL)
+		err(EXIT_FAILURE, "Unable to create IKEv2 Child SA cache");
+
+	arc4random_buf(&remote_noise, sizeof (remote_noise));
+	arc4random_buf(&addr_noise, sizeof (addr_noise));
+
+	i2sa_lspi_refhash = refhash_create(I2SA_NBUCKETS, i2sa_lspi_hash,
+	    i2sa_lspi_cmp, dummy_dtor, sizeof (ikev2_sa_t),
+	    offsetof(ikev2_sa_t, i2sa_lspi_link), 0, UMEM_NOFAIL);
+
+	i2sa_rspi_refhash = refhash_create(I2SA_NBUCKETS, i2sa_rspi_hash,
+	    i2sa_rspi_cmp, dummy_dtor, sizeof (ikev2_sa_t),
+	    offsetof(ikev2_sa_t, i2sa_rspi_link), 0, UMEM_NOFAIL);
+
+	i2sa_addr_refhash = refhash_create(I2SA_NBUCKETS, i2sa_addr_hash,
+	    i2sa_addr_cmp, dummy_dtor, sizeof (ikev2_sa_t),
+	    offsetof(ikev2_sa_t, i2sa_addr_link), 0, UMEM_NOFAIL);
+}
+
+void
+ikev2_sa_fini(void)
+{
+	umem_cache_destroy(i2sa_cache);
+	umem_cache_destroy(i2c_cache);
+	refhash_destroy(i2sa_lspi_refhash);
+	refhash_destroy(i2sa_rspi_refhash);
+	refhash_destroy(i2sa_addr_refhash);
+}
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_sa.h b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_sa.h
new file mode 100644
index 0000000000..e2ac525455
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_sa.h
@@ -0,0 +1,307 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the "License").
+ * You may not use this file except in compliance with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ */
+
+/*
+ * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ *
+ * Copyright 2014 Jason King.
+ * Copyright 2017 Joyent, Inc.
+ */
+
+#ifndef _IKEV2_SA_H
+#define	_IKEV2_SA_H
+
+#include <atomic.h>
+#include <libperiodic.h>
+#include <security/cryptoki.h>
+#include <sys/list.h>
+#include <sys/refhash.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <stddef.h>
+#include <synch.h>
+#include <thread.h>
+#include "defs.h"
+#include "ikev2.h"
+#include "ts.h"
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+struct ikev2_sa_s;
+struct ikev2_child_sa;
+struct ikev2_sa_args_s;
+struct pkt_s;
+struct config_rule_s;
+
+typedef struct ikev2_sa_s ikev2_sa_t;
+typedef struct ikev2_child_sa_s ikev2_child_sa_t;
+
+#define	I2SA_SALT_LEN		32	/* Max size of salt, may be smaller */
+
+typedef enum i2sa_msg_type {
+	I2SA_MSG_NONE = 0,
+	I2SA_MSG_PKT,
+	I2SA_MSG_PFKEY,
+} i2sa_msg_type_t;
+
+typedef struct i2sa_msg {
+	i2sa_msg_type_t	i2m_type;
+	void		*i2m_data;
+} i2sa_msg_t;
+#define	I2SA_QUEUE_DEPTH	8	/* How many messages we'll queue */
+
+/* Outbound requests */
+typedef struct i2sa_req {
+	struct pkt_s	*i2r_pkt;
+	void		*i2r_cb;	/* Handler for reply */
+	void		*i2r_arg;	/* Cookie for handler */
+	periodic_id_t	i2r_timer;	/* Retransmit timer */
+	uint32_t	i2r_msgid;	/* Request msgid in local byte order */
+	boolean_t	i2r_fired;	/* B_TRUE if i2r_timer has fired */
+} i2sa_req_t;
+#define	I2REQ_ACTIVE(i2r) ((i2r)->i2r_pkt != NULL)
+
+/* Timer events */
+typedef enum i2sa_evt {
+	I2SA_EVT_NONE		= 0x00,
+	I2SA_EVT_PKT_XMIT	= 0x01,
+	I2SA_EVT_P1_EXPIRE	= 0x02,
+	I2SA_EVT_SOFT_EXPIRE	= 0x04,
+	I2SA_EVT_HARD_EXPIRE	= 0x08,
+} i2sa_evt_t;
+
+/*
+ * The IKEv2 SA.
+ *
+ * This is the central data structure to the IKEv2 daemon.  It is a
+ * reference-counted node, where the lookup key is either the local
+ * SPI/cookie, or a hash based on the remote address and remote SPI.  (See
+ * ikev2_pkt.h for the _SPI() macros.)  It should be allocated with a umem
+ * cache.
+ *
+ * Because of the distinct sets of lookup keys, it requires two linkages.
+ */
+struct ikev2_sa_s {
+	/*
+	 * i2sa_queue_lock protects i2sa_queue_*, i2sa_events, and the
+	 * periodic timers.  Acquire before acquiring i2sa_lock.
+	 */
+	mutex_t		i2sa_queue_lock;
+	i2sa_msg_t	i2sa_queue[I2SA_QUEUE_DEPTH];
+	size_t		i2sa_queue_start;
+	size_t		i2sa_queue_end;
+	i2sa_evt_t	i2sa_events;
+	periodic_id_t	i2sa_p1_timer;
+	periodic_id_t	i2sa_softlife_timer;
+	periodic_id_t	i2sa_hardlife_timer;
+
+			/*
+			 * i2sa_lock protects everything else, acquire after
+			 * i2sa_queue_lock
+			 */
+	mutex_t		i2sa_lock;
+	thread_t	i2sa_tid;	/* active tid */
+
+	refhash_link_t	i2sa_lspi_link;
+	refhash_link_t	i2sa_rspi_link;
+	refhash_link_t	i2sa_addr_link;
+
+	struct config_rule_s	*i2sa_rule;
+
+	uint64_t		i_spi;	  /* Initiator SPI. */
+	uint64_t		r_spi;	  /* Responder SPI. */
+	uint32_t		flags;
+	volatile uint32_t	refcnt;
+
+	struct sockaddr_storage laddr;  /* Local address & port. */
+	struct sockaddr_storage raddr;  /* Remote address & port. */
+	struct sockaddr_storage lnatt;	/* Local NAT-Ted address */
+	struct sockaddr_storage rnatt;	/* Remote NAT-Ted address */
+
+			/*
+			 * What IKEv2 daemon are we talking to.
+			 * Currently it is just used to determine if
+			 * we can validate padding in SK payloads.
+			 * If there are any additional custom behaviors
+			 * we want to support in the future, this
+			 * will probably need to evolve into
+			 * feature flags or such.
+			 */
+	vendor_t	vendor;
+
+	struct config_id_s *local_id;
+	struct config_id_s *remote_id;
+
+	ikev2_auth_type_t authmethod;	/* How the IKEV2 SA is authenticated */
+	ikev2_xf_encr_t	encr;		/* Encryption algorithm */
+	size_t		encr_keylen;	/* Key length (bits) for encr */
+	ikev2_xf_auth_t	auth;		/* Authentication algorithm */
+	ikev2_prf_t	prf;		/* PRF algorithm */
+	ikev2_dh_t	dhgrp;		/* Diffie-Hellman group. */
+
+	/* Current number of outstanding messages prior to outmsgid. */
+	int		msgwin;
+	uint32_t	outmsgid;	/* Next msgid for outbound packets. */
+	uint32_t	inmsgid;	/* Next expected inbound msgid. */
+
+	struct pkt_s	*last_resp_sent;
+	struct pkt_s	*last_recvd;
+	i2sa_req_t	last_req;
+
+	time_t		birth;		/* When was AUTH completed */
+	hrtime_t	softexpire;
+	hrtime_t	hardexpire;
+
+	refhash_t	*i2sa_child_sas;
+
+	CK_OBJECT_HANDLE sk_d;
+	CK_OBJECT_HANDLE sk_ai;
+	CK_OBJECT_HANDLE sk_ar;
+	CK_OBJECT_HANDLE sk_ei;
+	CK_OBJECT_HANDLE sk_er;
+	CK_OBJECT_HANDLE sk_pi;
+	CK_OBJECT_HANDLE sk_pr;
+
+	CK_OBJECT_HANDLE psk;
+
+	/* Salt size may be smaller, but no larger than I2SA_SALT_LEN */
+	uint8_t		salt_i[I2SA_SALT_LEN];
+	uint8_t		salt_r[I2SA_SALT_LEN];
+	size_t		saltlen;
+
+	struct ikev2_sa_args_s	*sa_init_args;
+};
+
+/* SA flags */
+#define	I2SA_INITIATOR		0x1	/* Am I the initiator of this IKE SA? */
+#define	I2SA_NAT_LOCAL		0x2	/* I am behind a NAT. */
+#define	I2SA_NAT_REMOTE		0x4	/* My peer is behind a NAT. */
+#define	I2SA_CONDEMNED		0x8	/* SA is unlinked from a tree. */
+#define	I2SA_AUTHENTICATED	0x10	/* SA has been authenticated */
+
+#define	I2SA_LOCAL_SPI(i2sa) \
+	(((i2sa)->flags & I2SA_INITIATOR) ? (i2sa)->i_spi : \
+	    (i2sa)->r_spi)
+
+#define	I2SA_REMOTE_SPI(i2sa) \
+	(((i2sa)->flags & I2SA_INITIATOR) ? (i2sa)->r_spi : \
+	    (i2sa)->i_spi)
+
+#define	I2SA_IS_NAT(i2sa) \
+	(!!((i2sa)->flags & (I2SA_NAT_LOCAL|I2SA_NAT_REMOTE)))
+
+#define	I2SA_REFHOLD(i2sa) \
+	atomic_inc_32(&(i2sa)->refcnt)
+
+/* Stupid C tricks stolen from <assert.h>. */
+#define	I2SA_REFRELE(i2sa) \
+	(void) ((atomic_dec_32_nv(&(i2sa)->refcnt) != 0) || \
+	    (ikev2_sa_free(i2sa), 0))
+
+#define	I2SA_QUEUE_EMPTY(i2sa) \
+	((i2sa)->i2sa_queue_start == (i2sa)->i2sa_queue_end)
+#define	I2SA_QUEUE_FULL(i2sa) \
+	((((i2sa)->i2sa_queue_end + 1) % I2SA_QUEUE_DEPTH) == \
+	(i2sa)->i2sa_queue_start)
+
+struct ikev2_child_sa_s {
+	refhash_link_t		i2c_link;
+	ikev2_child_sa_t	*i2c_pair;
+	hrtime_t		i2c_birth;
+
+	/* A subset of the child SAs state duplicated for observability */
+	ikev2_spi_proto_t	i2c_satype;
+	uint32_t		i2c_spi;
+	boolean_t		i2c_initiator;
+	boolean_t		i2c_inbound;
+	boolean_t		i2c_transport;
+	boolean_t		i2c_moribund;	/* deleted in kernel */
+
+	ikev2_xf_encr_t		i2c_encr;
+	uint16_t		i2c_encr_keylen; /* in bits */
+	uint16_t		i2c_encr_saltlen; /* in bits */
+	ikev2_xf_auth_t		i2c_auth;
+	ikev2_dh_t		i2c_dh;
+
+	ts_t			i2c_ts_i;
+	ts_t			i2c_ts_r;
+};
+
+#define	I2C_SRC(_c) \
+    ((_c)->i2c_initiator ^ (_c)->i2c_inbound) ? \
+	&(_c)->i2c_ts_i : &(_c)->i2c_ts_r
+
+#define	I2C_DST(_c) \
+    ((_c)->i2c_initiator ^ (_c)->i2c_inbound) ? \
+	&(_c)->i2c_ts_r : &(_c)->i2c_ts_i
+
+#define	I2C_SRC_ID(_i2sa, _i2csa) \
+    ((_i2csa)->i2c_inbound ? (_i2sa)->remote_id : (_i2sa)->local_id)
+#define	I2C_DST_ID(_i2sa, _i2csa) \
+    ((_i2csa)->i2c_inbound ? (_i2sa)->local_id : (_i2sa)->remote_id)
+
+ikev2_sa_t *ikev2_sa_getbylspi(uint64_t, boolean_t);
+ikev2_sa_t *ikev2_sa_getbyrspi(uint64_t,
+    const struct sockaddr *restrict,
+    const struct sockaddr *restrict,
+    struct pkt_s *restrict);
+ikev2_sa_t *ikev2_sa_getbyaddr(const struct sockaddr *restrict,
+    const struct sockaddr *restrict);
+
+ikev2_sa_t *ikev2_sa_alloc(struct pkt_s *restrict,
+    const struct sockaddr *restrict,
+    const struct sockaddr *restrict);
+
+void	ikev2_sa_set_remote_spi(ikev2_sa_t *, uint64_t);
+void	ikev2_sa_free(ikev2_sa_t *);
+void	ikev2_sa_condemn(ikev2_sa_t *);
+
+void	ikev2_sa_flush(void);
+
+boolean_t ikev2_sa_has_requests(const ikev2_sa_t *restrict);
+struct pkt_s *ikev2_sa_get_response(ikev2_sa_t *restrict,
+    const struct pkt_s *restrict);
+
+void ikev2_sa_post_event(ikev2_sa_t *, i2sa_evt_t);
+boolean_t ikev2_sa_arm_timer(ikev2_sa_t *, hrtime_t, i2sa_evt_t, ...);
+void ikev2_sa_disarm_timer(ikev2_sa_t *, i2sa_evt_t, ...);
+void ikev2_sa_queuemsg(ikev2_sa_t *, i2sa_msg_type_t, void *);
+const char *i2sa_msgtype_str(i2sa_msg_type_t);
+
+ikev2_child_sa_t *ikev2_child_sa_alloc(boolean_t);
+void ikev2_child_sa_free(ikev2_sa_t *restrict, ikev2_child_sa_t *restrict);
+ikev2_child_sa_t *ikev2_sa_get_child(ikev2_sa_t *, uint32_t, boolean_t);
+void ikev2_sa_add_child(ikev2_sa_t *restrict, ikev2_child_sa_t *restrict);
+void ikev2_sa_delete_children(ikev2_sa_t *);
+void ikev2_sa_delete_child(ikev2_sa_t *restrict, ikev2_child_sa_t *);
+
+void ikev2_sa_clear_req(ikev2_sa_t *restrict, i2sa_req_t *restrict);
+void ikev2_sa_init(void);
+void ikev2_sa_fini(void);
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif  /* _IKEV2_SA_H */
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_sa_init.c b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_sa_init.c
new file mode 100644
index 0000000000..208f0418dc
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_sa_init.c
@@ -0,0 +1,1038 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017 Joyent, Inc.
+ */
+
+#include <bunyan.h>
+#include <err.h>
+#include <errno.h>
+#include <string.h>
+#include <strings.h>
+#include <sys/debug.h>
+#include <time.h>
+#include <umem.h>
+#include "config.h"
+#include "defs.h"
+#include "dh.h"
+#include "ikev2_common.h"
+#include "ikev2_enum.h"
+#include "ikev2_pkt.h"
+#include "ikev2_proto.h"
+#include "ikev2_sa.h"
+#include "pfkey.h"
+#include "pkcs11.h"
+#include "pkt.h"
+#include "prf.h"
+#include "worker.h"
+
+static void ikev2_sa_init_init_resp(ikev2_sa_t *restrict, pkt_t *restrict,
+    void *restrict);
+static boolean_t redo_sa_init(pkt_t *restrict, ikev2_sa_args_t *restrict);
+
+static config_rule_t *find_rule(sockaddr_u_t, sockaddr_u_t);
+static boolean_t add_nat(pkt_t *);
+static boolean_t check_nats(pkt_t *);
+static void check_vendor(pkt_t *);
+static boolean_t add_vendor(pkt_t *);
+static boolean_t add_cookie(pkt_t *restrict, void *restrict, size_t len);
+static boolean_t ikev2_sa_keygen(ikev2_sa_match_t *restrict, pkt_t *restrict);
+static boolean_t ikev2_save_init_pkt(ikev2_sa_args_t *restrict,
+    pkt_t *restrict);
+
+/* New IKE_SA_INIT exchange, we are initiator */
+void
+ikev2_sa_init_init(ikev2_sa_t *restrict i2sa, parsedmsg_t *restrict pmsg)
+{
+	pkt_t *pkt = NULL;
+	ikev2_sa_args_t *sa_args = i2sa->sa_init_args;
+	sockaddr_u_t laddr = { .sau_ss = &i2sa->laddr };
+	sockaddr_u_t raddr = { .sau_ss = &i2sa->raddr };
+
+	VERIFY(MUTEX_HELD(&i2sa->i2sa_lock));
+	VERIFY(!(i2sa->flags & I2SA_AUTHENTICATED));
+	VERIFY(i2sa->flags & I2SA_INITIATOR);
+
+	pkt = ikev2_pkt_new_exchange(i2sa, IKEV2_EXCH_IKE_SA_INIT);
+
+	if (sa_args->i2a_pmsg == NULL) {
+		sa_args->i2a_pmsg = pmsg;
+		sa_args->i2a_sadb_msg = pmsg->pmsg_samsg;
+
+		(void) bunyan_info(log,
+		    "Starting new IKE_SA_INIT exchange as initiator",
+		    BUNYAN_T_END);
+	}
+
+	if (i2sa->i2sa_rule == NULL) {
+		i2sa->i2sa_rule = find_rule(laddr, raddr);
+		if (i2sa->i2sa_rule == NULL)
+			goto fail;
+	}
+
+	if (RULE_IS_DEFAULT(i2sa->i2sa_rule)) {
+		(void) bunyan_debug(log, "Using default rule",
+		    BUNYAN_T_END);
+	} else {
+		(void) bunyan_debug(log, "Found rule",
+		    BUNYAN_T_POINTER, "rule", i2sa->i2sa_rule,
+		    BUNYAN_T_STRING, "label", i2sa->i2sa_rule->rule_label,
+		    BUNYAN_T_END);
+	}
+
+	if (!add_cookie(pkt, sa_args->i2a_cookie, sa_args->i2a_cookielen))
+		goto fail;
+
+	if (!ikev2_sa_from_rule(pkt, i2sa->i2sa_rule, 0))
+		goto fail;
+
+	/*
+	 * Try the first DH group in the first rule if we already don't have
+	 * one set from a previous attempt.
+	 */
+	if (sa_args->i2a_dh == IKEV2_DH_NONE)
+		sa_args->i2a_dh = i2sa->i2sa_rule->rule_xf[0]->xf_dh;
+
+	if (!dh_genpair(sa_args->i2a_dh, &sa_args->i2a_pubkey,
+	    &sa_args->i2a_privkey))
+		goto fail;
+
+	if (!ikev2_add_ke(pkt, sa_args->i2a_dh, sa_args->i2a_pubkey))
+		goto fail;
+
+	/*
+	 * ikev2_create_nonce() will only create a nonce once and will be a
+	 * no-op if the nonce already exists.
+	 */
+	if (!ikev2_create_nonce(sa_args, B_TRUE, IKEV2_NONCE_DEFAULT) ||
+	    !ikev2_add_nonce(pkt, sa_args->i2a_nonce_i,
+	    sa_args->i2a_nonce_i_len))
+		goto fail;
+
+	if (!add_nat(pkt))
+		goto fail;
+
+	if (!add_vendor(pkt))
+		goto fail;
+
+	/* XXX: Add CERTREQ once supported */
+
+	if (!ikev2_save_init_pkt(sa_args, pkt))
+		goto fail;
+
+	if (!ikev2_send_req(pkt, ikev2_sa_init_init_resp, sa_args)) {
+		pkt = NULL;
+		goto fail;
+	}
+
+	return;
+
+fail:
+	(void) bunyan_error(log, "Could not send IKE_SA_INIT packet",
+	    BUNYAN_T_END);
+
+	i2sa->flags |= I2SA_CONDEMNED;
+	ikev2_pkt_free(pkt);
+}
+
+/* We are responder */
+void
+ikev2_sa_init_resp(pkt_t *pkt)
+{
+	ikev2_sa_t *sa = pkt->pkt_sa;
+	ikev2_sa_args_t *sa_args = sa->sa_init_args;
+	pkt_t *resp = NULL;
+	sockaddr_u_t laddr = { .sau_ss = &sa->laddr };
+	sockaddr_u_t raddr = { .sau_ss = &sa->raddr };
+	pkt_payload_t *ke_i = pkt_get_payload(pkt, IKEV2_PAYLOAD_KE, NULL);
+	ikev2_auth_type_t authmethod;
+	ikev2_sa_match_t sa_result = { 0 };
+
+	/* Verify inbound sanity checks */
+	VERIFY(!(sa->flags & I2SA_INITIATOR));
+	VERIFY3P(ke_i, !=, NULL);
+
+	(void) bunyan_info(log,
+	    "Starting new IKE_SA_INIT exchange as responder",
+	    BUNYAN_T_END);
+
+	resp = ikev2_pkt_new_response(pkt);
+	if (resp == NULL)
+		goto fail;
+
+	sa->i2sa_rule = find_rule(laddr, raddr);
+	if (sa->i2sa_rule == NULL) {
+		/* This is the 2nd payload, it should fit */
+		VERIFY(ikev2_add_notify(resp, IKEV2_N_NO_PROPOSAL_CHOSEN));
+		(void) ikev2_send_resp(resp);
+		return;
+	}
+
+	if (RULE_IS_DEFAULT(sa->i2sa_rule)) {
+		(void) bunyan_debug(log, "Using default rule",
+		    BUNYAN_T_END);
+	} else {
+		(void) bunyan_debug(log, "Found rule",
+		    BUNYAN_T_POINTER, "rule", sa->i2sa_rule,
+		    BUNYAN_T_STRING, "label", sa->i2sa_rule->rule_label,
+		    BUNYAN_T_END);
+	}
+
+	if (!ikev2_sa_match_rule(sa->i2sa_rule, pkt, &sa_result, B_FALSE)) {
+		VERIFY(ikev2_add_notify(resp, IKEV2_N_NO_PROPOSAL_CHOSEN));
+		(void) ikev2_send_resp(resp);
+		return;
+	}
+
+	sa->authmethod = sa_result.ism_authmethod;
+
+	/*
+	 * A bit annoying, but it's possible the negotiated DH group is
+	 * different than the public key value that was sent in the IKE_SA_INIT
+	 * exchange.  In that case, we respond with an INVALID_KE_PAYLOAD
+	 * notification and include the result we want.  In this instance, we
+	 * expect that the initiator will respond with a new KE payload
+	 * containing the desired DH group (and otherwise identical).
+	 * Therefore, keep the larval IKE SA around until we either proceed to
+	 * an AUTH exchange, or we time out.
+	 */
+	sa_args->i2a_dh = sa_result.ism_dh;
+	if (ikev2_get_dhgrp(pkt) != sa_args->i2a_dh) {
+		if (ikev2_invalid_ke(resp, sa_args->i2a_dh))
+			goto send;
+		else
+			goto fail;
+	}
+
+	if (!check_nats(pkt))
+		goto fail;
+
+	check_vendor(pkt);
+
+	/* Save the initiator's nonce */
+	ikev2_save_nonce(sa_args, pkt);
+
+	if (!ikev2_create_nonce(sa_args, B_FALSE, IKEV2_NONCE_DEFAULT))
+		goto fail;
+
+	/*
+	 * The packet response functions take their SPI values from the
+	 * initating packet, so for this one instance we must set it
+	 * manually since the initiator doesn't yet know our local SPI.
+	 *
+	 * This is done _after_ we've verified our response isn't an error
+	 * (NO_PROPOSALS_CHOSEN) or a request for a new KE group.  Cookies
+	 * are checked/requested prior to ikev2_sa_init_resp() being called.
+	 */
+	pkt_header(resp)->responder_spi = I2SA_LOCAL_SPI(sa);
+
+	if (!ikev2_sa_add_result(resp, &sa_result, 0))
+		goto fail;
+
+	/*
+	 * While premissible, we do not currently reuse DH exponentials.  Since
+	 * generating them is a potentially an expensive operation, we wait
+	 * until necessary to create them.
+	 */
+	if (!dh_genpair(sa_args->i2a_dh, &sa_args->i2a_pubkey,
+	    &sa_args->i2a_privkey))
+		goto fail;
+
+	if (!ikev2_ke(sa_args, pkt))
+		goto fail;
+
+	if (!ikev2_add_ke(resp, sa_args->i2a_dh, sa_args->i2a_pubkey))
+		goto fail;
+
+	if (!ikev2_add_nonce(resp, sa_args->i2a_nonce_r,
+	    sa_args->i2a_nonce_r_len))
+		goto fail;
+
+	if (!add_nat(resp))
+		goto fail;
+
+	/* XXX: HTTP_CERT_LOOKUP_SUPPORTED if we do support it */
+	/* XXX: CERTREQ? */
+
+	if (!add_vendor(resp))
+		goto fail;
+
+	if (!ikev2_sa_keygen(&sa_result, resp))
+		goto fail;
+
+	if (!ikev2_save_init_pkt(sa_args, pkt) ||
+	    !ikev2_save_init_pkt(sa_args, resp))
+		goto fail;
+
+send:
+	if (!ikev2_send_resp(resp)) {
+		resp = NULL;
+		goto fail;
+	}
+	return;
+
+fail:
+	(void) bunyan_error(log,
+	    "Could not send response in IKE_SA_INIT exchange",
+	    BUNYAN_T_END);
+
+	/* condemning/deleting the IKEv2 SA will destroy the DH objects */
+	sa->flags |= I2SA_CONDEMNED;
+	ikev2_pkt_free(resp);
+}
+
+/*
+ * We initiated the IKE_SA_INIT exchange, this is the remote response
+ */
+static void
+ikev2_sa_init_init_resp(ikev2_sa_t *restrict sa, pkt_t *restrict pkt,
+    void *restrict arg)
+{
+	ikev2_sa_args_t *sa_args = arg;
+	parsedmsg_t *pmsg = sa_args->i2a_pmsg;
+	ikev2_auth_type_t authmethod;
+	ikev2_sa_match_t sa_result = { 0 };
+
+	VERIFY(!MUTEX_HELD(&sa->i2sa_queue_lock));
+	VERIFY(MUTEX_HELD(&sa->i2sa_lock));
+
+	if (pkt == NULL) {
+		(void) bunyan_info(log, "Timeout during IKE_SA_INIT exchange",
+		    BUNYAN_T_END);
+
+		/*
+		 * Timeout on IKE_SA_INIT packet send.  Timeout handler will
+		 * condemn the larval IKE SA, so only need to let the kernel
+		 * know we failed if it prompted the IKE_SA_INIT exchange.
+		 */
+		if (PMSG_FROM_KERNEL(sa_args->i2a_pmsg))
+			pfkey_send_error(sa_args->i2a_sadb_msg, ETIMEDOUT);
+		return;
+	}
+
+	(void) bunyan_debug(log, "Processing IKE_SA_INIT response",
+	     BUNYAN_T_END);
+
+	/*
+	 * Since this is an unprotected/unauthenticated reply, we only note
+	 * if we've received a NO_PROPOSAL_CHOSEN error.  This could be a
+	 * spoofed reply.  We let the retransmissions continue until we
+	 * either receive a non-error reply, we exhaust our transmission
+	 * attempts, or hit the P1 timeout based on the recommendation
+	 * in RFC7296 2.21.1.
+	 *
+	 * Note: this is different than when we receive a NO_PROPOSAL_CHOSEN
+	 * notification within a CREATE_CHILD_SA exchange -- at that point,
+	 * our peer has been authenticated and the communication is encrypted
+	 * and signed.
+	 */
+	if (pkt_get_notify(pkt, IKEV2_N_NO_PROPOSAL_CHOSEN, NULL) != NULL) {
+		(void) bunyan_warn(log, "Received NO_PROPOSAL_CHOSEN from peer",
+		    BUNYAN_T_END);
+		return;
+	}
+
+	/* Did we get a request for cookies or a new DH group? */
+	if (redo_sa_init(pkt, sa_args))
+		return;
+
+	/*
+	 * Verify the algorithms selected by the responder match our policy.
+	 * While the responder is supposed to reply with a set of algorithms
+	 * chosen from what we propose (or send NO_PROPOSAL_CHOSEN), there is
+	 * nothing in the protocol that can guarantee it.  Obviously we do not
+	 * want to let a peer to trick us into using a set of algorithms that
+	 * are not in our policy.  RFC7296 doesn't provide any specific
+	 * guidance for this instance, however in keeping with the
+	 * recommendations in section 2.21.1, we just ignore this response
+	 * and hope we either receive a correct response, we exhaust
+	 * transmission attempts, or we hit the P1 timeout.
+	 */
+	if (!ikev2_sa_check_prop(sa->i2sa_rule, pkt, &sa_result, B_FALSE)) {
+		(void) bunyan_warn(log,
+		    "Received response from peer that does not match our "
+		    "policy", BUNYAN_T_END);
+		return;
+	}
+
+	if (!check_nats(pkt))
+		goto fail;
+
+	check_vendor(pkt);
+
+	if (!ikev2_ke(sa_args, pkt))
+		goto fail;
+
+	/* Save the remote nonce */
+	ikev2_save_nonce(sa_args, pkt);
+
+	/* And the responder IKE_SA_INIT packet */
+	ikev2_save_init_pkt(sa_args, pkt);
+
+	/* The generated keys use the initiator/responder SPI values from
+	 * the ikev2_sa_t for the exchange, so we need to set the responder's
+	 * SPI before we try to create our keys.
+	 */
+	ikev2_sa_set_remote_spi(sa, INBOUND_REMOTE_SPI(pkt_header(pkt)));
+	sa->authmethod = sa_result.ism_authmethod;
+
+	if (!ikev2_sa_keygen(&sa_result, pkt))
+		goto fail;
+
+	/*
+	 * Per the comment in ikev2_handle_response(), unlike the other
+	 * exchanges, we must dispose of our request packet and cancel its
+	 * retransmit timer (since certain responses are ignored).
+	 */
+	ikev2_sa_clear_req(sa, &sa->last_req);
+	ikev2_ike_auth_init(sa);
+	return;
+
+fail:
+	sa->flags |= I2SA_CONDEMNED;
+	return;
+}
+
+static boolean_t
+redo_check_cookie(pkt_t *restrict pkt, ikev2_sa_args_t *restrict sa_args,
+    boolean_t *restrict discard)
+{
+	pkt_notify_t *cookie = pkt_get_notify(pkt, IKEV2_N_COOKIE, NULL);
+
+	if (cookie == NULL)
+		return (B_FALSE);
+
+	if (cookie->pn_len > IKEV2_COOKIE_MAX) {
+		(void) bunyan_info(log,
+		    "Received IKEV2 COOKIE notification with oversized "
+		    "cookie value; ignoring",
+		    BUNYAN_T_UINT32, "cookielen", (uint32_t)cookie->pn_len,
+		    BUNYAN_T_END);
+		*discard = B_TRUE;
+		return (B_FALSE);
+	}
+
+	sa_args->i2a_cookielen = cookie->pn_len;
+	bcopy(cookie->pn_ptr, sa_args->i2a_cookie, cookie->pn_len);
+
+	return (B_TRUE);
+}
+
+static boolean_t
+redo_check_ke(pkt_t *restrict pkt, ikev2_sa_args_t *restrict sa_args,
+    boolean_t *restrict discard)
+{
+	pkt_notify_t *invalid_ke = NULL;
+	config_rule_t *rule = NULL;
+	uint16_t val = 0;
+	boolean_t match = B_FALSE;
+
+	invalid_ke = pkt_get_notify(pkt, IKEV2_N_INVALID_KE_PAYLOAD, NULL);
+	if (invalid_ke == NULL)
+		return (B_FALSE);
+
+	if (invalid_ke->pn_len != sizeof (uint16_t)) {
+		uint32_t len = invalid_ke->pn_len;
+
+		/* The notification does not have the correct format */
+		(void) bunyan_warn(log,
+		    "INVALID_KE_PAYLOAD notification does not include a "
+		    "16-bit DH group payload",
+		    BUNYAN_T_UINT32, "ntfylen", len, BUNYAN_T_END);
+
+		*discard = B_TRUE;
+		return (B_FALSE);
+	}
+
+	rule = pkt->pkt_sa->i2sa_rule;
+	val = BE_IN16(invalid_ke->pn_ptr);
+
+	for (size_t i = 0; rule->rule_xf[i] != NULL; i++) {
+		config_xf_t *xf = rule->rule_xf[i];
+
+		if (val == xf->xf_dh) {
+			match = B_TRUE;
+			break;
+		}
+	}
+
+	if (!match) {
+		(void) bunyan_info(log,
+		    "Received INVALID_KE_PAYLOAD notification with "
+		    "unacceptable group; ignoring",
+		    BUNYAN_T_UINT32, "groupval", (uint32_t)val,
+		    BUNYAN_T_STRING, "group", ikev2_dh_str(val),
+		    BUNYAN_T_END);
+		*discard = B_TRUE;
+		return (B_FALSE);
+	}
+
+	pkcs11_destroy_obj("dh_pubkey", &sa_args->i2a_pubkey);
+	pkcs11_destroy_obj("dh_privkey", &sa_args->i2a_privkey);
+	sa_args->i2a_dh = val;
+
+	return (B_TRUE);
+}
+
+/*
+ * If we get a cookie request or a new DH group in response to our
+ * initiated IKE_SA_INIT exchange, restart with the new parameters.  Returns
+ * B_TRUE if it has consumed pkt and further processing by caller of packet
+ * should stop (i.e. we are restarting the IKE_SA_INIT exchange, or the
+ * payload was bad), B_FALSE if the caller should continue processing.
+ *
+ * Since this packet is sent to us unprotected, it's treated mostly as advisory.
+ * If something's wrong with the packet, or if it is trying to get us to use
+ * a DH group our policy doesn't allow, we merely ignore the packet.  The
+ * worst case is that the larval IKE SA will timeout and be deleted.
+ *
+ */
+static boolean_t
+redo_sa_init(pkt_t *restrict pkt, ikev2_sa_args_t *restrict sa_args)
+{
+	ikev2_sa_t *sa = pkt->pkt_sa;
+	boolean_t discard = B_FALSE;
+	boolean_t redo = B_FALSE;
+
+	redo |= redo_check_cookie(pkt, sa_args, &discard);
+	if (discard) {
+		ikev2_pkt_free(pkt);
+		return (B_TRUE);
+	}
+
+	redo |= redo_check_ke(pkt, sa_args, &discard);
+	if (discard) {
+		ikev2_pkt_free(pkt);
+		return (B_TRUE);
+	}
+
+	if (!redo)
+		return (B_FALSE);
+
+	/*
+	 * If we're restarting the IKE_SA_INIT exchange, we must always start
+	 * with msgid 0.
+	 */
+	sa->outmsgid = 0;
+
+	/* Discard old request since we're restarting with new parameters */
+	ikev2_sa_clear_req(sa, &sa->last_req);
+
+	(void) bunyan_debug(log,
+	    "Response requested new parameters; "
+	    "restarting IKE_SA_INIT exchange",
+	    BUNYAN_T_END);
+
+	ikev2_sa_init_init(sa, sa_args->i2a_pmsg);
+	ikev2_pkt_free(pkt);
+	return (B_TRUE);
+}
+
+static config_rule_t *
+find_rule(sockaddr_u_t laddr, sockaddr_u_t raddr)
+{
+	config_rule_t *rule = config_get_rule(laddr, raddr);
+
+	if (rule == NULL) {
+		(void) bunyan_warn(log, "No rules found for address",
+		    BUNYAN_T_END);
+		return (NULL);
+	}
+
+	if (rule->rule_xf == NULL || rule->rule_xf[0] == NULL) {
+		(void) bunyan_debug(log, "No transforms found in rue",
+		    BUNYAN_T_END);
+		CONFIG_REFRELE(rule->rule_config);
+		return (NULL);
+	}
+
+	VERIFY3P(rule->rule_config, !=, NULL);
+	return (rule);
+}
+
+/* Compute a NAT detection payload and place result into buf */
+static boolean_t
+compute_nat(uint64_t *restrict spi, struct sockaddr *restrict addr,
+    uint8_t *restrict buf, size_t buflen)
+{
+	const char *p11f = NULL;
+	CK_SESSION_HANDLE h = p11h();
+	CK_MECHANISM mech = {
+		.mechanism = CKM_SHA_1,
+		.pParameter = NULL_PTR,
+		.ulParameterLen = 0
+	};
+	CK_BYTE_PTR addrp = (CK_BYTE_PTR)ss_addr(addr);
+	CK_ULONG len = buflen;
+	CK_RV ret = CKR_OK;
+	size_t addrlen = ss_addrlen(addr);
+	uint16_t port = htons((uint16_t)ss_port(addr));
+
+	VERIFY3U(buflen, >=, IKEV2_N_NAT_SIZE);
+	VERIFY(addr->sa_family == AF_INET || addr->sa_family == AF_INET6);
+
+	p11f = "C_DigestInit";
+	ret = C_DigestInit(h, &mech);
+	if (ret != CKR_OK)
+		goto fail;
+
+	/* Both SPIs (in order) */
+	p11f = "C_DigestUpdate";
+	ret = C_DigestUpdate(h, (CK_BYTE_PTR)spi, 2 * sizeof (uint64_t));
+	if (ret != CKR_OK)
+		goto fail;
+
+	ret = C_DigestUpdate(h, addrp, addrlen);
+	if (ret != CKR_OK)
+		goto fail;
+
+	ret = C_DigestUpdate(h, (CK_BYTE_PTR)&port, sizeof (port));
+	if (ret != CKR_OK)
+		goto fail;
+
+	p11f = "C_DigestFinal";
+	ret = C_DigestFinal(h, buf, &len);
+	if (ret != CKR_OK)
+		goto fail;
+
+	return (B_TRUE);
+
+fail:
+	PKCS11ERR(error, p11f, ret);
+	return (B_FALSE);
+}
+
+/*
+ * Perform NAT detection and update IKEV2 SA accordingly.  Return B_FALSE on
+ * error, B_TRUE if no error.
+ */
+static boolean_t
+check_nats(pkt_t *pkt)
+{
+	ikev2_sa_t *sa = pkt->pkt_sa;
+	struct {
+		ikev2_notify_type_t	ntype;
+		struct sockaddr		*addr;
+		const char		*msg;
+		uint32_t		flag;
+	} params[] = {
+		/*
+		 * Since these are from the perspective of the remote system,
+		 * we check the local address against the NAT destination IP
+		 * and vice versa.
+		 */
+		{
+			IKEV2_N_NAT_DETECTION_DESTINATION_IP,
+			SSTOSA(&pkt->pkt_sa->laddr),
+			"Local NAT detected",
+			I2SA_NAT_LOCAL
+		},
+		{
+			IKEV2_N_NAT_DETECTION_SOURCE_IP,
+			SSTOSA(&pkt->pkt_sa->raddr),
+			"Remote NAT detected",
+			I2SA_NAT_REMOTE
+		}
+	};
+
+	/*
+	 * RFC7296 2.23 goes into more detail, but briefly, each side
+	 * generates an SHA1 hash of the packet SPIs (in the order they
+	 * appear in the header), the IP address of the source/destination
+	 * (based on which NAT payload is being constructed) and port number.
+	 * It is permissible that an implementation may include multiple
+	 * NAT_DETECTION_SOURCE_IP payloads if the host has multiple addresses
+	 * and is unsure which one was used to send the datagram.
+	 *
+	 * We perform the same hash (using the IP and port we see) and if
+	 * there are no matches, then the side (local/remote) being checked
+	 * is behind a NAT.  If either side is behind a NAT,  we switch to
+	 * using the NATT port (4500) for all subsequent traffic.
+	 *
+	 * While the presense of a NAT on one side of the connection is all
+	 * that is necessary to switch to NAT traversal mode, we still
+	 * retain knowledge of which side is behind the NAT as we will
+	 * (eventually) want to enable UDP keepalives when we are the ones
+	 * behind a NAT.
+	 */
+	for (size_t i = 0; i < ARRAY_SIZE(params); i++) {
+		pkt_notify_t *n = pkt_get_notify(pkt, params[i].ntype, NULL);
+		uint8_t data[IKEV2_N_NAT_SIZE] = { 0 };
+		boolean_t match = B_FALSE;
+
+		/* If notification isn't present, assume no NAT */
+		if (n == NULL)
+			continue;
+
+		if (!compute_nat(pkt->pkt_raw, params[i].addr, data,
+		    sizeof (data)))
+			return (B_FALSE);
+
+		while (n != NULL) {
+			/*
+			 * Ignore the proto (satype) and SPI values.  RFC7296
+			 * is somewhat unclear here -- RFC4718 suggests that
+			 * most notifications do not use the proto or SPI
+			 * fields of the notification (which then by RFC7296
+			 * 3.10 means they MUST be ignored).  We have no
+			 * use for them for NAT detection, so we will opt
+			 * to ignore them.
+			 */
+			if (n->pn_len != IKEV2_N_NAT_SIZE) {
+				(void) bunyan_error(log,
+				    "NAT notification size mismatch",
+				    BUNYAN_T_STRING, "notification",
+				    ikev2_notify_str(params[i].ntype),
+				    BUNYAN_T_UINT32, "notifylen",
+				    (uint32_t)n->pn_len,
+				    BUNYAN_T_UINT32, "expected",
+				    (uint32_t)IKEV2_N_NAT_SIZE,
+				    BUNYAN_T_END);
+				return (B_FALSE);
+			}
+
+			if (memcmp(data, n->pn_ptr, IKEV2_N_NAT_SIZE) == 0) {
+				match = B_TRUE;
+				break;
+			}
+
+			n = pkt_get_notify(pkt, params[i].ntype, n);
+		}
+
+		if (!match) {
+			sa->flags |= params[i].flag;
+			(void) bunyan_debug(log, params[i].msg, BUNYAN_T_END);
+		}
+	}
+
+	/* Switch to using the NAT port if either side is NATted */
+	if (I2SA_IS_NAT(sa)) {
+		sockaddr_u_t local_addr = { .sau_ss = &sa->laddr };
+		sockaddr_u_t remote_addr = { .sau_ss = &sa->raddr };
+
+		VERIFY3S(local_addr.sau_ss->ss_family, ==,
+		    remote_addr.sau_ss->ss_family);
+
+		/*
+		 * While sendfromto() uses the source port of the bound socket
+		 * when sending, we still update local and remote for
+		 * clarity
+		 */
+		switch (local_addr.sau_ss->ss_family) {
+		case AF_INET:
+			local_addr.sau_sin->sin_port = htons(IPPORT_IKE_NATT);
+			remote_addr.sau_sin->sin_port = htons(IPPORT_IKE_NATT);
+			break;
+		case AF_INET6:
+			local_addr.sau_sin6->sin6_port = htons(IPPORT_IKE_NATT);
+			remote_addr.sau_sin6->sin6_port =
+			    htons(IPPORT_IKE_NATT);
+			break;
+		default:
+			INVALID(ss_family);
+		}
+	}
+
+	return (B_TRUE);
+}
+
+/*
+ * RFC7296 2.23 -- Add NAT detection notifiation payloads.  The notification
+ * payload consists of the SHA-1 has of the SPIs (in order as they appear in
+ * the header), IP address, and port.
+ */
+static boolean_t
+add_nat(pkt_t *pkt)
+{
+	ikev2_sa_t *sa = pkt->pkt_sa;
+	struct {
+		ikev2_notify_type_t	ntype;
+		struct sockaddr		*addr;
+	} params[] = {
+		/*
+		 * Since these are from our perspective, the local address
+		 * corresponds to the source address and remote to the
+		 * destination address.
+		 */
+		{
+			IKEV2_N_NAT_DETECTION_SOURCE_IP,
+			SSTOSA(&pkt->pkt_sa->laddr),
+		},
+		{
+			IKEV2_N_NAT_DETECTION_DESTINATION_IP,
+			SSTOSA(&pkt->pkt_sa->raddr),
+		}
+	};
+
+	for (int i = 0; i < ARRAY_SIZE(params); i++) {
+		uint8_t data[IKEV2_N_NAT_SIZE] = { 0 };
+
+		/* The SPIs are always at the start of the packet */
+		if (!compute_nat(pkt->pkt_raw, params[i].addr, data,
+		    sizeof (data)))
+			return (B_FALSE);
+
+		if (!ikev2_add_notify_full(pkt, IKEV2_PROTO_NONE, 0,
+		    params[i].ntype, data, sizeof (data)))
+			return (B_FALSE);
+	}
+	return (B_TRUE);
+}
+
+static void
+check_vendor(pkt_t *pkt)
+{
+	ikev2_sa_t *sa = pkt->pkt_sa;
+	pkt_payload_t *pay = NULL;
+
+	for (pay = pkt_get_payload(pkt, IKEV2_PAYLOAD_VENDOR, NULL);
+	    pay != NULL;
+	    pay = pkt_get_payload(pkt, IKEV2_PAYLOAD_VENDOR, pay)) {
+		if (pay->pp_len != sizeof (VENDOR_STR_ILLUMOS_1))
+			continue;
+
+		if (memcmp(VENDOR_STR_ILLUMOS_1, pay->pp_ptr,
+		    sizeof (VENDOR_STR_ILLUMOS_1)) == 0) {
+			(void) bunyan_debug(log,
+			    "Found illumos_1 vendor payload", BUNYAN_T_END);
+			sa->vendor = VENDOR_ILLUMOS_1;
+		}
+	}
+}
+
+static boolean_t
+add_vendor(pkt_t *pkt)
+{
+	return (ikev2_add_vendor(pkt, (uint8_t *)VENDOR_STR_ILLUMOS_1,
+	    sizeof (VENDOR_STR_ILLUMOS_1)));
+}
+
+static boolean_t
+add_cookie(pkt_t *restrict pkt, void *restrict cookie, size_t len)
+{
+	if (cookie == NULL || len == 0)
+		return (B_TRUE);
+
+	/* Should be the first payload */
+	VERIFY3U(pkt->pkt_payload_count, ==, 0);
+
+	return (ikev2_add_notify_full(pkt, IKEV2_PROTO_NONE, 0, IKEV2_N_COOKIE,
+	    cookie, len));
+}
+
+static size_t
+skeyseed_noncelen(ikev2_prf_t prf, size_t len)
+{
+	switch (prf) {
+	/*
+	 * RFC7296 2.14 - For these PRFs, only the first 64 bits of Ni and Nr
+	 * are used when calculating skeyseed, though all bits are used for
+	 * the prf+ function
+	 */
+	case IKEV2_PRF_AES128_XCBC:
+	case IKEV2_PRF_AES128_CMAC:
+		if (len > 8)
+			return (8);
+		/*FALLTHRU*/
+	default:
+		return (len);
+	}
+}
+
+/* Create a PKCS#11 object of Ni | Nr */
+static boolean_t
+create_nonceobj(ikev2_prf_t prf, ikev2_sa_args_t *restrict sa_args,
+    CK_OBJECT_HANDLE_PTR restrict objp)
+{
+	CK_MECHANISM_TYPE p11_prf = ikev2_prf_to_p11(prf);
+	size_t ni_len = skeyseed_noncelen(prf, sa_args->i2a_nonce_i_len);
+	size_t nr_len = skeyseed_noncelen(prf, sa_args->i2a_nonce_r_len);
+	size_t noncelen = MAX(ni_len + nr_len, ikev2_prf_outlen(prf));
+	uint8_t nonce[noncelen];
+	CK_RV rc;
+
+	bzero(nonce, noncelen);
+	bcopy(sa_args->i2a_nonce_i, nonce, ni_len);
+	bcopy(sa_args->i2a_nonce_r, nonce + ni_len, nr_len);
+
+	rc = SUNW_C_KeyToObject(p11h(), p11_prf, nonce, noncelen, objp);
+
+	if (rc != CKR_OK) {
+		PKCS11ERR(error, "SUNW_C_KeyToObject", rc,
+		    BUNYAN_T_STRING, "objname", "Ni|Nr");
+	} else if (show_keys) {
+		size_t hexlen = noncelen * 2 + 1;
+		char hex[hexlen];
+
+		bzero(hex, hexlen);
+		writehex(nonce, noncelen, "", hex, hexlen);
+
+		/*
+		 * This really isn't a key and is already sent in plaintext,
+		 * but can't hurt to be consistent.
+		 */
+		(void) bunyan_debug(log, "Ni|Nr",
+		    BUNYAN_T_STRING, "key", hex,
+		    BUNYAN_T_END);
+
+		explicit_bzero(hex, hexlen);
+	}
+
+	explicit_bzero(nonce, noncelen);
+	return ((rc == CKR_OK) ? B_TRUE : B_FALSE);
+}
+
+static boolean_t
+create_skeyseed(ikev2_sa_t *restrict sa, CK_OBJECT_HANDLE nonce,
+    CK_OBJECT_HANDLE_PTR restrict keyp)
+{
+	void *dh_key = NULL;
+	size_t dh_len = 0;
+	size_t skeyseed_len = ikev2_prf_outlen(sa->prf);
+	CK_SESSION_HANDLE h = p11h();
+	CK_OBJECT_HANDLE dhkey_h = sa->sa_init_args->i2a_dhkey;
+	CK_RV rc = CKR_OK;
+	boolean_t ok = B_TRUE;
+	/* The largest prf output (SHA512) is 64 bytes */
+	uint8_t skeyseed[skeyseed_len];
+
+	/*
+	 * Unfortunately, to generate SKEYSEED, we need to copy down the g^ir
+	 * value to perform the prf function since there is no C_SignKey
+	 * function in PKCS#11. As such we try to keep the value in memory for
+	 * as short a time as possible.
+	 */
+	rc = pkcs11_ObjectToKey(h, dhkey_h, &dh_key, &dh_len, B_FALSE);
+	if (rc != CKR_OK) {
+		PKCS11ERR(error, "pkcs11_ObjectToKey", rc,
+		    BUNYAN_T_STRING, "objname", "dh_key");
+		goto fail;
+	}
+
+	/*
+	 * RFC7296 2.14:
+	 *	SKEYSEED = prf(Ni | Nr, g^ir)
+	 */
+	ok = prf(sa->prf, nonce, skeyseed, skeyseed_len, dh_key, dh_len, NULL);
+	explicit_bzero(dh_key, dh_len);
+	free(dh_key);
+	dh_key = NULL;
+	dh_len = 0;
+
+	if (!ok)
+		goto fail;
+
+	rc = SUNW_C_KeyToObject(h, ikev2_prf_to_p11(sa->prf), skeyseed,
+	    skeyseed_len, keyp);
+
+	if (rc != CKR_OK) {
+		PKCS11ERR(error, "SUNW_C_KeyToObject", rc,
+		    BUNYAN_T_STRING, "objname", "skeyseed");
+		goto fail;
+	} else {
+		size_t hexlen = skeyseed_len * 2 + 1;
+		char hex[hexlen];
+
+		bzero(hex, hexlen);
+		if (show_keys)
+			writehex(skeyseed, skeyseed_len, "", hex, hexlen);
+
+		(void) bunyan_debug(log, "Created SKEYSEED",
+		    show_keys ? BUNYAN_T_STRING : BUNYAN_T_END, "key", hex,
+		    BUNYAN_T_END);
+
+		explicit_bzero(hex, hexlen);
+	}
+
+	explicit_bzero(skeyseed, skeyseed_len);
+	return (B_TRUE);
+
+fail:
+	if (dh_key != NULL) {
+		explicit_bzero(dh_key, dh_len);
+		free(dh_key);
+	}
+	explicit_bzero(skeyseed, skeyseed_len);
+	return (B_FALSE);
+}
+
+static boolean_t
+ikev2_sa_keygen(ikev2_sa_match_t *restrict result, pkt_t *restrict resp)
+{
+	ikev2_sa_t *sa = resp->pkt_sa;
+	ikev2_sa_args_t *sa_args = sa->sa_init_args;
+	CK_OBJECT_HANDLE nonce = CK_INVALID_HANDLE;
+	CK_OBJECT_HANDLE skeyseed = CK_INVALID_HANDLE;
+	boolean_t ret = B_FALSE;
+
+	ikev2_save_i2sa_results(sa, result);
+
+	if (!create_nonceobj(result->ism_prf, sa_args, &nonce))
+		goto done;
+	if (!create_skeyseed(sa, nonce, &skeyseed))
+		goto done;
+	pkcs11_destroy_obj("Ni|Nr", &nonce);
+
+	ret = ikev2_create_i2sa_keys(sa, skeyseed,
+	    sa_args->i2a_nonce_i, sa_args->i2a_nonce_i_len,
+	    sa_args->i2a_nonce_r, sa_args->i2a_nonce_r_len);
+
+done:
+	/*
+	 * pkcs11_destroy_obj sets the object handle to CK_INVALID_HANDLE
+	 * after destruction, so subsequent calls w/ the same var are a
+	 * no-op
+	 */
+	pkcs11_destroy_obj("Ni|Nr", &nonce);
+	pkcs11_destroy_obj("skeyseed", &skeyseed);
+	return (ret);
+}
+
+/*
+ * Save the contents of the IKE_SA_INIT packets so that we can sign/verify
+ * in the IKE_AUTH exchange
+ */
+static boolean_t
+ikev2_save_init_pkt(ikev2_sa_args_t *restrict i2a, pkt_t *restrict pkt)
+{
+	uint8_t **pktp = NULL;
+	size_t *lenp = NULL;
+	size_t len = pkt_len(pkt);
+
+	if (!ikev2_pkt_done(pkt)) {
+		(void) bunyan_error(log, "Packet not done", BUNYAN_T_END);
+		return (B_FALSE);
+	}
+
+	if (I2P_INITIATOR(pkt)) {
+		pktp = &i2a->i2a_init_i;
+		lenp = &i2a->i2a_init_i_len;
+	} else {
+		pktp = &i2a->i2a_init_r;
+		lenp = &i2a->i2a_init_r_len;
+	}
+
+	if (*pktp != NULL) {
+		umem_free(*pktp, *lenp);
+		*pktp = NULL;
+		*lenp = 0;
+	}
+
+	if ((*pktp = umem_alloc(len, UMEM_DEFAULT)) == NULL) {
+		STDERR(error, "No memory to perform IKE_SA_INIT exchange");
+		return (B_FALSE);
+	}
+	*lenp = len;
+	bcopy(pkt_start(pkt), *pktp, len);
+
+	return (B_TRUE);
+}
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/inbound.c b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/inbound.c
new file mode 100644
index 0000000000..f614d758e9
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/inbound.c
@@ -0,0 +1,248 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the "License").
+ * You may not use this file except in compliance with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ */
+
+/*
+ * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ *
+ * Copyright 2017 Jason King.
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+#include <arpa/inet.h>
+#include <bunyan.h>
+#include <inttypes.h>
+#include <err.h>
+#include <errno.h>
+#include <ipsec_util.h>
+#include <locale.h>
+#include <netinet/in.h>
+#include <netinet/udp.h>
+#include <note.h>
+#include <port.h>
+#include <string.h>
+#include <sys/debug.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <thread.h>
+#include "inbound.h"
+#include "defs.h"
+#include "fromto.h"
+#include "ikev1.h"
+#include "ikev2.h"
+#include "ikev2_pkt.h"
+#include "ikev2_proto.h"
+#include "worker.h"
+
+int ikesock4 = -1;
+int ikesock6 = -1;
+int nattsock = -1;
+
+static void
+inbound(int s)
+{
+	pkt_t *pkt = NULL;
+	struct sockaddr_storage to = { 0 };
+	struct sockaddr_storage from = { 0 };
+	socklen_t tolen = sizeof (to);
+	socklen_t fromlen = sizeof (from);
+	ssize_t pktlen;
+
+	VERIFY(IS_WORKER);
+
+	(void) memset(worker->w_buf, 0, sizeof (worker->w_buf));
+	pktlen = recvfromto(s, worker->w_buf, sizeof (worker->w_buf), 0, &from,
+	    &fromlen, &to, &tolen);
+
+	/*
+	 * Once we've received the datagram, re-arm socket so other threads
+	 * can receive datagrams from this socket.
+	 */
+	schedule_socket(s, inbound);
+
+	/* recvfromto() should have dumped enough debug info */
+	if (pktlen == -1)
+		return;
+
+	/* recvfromto() should discard truncated packets, if not, it's a bug */
+	VERIFY3U(pktlen, >=, sizeof (ike_header_t));
+
+	/* sanity checks */
+	ike_header_t *hdr = (ike_header_t *)worker->w_buf;
+	size_t hdrlen = ntohl(hdr->length);
+
+	key_add_ike_version(LOG_KEY_VERSION, hdr->version);
+	(void) bunyan_key_add(log,
+	    BUNYAN_T_UINT32, LOG_KEY_MSGID, ntohl(hdr->msgid),
+	    BUNYAN_T_END);
+
+	if (hdrlen != pktlen) {
+		(void) bunyan_info(log,
+		    "ISAKMP/IKE header length doesn't match received length",
+		    BUNYAN_T_UINT32, "hdrlen", (uint32_t)hdrlen,
+		    BUNYAN_T_UINT32, "pktlen", (uint32_t)pktlen,
+		    BUNYAN_T_END);
+		return;
+	}
+
+	switch (hdr->version) {
+	case IKEV1_VERSION:
+		/* XXX: Until we support V1 */
+		(void) bunyan_info(log, "Discarding ISAKMP/IKEV1 packet",
+		    BUNYAN_T_END);
+		return;
+	case IKEV2_VERSION:
+		pkt = ikev2_pkt_new_inbound(worker->w_buf, pktlen);
+		if (pkt == NULL)
+			return;
+		ikev2_inbound(pkt, SSTOSA(&from), SSTOSA(&to));
+		return;
+	default:
+		(void) bunyan_info(log, "Unsupported ISAKMP/IKE version",
+		    BUNYAN_T_END);
+		return;
+	}
+}
+
+void
+schedule_socket(int fd, void (*cb)(int))
+{
+	if (port_associate(wk_evport, PORT_SOURCE_FD, fd, POLLIN,
+	    (void *)cb) < 0) {
+		STDERR(error, "port_associate() failed",
+		    BUNYAN_T_INT32, "fd", (int32_t)fd,
+		    BUNYAN_T_END);
+
+		/*
+		 * If port_associate() fails, we'll stop receiving messages
+		 * in the corresponding socket, so no use in trying to stay
+		 * alive.
+		 *
+		 * XXX: abort() instead of exit()?
+		 */
+		exit(EXIT_FAILURE);
+	}
+}
+
+static int
+udp_listener_socket(sa_family_t af, uint16_t port, boolean_t natt)
+{
+	struct sockaddr_storage storage = { 0 };
+	sockaddr_u_t sau = { .sau_ss = &storage };
+	size_t socksize = 0;
+	int sock = -1;
+	int yes = 1;
+	ipsec_req_t ipsr = { 0 };
+
+	/* natt can only be true for AF_INET sockets */
+	VERIFY(af == AF_INET || !natt);
+
+	ipsr.ipsr_ah_req = ipsr.ipsr_esp_req = IPSEC_PREF_NEVER;
+
+	switch (af) {
+	case AF_INET:
+		socksize = sizeof (struct sockaddr_in);
+		break;
+	case AF_INET6:
+		socksize = sizeof (struct sockaddr_in6);
+		break;
+	default:
+		INVALID("af");
+	}
+
+	if ((sock = socket(af, SOCK_DGRAM, 0)) == -1) {
+		STDERR(fatal, "socket(af, SOCK_DGRAM) call failed",
+		    BUNYAN_T_STRING, "af", afstr(af),
+		    BUNYAN_T_END);
+		exit(EXIT_FAILURE);
+	}
+
+	sau.sau_ss->ss_family = af;
+	/* Exploit that sin_port and sin6_port live at the same offset. */
+	sau.sau_sin->sin_port = htons(port);
+	if (bind(sock, sau.sau_sa, socksize) == -1) {
+		STDERR(fatal, "bind(fd, addr) failed",
+		    BUNYAN_T_INT32, "fd", (int32_t)sock,
+		    ss_bunyan(sau.sau_sa), "addr", ss_addr(sau.sau_sa),
+		    BUNYAN_T_UINT32, "port", ss_port(sau.sau_sa),
+		    BUNYAN_T_END);
+		exit(EXIT_FAILURE);
+	}
+
+	switch (af) {
+	case AF_INET:
+		/* Make sure we can receive the destination address */
+		if (setsockopt(sock, IPPROTO_IP, IP_RECVDSTADDR,
+		    (const void *)&yes, sizeof (yes)) == -1)
+			err(EXIT_FAILURE, "%s: setsockopt(IP_RECVDSTADDR)",
+			    __func__);
+
+		if (setsockopt(sock, IPPROTO_IP, IP_SEC_OPT,
+		    (const void *)&ipsr, sizeof (ipsr)) == -1)
+			err(EXIT_FAILURE, "%s: setsockopt(IP_SEC_OPT)",
+			    __func__);
+		break;
+	case AF_INET6:
+		if (setsockopt(sock, IPPROTO_IPV6, IPV6_RECVPKTINFO,
+		    (const void *)&yes, sizeof (yes)) == -1)
+			err(EXIT_FAILURE, "%s: setsockopt(IPV6_RECVPKTINFO)",
+			    __func__);
+
+		if (setsockopt(sock, IPPROTO_IPV6, IPV6_SEC_OPT,
+		    (const void *)&ipsr, sizeof (ipsr)) == -1)
+			err(EXIT_FAILURE, "%s: setsockopt(IPV6_SEC_OPT)",
+			    __func__);
+		break;
+	default:
+		INVALID(af);
+	}
+
+	/* Setup IPv4 NAT Traversal */
+	if (natt) {
+		int nat_t = 1;
+
+		if (setsockopt(sock, IPPROTO_UDP, UDP_NAT_T_ENDPOINT,
+		    &nat_t, sizeof (nat_t)) == -1)
+			err(EXIT_FAILURE, "%s: setsockopt(IPPROTO_UDP, "
+			    "UDP_NAT_T_ENDPOINT", __func__);
+	}
+
+	(void) bunyan_trace(log, "UDP socket created",
+	    BUNYAN_T_INT32, "fd", (int32_t)sock,
+	    BUNYAN_T_STRING, "af", afstr(af),
+	    BUNYAN_T_UINT32, "port", (uint32_t)port,
+	    BUNYAN_T_BOOLEAN, "natt", natt,
+	    BUNYAN_T_END);
+
+	return (sock);
+}
+
+void
+inbound_init(void)
+{
+	ikesock4 = udp_listener_socket(AF_INET, IPPORT_IKE, B_FALSE);
+	nattsock = udp_listener_socket(AF_INET, IPPORT_IKE_NATT, B_TRUE);
+	ikesock6 = udp_listener_socket(AF_INET6, IPPORT_IKE, B_FALSE);
+
+	schedule_socket(ikesock4, inbound);
+	schedule_socket(nattsock, inbound);
+	schedule_socket(ikesock6, inbound);
+}
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/inbound.h b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/inbound.h
new file mode 100644
index 0000000000..37f807be02
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/inbound.h
@@ -0,0 +1,35 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2015 Jason King.
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+#ifndef _INBOUND_H
+#define	_INBOUND_H
+
+#include <inttypes.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern int ikesock4, ikesock6, nattsock;
+
+void schedule_socket(int, void (*)(int));
+void inbound_init(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _INBOUND_H */
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/main.c b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/main.c
new file mode 100644
index 0000000000..6b1eb765fc
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/main.c
@@ -0,0 +1,490 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+#include <bunyan.h>
+#include <errno.h>
+#include <err.h>
+#include <fcntl.h>
+#include <locale.h>
+#include <libgen.h>
+#include <netinet/in.h>
+#include <paths.h>
+#include <port.h>
+#include <signal.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/debug.h>
+#include <sys/resource.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <thread.h>
+#include <unistd.h>
+#include "config.h"
+#include "defs.h"
+#include "defs.h"
+#include "ikev2_cookie.h"
+#include "ikev2_sa.h"
+#include "inbound.h"
+#include "pkcs11.h"
+#include "preshared.h"
+#include "worker.h"
+
+typedef struct lockingfd {
+	mutex_t lf_lock;
+	int	lf_fd;
+} lockingfd_t;
+
+extern void pkt_init(void);
+extern void pkt_fini(void);
+extern void pfkey_init(void);
+static void signal_init(void);
+static void event(event_t, void *);
+static void do_signal(int);
+static void main_loop(int);
+static int ikev2_daemonize(void);
+
+static void do_immediate(void);
+
+static boolean_t done;
+static thread_t signal_tid;
+
+__thread bunyan_logger_t *log = NULL;
+bunyan_logger_t *main_log = NULL;
+int main_port = -1;
+
+lockingfd_t fdlock = {
+    .lf_lock = ERRORCHECKMUTEX,
+    .lf_fd = STDOUT_FILENO
+};
+
+
+/*
+ * XXX: Both ipseckey(1M) and ikeadm(1M) have the ability to show actual key
+ * values.  in.iked(1M) also has the notion of a privilege level (not to
+ * be confused with privileges(5)) where one can prevent it from ever disclosing
+ * key material and to change the setting requires a restart.  We'll probably
+ * want similar functionality and this setting will get weaved into that.
+ */
+boolean_t show_keys = B_TRUE; /* XXX XXX Change before putback! */
+
+static void
+usage(const char *name)
+{
+	(void) fprintf(stderr, "Usage: %s [-d] [-f cfgfile]\n"
+	    "      %s -c [-f cfgfile]\n", name, name);
+	exit(1);
+}
+
+#ifdef	DEBUG
+const char *
+_umem_debug_init(void)
+{
+	return ("default,verbose");
+}
+
+const char *
+_umem_logging_init(void)
+{
+	return ("fail,contents");
+}
+#else
+const char *
+_umem_debug_init(void)
+{
+	return ("guards");
+}
+#endif
+
+static int
+nofail_cb(void)
+{
+	/*
+	 * XXX Do we want to control behavior (abort vs exit) based on
+	 * debug/non-debug, configuration or a SMF parameter?
+	 *
+	 * In general, we try to recover or just abort the specific operation
+	 * we're attempting if we cannot allocate memory and let everything else
+	 * continue as much as we can (saving the nofail allocations largely for
+	 * startup).  It may be more desirable to exit or abort and let SMF
+	 * try to recover things if we get to this point (subject to sanity
+	 * checks -- e.g. that we're not allowing a remote peer to get us
+	 * to allocate 1Tb of ram, etc.).
+	 */
+	assfail("Out of memory", __FILE__, __LINE__);
+	/*NOTREACHED*/
+	return (UMEM_CALLBACK_EXIT(EXIT_FAILURE));
+}
+
+/*
+ * A temporary workaround to serialize writing to the same fd by multiple
+ * bunyan children
+ */
+static int
+lockingfd_log(nvlist_t *nvl, const char *js, void *arg)
+{
+	lockingfd_t *lf = arg;
+	int ret;
+
+	mutex_enter(&lf->lf_lock);
+	ret = bunyan_stream_fd(nvl, js, (void *)(uintptr_t)lf->lf_fd);
+	mutex_exit(&lf->lf_lock);
+	return (ret);
+}
+
+int
+main(int argc, char **argv)
+{
+	FILE *f = NULL;
+	char *cfgfile = "/etc/inet/ike/config";
+	struct rlimit rlim;
+	int c, rc;
+	int fd = -1;
+	boolean_t debug_mode = B_FALSE;
+	boolean_t check_cfg = B_FALSE;
+
+	(void) setlocale(LC_ALL, "");
+#if !defined(TEXT_DOMAIN)
+#define	TEXT_DOMAIN "SYS_TEST"
+#endif
+	(void) textdomain(TEXT_DOMAIN);
+
+	umem_nofail_callback(nofail_cb);
+
+	rlim.rlim_cur = RLIM_INFINITY;
+	rlim.rlim_max = RLIM_INFINITY;
+	(void) setrlimit(RLIMIT_CORE, &rlim);
+
+	while ((c = getopt(argc, argv, "cdf:")) != -1) {
+		switch (c) {
+		case 'd':
+			debug_mode = B_TRUE;
+			break;
+		case 'c':
+			check_cfg = B_TRUE;
+			break;
+		case 'f':
+			cfgfile = optarg;
+			break;
+		case '?':
+			(void) fprintf(stderr,
+			    "Unrecognized option: -%c\n", optopt);
+			usage(argv[0]);
+			break;
+		}
+	}
+
+	if (check_cfg && debug_mode) {
+		(void) fprintf(stderr, "-d and -c options cannot both be "
+		    "set\n");
+		usage(argv[0]);
+		return (EXIT_FAILURE);
+	}
+
+	if ((rc = bunyan_init(basename(argv[0]), &log)) < 0)
+		errx(EXIT_FAILURE, "bunyan_init() failed: %s", strerror(rc));
+
+	/* hard coded to TRACE just during development */
+	if ((rc = bunyan_stream_add(log, "stdout", BUNYAN_L_TRACE,
+	    lockingfd_log, &fdlock)) < 0) {
+		errx(EXIT_FAILURE, "bunyan_stream_add() failed: %s",
+		    strerror(rc));
+	}
+	main_log = log;
+
+	if ((f = fopen(cfgfile, "rF")) == NULL) {
+		STDERR(fatal, "cannot open config file",
+		    BUNYAN_T_STRING, "filename", cfgfile);
+		exit(EXIT_FAILURE);
+	}
+
+	process_config(f, check_cfg);
+
+	if (fclose(f) == EOF)
+		err(EXIT_FAILURE, "fclose(\"%s\") failed", cfgfile);
+
+	if (check_cfg)
+		return (EXIT_SUCCESS);
+
+	preshared_init(B_FALSE);
+
+	if (!debug_mode)
+		fd = ikev2_daemonize();
+
+	if ((main_port = port_create()) < 0) {
+		STDERR(fatal, "main port_create() failed");
+		exit(EXIT_FAILURE);
+	}
+
+	signal_init();
+	pkcs11_init();
+	pkt_init();
+	ikev2_sa_init();
+
+	/* XXX: make these configurable */
+	worker_init(8);
+	pfkey_init();
+	ikev2_cookie_init();
+	inbound_init();
+	main_loop(fd);
+
+	pkt_fini();
+	pkcs11_fini();
+	return (0);
+}
+
+/* Temp function to fire off IKE_SA_INIT exchanges */
+static void
+do_immediate(void)
+{
+	config_t *cfg = config_get();
+
+	for (size_t i = 0; cfg->cfg_rules[i] != NULL; i++) {
+		config_rule_t *rule = cfg->cfg_rules[i];
+
+		if (!rule->rule_immediate)
+			continue;
+
+		CONFIG_REFHOLD(cfg);	/* for worker */
+		VERIFY(worker_send_cmd(WC_START, rule));
+	}
+
+	CONFIG_REFRELE(cfg);
+}
+
+static void
+main_loop(int fd)
+{
+	port_event_t pe;
+	int rval = 0;
+
+	(void) write(fd, &rval, sizeof (rval));
+	(void) close(fd);
+
+	(void) bunyan_trace(log, "starting main loop", BUNYAN_T_END);
+
+	do_immediate();
+
+	/*CONSTCOND*/
+	while (!done) {
+		if (port_get(main_port, &pe, NULL) < 0) {
+			STDERR(error, "port_get() failed");
+			continue;
+		}
+
+		(void) bunyan_trace(log, "received event",
+		    BUNYAN_T_STRING, "source",
+		    port_source_str(pe.portev_source),
+		    BUNYAN_T_STRING, "event",
+		    event_str(pe.portev_events),
+		    BUNYAN_T_UINT32, "event num",
+		    (int32_t)pe.portev_events,
+		    BUNYAN_T_POINTER, "event arg", pe.portev_user,
+		    BUNYAN_T_END);
+
+		switch (pe.portev_source) {
+		case PORT_SOURCE_USER:
+			event(pe.portev_events, pe.portev_user);
+			break;
+
+		case PORT_SOURCE_ALERT:
+			break;
+
+		case PORT_SOURCE_TIMER: {
+			void (*fn)(void) = (void (*)(void))pe.portev_user;
+			fn();
+			break;
+		}
+		default:
+			INVALID(pe.portev_source);
+		}
+	}
+
+	(void) bunyan_info(log, "Exiting", BUNYAN_T_END);
+}
+
+static void
+event(event_t evt, void *arg)
+{
+	switch (evt) {
+	case EVENT_NONE:
+		return;
+	case EVENT_SIGNAL:
+		do_signal((int)(uintptr_t)arg);
+		break;
+	}
+}
+
+void
+reload(void)
+{
+}
+
+static int
+ikev2_daemonize(void)
+{
+	sigset_t set, oset;
+	pid_t child;
+	int dupfd, fds[2];
+
+	if (chdir("/") != 0)
+		err(EXIT_FAILURE, "chdir(\"/\") failed");
+
+	closefrom(STDERR_FILENO + 1);
+
+	if (pipe(fds) != 0)
+		err(EXIT_FAILURE, "Could not create pipe for daemonizing");
+
+	/*
+	 * Block everything except SIGABRT until the child is up and running
+	 * so the parent doesn't accidentially exit too soon.
+	 */
+	if (sigfillset(&set) != 0)
+		abort();
+	if (sigdelset(&set, SIGABRT) != 0)
+		abort();
+	if (thr_sigsetmask(SIG_SETMASK, &set, &oset) != 0)
+		abort();
+
+	if ((child = fork()) == -1)
+		err(EXIT_FAILURE, "Could not fork for daemonizing");
+
+	if (child != 0) {
+		int status;
+
+		(void) close(fds[1]);
+		if (read(fds[0], &status, sizeof (status)) == sizeof (status))
+			_exit(status);
+
+		if (waitpid(child, &status, 0) == child && WIFEXITED(status))
+			_exit(WEXITSTATUS(status));
+
+		_exit(EXIT_FAILURE);
+	}
+
+	/* XXX: Drop privileges */
+
+	if (close(fds[0]) != 0)
+		abort();
+	if (setsid() == -1)
+		abort();
+	if (thr_sigsetmask(SIG_SETMASK, &oset, NULL) != 0)
+		abort();
+
+	(void) umask(0022);
+
+	if ((dupfd = open(_PATH_DEVNULL, O_RDONLY)) < 0)
+		err(EXIT_FAILURE, "Could not open %s", _PATH_DEVNULL);
+	if (dup2(dupfd, STDIN_FILENO) == -1)
+		err(EXIT_FAILURE, "Could not dup stdin");
+
+	return (fds[1]);
+}
+
+static void
+do_signal(int signum)
+{
+	switch (signum) {
+	case SIGINT:
+	case SIGTERM:
+	case SIGQUIT:
+		done = B_TRUE;
+		break;
+	case SIGHUP:
+		reload();
+		break;
+	case SIGUSR1:
+		(void) worker_add();
+		break;
+	case SIGUSR2:
+		(void) worker_del();
+		break;
+	default:
+		break;
+	}
+}
+
+/*ARGSUSED*/
+static void *
+signal_thread(void *arg)
+{
+	char sigbuf[SIG2STR_MAX + 3]; /* add room for 'SIG' */
+	sigset_t sigset;
+	int signo;
+
+	log = arg;
+
+	(void) bunyan_trace(log, "signal thread awaiting signals",
+	    BUNYAN_T_END);
+
+	if (sigfillset(&sigset) != 0)
+		abort();
+	if (sigdelset(&sigset, SIGABRT) != 0)
+		abort();
+
+	/*CONSTCOND*/
+	while (1) {
+		if (sigwait(&sigset, &signo) != 0) {
+			STDERR(error, "sigwait() failed");
+			continue;
+		}
+
+		(void) memset(sigbuf, 0, sizeof (sigbuf));
+		(void) strlcat(sigbuf, "SIG", sizeof (sigbuf));
+		sig2str(signo, sigbuf + 3);
+
+		(void) bunyan_info(log, "signal received",
+		    BUNYAN_T_STRING, "signal", sigbuf,
+		    BUNYAN_T_INT32, "signum", (int32_t)signo,
+		    BUNYAN_T_END);
+
+		if (port_send(main_port, EVENT_SIGNAL,
+		    (void *)(uintptr_t)signo) < 0) {
+			STDERR(error, "port_send() failed");
+		}
+	}
+
+	/*NOTREACHED*/
+	return (NULL);
+}
+
+static void
+signal_init(void)
+{
+	bunyan_logger_t *child = NULL;
+	sigset_t nset;
+	int rc;
+
+	if (bunyan_child(log, &child, BUNYAN_T_END) != 0)
+		err(EXIT_FAILURE, "Cannot create signal thread logger");
+
+	(void) bunyan_trace(log, "Creating signal handling thread",
+	    BUNYAN_T_END);
+
+	/* block all signals in main thread */
+	if (sigfillset(&nset) != 0)
+		abort();
+	if (sigdelset(&nset, SIGABRT) != 0)
+		abort();
+
+	VERIFY0(thr_sigsetmask(SIG_SETMASK, &nset, NULL));
+
+	rc = thr_create(NULL, 0, signal_thread, child, THR_DETACHED,
+	    &signal_tid);
+	if (rc != 0) {
+		TSTDERR(rc, fatal,
+		    "Signal handling thread creation failed");
+		exit(EXIT_FAILURE);
+	}
+}
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/pfkey.c b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/pfkey.c
new file mode 100644
index 0000000000..3b8f3f7f37
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/pfkey.c
@@ -0,0 +1,1854 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the "License").
+ * You may not use this file except in compliance with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ */
+
+/*
+ * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ *
+ * Copyright 2017 Jason King.
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+#include <arpa/inet.h>
+#include <atomic.h>
+#include <bunyan.h>
+#include <errno.h>
+#include <locale.h>
+#include <note.h>
+#include <sys/list.h>
+#include <sys/types.h>
+#include <sys/stropts.h>	/* For I_NREAD */
+#include <sys/sysmacros.h>
+#include <ipsec_util.h>
+#include <netdb.h>
+#include <netinet/in.h>
+#include <net/pfkeyv2.h>
+#include <port.h>
+#include <stdio.h>
+#include <string.h>
+#include <strings.h>
+#include <synch.h>
+#include <time.h>
+#include "config.h"
+#include "defs.h"
+#include "ikev2.h"
+#include "ikev2_common.h"
+#include "ikev2_enum.h"
+#include "ikev2_pkt.h"
+#include "ikev2_sa.h"
+#include "inbound.h"
+#include "pfkey.h"
+#include "pkcs11.h"
+#include "worker.h"
+
+/*
+ * pf_key(7P) operates by exchanging messages over a special socket (creatively
+ * named pfkey in this file).  Our model is that worker threads that need to
+ * interact with the kernel's SADB via pfkey will create the appropriate
+ * message, and then use pfkey_send_msg() to send it to the kernel and receive
+ * it's response (or an error).  In the background there is a (currently)
+ * single dedicated thread for receiving pf_key(7P) messages from the kernel.
+ * This thread will match up replies with the requests sent via pfkey_send_msg()
+ * to determine the correct worker to wake up (as pfkey_send_msg() will block
+ * via a CV until it has either received a reply or has timed out).  Since
+ * pf_key(7P) is message and not stream based, once the socket is readable,
+ * (a dedicated event port waiting on a POLLIN event is used for this), the
+ * pfkey thread itself should never be blocked waiting for I/O.
+ *
+ * The kernel typically replies to a request within milliseconds,
+ * however certain operations (e.g. DUMP) can delay replies.  To prevent
+ * callers from possibly blocking forever (in case a reply was somehow missed,
+ * or dropped), a timeout is defined that should be long enough for any DUMP
+ * operation to complete.  Any request that takes longer than this should be
+ * considered failed by the caller.
+ *
+ * The current timeout value is a guess, and might need to be adjusted based
+ * on live experience.
+ */
+#define	PFKEY_TIMEOUT	5	/* in seconds */
+
+#define	PFKEY_K_SRCADDR	"sadb_src_addr"
+#define	PFKEY_K_DSTADDR	"sadb_dst_addr"
+#define	PFKEY_K_ISRCADDR "sadb_inner_src_addr"
+#define	PFKEY_K_IDSTADDR "sadb_inner_dst_addr"
+#define	PFKEY_K_NLOC "sadb_natt_loc"
+#define	PFKEY_K_NREM "sadb_natt_rem"
+#define	PFKEY_K_SPI "sadb_sa_spi"
+#define	PFKEY_K_AUTH "sadb_sa_auth"
+#define	PFKEY_K_ENCR "sadb_sa_encr"
+#define	PFKEY_K_PORT "_port"
+#define	PFKEY_K_PAIR "sadb_pair_spi"
+#define	PFKEY_K_ENCR_KEY "encr_key"
+#define	PFKEY_K_ENCR_KEYLEN "encr_keylen"
+#define	PFKEY_K_AUTH_KEY "auth_key"
+#define	PFKEY_K_AUTH_KEYLEN "auth_keylen"
+#define	PFKEY_K_FLAGS "sadb_sa_flags"
+#define	PFKEY_K_KMC_PROTO "kmc_proto"
+#define	PFKEY_K_KMC_COOKIE "kmc_cookie"
+
+static const char *pfkey_keys[] = {
+	PFKEY_K_SRCADDR,
+	PFKEY_K_DSTADDR,
+	PFKEY_K_ISRCADDR,
+	PFKEY_K_IDSTADDR,
+	PFKEY_K_NLOC,
+	PFKEY_K_NREM,
+	PFKEY_K_SRCADDR PFKEY_K_PORT,
+	PFKEY_K_DSTADDR PFKEY_K_PORT,
+	PFKEY_K_ISRCADDR PFKEY_K_PORT,
+	PFKEY_K_IDSTADDR PFKEY_K_PORT,
+	PFKEY_K_NLOC PFKEY_K_PORT,
+	PFKEY_K_NREM PFKEY_K_PORT,
+	PFKEY_K_AUTH,
+	PFKEY_K_ENCR,
+	PFKEY_K_SPI,
+	PFKEY_K_PAIR,
+	PFKEY_K_ENCR_KEY,
+	PFKEY_K_ENCR_KEYLEN,
+	PFKEY_K_AUTH_KEY,
+	PFKEY_K_AUTH_KEYLEN,
+	PFKEY_K_FLAGS,
+	PFKEY_K_KMC_PROTO,
+	PFKEY_K_KMC_COOKIE,
+};
+
+#define	PFKEY_MSG_LEN(msg, ext) \
+    SADB_8TO64((size_t)((uint8_t *)ext - (uint8_t *)msg))
+#define	ROUND64(val) P2ROUNDUP(val, sizeof (uint64_t))
+
+typedef struct pfreq {
+	list_node_t	pr_node;
+	pid_t		pr_pid;
+	uint32_t	pr_msgid;
+	mutex_t		pr_lock;
+	cond_t		pr_cv;
+	sadb_msg_t	*pr_msg;
+	boolean_t	pr_recv;
+} pfreq_t;
+
+/* pfreq lock protects pfreq_list */
+static mutex_t	pfreq_lock = ERRORCHECKMUTEX;
+static list_t	pfreq_list;
+
+/* PF_KEY socket. */
+static int pfsock;
+
+/* our event port */
+static int pfport;
+
+static thread_t pftid;
+
+/* our msgids */
+static volatile uint32_t msgid = 0;
+
+static void handle_reply(sadb_msg_t *);
+static void handle_delete(sadb_msg_t *);
+static void handle_flush(sadb_msg_t *);
+static void handle_expire(sadb_msg_t *);
+static void handle_acquire(sadb_msg_t *, boolean_t);
+static void handle_register(sadb_msg_t *);
+
+int ikev2_auth_to_pfkey(ikev2_xf_auth_t);
+int ikev2_encr_to_pfkey(ikev2_xf_encr_t);
+
+/* Deal with algorithm name lookups */
+
+static const char *
+alg_to_string(int doi_number, const algindex_t *algindex)
+{
+	int i;
+
+	for (i = 0; algindex[i].desc; i++)
+		if (doi_number == algindex[i].doi_num)
+			return (algindex[i].desc);
+	return ("unknown");
+}
+
+char *
+kef_alg_to_string(int algnum, int protonum, char *algname)
+{
+	struct ipsecalgent *testentry;
+	int error;
+
+	testentry = getipsecalgbynum(algnum, protonum, &error);
+	if (testentry == NULL || testentry->a_names[0] == NULL)
+		(void) snprintf(algname, 80, "unknown");
+	else
+		(void) snprintf(algname, 80, "%s", testentry->a_names[0]);
+
+	/* safe to use on a NULL pointer */
+	(void) freeipsecalgent(testentry);
+	return (algname);
+}
+
+/*
+ * The passed in parsedmsg_t looks like this (see defs.h):
+ *
+ * {
+ *	*pmsg_next
+ *	*pmsg_samsg
+ *	*pmsg_exts[0][1][2][3].....[SADB_EXT_MAX + 2]
+ *	*pmsg_sss  (struct sockaddr_storage *)
+ *	*pmsg_dss  (struct sockaddr_storage *)
+ *	*pmsg_isss (struct sockaddr_storage *)
+ *	*pmsg_idss (struct sockaddr_storage *)
+ *	*pmsg_nlss (struct sockaddr_storage *)
+ *	*pmsg_nrss (struct sockaddr_storage *)
+ * } parsedmsg_t;
+ *
+ * This function parses through the whole samsg looking for valid PF_KEY
+ * extensions. Each extension type found is saved in the pmsg_exts array.
+ * As the parsedmsg_t is initialised as zero's when entering the function, it's
+ * easy to check later to see which extensions exist in the samsg by
+ * checking for NULL.
+ *
+ * Some extensions will have a sockaddr_storage associated with the type
+ * EG: SADB_EXT_ADDRESS_SRC, in these cases a pointer to the appropriate
+ * structure in samsg is set in the parsedmsg_t.
+ *
+ * After parsing the whole samsg, the optional arguments (which is a list
+ * of required extensions) are checked for in the parsedmsg_t. If all of the
+ * required extensions are valid then the function returns B_TRUE.
+ *
+ * Even if the required extensions are not in the samsg (and the function
+ * returns B_FALSE) the pmsg->pmsg_exts array will still contain the headers
+ * that were in the samsg.
+ *
+ * Assume the kernel knows what it's doing with messages that get passed up.
+ * The variable arguments are a list of ints with SADB_EXT_* values.
+ */
+static boolean_t
+vextract_exts(sadb_msg_t *samsg, parsedmsg_t *pmsg, int numexts, va_list ap)
+{
+	sadb_ext_t *ext, *end;
+	sadb_ext_t **exts = pmsg->pmsg_exts;
+	int current_ext;
+	boolean_t rc = B_TRUE;
+
+	(void) memset(pmsg, 0, sizeof (parsedmsg_t));
+
+	end = (sadb_ext_t *)(((uint64_t *)samsg) + samsg->sadb_msg_len);
+	ext = (sadb_ext_t *)(samsg + 1);
+	pmsg->pmsg_samsg = samsg;
+
+	while (ext < end) {
+		exts[ext->sadb_ext_type] = ext;
+		if (ext->sadb_ext_type == SADB_EXT_ADDRESS_SRC)
+			pmsg->pmsg_sss = (struct sockaddr_storage *)
+			    (((sadb_address_t *)ext) + 1);
+		if (ext->sadb_ext_type == SADB_EXT_ADDRESS_DST)
+			pmsg->pmsg_dss = (struct sockaddr_storage *)
+			    (((sadb_address_t *)ext) + 1);
+		if (ext->sadb_ext_type == SADB_X_EXT_ADDRESS_INNER_SRC)
+			pmsg->pmsg_isss = (struct sockaddr_storage *)
+			    (((sadb_address_t *)ext) + 1);
+		if (ext->sadb_ext_type == SADB_X_EXT_ADDRESS_INNER_DST)
+			pmsg->pmsg_idss = (struct sockaddr_storage *)
+			    (((sadb_address_t *)ext) + 1);
+		if (ext->sadb_ext_type == SADB_X_EXT_ADDRESS_NATT_REM)
+			pmsg->pmsg_nrss = (struct sockaddr_storage *)
+			    (((sadb_address_t *)ext) + 1);
+		if (ext->sadb_ext_type == SADB_X_EXT_ADDRESS_NATT_LOC)
+			pmsg->pmsg_nlss = (struct sockaddr_storage *)
+			    (((sadb_address_t *)ext) + 1);
+
+		ext = (sadb_ext_t *)(((uint64_t *)ext) + ext->sadb_ext_len);
+
+	}
+
+	while (numexts-- > 0) {
+		current_ext = va_arg(ap, int);
+		if (exts[current_ext] == NULL) {
+			rc = B_FALSE;
+			break;
+		}
+	}
+
+	return (rc);
+}
+
+static boolean_t
+extract_exts(sadb_msg_t *samsg, parsedmsg_t *pmsg, int numexts, ...)
+{
+	va_list ap;
+	boolean_t ret;
+
+	va_start(ap, numexts);
+	ret = vextract_exts(samsg, pmsg, numexts, ap);
+	va_end(ap);
+	return (ret);
+}
+
+static void
+pfkey_arm(int s)
+{
+	/* At this point, we can safely re-schedule the socket for reading. */
+	if (port_associate(pfport, PORT_SOURCE_FD, s, POLLIN, NULL) < 0) {
+		STDERR(error, "port_associate() failed",
+		    BUNYAN_T_INT32, "fd", (int32_t)s, BUNYAN_T_END);
+		exit(EXIT_FAILURE);
+	}
+}
+
+static void
+pfkey_inbound(int s)
+{
+	sadb_msg_t *samsg;
+	ssize_t rc;
+	int length;
+
+	if (ioctl(s, I_NREAD, &length) < 0) {
+		STDERR(error, "ioctl(I_NREAD) failed");
+		pfkey_arm(s);
+		return;
+	}
+
+	if (length == 0) {
+		(void) bunyan_info(log, "ioctl: zero length message",
+		    BUNYAN_T_STRING, LOG_KEY_FUNC, __func__,
+		    BUNYAN_T_STRING, LOG_KEY_FILE, __FILE__,
+		    BUNYAN_T_INT32, LOG_KEY_LINE, __LINE__,
+		    BUNYAN_T_END);
+		pfkey_arm(s);
+		return;
+	}
+
+	samsg = malloc(length);
+	if (samsg == NULL) {
+		(void) bunyan_error(log, "No memory for pfkey message",
+		    BUNYAN_T_END);
+		pfkey_arm(s);
+		return;
+	}
+
+	rc = read(s, samsg, length);
+	if (rc <= 0) {
+		if (rc == -1) {
+			STDERR(error, "read failed");
+			/* XXX: Should I exit()? */
+		}
+		free(samsg);
+		pfkey_arm(s);
+		return;
+	}
+
+	/* At this point, we can safely re-schedule the socket for reading. */
+	pfkey_arm(s);
+
+	sadb_log(BUNYAN_L_DEBUG, "SADB message received", samsg);
+
+	/*
+	 * XXX KEBE SAYS for now don't print the full inbound message.  An
+	 * "ipseckey monitor" instance is useful here.
+	 */
+
+	/*
+	 * If it might be a reply to us, handle it.  Anything from the kernel
+	 * with our pid is always a reply, however we also send SADB_GETSPI,
+	 * SADB_ADD, and SADB_UPDATE messages to the kernel using the pid/seq
+	 * of an earlier kernel initiated SADB_ACQUIRE msg when those requests
+	 * are made in response to that SADB_ACQUIRE (per PF_KEY(7P)).  The
+	 * will not have our pid, but the kernel only ever sends those
+	 * messages as replies to a user, so we can safely treat them as
+	 * replies.
+	 */
+	if (samsg->sadb_msg_pid == getpid() ||
+	    samsg->sadb_msg_type == SADB_GETSPI ||
+	    samsg->sadb_msg_type == SADB_ADD ||
+	    samsg->sadb_msg_type == SADB_UPDATE) {
+		handle_reply(samsg);
+		return;
+	}
+
+	/*
+	 * Silently pitch the message if it's an error reply to someone else.
+	 */
+	if (samsg->sadb_msg_errno != 0) {
+		(void) bunyan_debug(log, "Reply not for us, dropped",
+		    BUNYAN_T_END);
+		free(samsg);
+		return;
+	}
+
+	/*
+	 * At this point, we have a kernel-emitted message.  Typically this
+	 * will be an ACQUIRE, EXPIRE, or DELETE/DELPAIR.  Other ones include
+	 * FLUSH (which if we follow in.iked semantics, will nuke all IKE SA
+	 * state) and REGISTER (indicating a change in kernel algorithm
+	 * support).
+	 */
+
+	switch (samsg->sadb_msg_type) {
+	case SADB_ACQUIRE:
+		handle_acquire(samsg, B_TRUE);
+		return;
+	case SADB_EXPIRE:
+		handle_expire(samsg);
+		return;
+	case SADB_DELETE:
+	case SADB_X_DELPAIR:
+		handle_delete(samsg);
+		return;
+	case SADB_FLUSH:
+		handle_flush(samsg);
+		return;
+	case SADB_REGISTER:
+		handle_register(samsg);
+		/*
+		 * Explicitly free it here because handle_register() is also
+		 * called from pfkey_init(), which has samsg on the stack
+		 * instead.
+		 */
+		free(samsg);
+		return;
+	}
+
+	(void) bunyan_debug(log, "SADB message type unknown, ignored.",
+	    BUNYAN_T_UINT32, "msg_type_val", (uint32_t)samsg->sadb_msg_type,
+	    BUNYAN_T_END);
+	free(samsg);
+}
+
+/*
+ * Send an sadb message to pfkey.  The response is allocated and placed into
+ * *pmsg.  Optionally, a list of extensions can be given.  Returns B_TRUE
+ * is message was successful and any expected extensions passed in are
+ * present.  This function should only be called by threads in the worker
+ * pool.  It will sleep until a response is received by a pfkey thread and
+ * is then woken up by the pfkey thread.
+ *
+ * On failure, B_FALSE is returned, however there are two distinct
+ * possibilities to check:
+ *
+ * 1. Pfkey error
+ *	If there was some problem with the request itself, the kernel may send
+ *	a response with sadb_msg_errno and possible sadb_x_msg_diagnostic set.
+ *	As this may be useful to the caller, if this occurs, *pmsg is still
+ *	allocated.  It may or may not include any of the expected or passed in
+ *	extensions.
+ * 2. System error
+ *	If there was a problem allocated the response or in sending the
+ *	message (i.e. write(2) failure), *pmsg will be NULL and errno
+ *	should be set by the failing function.
+ */
+boolean_t
+pfkey_send_msg(sadb_msg_t *msg, parsedmsg_t **pmsg, int numexts, ...)
+{
+	pfreq_t req = { 0 };
+	size_t len = SADB_64TO8(msg->sadb_msg_len);
+	ssize_t n;
+	int rc;
+	timestruc_t amt;
+	va_list ap;
+	boolean_t ret = B_TRUE;
+
+	VERIFY(IS_WORKER);
+
+	if ((*pmsg = malloc(sizeof (parsedmsg_t))) == NULL)
+		return (B_FALSE);
+
+	VERIFY0(cond_init(&req.pr_cv, USYNC_THREAD, NULL));
+	VERIFY0(mutex_init(&req.pr_lock, USYNC_THREAD|LOCK_ERRORCHECK, NULL));
+	req.pr_pid = msg->sadb_msg_pid;
+	req.pr_msgid = msg->sadb_msg_seq;
+
+	mutex_enter(&pfreq_lock);
+	list_insert_tail(&pfreq_list, &req);
+	mutex_exit(&pfreq_lock);
+
+	sadb_log(BUNYAN_L_TRACE, "Sending pfkey request", msg);
+
+	n = write(pfsock, msg, len);
+	if (n != len) {
+		if (n < 0) {
+			STDERR(error, "pf_key write failed");
+		} else {
+			(void) bunyan_error(log,
+			    "pf_key truncated write",
+			    BUNYAN_T_UINT32, "len", len,
+			    BUNYAN_T_INT32, "n", (int32_t)n,
+			    BUNYAN_T_END);
+		}
+
+		mutex_enter(&pfreq_lock);
+		list_remove(&pfreq_list, &req);
+		mutex_exit(&pfreq_lock);
+		ret = B_FALSE;
+		goto done;
+	}
+
+	amt.tv_sec = time(NULL) + PFKEY_TIMEOUT;
+	amt.tv_nsec = 0;
+
+	mutex_enter(&req.pr_lock);
+	while (!req.pr_recv) {
+		rc = cond_timedwait(&req.pr_cv, &req.pr_lock, &amt);
+		mutex_exit(&req.pr_lock);
+
+		switch (rc) {
+		case 0:
+		case EINTR:
+			continue;
+		case ETIME:
+			free(*pmsg);
+			*pmsg = NULL;
+			bunyan_error(log, "pf_key timeout",
+			    BUNYAN_T_UINT32, "msgid", req.pr_msgid,
+			    BUNYAN_T_END);
+
+			errno = ETIME;
+			ret = B_FALSE;
+			goto done;
+		default:
+			TSTDERR(rc, fatal,
+			    "cond_timedwait() unexpected failure");
+			abort();
+		}
+	}
+
+	va_start(ap, numexts);
+	ret = vextract_exts(req.pr_msg, *pmsg, numexts, ap);
+	va_end(ap);
+
+done:
+	mutex_destroy(&req.pr_lock);
+	cond_destroy(&req.pr_cv);
+	return (ret);
+}
+
+void
+pfkey_msg_init(const sadb_msg_t *restrict src, sadb_msg_t *restrict samsg,
+    uint8_t type, uint8_t satype)
+{
+	samsg->sadb_msg_version = PF_KEY_V2;
+	samsg->sadb_msg_type = type;
+	samsg->sadb_msg_errno = 0;
+	samsg->sadb_msg_satype = satype;
+	samsg->sadb_msg_len = SADB_8TO64(sizeof (*samsg));
+	samsg->sadb_msg_reserved = 0;
+	if (src != NULL) {
+		samsg->sadb_msg_seq = src->sadb_msg_seq;
+		samsg->sadb_msg_pid = src->sadb_msg_pid;
+	} else {
+		samsg->sadb_msg_seq = atomic_inc_32_nv(&msgid);
+		samsg->sadb_msg_pid = getpid();
+	}
+}
+
+/*
+ * Inform the kernel of an error.
+ * src is the pfkey message the error is a response to, reason is
+ * the reason for the error
+ */
+void
+pfkey_send_error(const sadb_msg_t *src, uint8_t reason)
+{
+	sadb_msg_t msg = { 0 };
+	ssize_t n;
+
+	/* Errors consists of just the sadb header */
+	pfkey_msg_init(src, &msg, src->sadb_msg_type, src->sadb_msg_satype);
+	msg.sadb_msg_errno = reason;
+
+	n = write(pfsock, &msg, sizeof (sadb_msg_t));
+	if (n != sizeof (sadb_msg_t))
+		STDERR(error, "Unable to send PFKEY error notification");
+}
+
+/*
+ * Copy an existing extension.  If type != 0, type of the destination
+ * extension is explicitly set to the given value (e.g. changing a
+ * SADB_EXT_ADDRESS_SRC to SADB_EXT_ADDRESS_DST), otherwise the source
+ * extentsion type is preserved.
+ */
+sadb_ext_t *
+pfkey_add_ext(sadb_ext_t *dest, uint16_t type, const sadb_ext_t *src)
+{
+	if (src == NULL)
+		return (dest);
+
+	size_t len = SADB_64TO8(src->sadb_ext_len);
+
+	bcopy(src, dest, len);
+	if (type != SADB_EXT_RESERVED)
+		dest->sadb_ext_type = type;
+
+	return ((sadb_ext_t *)((uint8_t *)dest + len));
+}
+
+/*
+ * Add an sadb_address_t extension to a pfkey message.  Caller must fill
+ * in SADB address type (SRC, INNER_DST, etc.).  Caller must guarantee memory
+ * pointed to by saaddr is sufficiently large to hold sadb_address_t + the
+ * actual address.
+ *
+ * Returns total size of extension (in bytes) -- sadb_address_t and actual
+ * address.  It also sets *endp to just after the end of the address (i.e.
+ * where the next extension would go).
+ */
+sadb_ext_t *
+pfkey_add_address(sadb_ext_t *restrict ext, uint16_t type,
+    const struct sockaddr *restrict addr, uint8_t prefixlen, uint8_t proto)
+{
+	sadb_address_t *sadb_addr = (sadb_address_t *)ext;
+	size_t addrlen = 0;
+	size_t len = 0;
+
+	switch (type) {
+	case SADB_EXT_ADDRESS_SRC:
+	case SADB_EXT_ADDRESS_DST:
+	case SADB_X_EXT_ADDRESS_NATT_LOC:
+	case SADB_X_EXT_ADDRESS_NATT_REM:
+	case SADB_X_EXT_ADDRESS_INNER_SRC:
+	case SADB_X_EXT_ADDRESS_INNER_DST:
+		break;
+	default:
+		INVALID(type);
+	}
+
+	if (addr == NULL)
+		return (ext);
+
+	switch (addr->sa_family) {
+	case AF_INET:
+		addrlen = sizeof (struct sockaddr_in);
+		break;
+	case AF_INET6:
+		addrlen = sizeof (struct sockaddr_in6);
+		break;
+	default:
+		INVALID(su.sau_ss->ss_family);
+	}
+	bcopy(addr, sadb_addr + 1, addrlen);
+
+	len = sizeof (*sadb_addr) + addrlen;
+	sadb_addr->sadb_address_len = SADB_8TO64(len);
+	sadb_addr->sadb_address_exttype = type;
+	sadb_addr->sadb_address_prefixlen = prefixlen;
+	sadb_addr->sadb_address_proto = proto;
+
+	return ((sadb_ext_t *)((uint8_t *)ext + len));
+}
+
+sadb_ext_t *
+pfkey_add_sa(sadb_ext_t *restrict ext, uint32_t spi, ikev2_xf_encr_t i2encr,
+    ikev2_xf_auth_t i2auth, uint32_t flags)
+{
+	sadb_sa_t *sa = (sadb_sa_t *)ext;
+	int encr = ikev2_encr_to_pfkey(i2encr);
+	int auth = ikev2_auth_to_pfkey(i2auth);
+
+	/*
+	 * We shouldn't negotiate anything we don't support nor should we
+	 * return an out of range value when translating to pf_key values.
+	 */
+	VERIFY3S(auth, >=, 0);
+	VERIFY3S(auth, <=, UINT8_MAX);
+	VERIFY3S(encr, >=, 0);
+	VERIFY3S(encr, <=, UINT8_MAX);
+
+	sa->sadb_sa_len = SADB_8TO64(sizeof (*sa));
+	sa->sadb_sa_exttype = SADB_EXT_SA;
+	sa->sadb_sa_spi = spi;
+	sa->sadb_sa_auth = (uint8_t)auth;
+	sa->sadb_sa_encrypt = (uint8_t)encr;
+	sa->sadb_sa_flags = flags;
+	sa->sadb_sa_state = SADB_SASTATE_MATURE;
+
+	return ((sadb_ext_t *)(sa + 1));
+}
+
+sadb_ext_t *
+pfkey_add_range(sadb_ext_t *restrict ext, uint32_t min, uint32_t max)
+{
+	sadb_spirange_t *r = (sadb_spirange_t *)ext;
+
+	r->sadb_spirange_len = SADB_8TO64(sizeof (*r));
+	r->sadb_spirange_exttype = SADB_EXT_SPIRANGE;
+	r->sadb_spirange_min = min;
+	r->sadb_spirange_max = max;
+	return ((sadb_ext_t *)(r + 1));
+}
+
+sadb_ext_t *
+pfkey_add_identity(sadb_ext_t *restrict ext, uint16_t type,
+    const config_id_t *cid)
+{
+	sadb_ident_t *id = (sadb_ident_t *)ext;
+	size_t len = sizeof (*id) + ROUND64(config_id_strlen(cid));
+
+	switch (type) {
+	case SADB_EXT_IDENTITY_SRC:
+	case SADB_EXT_IDENTITY_DST:
+		id->sadb_ident_exttype = type;
+		break;
+	default:
+		INVALID(type);
+	}
+
+	id->sadb_ident_len = SADB_8TO64(len);
+
+	switch (cid->cid_type) {
+	case CFG_AUTH_ID_DN:
+		id->sadb_ident_type = SADB_X_IDENTTYPE_DN;
+		break;
+	case CFG_AUTH_ID_DNS:
+		id->sadb_ident_type = SADB_IDENTTYPE_FQDN;
+		break;
+	case CFG_AUTH_ID_GN:
+		id->sadb_ident_type = SADB_X_IDENTTYPE_GN;
+		break;
+	case CFG_AUTH_ID_IPV4:
+	case CFG_AUTH_ID_IPV4_RANGE:
+	case CFG_AUTH_ID_IPV6:
+	case CFG_AUTH_ID_IPV6_RANGE:
+		id->sadb_ident_type = SADB_X_IDENTTYPE_ADDR_RANGE;
+		break;
+	case CFG_AUTH_ID_IPV4_PREFIX:
+	case CFG_AUTH_ID_IPV6_PREFIX:
+		id->sadb_ident_type = SADB_IDENTTYPE_PREFIX;
+		break;
+	case CFG_AUTH_ID_EMAIL:
+		id->sadb_ident_type = SADB_IDENTTYPE_USER_FQDN;
+		break;
+	}
+
+	id->sadb_ident_len = SADB_8TO64(len);
+	(void) config_id_str(cid, (char *)(id + 1), len);
+
+	return ((sadb_ext_t *)((uint8_t *)ext + len));
+}
+
+sadb_ext_t *
+pfkey_add_key(sadb_ext_t *restrict ext, uint16_t type, const uint8_t *key,
+    size_t keylen)
+{
+	sadb_key_t *skey = (sadb_key_t *)ext;
+	size_t len = sizeof (sadb_key_t) + ROUND64(keylen);
+
+	switch (type) {
+	case SADB_EXT_KEY_AUTH:
+	case SADB_EXT_KEY_ENCRYPT:
+		break;
+	default:
+		INVALID(type);
+	}
+
+	if (keylen == 0)
+		return (ext);
+
+	skey->sadb_key_len = SADB_8TO64(len);
+	skey->sadb_key_exttype = type;
+	skey->sadb_key_bits = SADB_8TO1(keylen);
+	bcopy(key, skey + 1, keylen);
+	return ((sadb_ext_t *)((uint8_t *)ext + len));
+}
+
+sadb_ext_t *
+pfkey_add_pair(sadb_ext_t *ext, uint32_t spi)
+{
+	sadb_x_pair_t *pair = (sadb_x_pair_t *)ext;
+
+	if (spi == 0)
+		return (ext);
+
+	pair->sadb_x_pair_len = SADB_8TO64(sizeof (*pair));
+	pair->sadb_x_pair_exttype = SADB_X_EXT_PAIR;
+	pair->sadb_x_pair_spi = spi;
+	return ((sadb_ext_t *)(pair + 1));
+}
+
+sadb_ext_t *
+pfkey_add_lifetime(sadb_ext_t *restrict ext)
+{
+	config_t *cfg = config_get();
+	sadb_lifetime_t *life = (sadb_lifetime_t *)ext;
+
+	if (cfg->cfg_p2_lifetime_secs > 0 ||
+	    cfg->cfg_p2_lifetime_kb > 0) {
+		life->sadb_lifetime_len = SADB_8TO64(sizeof (*life));
+		life->sadb_lifetime_exttype = SADB_EXT_LIFETIME_HARD;
+		life->sadb_lifetime_addtime = cfg->cfg_p2_lifetime_secs;
+		life->sadb_lifetime_bytes = cfg->cfg_p2_lifetime_kb * 1024;
+		life++;
+	}
+
+	if (cfg->cfg_p2_softlife_secs > 0 ||
+	    cfg->cfg_p2_softlife_kb > 0) {
+		life->sadb_lifetime_len = SADB_8TO64(sizeof (*life));
+		life->sadb_lifetime_exttype = SADB_EXT_LIFETIME_SOFT;
+		life->sadb_lifetime_addtime = cfg->cfg_p2_softlife_secs;
+		life->sadb_lifetime_bytes = cfg->cfg_p2_softlife_kb * 1024;
+		life++;
+	}
+
+	if (cfg->cfg_p2_idletime_secs > 0) {
+		life->sadb_lifetime_len = SADB_8TO64(sizeof (*life));
+		life->sadb_lifetime_exttype = SADB_X_EXT_LIFETIME_IDLE;
+		life->sadb_lifetime_addtime = cfg->cfg_p2_idletime_secs;
+		life++;
+	}
+
+	CONFIG_REFRELE(cfg);
+	return ((sadb_ext_t *)life);
+}
+
+sadb_ext_t *
+pfkey_add_kmc(sadb_ext_t *ext, uint32_t proto, uint64_t cookie)
+{
+	sadb_x_kmc_t *kmc = (sadb_x_kmc_t *)ext;
+
+	kmc->sadb_x_kmc_len = SADB_8TO64(sizeof (*kmc));
+	kmc->sadb_x_kmc_exttype = SADB_X_EXT_KM_COOKIE;
+	kmc->sadb_x_kmc_proto = proto;
+	kmc->sadb_x_kmc_cookie64 = cookie;
+
+	return ((sadb_ext_t *)(kmc + 1));
+}
+
+boolean_t
+pfkey_sadb_add_update(ikev2_sa_t *restrict sa,
+    ikev2_child_sa_t *restrict csa, const uint8_t *restrict encrkey,
+    const uint8_t *restrict authkey, const parsedmsg_t *restrict srcmsg)
+{
+	parsedmsg_t *pmsg = NULL;
+	sadb_msg_t *msg = NULL;
+	sadb_ext_t *ext = NULL;
+	size_t msglen = 0, encrlen = 0, authlen = 0;
+	uint32_t pair = (csa->i2c_pair != NULL) ? csa->i2c_pair->i2c_spi : 0;
+	uint32_t flags = 0;
+	ts_t *ts_src = I2C_SRC(csa);
+	ts_t *ts_dst = I2C_DST(csa);
+	struct sockaddr *natt_l = NULL, *natt_r = NULL;
+	const config_id_t *id_src = I2C_SRC_ID(sa, csa);
+	const config_id_t *id_dst = I2C_DST_ID(sa, csa);
+	uint16_t srctype = SADB_X_EXT_ADDRESS_INNER_SRC;
+	uint16_t dsttype = SADB_X_EXT_ADDRESS_INNER_DST;
+	uint8_t satype = ikev2_to_satype(csa->i2c_satype);
+	boolean_t ret = B_FALSE;
+
+	encrlen = SADB_1TO8(csa->i2c_encr_keylen);
+	authlen = auth_data(csa->i2c_auth)->ad_keylen;
+
+	/*
+	 * Worst case msg length:
+	 *	base, SA, lifetime(HSI), address(SD), address(Is, Id),
+	 *	address(Nl, Nr), key(AE), identity(SD), pair, kmc
+	 *
+	 * Note that the sadb_* types are already include padding for 64-bit
+	 * alignment, so they don't need to be rounded up.
+	 */
+
+	msglen = sizeof (*msg) + sizeof (sadb_sa_t) +
+	    3 * sizeof (sadb_lifetime_t) +
+	    6 * (sizeof (sadb_address_t) +
+	    ROUND64(sizeof (struct sockaddr_storage))) +
+	    sizeof (sadb_key_t) + ROUND64(encrlen) +
+	    sizeof (sadb_key_t) + ROUND64(authlen) +
+	    sizeof (sadb_ident_t) + ROUND64(config_id_strlen(sa->local_id)) +
+	    sizeof (sadb_ident_t) + ROUND64(config_id_strlen(sa->remote_id)) +
+	    sizeof (sadb_x_pair_t) + sizeof (sadb_x_kmc_t);
+
+	if (sa->flags & I2SA_INITIATOR)
+		flags |= IKEV2_SADB_INITIATOR;
+
+	flags |= csa->i2c_inbound ?
+	    SADB_X_SAFLAGS_INBOUND : SADB_X_SAFLAGS_OUTBOUND;
+
+	if (!csa->i2c_transport)
+		flags |= SADB_X_SAFLAGS_TUNNEL;
+
+	if ((sa->flags & I2SA_NAT_LOCAL) && csa->i2c_transport) {
+		flags |= SADB_X_SAFLAGS_NATT_LOC;
+		natt_l= SSTOSA(&sa->lnatt);
+	}
+	if ((sa->flags & I2SA_NAT_REMOTE) && csa->i2c_transport) {
+		flags |= SADB_X_SAFLAGS_NATT_REM;
+		natt_r = SSTOSA(&sa->rnatt);
+	}
+
+	msg = umem_zalloc(msglen, UMEM_DEFAULT);
+	if (msg == NULL) {
+		(void) bunyan_error(log, "No memory for pfkey request",
+		    BUNYAN_T_END);
+		return (B_FALSE);
+	}
+
+	/*
+	 * If the source message originated from the kernel (pid == 0),
+	 * we want to use it's pid/seq value so it can tie the SAs we're
+	 * creating/updating back to the original packets that triggered
+	 * the creation request.
+	 */
+	pfkey_msg_init(PMSG_FROM_KERNEL(srcmsg) ? srcmsg->pmsg_samsg : NULL,
+	    msg, csa->i2c_inbound ? SADB_UPDATE : SADB_ADD, satype);
+
+	ext = (sadb_ext_t *)(msg + 1);
+	ext = pfkey_add_sa(ext, csa->i2c_spi, csa->i2c_encr, csa->i2c_auth,
+	    flags);
+	ext = pfkey_add_lifetime(ext);
+
+	if (csa->i2c_transport) {
+		srctype = SADB_EXT_ADDRESS_SRC;
+		dsttype = SADB_EXT_ADDRESS_DST;
+	} else {
+		/*
+		 * For tunnel mode, reuse the SRC/DST addresses from our
+		 * ACQUIRE or INVERSE_ACQUIRE, though we need to flip
+		 * SRC/DST for the inbound SA.
+		 */
+		ext = pfkey_add_ext(ext,
+		    csa->i2c_inbound ? SADB_EXT_ADDRESS_DST : 0,
+		    srcmsg->pmsg_exts[SADB_EXT_ADDRESS_SRC]);
+		ext = pfkey_add_ext(ext,
+		    csa->i2c_inbound ? SADB_EXT_ADDRESS_SRC : 0,
+		    srcmsg->pmsg_exts[SADB_EXT_ADDRESS_DST]);
+	}
+
+	/*
+	 * But always want to use the negotiated traffic selectors add the
+	 * addresses for the actual traffic being sent.
+	 */
+	ext = pfkey_add_address(ext, srctype,
+	    &ts_src->ts_sa, TS_SADB_PREFIX(ts_src), ts_src->ts_proto);
+	ext = pfkey_add_address(ext, dsttype,
+	    &ts_dst->ts_sa, TS_SADB_PREFIX(ts_dst), ts_dst->ts_proto);
+
+	/* These are no-ops of the address argument is NULL */
+	ext = pfkey_add_address(ext, SADB_X_EXT_ADDRESS_NATT_LOC,
+	    (struct sockaddr *)natt_l, 0, 0);
+	ext = pfkey_add_address(ext, SADB_X_EXT_ADDRESS_NATT_REM,
+	    (struct sockaddr *)natt_r, 0, 0);
+
+	ext = pfkey_add_key(ext, SADB_EXT_KEY_AUTH, authkey, authlen);
+	ext = pfkey_add_key(ext, SADB_EXT_KEY_ENCRYPT, encrkey, encrlen);
+
+	ext = pfkey_add_identity(ext, SADB_EXT_IDENTITY_SRC, id_src);
+	ext = pfkey_add_identity(ext, SADB_EXT_IDENTITY_DST, id_dst);
+
+	ext = pfkey_add_pair(ext, pair);
+
+	ext = pfkey_add_kmc(ext, SADB_X_KMP_IKEV2, I2SA_LOCAL_SPI(sa));
+
+	VERIFY(IS_P2ALIGNED(ext, sizeof (uint64_t)));
+	msg->sadb_msg_len = PFKEY_MSG_LEN(msg, ext);
+
+	if (!pfkey_send_msg(msg, &pmsg, 1, SADB_EXT_SA) ||
+	    pmsg->pmsg_samsg == NULL) {
+		parsedmsg_free(pmsg);
+		umem_free(msg, msglen);
+		return (B_FALSE);
+	}
+
+	if (pmsg->pmsg_samsg->sadb_msg_errno != 0) {
+		sadb_msg_t *m = pmsg->pmsg_samsg;
+
+		TSTDERR(m->sadb_msg_errno, error,
+		    "SADB_ADD failed",
+		    BUNYAN_T_STRING, "diagmsg",
+		    keysock_diag(m->sadb_x_msg_diagnostic),
+		    BUNYAN_T_UINT32, "diagcode",
+		    (uint32_t)m->sadb_x_msg_diagnostic);
+	} else {
+		(void) bunyan_debug(log, "Added IPsec SA",
+		    BUNYAN_T_STRING, "satype", ikev2_spi_str(csa->i2c_satype),
+		    BUNYAN_T_STRING, "spi",
+		    enum_printf("0x%" PRIX32, ntohl(csa->i2c_spi)),
+		    BUNYAN_T_END);
+
+		ret = B_TRUE;
+	}
+
+	umem_free(msg, msglen);
+	parsedmsg_free(pmsg);
+	return (ret);
+}
+
+boolean_t
+pfkey_getspi(const parsedmsg_t *restrict srcmsg, uint8_t satype,
+    uint32_t *restrict spip)
+{
+	uint64_t buffer[128] = { 0 };
+	const sadb_msg_t *src_sadb_msg = NULL;
+	parsedmsg_t *resp = NULL;
+	sadb_ext_t *src = NULL, *dst = NULL, *ext = NULL;
+	sadb_msg_t *samsg = (sadb_msg_t *)buffer;
+	boolean_t ret;
+
+	/*
+	 * Use sizeof (struct sockaddr_storage) as worst case address size
+	 * for compile time check
+	 */
+	CTASSERT(sizeof (buffer) >= sizeof (*samsg) +
+	    2 * (sizeof (sadb_address_t) + sizeof (struct sockaddr_storage)) +
+	    sizeof (sadb_spirange_t));
+
+	*spip = 0;
+
+	if (PMSG_FROM_KERNEL(srcmsg))
+		src_sadb_msg = srcmsg->pmsg_samsg;
+
+	/*
+	 * The address extensions in srcmsg are based on outbound traffic,
+	 * however we are reserving the inbound SPI, so src/dst are reversed.
+	 */
+	src = srcmsg->pmsg_exts[SADB_EXT_ADDRESS_DST];
+	dst = srcmsg->pmsg_exts[SADB_EXT_ADDRESS_SRC];
+	VERIFY3U(srcmsg->pmsg_sss->ss_family, ==, srcmsg->pmsg_dss->ss_family);
+
+	/*
+	 * The kernel randomly pics an SPI within the range we pass.  If it
+	 * happens to collide with an existing SPI, the GETSPI request will
+	 * fail with EEXIST.  We keep trying until we either succeed, or
+	 * get an error other than EEXIST.  Technically this means
+	 * if we've exhaused our SPI space, we'll loop forever.  However, there
+	 * is no definitive way to detect this, and since the address space is
+	 * 32 bits, it seems reasonable at this time to assume we will run out
+	 * of other resources long before having 2^32 IPsec SAs (larval or
+	 * fully formed) is likely.
+	 */
+	do {
+		bzero(buffer, sizeof (buffer));
+
+		pfkey_msg_init(src_sadb_msg, samsg, SADB_GETSPI, satype);
+		ext = (sadb_ext_t *)(samsg + 1);
+
+		ext = pfkey_add_ext(ext, SADB_EXT_ADDRESS_SRC, src);
+		ext = pfkey_add_ext(ext, SADB_EXT_ADDRESS_DST, dst);
+		ext = pfkey_add_range(ext, 1, UINT32_MAX);
+
+		samsg->sadb_msg_len = PFKEY_MSG_LEN(samsg, ext);
+
+		errno = 0;
+		(void) pfkey_send_msg(samsg, &resp, 1, SADB_EXT_SA);
+		if (resp == NULL || resp->pmsg_samsg == NULL) {
+			parsedmsg_free(resp);
+			return (B_FALSE);
+		}
+	} while (resp->pmsg_samsg->sadb_msg_errno == EEXIST);
+
+	if (resp->pmsg_samsg->sadb_msg_errno != 0) {
+		sadb_msg_t *m = resp->pmsg_samsg;
+
+		TSTDERR(m->sadb_msg_errno, error,
+		    "SADB_GETSPI failed",
+		    BUNYAN_T_STRING, "diagmsg",
+		    keysock_diag(m->sadb_x_msg_diagnostic),
+		    BUNYAN_T_UINT32, "diagcode",
+		    (uint32_t)m->sadb_x_msg_diagnostic);
+	} else {
+		sadb_sa_t *sa = (sadb_sa_t *)resp->pmsg_exts[SADB_EXT_SA];
+		char type[64] = { 0 };
+
+		*spip = sa->sadb_sa_spi;
+		(void) sadb_type_str(satype, type, sizeof (type));
+
+		(void) bunyan_debug(log, "Allocated larval IPsec SA",
+		    BUNYAN_T_STRING, "satype", type,
+		    BUNYAN_T_STRING, "spi",
+		    enum_printf("0x%" PRIX32, ntohl(*spip)),
+		    BUNYAN_T_END);
+	}
+
+	ret = (resp->pmsg_samsg->sadb_msg_errno == 0) ? B_TRUE : B_FALSE;
+	parsedmsg_free(resp);
+	return (ret);
+}
+
+boolean_t
+pfkey_inverse_acquire(const ts_t *src, const ts_t *dst, const ts_t *isrc,
+    const ts_t *idst, parsedmsg_t **resp)
+{
+	uint64_t buffer[128] = { 0 };
+	sadb_msg_t *msg = (sadb_msg_t *)buffer;
+	sadb_ext_t *ext = (sadb_ext_t *)(msg + 1);
+
+	VERIFY3U(src->ts_ss.ss_family, ==, dst->ts_ss.ss_family);
+
+	/*
+	 * The inner addresses (if present) can be a different address family
+	 * than the outer addresses, but the inner source and inner destination
+	 * address families should agree with each other.
+	 */
+	if (isrc != NULL)
+		VERIFY3U(isrc->ts_ss.ss_family, ==, idst->ts_ss.ss_family);
+
+	pfkey_msg_init(NULL, msg, SADB_X_INVERSE_ACQUIRE, SADB_SATYPE_UNSPEC);
+
+	ext = pfkey_add_address(ext, SADB_EXT_ADDRESS_SRC,
+	    &src->ts_sa, src->ts_prefix, src->ts_proto);
+	ext = pfkey_add_address(ext, SADB_EXT_ADDRESS_DST,
+	    &dst->ts_sa, dst->ts_prefix, dst->ts_proto);
+	if (isrc != NULL) {
+		ext = pfkey_add_address(ext, SADB_X_EXT_ADDRESS_INNER_SRC,
+		    &isrc->ts_sa, isrc->ts_prefix, isrc->ts_proto);
+		ext = pfkey_add_address(ext, SADB_X_EXT_ADDRESS_INNER_DST,
+		    &idst->ts_sa, idst->ts_prefix, idst->ts_proto);
+	}
+
+	msg->sadb_msg_len = PFKEY_MSG_LEN(msg, ext);
+	errno = 0;
+	return (pfkey_send_msg(msg, resp, 1, SADB_X_EXT_EPROP));
+}
+
+/*
+ * XXX: Are there any scenarios where we could do something if SADB_DELETE
+ * fails? Or should we change this to return void?
+ */
+boolean_t
+pfkey_delete(uint8_t satype, uint32_t spi, sockaddr_u_t src, sockaddr_u_t dst,
+    boolean_t pair)
+{
+	uint64_t buf[128] = { 0 };
+	sadb_msg_t *msg = (sadb_msg_t *)buf;
+	sadb_ext_t *ext = (sadb_ext_t *)(msg + 1);
+	parsedmsg_t *pmsg = NULL;
+	boolean_t ret = B_FALSE;
+
+	pfkey_msg_init(NULL, msg, pair ? SADB_X_DELPAIR : SADB_DELETE, satype);
+
+	ext = pfkey_add_sa(ext, spi, 0, 0, 0);
+	ext = pfkey_add_address(ext, SADB_EXT_ADDRESS_SRC, src.sau_sa, 0, 0);
+	ext = pfkey_add_address(ext, SADB_EXT_ADDRESS_DST, dst.sau_sa, 0, 0);
+
+	msg->sadb_msg_len = PFKEY_MSG_LEN(msg, ext);
+
+	if (!pfkey_send_msg(msg, &pmsg, 1, SADB_EXT_SA) ||
+	    (pmsg->pmsg_samsg != NULL &&
+	    pmsg->pmsg_samsg->sadb_msg_errno != 0)) {
+		sadb_msg_t *resp = pmsg->pmsg_samsg;
+
+		if (resp != NULL) {
+			TSTDERR(resp->sadb_msg_errno, warn,
+			    "Error deleting IPsec SA",
+			    BUNYAN_T_STRING, "diagmsg",
+			    keysock_diag(resp->sadb_x_msg_diagnostic),
+			    BUNYAN_T_UINT32, "diagcode",
+			    (uint32_t)resp->sadb_x_msg_diagnostic);
+		} else {
+			(void) bunyan_warn(log, "Error deleting IPsec SA",
+			    BUNYAN_T_END);
+		}
+	} else {
+		ret = B_TRUE;
+	}
+
+	parsedmsg_free(pmsg);
+	return (ret);
+}
+
+static void
+handle_reply(sadb_msg_t *reply)
+{
+	pfreq_t *req = NULL;
+
+	mutex_enter(&pfreq_lock);
+
+	req = list_head(&pfreq_list);
+	while (req != NULL) {
+		if (req->pr_msgid == reply->sadb_msg_seq &&
+		    req->pr_pid == reply->sadb_msg_pid)
+			break;
+
+		req = list_next(&pfreq_list, req);
+	}
+
+	if (req != NULL)
+		list_remove(&pfreq_list, req);
+
+	mutex_exit(&pfreq_lock);
+
+	if (req == NULL) {
+		sadb_log(BUNYAN_L_INFO,
+		    "Received a reply to an unknown request", reply);
+		free(reply);
+		return;
+	}
+
+	mutex_enter(&req->pr_lock);
+	req->pr_msg = reply;
+	req->pr_recv = B_TRUE;
+	mutex_exit(&req->pr_lock);
+	VERIFY0(cond_signal(&req->pr_cv));
+}
+
+static void
+handle_flush(sadb_msg_t *samsg)
+{
+	(void) bunyan_trace(log, "Handling SADB flush message", BUNYAN_T_END);
+
+	/* Return if just AH or ESP SAs are being freed. */
+	if (samsg->sadb_msg_satype != SADB_SATYPE_UNSPEC)
+		return;
+
+	/* XXX KEBE SAYS FILL ME IN! */
+
+	ikev2_sa_flush();
+
+	/*
+	 * If we receive an SADB_FLUSH for all SA types, get rid of any IKE
+	 * SAs.
+	 */
+
+	free(samsg);
+}
+
+/*
+ * Handle the PF_KEY SADB_EXPIRE message for idle timeout.
+ *
+ * XXX KEBE SAYS this'll most likely kick off Dead Peer Detection if we can
+ * find an IKE SA.
+ */
+static void
+handle_idle_timeout(sadb_msg_t *samsg)
+{
+	(void) bunyan_trace(log, "Handling SADB idle expire message",
+	    BUNYAN_T_END);
+
+	/* XXX KEBE SAYS FILL ME IN! */
+	free(samsg);
+}
+
+/*
+ * XXX: We can probably simplify a lot of the handle_* functions here and
+ * just do some basic validations and call worker_send_cmd() to queue.
+ */
+static void
+handle_expire(sadb_msg_t *samsg)
+{
+	parsedmsg_t *pmsg;
+
+	pmsg = calloc(1, sizeof (*pmsg));
+	if (pmsg == NULL) {
+		(void) bunyan_error(log, "No memory to handle SADB message",
+		    BUNYAN_T_END);
+		free(samsg);
+		return;
+	}
+
+	/*
+	 * If SOFT expire, see if the SADB_X_SAFLAGS_KM1 (initiator) is set,
+	 * if so, consider treating this expire as an ACQUIRE message if
+	 * no IKE SA is found.
+	 *
+	 * If HARD expire, treat this message like a DELETE.
+	 *
+	 * If IDLE expire, see if we need to do a little DPD or not.
+	 */
+
+	if (!extract_exts(samsg, pmsg, 1, SADB_EXT_SA)) {
+		(void) bunyan_error(log,
+		    "SADB_EXPIRE message is missing an SA extension",
+		    BUNYAN_T_END);
+		parsedmsg_free(pmsg);
+		return;
+	}
+
+	if (!worker_send_cmd(WC_PFKEY, pmsg))
+		parsedmsg_free(pmsg);
+}
+
+static void
+handle_register(sadb_msg_t *samsg)
+{
+	_NOTE(ARGUNUSED(samsg))
+	/* XXX KEBE SAYS FILL ME IN! */
+
+	/*
+	 * XXX KEBE wonders if this is as necessary as 2367 first imagined?
+	 *
+	 * With inverse-ACQUIRE, you know better what algorithms are available
+	 * and acceptable.  This may go away or remain a mere stub.
+	 */
+}
+
+static void
+handle_delete(sadb_msg_t *samsg)
+{
+	(void) bunyan_trace(log, "Handling SADB delete", BUNYAN_T_END);
+
+	/* XXX KEBE SAYS FILL ME IN! */
+	free(samsg);
+}
+
+/*
+ * Handle a PF_KEY ACQUIRE message.  This function, or something that it
+ * calls (either directly or via callbacks) must free samsg.
+ */
+/* XXX KEBE wonders if create_child_sa will be needed here or not. */
+static void
+handle_acquire(sadb_msg_t *samsg, boolean_t create_child_sa)
+{
+	/* XXX: for now */
+	_NOTE(ARGUNUSED(create_child_sa))
+
+	parsedmsg_t *pmsg;
+
+	pmsg = calloc(1, sizeof (*pmsg));
+
+	(void) bunyan_debug(log, "Handling SADB acquire", BUNYAN_T_END);
+
+	if (!extract_exts(samsg, pmsg, 1, SADB_EXT_PROPOSAL)) {
+		(void) bunyan_info(log, "No proposal found in ACQUIRE message",
+		    BUNYAN_T_END);
+		free(samsg);
+		free(pmsg);
+		return;
+	}
+
+	if (!worker_send_cmd(WC_PFKEY, pmsg))
+		parsedmsg_free(pmsg);
+}
+
+static void *
+pfkey_thread(void *arg)
+{
+	port_event_t pe;
+	boolean_t stop = B_FALSE;
+
+	log = arg;
+
+	(void) bunyan_trace(log, "pfkey thread starting", BUNYAN_T_END);
+
+	while (!stop) {
+		if (port_get(pfport, &pe, NULL) < 0) {
+			STDERR(fatal, "port_get() failed");
+			exit(EXIT_FAILURE);
+		}
+
+		(void) bunyan_debug(log, "Received port event",
+		    BUNYAN_T_INT32, "event", pe.portev_events,
+		    BUNYAN_T_STRING, "source",
+		    port_source_str(pe.portev_source),
+		    BUNYAN_T_POINTER, "object", pe.portev_object,
+		    BUNYAN_T_POINTER, "cookie", pe.portev_user,
+		    BUNYAN_T_END);
+
+		VERIFY3S(pe.portev_source, ==, PORT_SOURCE_FD);
+
+		pfkey_inbound((int)pe.portev_object);
+	}
+
+	return (NULL);
+}
+
+static void
+pfkey_register(uint8_t satype)
+{
+	uint64_t buffer[128] = { 0 };
+	char str[64];
+	sadb_msg_t *samsg = (sadb_msg_t *)buffer;
+	ssize_t n;
+	uint32_t msgid = atomic_inc_32_nv(&msgid);
+	pid_t pid = getpid();
+
+	CTASSERT(sizeof (buffer) >= sizeof (*samsg));
+
+	pfkey_msg_init(NULL, samsg, SADB_REGISTER, satype);
+
+	n = write(pfsock, buffer, sizeof (*samsg));
+	if (n < 0)
+		err(EXIT_FAILURE, "pf_key write error");
+	if (n < sizeof (*samsg))
+		errx(EXIT_FAILURE, "Unable to write pf_key register message");
+
+	do {
+		(void) memset(buffer, 0, sizeof (buffer));
+		n = read(pfsock, buffer, sizeof (buffer));
+		if (n < 0)
+			err(EXIT_FAILURE, "pf_key read failure");
+	} while (samsg->sadb_msg_seq != msgid ||
+	    samsg->sadb_msg_pid != pid ||
+	    samsg->sadb_msg_type != SADB_REGISTER);
+
+	if (samsg->sadb_msg_errno != 0) {
+		if (samsg->sadb_msg_errno != EPROTONOSUPPORT)
+			errx(EXIT_FAILURE, "pf_key register returned %s (%d).",
+			    strerror(samsg->sadb_msg_errno),
+			    samsg->sadb_msg_errno);
+		(void) bunyan_error(log, "Protocol not supported",
+		    BUNYAN_T_STRING, "satype",
+		    sadb_type_str(samsg->sadb_msg_satype, str, sizeof (str)),
+		    BUNYAN_T_END);
+	}
+
+	(void) bunyan_debug(log, "Initial REGISTER with SADB",
+	    BUNYAN_T_STRING, "satype",
+	    sadb_type_str(samsg->sadb_msg_satype, str, sizeof (str)),
+	    BUNYAN_T_END);
+
+	handle_register(samsg);
+}
+
+static void
+sadb_log_sa(sadb_ext_t *ext)
+{
+	sadb_sa_t *sa = (sadb_sa_t *)ext;
+	const char *estr = NULL, *astr = NULL, *flagstr = NULL;
+	char buf[11] = { 0 }; /* 0x + 8 hex digits + NUL */
+
+#define	ESTR(x, s) case x: s = #x; break
+	switch (sa->sadb_sa_encrypt) {
+	ESTR(SADB_EALG_NONE, estr);
+	ESTR(SADB_EALG_DESCBC, estr);
+	ESTR(SADB_EALG_3DESCBC, estr);
+	ESTR(SADB_EALG_BLOWFISH, estr);
+	ESTR(SADB_EALG_NULL, estr);
+	ESTR(SADB_EALG_AES, estr);
+	ESTR(SADB_EALG_AES_CCM_8, estr);
+	ESTR(SADB_EALG_AES_CCM_12, estr);
+	ESTR(SADB_EALG_AES_CCM_16, estr);
+	ESTR(SADB_EALG_AES_GCM_8, estr);
+	ESTR(SADB_EALG_AES_GCM_12, estr);
+	ESTR(SADB_EALG_AES_GCM_16, estr);
+	default:
+		estr = enum_printf("%hhu", sa->sadb_sa_encrypt);
+		break;
+	}
+
+	switch (sa->sadb_sa_auth) {
+	ESTR(SADB_AALG_NONE, astr);
+	ESTR(SADB_AALG_SHA256HMAC, astr);
+	ESTR(SADB_AALG_SHA384HMAC, astr);
+	ESTR(SADB_AALG_SHA512HMAC, astr);
+	ESTR(SADB_AALG_MD5HMAC, astr);
+	ESTR(SADB_AALG_SHA1HMAC, astr);
+	default:
+		astr = enum_printf("%hhu", sa->sadb_sa_auth);
+		break;
+	}
+#undef ESTR
+
+	flagstr = enum_printf("0x%" PRIx32, sa->sadb_sa_flags);
+
+	/*
+	 * ipseckey(1M) treats SPI values in pf_key(7P) messages as being in
+	 * network byte order when printing them.  We do the same.
+	 */
+	(void) snprintf(buf, sizeof (buf), "0x%" PRIx32,
+	    ntohl(sa->sadb_sa_spi));
+
+	(void) bunyan_key_add(log,
+	    BUNYAN_T_STRING, PFKEY_K_SPI, buf,
+	    BUNYAN_T_STRING, PFKEY_K_ENCR, estr,
+	    BUNYAN_T_STRING, PFKEY_K_AUTH, astr,
+	    BUNYAN_T_STRING, PFKEY_K_FLAGS, flagstr,
+	    BUNYAN_T_END);
+}
+
+static void
+sadb_log_pair(sadb_ext_t *ext)
+{
+	sadb_x_pair_t *pair = (sadb_x_pair_t *)ext;
+	char buf[11] = { 0 };
+
+	(void) snprintf(buf, sizeof (buf), "0x%" PRIx32,
+	    ntohl(pair->sadb_x_pair_spi));
+	(void) bunyan_key_add(log,
+	    BUNYAN_T_STRING, PFKEY_K_PAIR, buf,
+	    BUNYAN_T_END);
+}
+
+static void
+sadb_log_addr(sadb_ext_t *ext)
+{
+	const char *name = NULL;
+	const char *portname = NULL;
+	sadb_address_t *addr = (sadb_address_t *)ext;
+	sockaddr_u_t su = { .sau_ss = (struct sockaddr_storage *)(addr + 1) };
+	void *ptr = NULL;
+	int af = su.sau_ss->ss_family;
+	char addrstr[INET6_ADDRSTRLEN + 4] = { 0 };	/* +4 for /xxx */
+
+	switch (addr->sadb_address_exttype) {
+	case SADB_EXT_ADDRESS_SRC:
+		name = PFKEY_K_SRCADDR;
+		portname = PFKEY_K_SRCADDR PFKEY_K_PORT;
+		break;
+	case SADB_EXT_ADDRESS_DST:
+		name = PFKEY_K_DSTADDR;
+		portname = PFKEY_K_DSTADDR PFKEY_K_PORT;
+		break;
+	case SADB_X_EXT_ADDRESS_INNER_SRC:
+		name = PFKEY_K_ISRCADDR;
+		portname = PFKEY_K_ISRCADDR PFKEY_K_PORT;
+		break;
+	case SADB_X_EXT_ADDRESS_INNER_DST:
+		name = PFKEY_K_IDSTADDR;
+		portname = PFKEY_K_IDSTADDR PFKEY_K_PORT;
+		break;
+	case SADB_X_EXT_ADDRESS_NATT_REM:
+		name = PFKEY_K_NLOC;
+		portname = PFKEY_K_NLOC PFKEY_K_PORT;
+		break;
+	case SADB_X_EXT_ADDRESS_NATT_LOC:
+		name = PFKEY_K_NREM;
+		portname = PFKEY_K_NREM PFKEY_K_PORT;
+		break;
+	}
+
+	switch (af) {
+	case AF_INET:
+		ptr = &su.sau_sin->sin_addr;
+		break;
+	case AF_INET6:
+		ptr = &su.sau_sin6->sin6_addr;
+		break;
+	default:
+		INVALID("ss_family");
+	}
+
+	if (inet_ntop(af, ptr, addrstr, sizeof (addrstr)) == NULL)
+		return;
+
+	if (addr->sadb_address_prefixlen != 0 &&
+	    ((af == AF_INET && addr->sadb_address_prefixlen != 32) ||
+	    (af == AF_INET6 && addr->sadb_address_prefixlen != 128))) {
+		char prefix[5] = { 0 };
+
+		(void) snprintf(prefix, sizeof (prefix), "/%hhu",
+		    addr->sadb_address_prefixlen);
+		(void) strlcat(addrstr, prefix, sizeof (addrstr));
+	}
+	(void) bunyan_key_add(log,
+	    BUNYAN_T_STRING, name, addrstr,
+	    BUNYAN_T_END);
+
+	/* Take advantage of port (sin_port/sin6_port) at the same offset */
+	if (su.sau_sin->sin_port == 0)
+		return;
+
+	struct protoent *pe = NULL;
+	const char *portstr = NULL;
+	const char *protostr = NULL;
+	uint32_t port = ss_port(su.sau_sa);
+
+	if ((pe = getprotobynumber(addr->sadb_address_proto)) == NULL)
+		protostr = enum_printf("%hhu", addr->sadb_address_proto);
+	else
+		protostr = pe->p_name;
+
+	portstr = (port == 0) ? "any" : enum_printf("%u", port);
+
+	size_t plen = strlen(portstr) + strlen(protostr) + 2; /* '/' + NUL */
+	char pstr[plen];
+
+	(void) snprintf(pstr, plen, "%s/%s", protostr, portstr);
+
+	(void) bunyan_key_add(log,
+	    BUNYAN_T_STRING, portname, pstr, BUNYAN_T_END);
+}
+
+static void
+sadb_log_key(sadb_ext_t *ext)
+{
+	const char *kstr = NULL;
+	const char *klenstr = NULL;
+	sadb_key_t *key = (sadb_key_t *)ext;
+	size_t klen = SADB_64TO8(key->sadb_key_len) - sizeof (*key);
+	size_t slen = klen * 2 + 1;
+	char str[slen];
+
+	switch (ext->sadb_ext_type) {
+	case SADB_EXT_KEY_AUTH:
+		kstr = PFKEY_K_AUTH_KEY;
+		klenstr = PFKEY_K_AUTH_KEYLEN;
+		break;
+	case SADB_EXT_KEY_ENCRYPT:
+		kstr = PFKEY_K_ENCR_KEY;
+		klenstr = PFKEY_K_ENCR_KEYLEN;
+		break;
+	default:
+		INVALID(ext->sadb_ext_type);
+	}
+
+	if (show_keys)
+		writehex((uint8_t *)(key + 1), klen, "", str, slen);
+	else
+		(void) strlcpy(str, "xxx", slen);
+
+	(void) bunyan_key_add(log,
+	    BUNYAN_T_STRING, kstr, str,
+	    BUNYAN_T_UINT32, klenstr, key->sadb_key_bits,
+	    BUNYAN_T_END);
+
+	explicit_bzero(str, slen);
+}
+
+static void
+sadb_log_kmc(sadb_ext_t *ext)
+{
+	sadb_x_kmc_t *kmc = (sadb_x_kmc_t *)ext;
+	const char *proto = NULL;
+	char kmcstr[19] = { 0 }; /* 0x + 64 bit hex + NUL */
+
+	switch (kmc->sadb_x_kmc_proto) {
+	case SADB_X_KMP_MANUAL:
+		proto = "MANUAL";
+		break;
+	case SADB_X_KMP_IKE:
+		proto = "IKEv1";
+		break;
+	case SADB_X_KMP_KINK:
+		proto = "KINK";
+		break;
+	case SADB_X_KMP_IKEV2:
+		proto = "IKEv2";
+		break;
+	default:
+		proto = enum_printf("0x%" PRIu32, kmc->sadb_x_kmc_proto);
+		break;
+	}
+
+	(void) snprintf(kmcstr, sizeof (kmcstr), "0x%" PRIx64,
+	    kmc->sadb_x_kmc_cookie64);
+
+	(void) bunyan_key_add(log,
+	    BUNYAN_T_STRING, PFKEY_K_KMC_PROTO, proto,
+	    BUNYAN_T_STRING, PFKEY_K_KMC_COOKIE, kmcstr,
+	    BUNYAN_T_END);
+}
+
+void
+sadb_log(bunyan_level_t level, const char *restrict msg,
+    sadb_msg_t *restrict samsg)
+{
+	bunyan_logfn_t logf = getlog(level);
+	sadb_ext_t *ext, *end;
+	char op[64];
+	char type[64];
+
+	end = (sadb_ext_t *)((uint64_t *)samsg + samsg->sadb_msg_len);
+	ext = (sadb_ext_t *)(samsg + 1);
+
+	while (ext < end) {
+		switch (ext->sadb_ext_type) {
+		case SADB_EXT_SA:
+			sadb_log_sa(ext);
+			break;
+		case SADB_EXT_KEY_AUTH:
+		case SADB_EXT_KEY_ENCRYPT:
+			sadb_log_key(ext);
+			break;
+		case SADB_EXT_ADDRESS_SRC:
+		case SADB_EXT_ADDRESS_DST:
+		case SADB_X_EXT_ADDRESS_INNER_SRC:
+		case SADB_X_EXT_ADDRESS_INNER_DST:
+		case SADB_X_EXT_ADDRESS_NATT_REM:
+		case SADB_X_EXT_ADDRESS_NATT_LOC:
+			sadb_log_addr(ext);
+			break;
+		case SADB_X_EXT_PAIR:
+			sadb_log_pair(ext);
+			break;
+		case SADB_X_EXT_KM_COOKIE:
+			sadb_log_kmc(ext);
+			break;
+		}
+
+		ext = (sadb_ext_t *)((uint64_t *)ext + ext->sadb_ext_len);
+	}
+
+	logf(log, msg,
+	    BUNYAN_T_STRING, "msg_type",
+	    sadb_op_str(samsg->sadb_msg_type, op, sizeof (op)),
+	    BUNYAN_T_STRING, "sa_type",
+	    sadb_type_str(samsg->sadb_msg_satype, type, sizeof (type)),
+	    BUNYAN_T_UINT32, "msg_pid", samsg->sadb_msg_pid,
+	    BUNYAN_T_UINT32, "msg_seq", samsg->sadb_msg_seq,
+	    BUNYAN_T_UINT32, "msg_errno_val", (uint32_t)samsg->sadb_msg_errno,
+	    BUNYAN_T_STRING, "msg_errno", strerror(samsg->sadb_msg_errno),
+	    BUNYAN_T_UINT32, "msg_diagnostic_val",
+	    (uint32_t)samsg->sadb_x_msg_diagnostic,
+	    BUNYAN_T_STRING, "msg_diagnostic",
+	    keysock_diag(samsg->sadb_x_msg_diagnostic),
+	    BUNYAN_T_UINT32, "length", (uint32_t)samsg->sadb_msg_len,
+	    BUNYAN_T_END);
+
+	for (size_t i = 0; i < ARRAY_SIZE(pfkey_keys); i++)
+		(void) bunyan_key_remove(log, pfkey_keys[i]);
+}
+
+void
+pfkey_init(void)
+{
+	bunyan_logger_t *newlog = NULL;
+	int rc;
+
+	list_create(&pfreq_list, sizeof (pfreq_t), offsetof (pfreq_t, pr_node));
+
+	pfport = port_create();
+	if (pfport == -1)
+		err(EXIT_FAILURE, "Unable to create pfkey event port");
+
+	pfsock = socket(PF_KEY, SOCK_RAW, PF_KEY_V2);
+	if (pfsock == -1)
+		err(EXIT_FAILURE, "Unable to create pf_key socket");
+
+	rc = bunyan_child(log, &newlog,
+	    BUNYAN_T_INT32, "pfsock", (int32_t)pfsock,
+	    BUNYAN_T_END);
+
+	if (rc != 0) {
+		errx(EXIT_FAILURE, "Unable to create child logger: %s",
+		    strerror(rc));
+	}
+
+	pfkey_register(SADB_SATYPE_ESP);
+	pfkey_register(SADB_SATYPE_AH);
+
+	rc = thr_create(NULL, 0, pfkey_thread, newlog, 0, &pftid);
+	if (rc != 0) {
+		errx(EXIT_FAILURE, "Unable to create pfkey thread: %s",
+		    strerror(rc));
+	}
+
+	pfkey_arm(pfsock);
+}
+
+void
+parsedmsg_free(parsedmsg_t *pmsg)
+{
+	if (pmsg == NULL)
+		return;
+
+	free(pmsg->pmsg_samsg);
+	free(pmsg);
+}
+
+/*
+ * Convert a pf_key(7P) SADB_SATYPE_* value to the corresponding IKEv2
+ * protocol.
+ *
+ * This is future-proofing things a bit.  If we ever support key exchange
+ * for additional SA types, it's unlikely the SADB and IKEv2 values will
+ * match, so this provides a single place to do the translation.
+ */
+ikev2_spi_proto_t
+satype_to_ikev2(uint8_t satype)
+{
+	switch (satype) {
+	/* These values match */
+	case SADB_SATYPE_UNSPEC:
+	case SADB_SATYPE_AH:
+	case SADB_SATYPE_ESP:
+		return ((ikev2_spi_proto_t)satype);
+	default:
+		INVALID("satype");
+	}
+	/*NOTREACHED*/
+	return (0);
+}
+
+uint8_t
+ikev2_to_satype(ikev2_spi_proto_t proto)
+{
+	switch (proto) {
+	case IKEV2_PROTO_NONE:
+	case IKEV2_PROTO_AH:
+	case IKEV2_PROTO_ESP:
+		return ((uint8_t)proto);
+	case IKEV2_PROTO_IKE:
+	case IKEV2_PROTO_FC_ESP_HEADER:
+	case IKEV2_PROTO_FC_CT_AUTH:
+		INVALID(proto);
+	}
+	/*NOTREACHED*/
+	return (0);
+}
+
+int
+ikev2_encr_to_pfkey(ikev2_xf_encr_t encr)
+{
+	switch (encr) {
+	/* These all correspond */
+	case IKEV2_ENCR_NONE:
+		return (SADB_EALG_NONE);
+	case IKEV2_ENCR_DES:
+		return (SADB_EALG_DESCBC);
+	case IKEV2_ENCR_3DES:
+		return (SADB_EALG_3DESCBC);
+	case IKEV2_ENCR_BLOWFISH:
+		return (SADB_EALG_BLOWFISH);
+	case IKEV2_ENCR_NULL:
+		return (SADB_EALG_NULL);
+	case IKEV2_ENCR_AES_CBC:
+		return (SADB_EALG_AES);
+	case IKEV2_ENCR_AES_CCM_8:
+		return (SADB_EALG_AES_CCM_8);
+	case IKEV2_ENCR_AES_CCM_12:
+		return (SADB_EALG_AES_CCM_12);
+	case IKEV2_ENCR_AES_CCM_16:
+		return (SADB_EALG_AES_CCM_16);
+	case IKEV2_ENCR_AES_GCM_8:
+		return (SADB_EALG_AES_GCM_8);
+	case IKEV2_ENCR_AES_GCM_12:
+		return (SADB_EALG_AES_GCM_12);
+	case IKEV2_ENCR_AES_GCM_16:
+		return (SADB_EALG_AES_GCM_16);
+	case IKEV2_ENCR_AES_CTR:
+	case IKEV2_ENCR_NULL_AES_GMAC:
+	case IKEV2_ENCR_CAMELLIA_CBC:
+	case IKEV2_ENCR_CAMELLIA_CTR:
+	case IKEV2_ENCR_CAMELLIA_CCM_8:
+	case IKEV2_ENCR_CAMELLIA_CCM_12:
+	case IKEV2_ENCR_CAMELLIA_CCM_16:
+	case IKEV2_ENCR_DES_IV64:
+	case IKEV2_ENCR_DES_IV32:
+	case IKEV2_ENCR_XTS_AES:
+	case IKEV2_ENCR_RC5:
+	case IKEV2_ENCR_IDEA:
+	case IKEV2_ENCR_CAST:
+	case IKEV2_ENCR_3IDEA:
+	case IKEV2_ENCR_RC4:
+		return (-1);
+	}
+	return (-1);
+}
+
+int
+ikev2_auth_to_pfkey(ikev2_xf_auth_t auth)
+{
+	switch (auth) {
+	case IKEV2_XF_AUTH_NONE:
+		return (SADB_AALG_NONE);
+	case IKEV2_XF_AUTH_HMAC_SHA2_256_128:
+		return (SADB_AALG_SHA256HMAC);
+	case IKEV2_XF_AUTH_HMAC_SHA2_384_192:
+		return (SADB_AALG_SHA384HMAC);
+	case IKEV2_XF_AUTH_HMAC_SHA2_512_256:
+		return (SADB_AALG_SHA512HMAC);
+	case IKEV2_XF_AUTH_HMAC_MD5_96:
+		return (SADB_AALG_MD5HMAC);
+	case IKEV2_XF_AUTH_HMAC_SHA1_96:
+		return (SADB_AALG_SHA1HMAC);
+	case IKEV2_XF_AUTH_AES_CMAC_96:
+	case IKEV2_XF_AUTH_AES_128_GMAC:
+	case IKEV2_XF_AUTH_AES_192_GMAC:
+	case IKEV2_XF_AUTH_AES_256_GMAC:
+	case IKEV2_XF_AUTH_DES_MAC:
+	case IKEV2_XF_AUTH_KPDK_MD5:
+	case IKEV2_XF_AUTH_AES_XCBC_96:
+	case IKEV2_XF_AUTH_HMAC_MD5_128:
+	case IKEV2_XF_AUTH_HMAC_SHA1_160:
+		return (-1);
+	}
+	return (-1);
+}
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/pfkey.h b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/pfkey.h
new file mode 100644
index 0000000000..d1815520fe
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/pfkey.h
@@ -0,0 +1,57 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2017 Joyent, Inc.
+ */
+
+#ifndef _PFKEY_H
+#define	_PFKEY_H
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <net/pfkeyv2.h>
+#include "ikev2.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define	IKEV2_SADB_INITIATOR	SADB_X_SAFLAGS_KM1
+
+struct ikev2_sa_s;
+struct ikev2_child_sa_s;
+struct ikev2_sa_result_s;
+struct parsedmsg_s;
+struct ts_s;
+
+void pfkey_send_error(const sadb_msg_t *, uint8_t);
+boolean_t pfkey_getspi(const struct parsedmsg_s *restrict, uint8_t,
+    uint32_t *restrict);
+boolean_t pfkey_inverse_acquire(const struct ts_s *, const struct ts_s *,
+    const struct ts_s *, const struct ts_s *, struct parsedmsg_s **);
+boolean_t pfkey_sadb_add_update(struct ikev2_sa_s *restrict,
+    struct ikev2_child_sa_s *restrict, const uint8_t *restrict,
+    const uint8_t *restrict, const struct parsedmsg_s *restrict);
+boolean_t pfkey_delete(uint8_t, uint32_t, sockaddr_u_t, sockaddr_u_t,
+    boolean_t);
+
+ikev2_spi_proto_t satype_to_ikev2(uint8_t);
+void sadb_log(bunyan_level_t, const char *restrict, sadb_msg_t *restrict);
+
+ikev2_spi_proto_t satype_to_ikev2(uint8_t);
+uint8_t ikev2_to_satype(ikev2_spi_proto_t);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _PFKEY_H */
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/pkcs11.c b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/pkcs11.c
new file mode 100644
index 0000000000..10bfde03d2
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/pkcs11.c
@@ -0,0 +1,557 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the "License").
+ * You may not use this file except in compliance with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ */
+
+/*
+ * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ *
+ * Copyright 2017 Jason King.
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+#include <errno.h>
+#include <ipsec_util.h>
+#include <locale.h>
+#include <note.h>
+#include <security/cryptoki.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include <string.h>
+#include <synch.h>
+#include <syslog.h>
+#include <sys/debug.h>
+#include <umem.h>
+#include "defs.h"
+#include "pkcs11.h"
+#include "worker.h"
+
+/*
+ * This largely handles PKCS#11 session handles as well as providing information
+ * and mapping from PKCS#11 mechanisms to their IKE equivalents.
+ *
+ * PKCS#11 session handles are somewhat quirky.  The documentation isn't
+ * explicit, but strongly implies that a given session handle
+ * (CK_SESSION_HANDLE) can only perform one crypto operation at a time.  As
+ * such, we create a PKCS#11 session handle for each worker thread (in fact
+ * worker.c`worker_init_one() guarantees that each worker thread has it's own
+ * session handle at worker thread creation.  PKCS#11 states (in the
+ * PKCS#11 Usage Guide) that all objects created on a given token are visible
+ * to any other session handles within the same process.  It also states that
+ * the PKCS#11 library is responsible for doing any necessary locking when
+ * a PKCS#11 object is manipulated.
+ *
+ * One quirk of how PKCS#11 handles session, is that when a session handle
+ * is destroyed, any non-presistent objects created by that session handle
+ * are destroyed (though as stated above, the PKCS#11 library takes care
+ * so that if one session is using an object in a PKCS#11 operation while
+ * another session tries to the same object while it's in use, the destruction
+ * will not intefere with the in-progress operation in the other session).
+ * Because the PKCS#11 objects in.ikev2d creates are associated with an
+ * IKE SA, the lifetime of the objects is tied to the lifetime of the IKE SA
+ * and not necessairly that of the worker thread.  As such, any session
+ * handles that are created need to be retained for the lifetime of the
+ * in.ikev2d process.  To accomplish this, we maintain a 'free list' of
+ * session handles.  Any worker threads that exit will have their
+ * session handles placed on the free list, and any requests for a new
+ * session handle will first try to grab a session handle from the
+ * free list before attempting to create a new session.
+ *
+ * If in the future, we wish to allow the use of multiple tokens, this
+ * will likely need to be reworked a bit.  Our pkcs11_softtoken allows
+ * effectively unlimited sessions (bounded by memory), but a hardware
+ * token may have a limit on the number of sessions that can be created,
+ * which might require a more complicated method of managing PKCS#11
+ * session handles.
+ */
+
+/*
+ * Per usr/src/lib/pkcs11/libpkcs11/common/metaGlobal.h, the metaslot
+ * is always slot 0
+ */
+#define	METASLOT_ID	(0)
+
+/*
+ * Unfortunately, the PKCS#11 header files don't define constants for the
+ * string fields in the CK_SLOT_INFO and CK_TOKEN_INFO structures, so
+ * we define them here based on their definitions in <security/pkcs11t.h>
+ */
+
+/* Sizes of CK_SLOT_INFO string fields + NUL */
+#define	PKCS11_MANUF_LEN	(33)
+#define	PKCS11_DESC_LEN		(65)
+
+/* Sizes of CK_TOKEN_INFO string fields + NUL */
+#define	PKCS11_LABEL_LEN	(33)
+#define	PKCS11_MODEL_LEN	(17)
+#define	PKCS11_SERIAL_LEN	(17)
+#define	PKCS11_UTCTIME_LEN	(17)
+
+/* pkcs11_init() sets this during startup and is never altered afterwards */
+CK_INFO			pkcs11_info = { 0 };
+
+static mutex_t			pkcs11_handle_lock;
+static CK_SESSION_HANDLE	*pkcs11_handles;
+static size_t			pkcs11_nhandles;
+static size_t			pkcs11_handlesz;
+
+#define	PKCS11_FUNC		"func"
+#define	PKCS11_RC		"errnum"
+#define	PKCS11_ERRMSG		"err"
+
+static void pkcs11_free(void *);
+static void fmtstr(char *, size_t, CK_UTF8CHAR *, size_t);
+static CK_RV pkcs11_callback_handler(CK_SESSION_HANDLE, CK_NOTIFICATION,
+    void *);
+static void log_slotinfo(CK_SLOT_ID);
+
+/*
+ * Entries with 0 for the PKCS#11 mechanism are ones that aren't supported
+ * by PKCS#11, so their values aren't used beyond the stringified name.
+ */
+static encr_data_t encr_tbl[IKEV2_ENCR_MAX + 1] = {
+	/* p11, desc, mode, min, max, incr, default, blocksz, iv, icv, salt */
+	{ 0, "NONE", MODE_NONE, 0, 0, 0, 0, 0, 0, 0, 0 },
+	{ CKM_DES_CBC, "DES_IV64", MODE_CBC, 64, 64, 0, 64, 8, 8, 0, 0 },
+	{ CKM_DES_CBC, "DES", MODE_CBC, 64, 64, 0, 64, 64, 8, 0, 0 },
+	{ CKM_DES3_CBC, "3DES", MODE_CBC, 192, 192, 0, 192, 8, 8, 0, 0 },
+	{ CKM_RC5_CBC, "RC5", MODE_CBC, 40, 2040, 1, 128, 8, 8, 0, 0 },
+	{ CKM_IDEA_CBC, "IDEA", MODE_CBC, 128, 128, 0, 128, 8, 8, 0, 0 },
+	{ CKM_CAST5_CBC, "CAST", MODE_CBC, 40, 128, 1, 128, 8, 8, 0, 0 },
+	{ CKM_BLOWFISH_CBC, "BLOWFISH", MODE_CBC, 40, 448, 1, 128, 8, 8, 0, 0 },
+	{ 0, "3IDEA", MODE_CBC, 128, 128, 0, 16, 8, 8, 0, 0 },
+	{ CKM_DES_CBC, "DES_IV32", MODE_CBC, 64, 64, 0, 64, 8, 4, 0, 0 },
+	{ CKM_RC4, "RC4", MODE_CBC, 0, 0, 0, 0, 0, 0, 0, 0 },
+	{ 0, "NULL", MODE_NONE, 0, 0, 0, 0, 0, 0, 0, 0 },
+	{ CKM_AES_CBC, "AES_CBC", MODE_CBC, 128, 256, 64, 0, 16, 16, 0, 0 },
+	{ CKM_AES_CTR, "AES_CTR", MODE_CTR,  128, 256, 64, 0, 16, 16, 0, 0 },
+	{ CKM_AES_CCM, "AES_CCM_8", MODE_CCM, 128, 256, 64, 0, 16, 16, 8, 12 },
+	{ CKM_AES_CCM, "AES_CCM_12", MODE_CCM,
+	    128, 256, 64, 0, 16, 16, 12, 12 },
+	{ CKM_AES_CCM, "AES_CCM_16", MODE_CCM,
+	    128, 256, 64, 0, 16, 16, 16, 12 },
+	{ CKM_AES_GCM, "AES_GCM_8", MODE_GCM, 128, 256, 64, 0, 16, 16, 8, 16 },
+	{ CKM_AES_GCM, "AES_GCM_12", MODE_GCM,
+	    128, 256, 64, 0, 16, 16, 12, 16 },
+	{ CKM_AES_GCM, "AES_GCM_16", MODE_GCM,
+	    128, 256, 64, 0, 16, 16, 16, 16 },
+	{ 0, "NULL_AES_GMAC", MODE_NONE, 128, 256, 64, 0, 16, 16, 16, 0 },
+	{ 0, "AES_XTS_AES", MODE_NONE, 128, 256, 64, 0, 0, 0, 0, 0 },
+	{ CKM_CAMELLIA_CBC, "CAMELLIA_CBC", MODE_CBC,
+	    128, 256, 64, 0, 16, 16, 0, 0 },
+	{ CKM_CAMELLIA_CTR, "CAMELLIA_CTR", MODE_CTR,
+	    128, 256, 64, 0, 16, 16, 0, 0 },
+	{ 0, "CAMELLIA_CCM_8", MODE_CCM, 128, 256, 64, 0, 16, 16, 8, 12 },
+	{ 0, "CAMELLIA_CCM_12", MODE_CCM, 128, 256, 64, 0, 16, 16, 12, 12 },
+	{ 0, "CAMELLIA_CCM_16", MODE_CCM, 128, 256, 64, 0, 16, 16, 16, 12 },
+};
+
+static auth_data_t auth_tbl[IKEV2_XF_AUTH_MAX + 1] = {
+	{ 0, "NONE", 0, 0, 0 },
+	{ CKM_MD5_HMAC, "HMAC_MD5_96", 16, 16, 12 },
+	{ CKM_SHA_1_HMAC, "HMAC_SHA1_96", 20, 20, 12 },
+	{ CKM_DES_MAC, "DES_MAC", 0, 0, 0 },
+	{ 0, "KPDK_MD5", 0, 0, 0 },
+	{ CKM_AES_XCBC_MAC_96, "AES_XCBC_96", 16, 16, 12 },
+	{ CKM_MD5_HMAC, "HMAC_MD5_128", 16, 16, 16 },
+	{ CKM_SHA_1_HMAC, "HMAC_SHA1_160", 20, 20, 20 },
+	{ CKM_AES_CMAC, "AES_CMAC_96", 16, 16, 12 },
+
+	/*
+	 * These three aren't specified for IKE, just AH and ESP, so
+	 * their key length, etc. aren't needed.
+	 */
+	{ CKM_AES_GMAC, "AES_128_GMAC", 16, 0, 0 },
+	{ CKM_AES_GMAC, "AES_192_GMAC", 24, 0, 0 },
+	{ CKM_AES_GMAC, "AES_256_GMAC", 32, 0, 0 },
+
+	{ CKM_SHA256_HMAC, "HMAC_SHA2_256_128", 32, 32, 16 },
+	{ CKM_SHA384_HMAC, "HMAC_SHA2_384_192", 48, 48, 24 },
+	{ CKM_SHA512_HMAC, "HMAC_SHA2_512_256", 64, 64, 32 },
+};
+
+/*
+ * Locates the metaslot among the available slots.  If the metaslot
+ * is inable to be located, we terminate.
+ */
+void
+pkcs11_init(void)
+{
+	CK_RV			rv = CKR_OK;
+	CK_ULONG		nslot = 0;
+	CK_C_INITIALIZE_ARGS	args = {
+		NULL_PTR,		/* CreateMutex */
+		NULL_PTR,		/* DestroyMutex */
+		NULL_PTR,		/* LockMutex */
+		NULL_PTR,		/* UnlockMutex */
+		CKF_OS_LOCKING_OK,	/* flags */
+		NULL_PTR		/* reserved */
+	};
+
+	VERIFY0(mutex_init(&pkcs11_handle_lock, USYNC_THREAD|LOCK_ERRORCHECK,
+	    NULL));
+
+	if ((rv = C_Initialize(&args)) != CKR_OK) {
+		PKCS11ERR(fatal, "C_Initialize", rv);
+		exit(EXIT_FAILURE);
+	}
+
+	if ((rv = C_GetInfo(&pkcs11_info)) != CKR_OK) {
+		PKCS11ERR(fatal, "C_Info", rv);
+		exit(EXIT_FAILURE);
+	}
+
+	if ((rv = C_GetSlotList(CK_FALSE, NULL, &nslot)) != CKR_OK) {
+		PKCS11ERR(fatal, "C_GetSlotList", rv);
+		exit(EXIT_FAILURE);
+	}
+
+	CK_SLOT_ID slots[nslot];
+
+	if ((rv = C_GetSlotList(CK_FALSE, slots, &nslot)) != CKR_OK) {
+		PKCS11ERR(fatal, "C_GetSlotList", rv);
+		exit(EXIT_FAILURE);
+	}
+
+	{
+		char manf[PKCS11_MANUF_LEN];
+		char libdesc[PKCS11_DESC_LEN];
+
+		fmtstr(manf, sizeof (manf), pkcs11_info.manufacturerID,
+		    sizeof (pkcs11_info.manufacturerID));
+		fmtstr(libdesc, sizeof (libdesc),
+		    pkcs11_info.libraryDescription,
+		    sizeof (pkcs11_info.libraryDescription));
+
+		(void) bunyan_debug(log, "PKCS#11 provider info",
+		    BUNYAN_T_STRING, "manufacturer", manf,
+		    BUNYAN_T_UINT32, "version.major",
+		    (uint32_t)pkcs11_info.cryptokiVersion.major,
+		    BUNYAN_T_UINT32, "version.minor",
+		    (uint32_t)pkcs11_info.cryptokiVersion.minor,
+		    BUNYAN_T_UINT64, "flags",
+		    (uint64_t)pkcs11_info.flags,
+		    BUNYAN_T_STRING, "library", libdesc,
+		    BUNYAN_T_UINT32, "lib.major",
+		    (uint32_t)pkcs11_info.libraryVersion.major,
+		    BUNYAN_T_UINT32, "lib.minor",
+		    (uint32_t)pkcs11_info.libraryVersion.minor,
+		    BUNYAN_T_UINT32, "numslots", nslot,
+		    BUNYAN_T_END);
+	}
+
+	for (size_t i = 0; i < nslot; i++)
+		log_slotinfo(slots[i]);
+}
+
+static void
+log_slotinfo(CK_SLOT_ID slot)
+{
+	CK_SLOT_INFO info = { 0 };
+	char manuf[PKCS11_MANUF_LEN];
+	CK_RV rv;
+
+	rv = C_GetSlotInfo(slot, &info);
+	if (rv != CKR_OK) {
+		PKCS11ERR(error, "C_GetSlotInfo", rv);
+		return;
+	}
+
+	{
+		char desc[PKCS11_DESC_LEN];
+		fmtstr(desc, sizeof (desc), info.slotDescription,
+		    sizeof (info.slotDescription));
+		fmtstr(manuf, sizeof (manuf), info.manufacturerID,
+		    sizeof (info.manufacturerID));
+
+		(void) bunyan_debug(log, "PKCS#11 slot Info",
+		    BUNYAN_T_UINT64, "slot", (uint64_t)slot,
+		    BUNYAN_T_STRING, "desc", desc,
+		    BUNYAN_T_STRING, "manufacturer", manuf,
+		    BUNYAN_T_UINT32, "hwversion.major",
+		    (uint32_t)info.hardwareVersion.major,
+		    BUNYAN_T_UINT32, "hwversion.minor",
+		    (uint32_t)info.hardwareVersion.minor,
+		    BUNYAN_T_UINT32, "fwversion.major",
+		    (uint32_t)info.firmwareVersion.major,
+		    BUNYAN_T_UINT32, "fwversion.minor",
+		    (uint32_t)info.firmwareVersion.minor,
+		    BUNYAN_T_UINT64, "flags", (uint64_t)info.flags,
+		    BUNYAN_T_BOOLEAN, "present",
+		    !!(info.flags & CKF_TOKEN_PRESENT),
+		    BUNYAN_T_BOOLEAN, "removable",
+		    !!(info.flags & CKF_REMOVABLE_DEVICE),
+		    BUNYAN_T_BOOLEAN, "hwslot", !!(info.flags & CKF_HW_SLOT),
+		    BUNYAN_T_END);
+	}
+
+	if (!(info.flags & CKF_TOKEN_PRESENT))
+		return;
+
+	CK_TOKEN_INFO tinfo = { 0 };
+	rv = C_GetTokenInfo(slot, &tinfo);
+	if (rv != CKR_OK)
+		PKCS11ERR(error, "C_GetTokenInfo", rv);
+
+	char label[PKCS11_LABEL_LEN];
+	char model[PKCS11_MODEL_LEN];
+	char serial[PKCS11_SERIAL_LEN];
+	char utctime[PKCS11_UTCTIME_LEN];
+
+	fmtstr(manuf, sizeof (manuf), tinfo.manufacturerID,
+	    sizeof (tinfo.manufacturerID));
+	fmtstr(label, sizeof (label), tinfo.label, sizeof (tinfo.label));
+	fmtstr(model, sizeof (model), tinfo.model, sizeof (tinfo.model));
+	fmtstr(serial, sizeof (serial), tinfo.serialNumber,
+	    sizeof (tinfo.serialNumber));
+	fmtstr(utctime, sizeof (utctime), tinfo.utcTime,
+	    sizeof (tinfo.utcTime));
+
+#define	F(_inf, _flg) BUNYAN_T_BOOLEAN, #_flg, ((_inf).flags & (_flg))
+	char flagstr[19];
+	(void) snprintf(flagstr, sizeof (flagstr), "0x%lu", info.flags);
+
+	(void) bunyan_debug(log, "PKCS#11 token info",
+	    BUNYAN_T_UINT32, "slot", (uint32_t)slot,
+	    BUNYAN_T_STRING, "label", label,
+	    BUNYAN_T_STRING, "manuf", manuf,
+	    BUNYAN_T_STRING, "model", model,
+	    BUNYAN_T_STRING, "serial", serial,
+	    BUNYAN_T_STRING, "flags", flagstr,
+	    F(info, CKF_RNG),
+	    F(info, CKF_WRITE_PROTECTED),
+	    F(info, CKF_LOGIN_REQUIRED),
+	    F(info, CKF_USER_PIN_INITIALIZED),
+	    F(info, CKF_RESTORE_KEY_NOT_NEEDED),
+	    F(info, CKF_CLOCK_ON_TOKEN),
+	    F(info, CKF_PROTECTED_AUTHENTICATION_PATH),
+	    F(info, CKF_DUAL_CRYPTO_OPERATIONS),
+	    F(info, CKF_TOKEN_INITIALIZED),
+	    F(info, CKF_SECONDARY_AUTHENTICATION),
+	    F(info, CKF_USER_PIN_COUNT_LOW),
+	    F(info, CKF_USER_PIN_FINAL_TRY),
+	    F(info, CKF_USER_PIN_LOCKED),
+	    F(info, CKF_USER_PIN_TO_BE_CHANGED),
+	    F(info, CKF_SO_PIN_COUNT_LOW),
+	    F(info, CKF_SO_PIN_FINAL_TRY),
+	    F(info, CKF_SO_PIN_LOCKED),
+	    F(info, CKF_SO_PIN_TO_BE_CHANGED),
+	    F(info, CKF_ERROR_STATE),
+	    BUNYAN_T_END);
+#undef F
+}
+
+void
+pkcs11_fini(void)
+{
+	CK_RV rv;
+
+	for (size_t i = 0; i < pkcs11_nhandles; i++) {
+		rv = C_CloseSession(pkcs11_handles[i]);
+		if (rv != CKR_OK)
+			PKCS11ERR(error, "C_CloseSession", rv);
+	}
+	free(pkcs11_handles);
+	pkcs11_handles = NULL;
+	pkcs11_nhandles = 0;
+	pkcs11_handlesz = 0;
+
+	rv = C_Finalize(NULL_PTR);
+	if (rv != CKR_OK)
+		PKCS11ERR(error, "C_Finalize", rv);
+}
+
+size_t
+ikev2_auth_icv_size(ikev2_xf_encr_t encr, ikev2_xf_auth_t auth)
+{
+	const encr_data_t *ed = encr_data(encr);
+	const auth_data_t *ad = auth_data(auth);
+
+	VERIFY3P(ed, !=, NULL);
+	VERIFY3P(ad, !=, NULL);
+
+	if (ed->ed_icvlen != 0)
+		return (ed->ed_icvlen);
+	return (ad->ad_icvlen);
+}
+
+/*
+ * Destroy a PKCS#11 object with nicer error messages in case of failure.
+ */
+void
+pkcs11_destroy_obj(const char *name, CK_OBJECT_HANDLE_PTR objp)
+{
+	CK_RV ret;
+
+	if (objp == NULL || *objp == CK_INVALID_HANDLE)
+		return;
+
+	if ((ret = C_DestroyObject(p11h(), *objp)) != CKR_OK) {
+		PKCS11ERR(error, "C_DestroyObject", ret,
+		    BUNYAN_T_STRING, "objname", name);
+	} else {
+		*objp = CK_INVALID_HANDLE;
+	}
+}
+
+static CK_RV
+pkcs11_callback_handler(CK_SESSION_HANDLE session, CK_NOTIFICATION surrender,
+    void *context)
+{
+	_NOTE(ARGUNUSED(session, context));
+	VERIFY3U(surrender, ==, CKN_SURRENDER);
+
+	return (CKR_OK);
+}
+
+#define	CHUNK_SZ (8)
+void
+pkcs11_session_free(CK_SESSION_HANDLE h)
+{
+	if (h == CK_INVALID_HANDLE)
+		return;
+
+	/*
+	 * Per the PKCS#11 standard, multiple handles in the same process
+	 * share any objects created.  However, when a particular handle is
+	 * closed, any objects created by that handle are deleted.  Due to
+	 * this behavior, we do not close any sessions and instead keep
+	 * unused sessions around on a free list for re-use.
+	 *
+	 * It also means in the (hopefully) rare instance we cannot expand
+	 * 'handles' to hold additional unused handles, we just leak them.
+	 * In practice if we are so low on memory that we cannot expand
+	 * 'handles', things are likely messed up enough we'll probably
+	 * end up restarting things anyway.
+	 */
+	mutex_enter(&pkcs11_handle_lock);
+	if (pkcs11_nhandles + 1 > pkcs11_handlesz) {
+		CK_SESSION_HANDLE *nh = NULL;
+		size_t newamt = pkcs11_handlesz + CHUNK_SZ;
+
+		pkcs11_handles = umem_reallocarray(pkcs11_handles,
+		    pkcs11_handlesz, newamt, sizeof (CK_SESSION_HANDLE),
+		    UMEM_NOFAIL);
+		pkcs11_handlesz = newamt;
+	}
+
+	pkcs11_handles[pkcs11_nhandles++] = h;
+	mutex_exit(&pkcs11_handle_lock);
+}
+
+CK_SESSION_HANDLE
+p11h(void)
+{
+	/*
+	 * When a worker is created, it must successfully create a
+	 * PKCS#11 session handle, so this call can never fail or return
+	 * CK_INVALID_HANDLE.
+	 */
+	return (worker->w_p11);
+}
+
+CK_SESSION_HANDLE
+pkcs11_new_session(void)
+{
+	CK_SESSION_HANDLE h;
+	CK_RV ret;
+
+	mutex_enter(&pkcs11_handle_lock);
+	if (pkcs11_nhandles > 0) {
+		h = pkcs11_handles[--pkcs11_nhandles];
+		mutex_exit(&pkcs11_handle_lock);
+		VERIFY3U(h, !=, CK_INVALID_HANDLE);
+		return (h);
+	}
+	mutex_exit(&pkcs11_handle_lock);
+
+	ret = C_OpenSession(METASLOT_ID, CKF_SERIAL_SESSION, NULL,
+	    pkcs11_callback_handler, &h);
+
+	if (ret != CKR_OK) {
+		PKCS11ERR(error, "C_OpenSession", ret);
+		return (CK_INVALID_HANDLE);
+	}
+
+	return (h);
+}
+
+const encr_data_t *
+encr_data(ikev2_xf_encr_t id)
+{
+	if (id > ARRAY_SIZE(encr_tbl))
+		return (NULL);
+
+	return (&encr_tbl[id]);
+}
+
+const auth_data_t *
+auth_data(ikev2_xf_auth_t id)
+{
+	if (id > ARRAY_SIZE(auth_tbl))
+		return (NULL);
+
+	return (&auth_tbl[id]);
+}
+
+boolean_t
+encr_keylen_req(const encr_data_t *ed)
+{
+	return (encr_keylen_allowed(ed) || ed->ed_keydefault != 0);
+}
+
+boolean_t
+encr_keylen_allowed(const encr_data_t *ed)
+{
+	return (ed->ed_keymin != ed->ed_keymax);
+}
+
+boolean_t
+encr_keylen_ok(const encr_data_t *ed, size_t len)
+{
+	if (len < ed->ed_keymin || len > ed->ed_keymax)
+		return (B_FALSE);
+
+	/*
+	 * If in range, value must also be a valid increment, e.g. for
+	 * AES, 192 bits is ok, but 200 bits is not.
+	 */
+	if (((len - ed->ed_keymin) % ed->ed_keyincr) != 0)
+		return (B_FALSE);
+
+	return (B_TRUE);
+}
+
+/*
+ * Sadly, string fields in PKCS#11 structs are not NUL-terminated and
+ * are space padded, so this converts it into a more traditional C-string
+ * with quoting so space padding is evident
+ */
+static void
+fmtstr(char *buf, size_t buflen, CK_UTF8CHAR *src, size_t srclen)
+{
+	ASSERT3U(srclen + 1, <=, buflen);
+
+	(void) memset(buf, 0, buflen);
+	(void) memcpy(buf, src, srclen);
+
+	for (char *p = buf + strlen(buf) - 1; p >= buf && *p == ' '; p--)
+		*p = '\0';
+}
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/pkcs11.h b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/pkcs11.h
new file mode 100644
index 0000000000..d2ca0a7a08
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/pkcs11.h
@@ -0,0 +1,111 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the "License").
+ * You may not use this file except in compliance with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ */
+
+/*
+ * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ *
+ * Copyright 2017 Jason King.
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+#ifndef _PKCS11_H
+#define	_PKCS11_H
+
+#include <sys/types.h>
+#include <security/cryptoki.h>
+#include <bunyan.h>
+#include "defs.h"
+#include "ikev2.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define	PKCS11ERR(_lvl, _p11f, _rv, ...)				\
+	(void) bunyan_##_lvl(log, "PKCS#11 call failed",		\
+	BUNYAN_T_STRING, LOG_KEY_FILE, __FILE__,			\
+	BUNYAN_T_UINT32, LOG_KEY_LINE, (uint32_t)__LINE__,		\
+	BUNYAN_T_STRING, LOG_KEY_FUNC, __func__,			\
+	BUNYAN_T_STRING, "p11func", _p11f,				\
+	BUNYAN_T_UINT64, "p11err", (uint64_t)(_rv),			\
+	BUNYAN_T_STRING, LOG_KEY_ERRMSG, pkcs11_strerror(_rv),		\
+	## __VA_ARGS__,							\
+	BUNYAN_T_END)
+
+typedef enum encr_mode_e {
+	MODE_NONE,
+	MODE_CBC,
+	MODE_CTR,
+	MODE_CCM,
+	MODE_GCM
+} encr_modes_t;
+#define	MODE_IS_COMBINED(m) ((m) == MODE_CCM || (m) == MODE_GCM)
+
+typedef struct encr_data_s {
+	CK_MECHANISM_TYPE	ed_p11id;
+	const char		*ed_name;
+	encr_modes_t		ed_mode;
+	size_t			ed_keymin;	/* bits */
+	size_t			ed_keymax;	/* bits */
+	size_t			ed_keyincr;	/* bits */
+	size_t			ed_keydefault;
+	size_t			ed_blocklen;
+	size_t			ed_ivlen;
+	size_t			ed_icvlen;	/* For combined modes */
+	size_t			ed_saltlen;	/* For combined modes */
+} encr_data_t;
+#define	IKEV2_ENCR_KEYLEN_MAX 256
+#define	IKEV2_ENCR_SALTLEN_MAX 32
+
+typedef struct auth_data_s {
+	CK_MECHANISM_TYPE	ad_p11id;
+	const char		*ad_name;
+	size_t			ad_keylen;
+	size_t			ad_outlen;
+	size_t			ad_icvlen;
+} auth_data_t;
+#define	IKEV2_AUTH_KEYLEN_MAX 512
+
+const encr_data_t *encr_data(ikev2_xf_encr_t);
+const auth_data_t *auth_data(ikev2_xf_auth_t);
+
+extern CK_INFO pkcs11_info;
+
+void pkcs11_init(void);
+void pkcs11_fini(void);
+
+boolean_t encr_keylen_req(const encr_data_t *);
+boolean_t encr_keylen_allowed(const encr_data_t *);
+boolean_t encr_keylen_ok(const encr_data_t *, size_t);
+
+CK_SESSION_HANDLE p11h(void);
+CK_SESSION_HANDLE pkcs11_new_session(void);
+void pkcs11_session_free(CK_SESSION_HANDLE);
+void pkcs11_destroy_obj(const char *, CK_OBJECT_HANDLE_PTR);
+
+size_t ikev2_auth_icv_size(ikev2_xf_encr_t, ikev2_xf_auth_t);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _PKCS11_H */
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/pkt.c b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/pkt.c
new file mode 100644
index 0000000000..89c2b883cd
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/pkt.c
@@ -0,0 +1,1059 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2017 Jason King.
+ * Copyright 2017 Joyent, Inc.
+ */
+#include <stddef.h>
+#include <assert.h>
+#include <umem.h>
+#include <string.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/byteorder.h>
+#include <ipsec_util.h>
+#include <locale.h>
+#include <netinet/in.h>
+#include <note.h>
+#include <security/cryptoki.h>
+#include <errno.h>
+#include <sys/socket.h>
+#include <sys/debug.h>
+#include <note.h>
+#include <err.h>
+#include <limits.h>
+#include <bunyan.h>
+#include "ikev1.h"
+#include "ikev2.h"
+#include "ikev2_sa.h"
+#include "pkt.h"
+#include "pkt_impl.h"
+#include "pkcs11.h"
+#include "worker.h"
+
+static umem_cache_t	*pkt_cache;
+
+static int pkt_reset(void *);
+
+pkt_t *
+pkt_out_alloc(uint64_t i_spi, uint64_t r_spi, uint8_t version,
+    uint8_t exch_type, uint32_t msgid, uint8_t flags)
+{
+	pkt_t *pkt = umem_cache_alloc(pkt_cache, UMEM_DEFAULT);
+	ike_header_t *hdr = pkt_header(pkt);
+
+	if (pkt == NULL)
+		return (NULL);
+
+	hdr->initiator_spi = i_spi;
+	hdr->responder_spi = r_spi;
+	hdr->version = version;
+	hdr->exch_type = exch_type;
+	hdr->msgid = htonl(msgid);
+	hdr->flags = flags;
+
+	pkt->pkt_ptr += sizeof (ike_header_t);
+	return (pkt);
+}
+
+/*
+ * Allocate an pkt_t for an inbound packet, populate the local byte order
+ * header, and cache the location of the payloads in the payload field.
+ */
+pkt_t *
+pkt_in_alloc(void *restrict buf, size_t buflen, pkt_check_fn_t cb)
+{
+	ike_header_t *hdr = (ike_header_t *)buf;
+	pkt_t *pkt = NULL;
+	uint8_t *payptr = NULL;
+	size_t paylen = 0;
+	uint8_t first;
+
+	VERIFY(IS_WORKER);
+
+	/* If inbound checks didn't catch these, it's a bug */
+	VERIFY3U(buflen, >=, sizeof (ike_header_t));
+	VERIFY3U(buflen, ==, ntohl(hdr->length));
+	VERIFY3U(buflen, <=, MAX_PACKET_SIZE);
+
+	first = hdr->next_payload;
+
+	if (!pkt_check_payloads(first, (const uint8_t *)(hdr + 1),
+	    buflen - sizeof (*hdr), cb))
+		return (NULL);
+
+	if ((pkt = umem_cache_alloc(pkt_cache, UMEM_DEFAULT)) == NULL) {
+		STDERR(error, "umem_cache_alloc failed");
+		return (NULL);
+	}
+
+	(void) bunyan_trace(log, "Allocated new pkt_t",
+	    BUNYAN_T_POINTER, "pkt", pkt, BUNYAN_T_END);
+
+	(void) memcpy(pkt->pkt_raw, buf, buflen);
+	pkt->pkt_ptr += buflen;
+
+	payptr = pkt_start(pkt) + sizeof (ike_header_t);
+	paylen = pkt_len(pkt) - sizeof (ike_header_t);
+	if (!pkt_index_payloads(pkt, payptr, paylen, first)) {
+		pkt_free(pkt);
+		return (NULL);
+	}
+
+	(void) bunyan_trace(log, "Finished indexing payloads",
+	    BUNYAN_T_UINT32, "num_payloads", pkt->pkt_payload_count,
+	    BUNYAN_T_END);
+
+	return (pkt);
+}
+
+boolean_t
+pkt_check_payloads(uint8_t first, const uint8_t *buf, size_t buflen,
+    pkt_check_fn_t cb)
+{
+	const uint8_t *ptr = buf;
+	const uint8_t *end = buf + buflen;
+	size_t paylen = 0, paycount = 0;
+	uint8_t type = first;
+
+	while (ptr < end && type != 0) {
+		const ike_payload_t *pay = (const ike_payload_t *)ptr;
+
+		if (ptr + sizeof (*pay) > end) {
+			(void) bunyan_warn(log, "Payload header is truncated",
+			    BUNYAN_T_UINT32, "paynum", (uint32_t)paycount,
+			    BUNYAN_T_UINT32, "paytype", (uint32_t)type,
+			    BUNYAN_T_UINT32, "paylen", (uint32_t)(end - ptr),
+			    BUNYAN_T_END);
+			return (B_FALSE);
+		}
+
+		paylen = BE_IN16(&pay->pay_length);
+		if (ptr + paylen > end) {
+			(void) bunyan_warn(log,
+			    "Payload overruns end of packet",
+			    BUNYAN_T_UINT32, "paynum", (uint32_t)paycount,
+			    BUNYAN_T_UINT32, "paytype", (uint32_t)type,
+			    BUNYAN_T_UINT32, "paylen", (uint32_t)paylen,
+			    BUNYAN_T_END);
+				return (B_FALSE);
+		}
+
+		if (!cb(type, ptr + sizeof (*pay), paylen - sizeof (*pay)))
+			return (B_FALSE);
+
+		type = pay->pay_next;
+		ptr += paylen;
+		paycount++;
+	}
+
+	if (ptr < end) {
+		(void) bunyan_warn(log,
+		    "Packet has trailing data after last payload",
+		    BUNYAN_T_UINT32, "amt", (uint32_t)(end - ptr),
+		    BUNYAN_T_END);
+		return (B_FALSE);
+	}
+
+	return (B_TRUE);
+}
+
+struct index_data {
+	pkt_t		*id_pkt;
+};
+
+static boolean_t
+pkt_index_cb(uint8_t paytype, uint8_t resv, uint8_t *restrict ptr, size_t len,
+    void *restrict cookie)
+{
+	NOTE(ARGUNUSED(resv))
+
+	struct index_data *restrict data = cookie;
+	pkt_t *pkt = data->id_pkt;
+
+	if (!pkt_add_index(pkt, paytype, ptr, len)) {
+		(void) bunyan_info(log,
+		    "Could not add index to packet",
+		    BUNYAN_T_END);
+		return (B_FALSE);
+	}
+
+	if (paytype != IKEV1_PAYLOAD_NOTIFY && paytype != IKEV2_PAYLOAD_NOTIFY)
+		return (B_TRUE);
+
+	ikev2_notify_t ntfy = { 0 };
+	uint64_t spi = 0;
+	uint32_t doi = 0;
+
+	if (len < sizeof (ikev2_notify_t)) {
+		(void) bunyan_warn(log, "Notify payload is truncated",
+		    BUNYAN_T_END);
+		return (B_FALSE);
+	}
+
+	if (pkt_header(pkt)->version == IKEV1_VERSION) {
+		/*
+		 * The IKEv1 notification payload is identical to the IKEv2
+		 * with the exception of the 32-bit DOI field at the begining
+		 * of the struct.
+		 */
+		if (len < sizeof (ikev2_notify_t) + sizeof (uint32_t)) {
+			(void) bunyan_warn(log,
+			    "Notify payload is truncated",
+			    BUNYAN_T_END);
+			return (B_FALSE);
+		}
+
+		doi = BE_IN32(ptr);
+		ptr += sizeof (uint32_t);
+		len -= sizeof (uint32_t);
+	}
+
+	(void) memcpy(&ntfy, ptr, sizeof (ntfy));
+	ptr += sizeof (ntfy);
+	len -= sizeof (ntfy);
+
+	if (ntfy.n_spisize > 0) {
+		if (len < ntfy.n_spisize) {
+			(void) bunyan_warn(log,
+			    "Notify payload SPI length overruns payload",
+			    BUNYAN_T_UINT32, "spilen", (uint32_t)ntfy.n_spisize,
+			    BUNYAN_T_UINT32, "len", (uint32_t)len,
+			    BUNYAN_T_END);
+			return (B_FALSE);
+		}
+
+		/* This advances ptr for us */
+		if (!pkt_get_spi(&ptr, ntfy.n_spisize, &spi)) {
+			(void) bunyan_warn(log,
+			    "Invalid SPI length in notify payload",
+			    BUNYAN_T_UINT32, "spilen", (uint32_t)ntfy.n_spisize,
+			    BUNYAN_T_END);
+			return (B_FALSE);
+		}
+
+		len -= ntfy.n_spisize;
+	}
+
+	if (!pkt_add_nindex(pkt, spi, doi, ntfy.n_protoid, ntohs(ntfy.n_type),
+	    ptr, len))
+		return (B_FALSE);
+
+	return (B_TRUE);
+}
+
+/*
+ * Add entries to pkt->pkt_payloads and pkt->pkt_notify.
+ * NOTE: buf points to the ike_payload_t where it should start.  This
+ * allows embedded encrypted IKEv2 payloads to be able to be indexed
+ * after decryption by running this after decryption with the address of the
+ * first embedded encrypted payload.
+ */
+boolean_t
+pkt_index_payloads(pkt_t *pkt, uint8_t *buf, size_t buflen, uint8_t first)
+{
+	VERIFY3P(pkt_start(pkt), <=, buf);
+	VERIFY3P(pkt->pkt_ptr, >=, buf + buflen);
+
+	struct index_data data = {
+		.id_pkt = pkt,
+	};
+
+	return (pkt_payload_walk(buf, buflen, pkt_index_cb, first, &data));
+}
+
+#define	PKT_CHUNK_SZ	(8)
+boolean_t
+pkt_add_index(pkt_t *pkt, uint8_t type, uint8_t *buf, uint16_t buflen)
+{
+	pkt_payload_t *pay = NULL;
+	ssize_t idx = pkt->pkt_payload_count - PKT_PAYLOAD_NUM;
+
+	VERIFY(!pkt->pkt_done);
+
+	if (pkt->pkt_payload_count < PKT_PAYLOAD_NUM) {
+		VERIFY3S(idx, <, 0);
+		pay = &pkt->pkt_payloads[pkt->pkt_payload_count];
+	} else if (idx < pkt->pkt_payload_alloc) {
+		VERIFY3S(idx, >=, 0);
+		pay = &pkt->pkt_payload_extra[idx];
+	} else {
+		pkt_payload_t *newpay = NULL;
+		size_t newsz = pkt->pkt_payload_alloc + PKT_CHUNK_SZ;
+		size_t amt = newsz * sizeof (pkt_payload_t);
+
+		VERIFY3U(amt, <, newsz);
+		VERIFY3U(amt, <=, sizeof (pkt_payload_t));
+
+		newpay = umem_zalloc(amt, UMEM_DEFAULT);
+		if (newpay == NULL)
+			return (B_FALSE);
+
+		if (pkt->pkt_payload_extra != NULL) {
+			/*
+			 * If the new size doesn't overflow, the original,
+			 * smaller size cannot either.
+			 */
+			(void) memcpy(newpay, pkt->pkt_payload_extra,
+			    pkt->pkt_payload_count * sizeof (pkt_payload_t));
+			umem_free(pkt->pkt_payload_extra,
+			    pkt->pkt_payload_alloc * sizeof (pkt_payload_t));
+		}
+
+		pkt->pkt_payload_extra = newpay;
+		pkt->pkt_payload_alloc = newsz;
+
+		VERIFY3S(idx, >=, 0);
+		pay = &pkt->pkt_payload_extra[idx];
+	}
+
+	pkt->pkt_payload_count++;
+	pay->pp_type = type;
+	pay->pp_ptr = buf;
+	pay->pp_len = buflen;
+	return (B_TRUE);
+}
+
+boolean_t
+pkt_add_nindex(pkt_t *pkt, uint64_t spi, uint32_t doi, uint8_t proto,
+    uint16_t type, uint8_t *buf, size_t buflen)
+{
+	pkt_notify_t *n = NULL;
+	ssize_t idx = pkt->pkt_notify_count - PKT_NOTIFY_NUM;
+
+	VERIFY(!pkt->pkt_done);
+
+	if (pkt->pkt_notify_count < PKT_NOTIFY_NUM) {
+		VERIFY3S(idx, <, 0);
+		n = &pkt->pkt_notify[pkt->pkt_notify_count];
+	} else if (idx < pkt->pkt_notify_alloc) {
+		VERIFY3S(idx, >=, 0);
+		n = &pkt->pkt_notify_extra[idx];
+	} else {
+		pkt_notify_t *newn = NULL;
+		size_t newsz = pkt->pkt_notify_alloc + PKT_CHUNK_SZ;
+		size_t amt = newsz * sizeof (pkt_notify_t);
+
+		VERIFY3U(amt, <, newsz);
+		VERIFY3U(amt, <=, sizeof (pkt_notify_t));
+
+		newn = umem_zalloc(amt, UMEM_DEFAULT);
+		if (newn == NULL)
+			return (B_FALSE);
+
+		if (pkt->pkt_notify_extra != NULL) {
+			(void) memcpy(newn, pkt->pkt_notify_extra,
+			    pkt->pkt_notify_count * sizeof (pkt_notify_t));
+			umem_free(pkt->pkt_notify_extra,
+			    pkt->pkt_notify_alloc * sizeof (pkt_notify_t));
+		}
+
+		pkt->pkt_notify_extra = newn;
+		pkt->pkt_notify_alloc = newsz;
+
+		VERIFY3S(idx, >=, 0);
+		n = &pkt->pkt_notify_extra[idx];
+	}
+
+	pkt->pkt_notify_count++;
+	n->pn_type = type;
+	n->pn_ptr = buf;
+	n->pn_len = buflen;
+	n->pn_doi = doi;
+	n->pn_spi = spi;
+	n->pn_proto = proto;
+	return (B_TRUE);
+}
+
+/*
+ * Add a payload header to pkt as the first step in adding a payload.
+ * NOTE: len is the amount of data that will be added by subsequent operations
+ * not including the payload header itself -- the function will add that itself.
+ * If there is not enough space left for 'len + sizeof (ike_payload_t)' bytes
+ * of data (i.e. header + size of data), the function will return B_FALSE.
+ *
+ * It is permissible to pass a length of 0 for complex payloads where it can
+ * be cumbersome or tedious to calculate the length a priori (e.g. an IKEv1 or
+ * IKEv2 SA payload).  In such instances, the functions constructing the
+ * payload must perform their own checks, and are responsible for updating
+ * the payload length value.  However such callers should still examine
+ * the return value of pkt_add_payload() as it will still check that there's
+ * at least enough space for the payload header.
+ */
+boolean_t
+pkt_add_payload(pkt_t *pkt, uint8_t ptype, uint8_t resv, size_t len)
+{
+	VERIFY(!pkt->pkt_done);
+
+	if (len + sizeof (ike_payload_t) > UINT16_MAX) {
+		errno = ERANGE;
+		return (B_FALSE);
+	}
+	if (pkt_write_left(pkt) < len + sizeof (ike_payload_t)) {
+		errno = ENOSPC;
+		return (B_FALSE);
+	}
+
+	ike_payload_t pld = {
+		.pay_next = 0,
+		.pay_reserved = resv,
+		.pay_length = htons(len + sizeof (ike_payload_t))
+	};
+
+	/* Special case for first payload */
+	if (pkt->pkt_payload_count == 0) {
+		VERIFY3U(pkt_len(pkt), ==, sizeof (ike_header_t));
+		pkt_header(pkt)->next_payload = ptype;
+	} else {
+		pkt_payload_t *pp =
+		    pkt_payload(pkt, pkt->pkt_payload_count - 1);
+		ike_payload_t *payp = ((ike_payload_t *)pp->pp_ptr) - 1;
+		payp->pay_next = ptype;
+	}
+
+	PKT_APPEND_STRUCT(pkt, pld);
+	return (pkt_add_index(pkt, ptype, pkt->pkt_ptr, len));
+}
+
+boolean_t
+pkt_add_sa(pkt_t *restrict pkt, pkt_sa_state_t *restrict pss)
+{
+	ike_payload_t *payp = (ike_payload_t *)pkt->pkt_ptr;
+	boolean_t ok;
+
+	if (pkt_header(pkt)->version == IKEV1_VERSION)
+		ok = pkt_add_payload(pkt, IKEV1_PAYLOAD_SA, 0, 0);
+	else
+		ok = pkt_add_payload(pkt, IKEV2_PAYLOAD_SA, 0, 0);
+
+	if (!ok)
+		return (B_FALSE);
+
+	(void) memset(pss, 0, sizeof (*pss));
+	pss->pss_pkt = pkt;
+	pss->pss_lenp = &payp->pay_length;
+	pss->pss_pld = pkt_payload(pkt, pkt->pkt_payload_count - 1);
+
+	return (B_TRUE);
+}
+
+boolean_t
+pkt_add_prop(pkt_sa_state_t *pss, uint8_t propnum, uint8_t proto, size_t spilen,
+    uint64_t spi)
+{
+	ike_prop_t	prop = { 0 };
+	uint16_t	val = 0, amt = sizeof (prop) + spilen;
+
+	VERIFY(!pss->pss_pkt->pkt_done);
+
+	if (pkt_write_left(pss->pss_pkt) < amt) {
+		errno = ENOSPC;
+		return (B_FALSE);
+	}
+
+	if (pss->pss_prop != NULL)
+		pss->pss_prop->prop_more = IKE_PROP_MORE;
+
+	pss->pss_prop = (ike_prop_t *)pss->pss_pkt->pkt_ptr;
+
+	prop.prop_len = htons(amt);
+	prop.prop_more = IKE_PROP_NONE;
+	prop.prop_num = propnum;
+	prop.prop_proto = proto;
+	prop.prop_spilen = spilen;
+	PKT_APPEND_STRUCT(pss->pss_pkt, prop);
+	/*
+	 * We've already checked there's enough room for the SPI with the
+	 * pkt_write_left() check above, so this better succeed.
+	 */
+	VERIFY(pkt_add_spi(pss->pss_pkt, spilen, spi));
+
+	pss->pss_pld->pp_len += amt;
+	pss->pss_xf = NULL;
+
+	val = BE_IN16(pss->pss_lenp);
+	val += amt;
+	BE_OUT16(pss->pss_lenp, val);
+
+	return (B_TRUE);
+}
+
+boolean_t
+pkt_add_xform(pkt_sa_state_t *pss, uint8_t xftype, uint16_t xfid)
+{
+	ike_xform_t	xf = { 0 };
+	size_t		proplen = BE_IN16(&pss->pss_prop->prop_len);
+	size_t		paylen = BE_IN16(pss->pss_lenp);
+
+	VERIFY(!pss->pss_pkt->pkt_done);
+	VERIFY3U(paylen, ==, pss->pss_pld->pp_len + sizeof (ike_payload_t));
+
+	proplen += sizeof (xf);
+	paylen += sizeof (xf);
+
+	if (pkt_write_left(pss->pss_pkt) < sizeof (xf)) {
+		errno = ENOSPC;
+		return (B_FALSE);
+	}
+	if (proplen > UINT16_MAX || paylen > UINT16_MAX) {
+		errno = ERANGE;
+		return (B_FALSE);
+	}
+	if (pss->pss_prop->prop_numxform == UINT8_MAX) {
+		errno = ERANGE;
+		return (B_FALSE);
+	}
+
+	if (pss->pss_xf != NULL)
+		pss->pss_xf->xf_more = IKE_XFORM_MORE;
+
+	pss->pss_xf = (ike_xform_t *)pss->pss_pkt->pkt_ptr;
+
+	xf.xf_len = htons(sizeof (xf));
+	xf.xf_more = IKE_XFORM_NONE;
+	xf.xf_type = xftype;
+	xf.xf_id = htons(xfid);
+	PKT_APPEND_STRUCT(pss->pss_pkt, xf);
+
+	/* prop_numxform is uint8_t so it can be derefenced directly */
+	pss->pss_prop->prop_numxform++;
+
+	BE_OUT16(&pss->pss_prop->prop_len, proplen);
+	BE_OUT16(pss->pss_lenp, paylen);
+	pss->pss_pld->pp_len += sizeof (xf);
+
+	return (B_TRUE);
+}
+
+boolean_t
+pkt_add_xform_attr_tv(pkt_sa_state_t *pss, uint16_t type, uint16_t val)
+{
+	ike_xf_attr_t	attr = { 0 };
+	size_t		xflen = BE_IN16(&pss->pss_xf->xf_len);
+	size_t		proplen = BE_IN16(&pss->pss_prop->prop_len);
+	size_t		paylen = BE_IN16(pss->pss_lenp);
+
+	VERIFY3U(type, <=, IKE_ATTR_MAXTYPE);
+	VERIFY(!pss->pss_pkt->pkt_done);
+	VERIFY3U(paylen, ==, pss->pss_pld->pp_len + sizeof (ike_payload_t));
+
+	xflen += sizeof (attr);
+	proplen += sizeof (attr);
+	paylen += sizeof (attr);
+
+	if (pkt_write_left(pss->pss_pkt) < sizeof (attr)) {
+		errno = ENOSPC;
+		return (B_FALSE);
+	}
+	if (xflen > UINT16_MAX || proplen > UINT16_MAX || paylen > UINT16_MAX) {
+		errno = ERANGE;
+		return (B_FALSE);
+	}
+
+	attr.attr_type = htons(IKE_ATTR_TYPE(IKE_ATTR_TV, type));
+	attr.attr_len = htons(val);
+	PKT_APPEND_STRUCT(pss->pss_pkt, attr);
+
+	BE_OUT16(&pss->pss_xf->xf_len, xflen);
+	BE_OUT16(&pss->pss_prop->prop_len, proplen);
+	BE_OUT16(pss->pss_lenp, paylen);
+	pss->pss_pld->pp_len += sizeof (attr);
+
+	return (B_TRUE);
+}
+
+boolean_t
+pkt_add_xform_attr_tlv(pkt_sa_state_t *pss, uint16_t type, const uint8_t *attrp,
+    size_t attrlen)
+{
+	ike_xf_attr_t attr = { 0 };
+	size_t		xflen = BE_IN16(&pss->pss_xf->xf_len);
+	size_t		proplen = BE_IN16(&pss->pss_prop->prop_len);
+	size_t		paylen = BE_IN16(pss->pss_lenp);
+	size_t		len = sizeof (attr) + attrlen;
+
+	VERIFY3U(type, <=, IKE_ATTR_MAXTYPE);
+
+	VERIFY(!pss->pss_pkt->pkt_done);
+	VERIFY3U(paylen, ==, pss->pss_pld->pp_len + sizeof (ike_payload_t));
+
+	/*
+	 * IKE_ATTR_MAXLEN is < UINT16_MAX, so if attrlen <= IKE_ATTR_MAXLEN,
+	 * len cannot have overflowed
+	 */
+	if (pkt_write_left(pss->pss_pkt) < len) {
+		errno = ENOSPC;
+		return (B_FALSE);
+	}
+	if (attrlen > IKE_ATTR_MAXLEN || paylen > UINT16_MAX ||
+	    proplen > UINT16_MAX || xflen > UINT16_MAX) {
+		errno = ERANGE;
+		return (B_FALSE);
+	}
+
+	attr.attr_type = htons(IKE_ATTR_TYPE(IKE_ATTR_TLV, type));
+	attr.attr_len = htons(len);
+	PKT_APPEND_STRUCT(pss->pss_pkt, attr);
+	VERIFY(pkt_append_data(pss->pss_pkt, attrp, attrlen));
+
+	BE_OUT16(&pss->pss_xf->xf_len, xflen);
+	BE_OUT16(&pss->pss_prop->prop_len, proplen);
+	BE_OUT16(pss->pss_lenp, paylen);
+	pss->pss_pld->pp_len += sizeof (attr);
+
+	return (B_TRUE);
+}
+
+boolean_t
+pkt_add_notify(pkt_t *restrict pkt, uint32_t doi, uint8_t proto,
+    uint8_t spilen, uint64_t spi, uint16_t type, const void *restrict data,
+    size_t datalen)
+{
+	union {
+		ikev1_notify_t n1;
+		ikev2_notify_t n2;
+	} n;
+	uint8_t *ptr = NULL;
+	size_t len = spilen + datalen;
+
+	VERIFY3U(spilen, <, UINT16_MAX);
+	VERIFY3U(datalen, <, UINT16_MAX);
+
+	if (pkt_header(pkt)->version == IKEV1_VERSION) {
+		len += sizeof (ikev1_notify_t);
+		VERIFY3U(len, <=, UINT16_MAX);
+
+		if (!pkt_add_payload(pkt, IKEV1_PAYLOAD_NOTIFY, 0, len))
+			return (B_FALSE);
+
+		n.n1.n_doi = htonl(doi);
+		n.n1.n_protoid = proto;
+		n.n1.n_spisize = spilen;
+		n.n1.n_type = htons(type);
+		PKT_APPEND_STRUCT(pkt, n.n1);
+	} else if (pkt_header(pkt)->version == IKEV2_VERSION) {
+		len += sizeof (ikev2_notify_t);
+		VERIFY3U(len, <=, UINT16_MAX);
+
+		if (!pkt_add_payload(pkt, IKEV2_PAYLOAD_NOTIFY, 0, len))
+			return (B_FALSE);
+
+		n.n2.n_protoid = proto;
+		n.n2.n_spisize = spilen;
+		n.n2.n_type = htons(type);
+		PKT_APPEND_STRUCT(pkt, n.n2);
+	}
+
+	VERIFY(pkt_add_spi(pkt, spilen, spi));
+	ptr = pkt->pkt_ptr;
+	pkt_append_data(pkt, data, datalen);
+
+	return (pkt_add_nindex(pkt, spi, doi, proto, type, ptr, datalen));
+}
+
+boolean_t
+pkt_add_cert(pkt_t *restrict pkt, uint8_t paytype, uint8_t encoding,
+    const void *data, size_t datalen)
+{
+	if (!pkt_add_payload(pkt, paytype, 0, datalen + 1))
+		return (B_FALSE);
+
+	pkt->pkt_ptr[0] = encoding;
+	pkt->pkt_ptr += 1;
+	VERIFY(pkt_append_data(pkt, data, datalen));
+	return (B_TRUE);
+}
+
+/* pops off all the callbacks in preparation for sending */
+boolean_t
+pkt_done(pkt_t *pkt)
+{
+	ike_header_t *hdr = pkt_header(pkt);
+	hdr->length = htonl(pkt_len(pkt));
+	pkt->pkt_done = B_TRUE;
+	return (B_TRUE);
+}
+
+/*
+ * Call cb on each encountered payload.
+ * data - the first payload to walk
+ * len - total size of the buffer to walk (should end on payload boundary)
+ * cb - callback function to invoke on each payload
+ * first - payload type of the first payload
+ * cookie - data passed to callback
+ */
+boolean_t
+pkt_payload_walk(uint8_t *restrict data, size_t len, pkt_walk_fn_t cb,
+    uint8_t first, void *restrict cookie)
+{
+	uint8_t			*ptr = data;
+	uint8_t			*end = data + len;
+	uint8_t			paytype = first;
+	boolean_t		ret = B_TRUE;
+
+	/* 0 is used for both IKEv1 and IKEv2 to indicate last payload */
+	while (ptr < end && paytype != 0) {
+		ike_payload_t pay = { 0 };
+
+		if (len < sizeof (pay)) {
+			(void) bunyan_info(log, "Payload header is truncated",
+			    BUNYAN_T_UINT32, "paylen", (uint32_t)len,
+			    BUNYAN_T_END);
+			return (B_FALSE);
+		}
+
+		(void) memcpy(&pay, ptr, sizeof (pay));
+
+		/* this length includes the size of the header */
+		pay.pay_length = ntohs(pay.pay_length);
+
+		if (pay.pay_length > len) {
+			(void) bunyan_info(log,
+			    "Payload size overruns end of packet",
+			    BUNYAN_T_UINT32, "paylen", (uint32_t)pay.pay_length,
+			    BUNYAN_T_END);
+			return (B_FALSE);
+		}
+
+		if (cb != NULL && !(ret = cb(paytype, pay.pay_reserved,
+		    ptr + sizeof (pay), pay.pay_length - sizeof (pay),
+		    cookie)))
+				break;
+
+		paytype = pay.pay_next;
+		ptr += pay.pay_length;
+	}
+
+	if (ret && ptr < end) {
+		(void) bunyan_info(log, "Packet contains extranenous data",
+		    BUNYAN_T_UINT32, "amt", (uint32_t)(end - ptr),
+		    BUNYAN_T_END);
+		return (B_FALSE);
+	}
+
+	return (ret);
+}
+
+static size_t
+pay_to_idx(pkt_t *pkt, pkt_payload_t *pay)
+{
+	if (pay == NULL)
+		return (0);
+
+	size_t idx = 0;
+	if (pay >= pkt->pkt_payloads &&
+	    pay < &pkt->pkt_payloads[PKT_PAYLOAD_NUM]) {
+		idx = (size_t)(pay - pkt->pkt_payloads);
+		VERIFY3U(idx, <, pkt->pkt_payload_count);
+		return (idx);
+	}
+
+	VERIFY3P(pay, >=, pkt->pkt_payload_extra);
+	VERIFY3P(pay, <, pkt->pkt_payload_extra + pkt->pkt_payload_count -
+	    PKT_PAYLOAD_NUM);
+	idx = (size_t)(pay - pkt->pkt_payload_extra);
+	return (idx);
+}
+
+/*
+ * Return the first payload of a given type after 'start'.  If start is NULL,
+ * the first payload of the given type will be returned.  This allows for
+ * iteration through payloads of a given type in a packet using code
+ * similar to:
+ *	pkt_payload_t *pay;
+ *	...
+ *	for (pay = pkt_get_payload(pkt, IKEV2_PAYLOAD_CERT, NULL);
+ *	    pay != NULL;
+ *	    pay = pkt_get_payload(pkt, IKEV2_PAYLOAD_CERT, pay)) {
+ *		...
+ *	}
+ *
+ * It is a fatal error to pass a value in start that is not an existing
+ * payload in pkt.
+ */
+pkt_payload_t *
+pkt_get_payload(pkt_t *pkt, uint8_t type, pkt_payload_t *start)
+{
+	size_t idx = (start == NULL) ? 0 : pay_to_idx(pkt, start);
+
+	/*
+	 * If we're searching for the next payload of 'type', we want to
+	 * being searching after 'start'.
+	 */
+	if (start != NULL)
+		idx++;
+
+	for (size_t i = idx; i < pkt->pkt_payload_count; i++) {
+		pkt_payload_t *pay = pkt_payload(pkt, i);
+
+		if (pay->pp_type == (uint8_t)type)
+			return (pay);
+	}
+	return (NULL);
+}
+
+static size_t
+notify_to_idx(pkt_t *pkt, pkt_notify_t *n)
+{
+	if (n == NULL)
+		return (0);
+
+	size_t idx = 0;
+
+	if (n >= pkt->pkt_notify &&
+	    n < &pkt->pkt_notify[PKT_NOTIFY_NUM]) {
+		idx = (size_t)(n - pkt->pkt_notify);
+		VERIFY3U(idx, <, pkt->pkt_notify_count);
+		return (idx);
+	}
+
+	VERIFY3P(n, >=, pkt->pkt_notify_extra);
+	VERIFY3P(n, <, pkt->pkt_notify_extra + pkt->pkt_notify_count -
+	    PKT_NOTIFY_NUM);
+
+	idx = (size_t)(n - pkt->pkt_notify_extra);
+	return (idx);
+}
+
+/*
+ * Return the first payload of type 'type' after 'start'.  If start is
+ * NULL, return the first notify payload of type 'type'.  This allows one
+ * to iterate through multiple instances of a given notify type using something
+ * such as:
+ * 	pkt_notify_t *n;
+ * 	...
+ * 	for (n = pkt_get_notify(pkt, IKEV2_N_NAT_DETECTION_SOURCE_IP, NULL);
+ * 	    n != NULL;
+ * 	    n = pkt_get_notify(pkt, IKEV2_N_NAT_DETECTION_SOURCE_IP, n)) {
+ * 		....
+ * 	}
+ *
+ * It is a fatal error to pass in a notify in 'start' that does not exist
+ * in pkt.
+ */
+pkt_notify_t *
+pkt_get_notify(pkt_t *pkt, uint16_t type, pkt_notify_t *start)
+{
+	size_t idx = notify_to_idx(pkt, start);
+
+	/*
+	 * If we're looking for the next instance of 'type', we need to
+	 * begin our search after the previous value returned (start).
+	 */
+	if (start != NULL)
+		idx++;
+
+	for (uint16_t i = idx; i < pkt->pkt_notify_count; i++) {
+		pkt_notify_t *n = pkt_notify(pkt, i);
+
+		if (n->pn_type == (uint16_t)type)
+			return (n);
+	}
+	return (NULL);
+}
+
+boolean_t
+pkt_add_spi(pkt_t *pkt, size_t spilen, uint64_t spi)
+{
+	if (pkt_write_left(pkt) < spilen)
+		return (B_FALSE);
+
+	switch (spilen) {
+	case sizeof (uint32_t):
+		VERIFY3U(spi, <=, UINT_MAX);
+		VERIFY(put32(pkt, (uint32_t)spi));
+		break;
+	case sizeof (uint64_t):
+		VERIFY(put64(pkt, spi));
+		break;
+	case 0:
+		break;
+	default:
+		INVALID(spilen);
+	}
+	return (B_TRUE);
+}
+
+boolean_t
+pkt_get_spi(uint8_t *restrict *pptr, size_t len, uint64_t *restrict spip)
+{
+	*spip = 0;
+
+	/*
+	 * When writing an SPI, we only support 3 sizes -- 0, 4 (32-bits),
+	 * and 8 (64-bits) corresponding to the IKE SPI and AH/ESP SPI sizes.
+	 * Thus, trying to write an unsupported value is a programming error.
+	 * However it is possible we might encounter an unsupported SPI length
+	 * on inbound packets (it would need to be for something other than
+	 * IKE, AH, or ESP however).  In such a situation, we return
+	 * an error to let the caller decide what to do.
+	 */
+	switch (len) {
+	case 0:
+		return (B_TRUE);
+	case sizeof (uint32_t):
+		*spip = BE_IN32(*pptr);
+		*pptr += sizeof (uint32_t);
+		return (B_TRUE);
+	case sizeof (uint64_t):
+		*spip = BE_IN64(*pptr);
+		*pptr += sizeof (uint64_t);
+		return (B_TRUE);
+	}
+
+	return (B_FALSE);
+}
+
+static int
+pkt_ctor(void *buf, void *ignore, int flags)
+{
+	NOTE(ARGUNUSED(ignore, flags))
+
+	pkt_t *pkt = buf;
+	(void) memset(pkt, 0, sizeof (pkt_t));
+	pkt->pkt_ptr = pkt_start(pkt);
+	return (0);
+}
+
+void
+pkt_free(pkt_t *pkt)
+{
+	if (pkt == NULL)
+		return;
+
+	size_t len = 0;
+	if (pkt->pkt_payload_extra != NULL) {
+		len = pkt->pkt_payload_alloc * sizeof (pkt_payload_t);
+		umem_free(pkt->pkt_payload_extra, len);
+	}
+
+	if (pkt->pkt_notify_extra != NULL) {
+		len = pkt->pkt_notify_alloc * sizeof (pkt_notify_t);
+		umem_free(pkt->pkt_notify_extra, len);
+	}
+
+	pkt_ctor(pkt, NULL, 0);
+	umem_cache_free(pkt_cache, pkt);
+}
+
+void
+pkt_init(void)
+{
+	pkt_cache = umem_cache_create("pkt cache", sizeof (pkt_t),
+	    sizeof (uint64_t), pkt_ctor, NULL, NULL, NULL, NULL, 0);
+	if (pkt_cache == NULL)
+		err(EXIT_FAILURE, "Unable to create pkt umem cache");
+}
+
+void
+pkt_fini(void)
+{
+	umem_cache_destroy(pkt_cache);
+}
+
+size_t
+pkt_len(const pkt_t *pkt)
+{
+	const uint8_t *start = (const uint8_t *)&pkt->pkt_raw;
+	size_t len = (size_t)(pkt->pkt_ptr - start);
+
+	VERIFY3P(pkt->pkt_ptr, >=, start);
+	VERIFY3U(len, <=, MAX_PACKET_SIZE);
+	return ((size_t)(pkt->pkt_ptr - start));
+}
+
+size_t
+pkt_write_left(const pkt_t *pkt)
+{
+	return (MAX_PACKET_SIZE - pkt_len(pkt));
+}
+
+pkt_payload_t *
+pkt_payload(pkt_t *pkt, uint16_t idx)
+{
+	VERIFY3U(idx, <, pkt->pkt_payload_count);
+	if (idx < PKT_PAYLOAD_NUM)
+		return (&pkt->pkt_payloads[idx]);
+	return (pkt->pkt_payload_extra + (idx - PKT_PAYLOAD_NUM));
+}
+
+pkt_notify_t *
+pkt_notify(pkt_t *pkt, uint16_t idx)
+{
+	VERIFY3U(idx, <, pkt->pkt_notify_count);
+	if (idx < PKT_NOTIFY_NUM)
+		return (&pkt->pkt_notify[idx]);
+	return (pkt->pkt_notify_extra + (idx - PKT_NOTIFY_NUM));
+}
+
+boolean_t
+put32(pkt_t *pkt, uint32_t val)
+{
+	if (pkt_write_left(pkt) < sizeof (uint32_t))
+		return (B_FALSE);
+
+	BE_OUT32(pkt->pkt_ptr, val);
+	pkt->pkt_ptr += sizeof (uint32_t);
+	return (B_TRUE);
+}
+
+boolean_t
+put64(pkt_t *pkt, uint64_t val)
+{
+	if (pkt_write_left(pkt) < sizeof (uint64_t))
+		return (B_FALSE);
+
+	BE_OUT64(pkt->pkt_ptr, val);
+	pkt->pkt_ptr += sizeof (uint64_t);
+	return (B_TRUE);
+}
+
+ike_payload_t *
+pkt_idx_to_payload(pkt_payload_t *idxp)
+{
+	VERIFY3P(idxp->pp_ptr, !=, NULL);
+
+	/*
+	 * This _always_ points to the first byte after the ISAKMP/IKEV2
+	 * payload header (empty payloads will have pp_len set to 0.
+	 * ike_payload_t is defined as having byte alignment, so
+	 * we can always backup up from pp_ptr to get to the payload
+	 * header.
+	 */
+	ike_payload_t *pay = (ike_payload_t *)idxp->pp_ptr;
+	return (pay - 1);
+}
+
+boolean_t
+pkt_append_data(pkt_t *restrict pkt, const void *restrict data, size_t len)
+{
+	if (len == 0)
+		return (B_TRUE);
+
+	if (pkt_write_left(pkt) < len)
+		return (B_FALSE);
+	(void) memcpy(pkt->pkt_ptr, data, len);
+	pkt->pkt_ptr += len;
+	return (B_TRUE);
+}
+
+uint8_t *
+pkt_start(const pkt_t *pkt)
+{
+	return ((uint8_t *)pkt->pkt_raw);
+}
+
+ike_header_t *
+pkt_header(const pkt_t *pkt)
+{
+	return ((ike_header_t *)pkt->pkt_raw);
+}
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/pkt.h b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/pkt.h
new file mode 100644
index 0000000000..77ed2395f9
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/pkt.h
@@ -0,0 +1,173 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the "License").
+ * You may not use this file except in compliance with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ */
+
+/*
+ * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ *
+ * Copyright 2017 Jason King.
+ * Copyirght 2017 Joyent, Inc.
+ */
+
+#ifndef _PKT_H
+#define	_PKT_H
+
+#include <net/pfkeyv2.h>
+#include <note.h>
+#include <stddef.h>
+#include <sys/types.h>
+#include "ike.h"
+#include "ikev2.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct ikev2_sa_s;
+struct pkt_s;
+struct pkt_stack_s;
+
+typedef struct pkt_s		pkt_t;
+
+/*
+ * For both payload and notify indices, the pointers point to start of
+ * the payload data, which immediately follows the respective headers.
+ * If either type of index (more likely notify) has no associated data,
+ * the length will equal zero, however the data pointer will still contain
+ * the start of where the data would be if present.  This makes it possible
+ * to still access the respective headers if necessary.
+ */
+typedef struct pkt_payload {
+	uint8_t		*pp_ptr;	/* Start of payload data */
+	uint16_t	pp_len;		/* Excludes payload header */
+	uint8_t		pp_type;
+} pkt_payload_t;
+/*
+ * All of the documented exchanges in RFC7296 use less than 16 payloads
+ * in any given packet of an exchange.  However certain payloads (CERT,
+ * CERTREQ, N, and V) can appear an arbitrary number of times in a packet.
+ * Typically this would be if a large number of certificates are being
+ * sent or requested in an exchange.  The value of 16 was chosen so
+ * that most of the time, we won't need to use pkt_payload_extra to
+ * hold additional indicies, and is a nice power of two.
+ */
+#define	PKT_PAYLOAD_NUM	(16)	/* usually don't need more than this */
+
+typedef struct pkt_notify {
+	uint8_t		*pn_ptr;	/* Start of payload data */
+	uint32_t	pn_doi;		/* Ignored with IKEv2 */
+	uint16_t	pn_len;		/* Excludes notify header + SPI */
+	uint16_t	pn_type;
+	uint8_t		pn_proto;
+	uint64_t	pn_spi;
+} pkt_notify_t;
+/*
+ * Similar to PKT_PAYLOAD_NUM, we choose a power of two that should be
+ * larger than the typical number of notification payloads that would
+ * appear in a packet of any given exchange.
+ */
+#define	PKT_NOTIFY_NUM	(8)
+
+/*
+ * RFC7296 Section 2 states that an implementation MUST accept
+ * payloads up to 1280 octects long, and SHOULD be able to send,
+ * receive, and support messages up to 3000 octets long.  We elect to
+ * round this up to a power of two (8192).  Similar to the
+ * rational for the sizing of pkt_t.pkt_payloads and pkt_t.pkt_notify,
+ * unless a large number of certificates or certificate requests are included
+ * this should be more than enough, especially if the recommendation in RFC7296
+ * of using "Hash and URL" formats for the CERT and CERTREQ payloads is
+ * followed (instead of including the certificates and/or certificate chains).
+ */
+#define	MAX_PACKET_SIZE	(8192)
+struct pkt_s {
+				/* refheld */
+	struct ikev2_sa_s	*pkt_sa;
+
+				/* Transmit count */
+	size_t			pkt_xmit;
+
+				/* Raw packet data */
+	uint64_t		pkt_raw[SADB_8TO64(MAX_PACKET_SIZE)];
+
+				/*
+				 * Points to one past last bit of valid data
+				 * in pkt_raw
+				 */
+	uint8_t			*pkt_ptr;
+
+				/* Payload index */
+	pkt_payload_t		pkt_payloads[PKT_PAYLOAD_NUM];
+	pkt_payload_t		*pkt_payload_extra;
+	uint16_t		pkt_payload_count;
+	uint16_t		pkt_payload_alloc;
+
+	pkt_notify_t		pkt_notify[PKT_NOTIFY_NUM];
+	pkt_notify_t		*pkt_notify_extra;
+	uint16_t		pkt_notify_count;
+	uint16_t		pkt_notify_alloc;
+
+				/*
+				 * Indicates contents of packet will not
+				 * longer be modified.  Set once a packet
+				 * is ready for transmit or after we've
+				 * decrypted/verified an inbound packet
+				 * and have index everything.
+				 */
+	boolean_t		pkt_done;
+	boolean_t		pkt_decrypted;
+};
+
+/* Used to help construct SA payloads */
+typedef struct pkt_sa_state {
+	pkt_t		*pss_pkt;	/* Packet in question */
+	uint16_t	*pss_lenp;	/* Ptr to SA payload length field */
+	pkt_payload_t	*pss_pld;	/* Ptr to SA payload index */
+	ike_prop_t	*pss_prop;	/* Ptr to current proposal struct */
+	ike_xform_t	*pss_xf;	/* Ptr to current xform struct */
+} pkt_sa_state_t;
+
+uint8_t *pkt_start(const pkt_t *);
+ike_header_t *pkt_header(const pkt_t *);
+size_t pkt_len(const pkt_t *);
+size_t pkt_write_left(const pkt_t *);
+boolean_t put32(pkt_t *, uint32_t);
+boolean_t put64(pkt_t *, uint64_t);
+boolean_t pkt_append_data(pkt_t *restrict, const void *restrict, size_t);
+boolean_t pkt_done(pkt_t *);
+void pkt_init(void);
+void pkt_fini(void);
+void pkt_free(pkt_t *);
+
+pkt_payload_t *pkt_get_payload(pkt_t *, uint8_t, pkt_payload_t *);
+pkt_payload_t *pkt_payload(pkt_t *, uint16_t);
+
+pkt_notify_t *pkt_get_notify(pkt_t *, uint16_t, pkt_notify_t *);
+pkt_notify_t *pkt_notify(pkt_t *, uint16_t);
+
+#define	PKT_APPEND_STRUCT(_pkt, _struct) \
+	VERIFY(pkt_append_data(_pkt, &(_struct), sizeof (_struct)))
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _PKT_H */
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/pkt_impl.h b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/pkt_impl.h
new file mode 100644
index 0000000000..165b879a39
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/pkt_impl.h
@@ -0,0 +1,63 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2014 Jason King.  All rights reserved.
+ */
+
+#ifndef _PKT_IMPL_H
+#define	_PKT_IMPL_H
+
+#include "pkt.h"
+#include "ike.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef boolean_t (*pkt_walk_fn_t)(uint8_t, uint8_t, uint8_t *restrict,
+    size_t, void *restrict);
+typedef boolean_t (*pkt_check_fn_t)(uint8_t, const uint8_t *, size_t);
+
+boolean_t pkt_payload_walk(uint8_t *restrict, size_t, pkt_walk_fn_t,
+    uint8_t, void *restrict);
+
+boolean_t pkt_check_payloads(uint8_t, const uint8_t *, size_t, pkt_check_fn_t);
+boolean_t pkt_index_payloads(pkt_t *, uint8_t *, size_t, uint8_t);
+boolean_t pkt_add_index(pkt_t *, uint8_t, uint8_t *, uint16_t);
+boolean_t pkt_add_nindex(pkt_t *, uint64_t, uint32_t, uint8_t, uint16_t,
+    uint8_t *, size_t);
+ike_payload_t *pkt_idx_to_payload(pkt_payload_t *);
+
+pkt_t *pkt_in_alloc(void *restrict, size_t, pkt_check_fn_t);
+pkt_t *pkt_out_alloc(uint64_t, uint64_t, uint8_t, uint8_t, uint32_t, uint8_t);
+void pkt_free(pkt_t *);
+
+boolean_t pkt_add_payload(pkt_t *, uint8_t, uint8_t, size_t);
+boolean_t pkt_add_sa(pkt_t *restrict, pkt_sa_state_t *restrict);
+boolean_t pkt_add_prop(pkt_sa_state_t *, uint8_t, uint8_t, size_t, uint64_t);
+boolean_t pkt_add_xform(pkt_sa_state_t *, uint8_t, uint16_t);
+boolean_t pkt_add_xform_attr_tv(pkt_sa_state_t *, uint16_t, uint16_t);
+boolean_t pkt_add_xform_attr_tlv(pkt_sa_state_t *restrict, uint16_t,
+    const uint8_t *restrict, size_t);
+boolean_t pkt_add_notify(pkt_t *restrict, uint32_t, uint8_t, uint8_t,
+    uint64_t, uint16_t, const void *restrict, size_t);
+boolean_t pkt_add_cert(pkt_t *restrict, uint8_t, uint8_t,
+    const void *restrict, size_t);
+
+boolean_t pkt_add_spi(pkt_t *, size_t, uint64_t);
+boolean_t pkt_get_spi(uint8_t *restrict *, size_t len, uint64_t *restrict);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _PKT_IMPL_H */
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/preshared.c b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/preshared.c
new file mode 100644
index 0000000000..63d9a9a53a
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/preshared.c
@@ -0,0 +1,2041 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the "License").
+ * You may not use this file except in compliance with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ */
+/*
+ * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ *
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+#include <sys/types.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <strings.h>
+#include <errno.h>
+#include <ctype.h>
+#include <libintl.h>
+#include <arpa/inet.h>
+#include <sys/socket.h>
+#include <netdb.h>
+#include <net/pfkeyv2.h>
+#include <pthread.h>
+#include <synch.h>
+#include <assert.h>
+#include <bunyan.h>
+#include <err.h>
+
+#include "preshared.h"
+#include "defs.h"
+#include <ipsec_util.h>
+
+static FILE *fp;
+
+/* Preshared key lock */
+static pthread_rwlock_t ps_rwlock = PTHREAD_RWLOCK_INITIALIZER;
+
+#define	hd2num(hd) (((hd) >= '0' && (hd) <= '9') ? ((hd) - '0') : \
+	(((hd) >= 'a' && (hd) <= 'f') ? ((hd) - 'a' + 10) : ((hd) - 'A' + 10)))
+
+#define	ADDRBITS_V4	32	/* number of bits in IPv4 address */
+#define	ADDRBITS_V6	128	/* number of bits in IPv6 address */
+
+
+#define	CHR_CURLY_BRACE_OPEN		'{'
+#define	CHR_CURLY_BRACE_CLOSE		'}'
+#define	CHR_COMMENT_BEGIN		'#'
+#define	CHR_COLON			':'
+#define	CHR_SLASH			'/'
+#define	CHR_BACKSLASH			'\\'
+#define	CHR_DOUBLEQUOTE			'"'
+#define	CHR_SPACE			' '
+#define	CHR_NEWLINE			'\n'
+#define	CHR_TAB				'\t'
+#define	CHR_NULL			'\0'
+
+/*
+ * Error message strings
+ */
+
+static const char *err_arr [] = {
+#define	ERR_LOCID_MISMATCH		0
+	"Local Id value does not match the specified Localid type",
+#define	ERR_REMID_MISMATCH		1
+	"Remote Id does not match the remoteid type",
+#define	ERR_MAINMODE_LOCID_NOTIP	2
+	"Local Id can only be an IP address",
+#define	ERR_MAINMODE_REMID_NOTIP	3
+	"Remote Id can only be an IP address",
+#define	ERR_ENTRY_NOBEGINBRACE		4
+	"Syntax error - Entry does not start with an open brace",
+#define	ERR_INVALID_FIELDNAME		5
+	"Invalid attribute field name",
+#define	ERR_REPEATED_FIELD		6
+	"Field in an entry is repeated",
+#define	ERR_INVALID_LOCALID_TYPE	7
+	"Invalid Local Id type",
+#define	ERR_MISSING_LOCALID		8
+	"localid not defined",
+#define	ERR_MISSING_REMID		9
+	"remotedid not defined",
+#define	ERR_INVALID_REMID_TYPE		10
+	"Invalid Remote Id type",
+#define	ERR_INVALID_IKE_MODE		11
+	"Invalid Ike Mode",
+#define	ERR_INVALID_BIT_SPECIFIER	12
+	"Invalid Bit Specifier",
+#define	ERR_BITLEN2BIG			13
+	"Bit length too large",
+#define	ERR_WARN_LOWBITS_TRUNC		14
+	"Lower bits will be truncated",
+#define	ERR_STRING_NOT_HEX		15
+	"Invalid string format - hex string expected",
+#define	ERR_BADADDR_PREFIXLEN_PART	16
+	"Invalid prefix length format in address",
+#define	ERR_BADADDR_SLASH_UNEXPECTED	17
+	"Unxpected '/' in address string",
+#define	ERR_BADADDR_TRY_AGAIN		18
+	"Bad address string - try again later",
+#define	ERR_BADADDR_ADDRESS		19
+	"Bad address string",
+#define	ERR_BADADDR_MISMATCH		20
+	"Address versions do not match",
+#define	ERR_BADADDR_MCAST    21
+	"Multicast address not allowed",
+#define	ERR_BADADDR_4MAPPED    22
+	"V4 mapped in v6 address not allowed",
+#define	ERR_BADADDR_4COMPAT    23
+	"V4 compatible in v6 address not allowed",
+#define	ERR_INVALID_ASCII_STRING	24
+	"Syntax error in ASCII string or quotes",
+};
+
+
+/*
+ * Buffer to hold input line
+ */
+static char	linebuf[1024];
+
+
+/*
+ * Types of tokens
+ */
+#define	PS_TOK_BEGIN_CURLY_BRACE	1
+#define	PS_TOK_END_CURLY_BRACE		2
+#define	PS_TOK_FLD_TYPE			3
+#define	PS_TOK_FLD_VALUE		4
+
+
+/*
+ * The prototype syntax of this file used, e.g. "localid" and "localidtype".
+ * The aliases support transitioning to using same keywords as the ike/config
+ * parser, e.g. "local_id" and "local_id_type".
+ *
+ * Also, {local,remote}_addr are aliases for {local,remote}_id for now,
+ * eventually they should be handled differently.
+ */
+static const keywdtab_t fldstab[] = {
+	{ PS_FLD_LOCID,		"localid" },
+	{ PS_FLD_LOCID,		"local_id" },
+	{ PS_FLD_LOCID,		"local_addr" },
+	{ PS_FLD_LOCID_TYPE,	"localidtype" },
+	{ PS_FLD_LOCID_TYPE,	"local_id_type" },
+	{ PS_FLD_REMID,		"remoteid" },
+	{ PS_FLD_REMID,		"remote_id" },
+	{ PS_FLD_REMID,		"remote_addr" },
+	{ PS_FLD_REMID_TYPE,	"remoteidtype" },
+	{ PS_FLD_REMID_TYPE,	"remote_id_type" },
+	{ PS_FLD_IKE_MODE,	"ike_mode" },
+	{ PS_FLD_IKE_MODE,	"mode" },
+	{ PS_FLD_KEY,		"key" },
+};
+
+static const keywdtab_t idstab[] = {
+	{ PS_ID_IP,			"IP" },
+	{ PS_ID_IP4,			"IPv4" },
+	{ PS_ID_IP6,			"IPv6" },
+	{ PS_ID_IP,			"IP_SUBNET" },
+	{ PS_ID_IP4,			"IPv4_SUBNET" },
+	{ PS_ID_IP6,			"IPv6_SUBNET" },
+};
+
+static const keywdtab_t ikmstab[] = {
+	{ PS_IKM_MAIN,			"main" },
+};
+
+/*
+ * Head and tail of linked list of entry data structures
+ */
+static preshared_entry_t *ps_head, *ps_tail;
+
+/*
+ * Global counters for use in reporting approximate error location
+ * in config file
+ */
+static int err_line_number;
+static int err_entry_number;
+
+/*
+ * Function prototypes
+ */
+static int getidtype(char *);
+static int getfldtype(char *);
+static int getikmtype(char *);
+static int postprocess_entry(preshared_entry_t *, char **);
+static char *get_next_token(char **);
+static char *readnextline(FILE *);
+static preshared_entry_t *getnextentry(FILE *, char **);
+static uint8_t *parsekey(char *, uint_t *, uint_t *, char **);
+/* Note: in_get{prefilen,addr}, in6_getaddr stolen from ifconfig.c */
+static int in_getprefixlen(char *, boolean_t, int);
+static int in_getaddr(char *, struct sockaddr_storage *, int *, char **);
+static int in6_getaddr(char *, struct sockaddr_storage *, int *, char **);
+static boolean_t check_if_v6(char *);
+
+
+/*
+ * Functions
+ */
+
+/*
+ * Check for same preshared entry.
+ * Caller holds ps_rwlock as reader
+ */
+static boolean_t
+same_psent(preshared_entry_t *ptr, preshared_entry_t *ps)
+{
+	struct sockaddr_in	*ptr_v4, *ps_v4;
+	struct sockaddr_in6	*ptr_v6, *ps_v6;
+
+	assert(RW_LOCK_HELD(&ps_rwlock));
+
+	/*
+	 * Check for duplicate entries.  Preshared type
+	 * of IPv4/IPv6 has a NULL locid/remid string and
+	 * has the sockaddr_storages structures populated.
+	 * All others store themselves in the aforementioned
+	 * strings.
+	 */
+
+	/* Local and Remote ID types must match */
+	if ((ptr->pe_locidtype != ps->pe_locidtype) ||
+	    (ptr->pe_remidtype != ps->pe_remidtype))
+		return (B_FALSE);
+
+	/* Check local ids */
+	switch (ptr->pe_locidtype) {
+	case PS_ID_IP:
+	case PS_ID_IP4:
+	case PS_ID_SUBNET4:
+		ptr_v4 = (struct sockaddr_in *)&ptr->pe_locid_sa;
+		ps_v4 = (struct sockaddr_in *)&ps->pe_locid_sa;
+		if ((uint32_t)ptr_v4->sin_addr.s_addr !=
+		    (uint32_t)ps_v4->sin_addr.s_addr)
+			return (B_FALSE);
+		/*
+		 * Prefix length either same number or same error
+		 * PS_PLEN_NO_PREFIX for non subnet
+		 */
+		if (&ptr->pe_locid_plen != &ps->pe_locid_plen)
+			return (B_FALSE);
+		break;
+	case PS_ID_IP6:
+	case PS_ID_SUBNET6:
+		ptr_v6 = (struct sockaddr_in6 *)&ptr->pe_locid_sa;
+		ps_v6 = (struct sockaddr_in6 *)&ps->pe_locid_sa;
+		if (!(IN6_ARE_ADDR_EQUAL(&ptr_v6->sin6_addr,
+		    &ps_v6->sin6_addr)))
+			return (B_FALSE);
+		/*
+		 * Prefix length either same number or same error
+		 * PS_PLEN_NO_PREFIX for non subnet
+		 */
+		if (&ptr->pe_locid_plen != &ps->pe_locid_plen)
+			return (B_FALSE);
+		break;
+	default:
+		if (strcmp(ptr->pe_locid, ps->pe_locid) != 0)
+				return (B_FALSE);
+	}
+
+	/* Check remote ids */
+	switch (ptr->pe_remidtype) {
+	case PS_ID_IP:
+	case PS_ID_IP4:
+		ptr_v4 = (struct sockaddr_in *)&ptr->pe_remid_sa;
+		ps_v4 = (struct sockaddr_in *)&ps->pe_remid_sa;
+		if ((uint32_t)ptr_v4->sin_addr.s_addr !=
+		    (uint32_t)ps_v4->sin_addr.s_addr)
+			return (B_FALSE);
+		/*
+		 * Prefix length either same number or same error
+		 * PS_PLEN_NO_PREFIX for non subnet
+		 */
+		if (&ptr->pe_remid_plen != &ps->pe_remid_plen)
+			return (B_FALSE);
+		break;
+	case PS_ID_IP6:
+		ptr_v6 = (struct sockaddr_in6 *)&ptr->pe_remid_sa;
+		ps_v6 = (struct sockaddr_in6 *)&ps->pe_remid_sa;
+		if (!(IN6_ARE_ADDR_EQUAL(&ptr_v6->sin6_addr,
+		    &ps_v6->sin6_addr)))
+			return (B_FALSE);
+		/*
+		 * Prefix length either same number or same error
+		 * PS_PLEN_NO_PREFIX for non subnet
+		 */
+		if (&ptr->pe_remid_plen != &ps->pe_remid_plen)
+			return (B_FALSE);
+		break;
+	default:
+		if (strcmp(ptr->pe_remid, ps->pe_remid) != 0)
+				return (B_FALSE);
+	}
+	return (B_TRUE);
+}
+
+/*
+ * Check for duplicate preshared entry.
+ * Caller holds ps_rwlock as reader
+ */
+static boolean_t
+has_dup(preshared_entry_t *ps, preshared_entry_t **head)
+{
+	preshared_entry_t *ptr;
+
+	assert(RW_LOCK_HELD(&ps_rwlock));
+
+	if (ps == NULL) /* no op */
+		return (B_FALSE);
+
+	ptr = *head;
+
+	while (ptr != NULL) {
+		if (same_psent(ptr, ps))
+			return (B_TRUE);
+		ptr = ptr->pe_next;
+	}
+	return (B_FALSE);
+}
+
+/*
+ * Append entries to list.
+ * Caller holds ps_rwlock as writer
+ */
+static boolean_t
+append_to_list(preshared_entry_t *ps, preshared_entry_t **head,
+    preshared_entry_t **tail)
+{
+	assert(RW_WRITE_HELD(&ps_rwlock));
+
+	if (ps == NULL)		/* no op */
+		return (B_TRUE);
+	assert(ps->pe_refcnt > 0);
+	if (has_dup(ps, head)) {
+		(void) fprintf(stderr,
+		    gettext("Ignoring duplicate preshared entry.\n"));
+		PE_REFRELE(ps);
+		return (B_FALSE);
+	}
+	ps->pe_next = NULL;	/* will be last entry */
+	if (*head == NULL) {
+		/* list initialization  */
+		*head = *tail = ps;
+	} else {
+		(*tail)->pe_next = ps;
+		*tail = (*tail)->pe_next;
+	}
+	return (B_TRUE);
+}
+
+/*
+ * Appends preshared entry to list
+ * Holds ps_rwlock as writer
+ */
+boolean_t
+append_preshared_entry(preshared_entry_t *ps)
+{
+	boolean_t rc;
+
+	(void) pthread_rwlock_wrlock(&ps_rwlock);
+	rc = append_to_list(ps, &ps_head, &ps_tail);
+	(void) pthread_rwlock_unlock(&ps_rwlock);
+	return (rc);
+}
+
+/*
+ * Frees preshared list
+ * Caller holds ps_rwlock as writer
+ */
+static void
+free_preshared_list(preshared_entry_t **head, preshared_entry_t **tail)
+{
+	preshared_entry_t	*ps;
+
+	assert(RW_WRITE_HELD(&ps_rwlock));
+
+	while (*head != NULL) {
+		/* Zero the old list in case of reloading. */
+		ps = *head;
+		if (ps == *tail)
+			*tail = NULL;
+		*head = ps->pe_next;
+		PE_REFRELE(ps);
+	}
+}
+
+static char *
+getidstr(int val)
+{
+	const keywdtab_t *idt;
+
+	for (idt = idstab; idt < A_END(idstab); idt++) {
+		if (val == idt->kw_tag)
+			return (idt->kw_str);
+	}
+	return (NULL);		/* not found */
+}
+
+static int
+getidtype(char *valp)
+{
+	const keywdtab_t *idt;
+
+	for (idt = idstab; idt < A_END(idstab); idt++) {
+		if (strcasecmp(valp, idt->kw_str) == 0)
+			return (idt->kw_tag);
+	}
+	return (-1);		/* not found */
+}
+
+static int
+getfldtype(char *valp)
+{
+	const keywdtab_t *fldt;
+
+	for (fldt = fldstab; fldt < A_END(fldstab); fldt++) {
+		if (strcasecmp(valp, fldt->kw_str) == 0)
+			return (fldt->kw_tag);
+	}
+	return (-1);		/* not found */
+}
+
+static char *
+getikmstr(int val)
+{
+	const keywdtab_t *idt;
+
+	for (idt = ikmstab; idt < A_END(ikmstab); idt++) {
+		if (val == idt->kw_tag)
+			return (idt->kw_str);
+	}
+	return (NULL);		/* not found */
+}
+
+static int
+getikmtype(char *valp)
+{
+	const keywdtab_t *ikmt;
+
+	for (ikmt = ikmstab; ikmt < A_END(ikmstab); ikmt++) {
+		if (strcasecmp(valp, ikmt->kw_str) == 0)
+			return (ikmt->kw_tag);
+	}
+	return (-1);		/* not found */
+
+}
+
+/*
+ * unlike the other get*str functions, this one mallocs the returned
+ * string, so the caller will need to free it.
+ */
+char *
+getkeystr(uint8_t *key, uint_t bytes, uint_t bits)
+{
+	uint8_t	*sp;
+	char	*dp, *buf;
+	uint_t	len;
+
+	/* assume two digits per byte, and no more than 4 digits of bitlen */
+	len = (bytes < 1) + 6;
+	if ((buf = malloc(len)) == NULL)
+		return (NULL);
+
+	sp = key;
+	dp = buf;
+	while (bytes-- != 0) {
+		(void) sprintf(dp, "%02x", *sp++);
+		dp += 2;
+	}
+	(void) sprintf(dp, "/%d", bits);
+
+	return (buf);
+}
+
+/*
+ * Parsing for hex key values.
+ * Return value:
+ *	Pointer to allocated buffer containing the key
+ *	Parameter, "len" contains length of key buffer on successful return
+ *	Parameter, "lbits" contains length of key in bits in the key buffer.
+ * Note:Stolen from ipseckey.c and then adapted for use here.
+ */
+static uint8_t *
+parsehexkey(char *input, uint_t *keybuflen, uint_t *lbits, char **errp)
+{
+	uint8_t *keyp, *keybufp;
+	uint_t i, hexlen = 0, bits, alloclen;
+
+	for (i = 0; input[i] != CHR_NULL && input[i] != CHR_SLASH; i++)
+		hexlen++;
+
+	if (input[i] == CHR_NULL) {
+		bits = 0;
+	} else {
+		/* Have /nn. */
+		input[i] = CHR_NULL;
+		if (sscanf((input + i + 1), "%u", &bits) != 1) {
+			*errp = (char *)err_arr[ERR_INVALID_BIT_SPECIFIER];
+			return (NULL);
+		}
+
+		/* hexlen in nibbles */
+		if (((bits + 3) >> 2) > hexlen) {
+			*errp = (char *)err_arr[ERR_BITLEN2BIG];
+			return (NULL);
+		}
+
+		/*
+		 * Adjust hexlen down if user gave us too small of a bit
+		 * count.
+		 */
+		if ((hexlen << 2) > bits + 3) {
+			/*
+			 * NOTE: Callers don't necessarily handle warnings
+			 * a successful return.
+			 */
+			*errp = (char *)err_arr[ERR_WARN_LOWBITS_TRUNC];
+			hexlen = (bits + 3) >> 2;
+			input[hexlen] = CHR_NULL;
+		}
+	}
+
+	/*
+	 * Allocate.  Remember, hexlen is in nibbles.
+	 */
+
+	alloclen = (hexlen/2 + (hexlen & 0x1));
+	keyp = malloc(alloclen);
+
+	if (keyp == NULL) {
+		*errp = strerror(errno);
+		return (NULL);
+	}
+
+	keybufp = keyp;
+	*keybuflen = alloclen;
+	if (bits == 0)
+		*lbits = (hexlen + (hexlen & 0x1)) << 2;
+	else
+		*lbits = bits;
+
+	/*
+	 * Read in nibbles.  Read in odd-numbered as shifted high.
+	 * (e.g. 123 becomes 0x1230).
+	 */
+
+	for (i = 0; input[i] != CHR_NULL; i += 2) {
+		boolean_t second = (input[i + 1] != CHR_NULL);
+
+		if (!isxdigit(input[i]) ||
+		    (!isxdigit(input[i + 1]) && second)) {
+			free(keybufp); /* free allocated memory on error */
+			*errp = (char *)err_arr[ERR_STRING_NOT_HEX];
+			return (NULL);
+		}
+		*keyp = (hd2num(input[i]) << 4);
+		if (second)
+			*keyp |= hd2num(input[i + 1]);
+		else
+			break;	/* out of for loop. */
+		keyp++;
+	}
+
+	/* bzero the remaining bits if we're a non-octet amount. */
+	if (bits & 0x7)
+		*((input[i] == CHR_NULL) ? keyp - 1 : keyp) &=
+		    0xff << (8 - (bits & 0x7));
+	return (keybufp);
+}
+/*
+ * Parsing for ASCII key values.
+ * Return value:
+ *	Pointer to allocated buffer containing the key
+ *	Parameter, "len" contains length of key buffer on successful return
+ *	Parameter, "lbits" contains length of key in bits in the key buffer.
+ * Note:Stolen from ipseckey.c and then adapted for use here.
+ */
+static uint8_t *
+parseasciikey(char *input, uint_t *keybuflen, uint_t *lbits, char **errp)
+{
+	uint8_t *keyp, *keybufp;
+	uint_t i, asciilen = 0;
+
+	/* Make sure the first and last characters are '"', unescaped */
+
+	if (input[0] != CHR_DOUBLEQUOTE)
+		goto invalid_ascii_string;
+
+	/* Set pointer past first quote, then find the end */
+	input++;
+
+	for (i = 0; input[i] != CHR_NULL; i++)
+		asciilen++;
+	/*
+	 * Length without trailing \0 and leading quote lopped off
+	 * from before must be at least 3 for a well formed key
+	 */
+	if (--asciilen < 3)
+		goto invalid_ascii_string;
+	/*
+	 * Make sure the last quote exists and is not escaped,
+	 * but also watch for valid "this string\\" syntax.
+	 */
+	if (input[asciilen] != CHR_DOUBLEQUOTE)
+		goto invalid_ascii_string;
+
+	/* We know we can dereference these because of length check above */
+	if ((input[asciilen - 1] == CHR_BACKSLASH) &&
+	    (input[asciilen - 2] != CHR_BACKSLASH))
+		goto invalid_ascii_string;
+
+	input[asciilen] = CHR_NULL;
+
+	/* Now we have something well-formed in quotes and length set */
+
+	/*
+	 * Allocate.  If we have backslashes, we can shrink later
+	 */
+
+	keyp = malloc(asciilen);
+	if (keyp == NULL) {
+		*errp = strerror(errno);
+		return (NULL);
+	}
+
+	keybufp = keyp;
+	/*
+	 * Read in bytes, but be aware of next byte for escape purposes
+	 */
+
+	for (i = 0; input[i] != CHR_NULL; i++) {
+		boolean_t second = (input[i + 1] != CHR_NULL);
+
+		if (!isascii(input[i]) ||
+		    (second && !isascii(input[i + 1]))) {
+			goto free_key_buffer;
+		}
+		/*
+		 * Consider backslash an escape character for
+		 * itself, single and double quotes, but not
+		 * for anything else
+		 */
+		if (second && (input[i] == CHR_BACKSLASH)) {
+			if (input[i + 1] == CHR_DOUBLEQUOTE ||
+			    input[i + 1] == CHR_BACKSLASH) {
+				*keyp = input[i + 1];
+				i++;
+				keyp++;
+				asciilen--;
+				continue; /* for loop */
+			}
+		}
+		*keyp = input[i];
+		keyp++;
+	}
+	/* Shrink to fit */
+	*keybuflen = asciilen;
+	*lbits = asciilen << 3;
+	keybufp = realloc(keybufp, asciilen);
+
+	return (keybufp);
+
+free_key_buffer:
+	free(keybufp);
+invalid_ascii_string:
+	*errp = (char *)err_arr[ERR_INVALID_ASCII_STRING];
+	return (NULL);
+}
+
+static uint8_t *
+parsekey(char *input, uint_t *keybuflen, uint_t *lbits, char **errp)
+{
+	/* Determine if this is an ASCII key or hex key */
+	if (input[0] == CHR_DOUBLEQUOTE) {
+		return (parseasciikey(input, keybuflen, lbits, errp));
+	} else {
+		return (parsehexkey(input, keybuflen, lbits, errp));
+	}
+}
+
+static boolean_t
+check_if_v6(char *abuf)
+{
+	char *cp;
+	for (cp = abuf; *cp != CHR_NULL; cp++) {
+		if (*cp == CHR_COLON)
+			return (B_TRUE);
+	}
+	return (B_FALSE);
+}
+
+static boolean_t
+valid_ip6_address(struct sockaddr_in6 *addr, char **errmsgp)
+{
+
+		/* is it mcast */
+		if (IN6_IS_ADDR_MULTICAST(&addr->sin6_addr)) {
+			*errmsgp = (char *)err_arr[ERR_BADADDR_MCAST];
+			return (B_FALSE);
+		}
+		/* is it v4 mapped */
+		if (IN6_IS_ADDR_V4MAPPED(&addr->sin6_addr)) {
+			*errmsgp = (char *)err_arr[ERR_BADADDR_4MAPPED];
+			return (B_FALSE);
+		}
+		/* is it v4 compat */
+		if (IN6_IS_ADDR_V4COMPAT(&addr->sin6_addr)) {
+			*errmsgp = (char *)err_arr[ERR_BADADDR_4COMPAT];
+			return (B_FALSE);
+		}
+
+		return (B_TRUE);
+}
+
+/*
+ * Post process preshared key entry.
+ * Caller holds ps_rwlock as reader
+ */
+static int
+postprocess_entry(preshared_entry_t *ps, char **errmsgp)
+{
+	assert(RW_LOCK_HELD(&ps_rwlock));
+
+	/* ID types default to IP. */
+	if ((ps->pe_flds_mask & PS_FLD_LOCID_TYPE) == 0) {
+		ps->pe_flds_mask |= PS_FLD_LOCID_TYPE;
+		ps->pe_locidtype = PS_ID_IP;
+	}
+	if ((ps->pe_flds_mask & PS_FLD_REMID_TYPE) == 0) {
+		ps->pe_flds_mask |= PS_FLD_REMID_TYPE;
+		ps->pe_remidtype = PS_ID_IP;
+	}
+
+	/*
+	 * Verify that all mandatory fields are there.
+	 * mandatory:  local_id and remote_id (or local_addr and remote_addr),
+	 * mode, and key.
+	 */
+
+	/*
+	 * Note: verify that semantic relationships among fields is fine
+	 * Since we only support main mode, we force the mode to be main.
+	 */
+
+	ps->pe_ike_mode = PS_IKM_MAIN;
+	if ((ps->pe_locidtype != PS_ID_IP) &&
+	    (ps->pe_locidtype != PS_ID_IP4) &&
+	    (ps->pe_locidtype != PS_ID_IP6)) {
+		*errmsgp = (char *)err_arr[ERR_MAINMODE_LOCID_NOTIP];
+		return (-1);
+	}
+	if ((ps->pe_remidtype != PS_ID_IP) &&
+	    (ps->pe_remidtype != PS_ID_IP4) &&
+	    (ps->pe_remidtype != PS_ID_IP6)) {
+		*errmsgp = (char *)err_arr[ERR_MAINMODE_REMID_NOTIP];
+		return (-1);
+	}
+
+	/*
+	 * Parse "id" values now and verify that they match the
+	 * "idtype" associated with them.
+	 * NOTE: Real work is TBD
+	 */
+	if (ps->pe_flds_mask & PS_FLD_LOCID_TYPE) {
+		int retval;
+
+		if (ps->pe_locid == NULL) {
+			*errmsgp = (char *)err_arr[ERR_MISSING_LOCALID];
+			return (-1);
+		}
+
+		switch (ps->pe_locidtype) {
+		case PS_ID_IP:
+		{
+			boolean_t isv6 = check_if_v6(ps->pe_locid);
+			if (isv6) {
+				ps->pe_locidtype = PS_ID_IP6;
+				retval = in6_getaddr(ps->pe_locid,
+				    &ps->pe_locid_sa, &ps->pe_locid_plen,
+				    errmsgp);
+			} else {
+				ps->pe_locidtype = PS_ID_IP4;
+				retval = in_getaddr(ps->pe_locid,
+				    &ps->pe_locid_sa, &ps->pe_locid_plen,
+				    errmsgp);
+			}
+			if (retval < 0)
+				return (-1);
+		}
+		break;
+		case PS_ID_IP4:
+		case PS_ID_SUBNET4:
+			retval = in_getaddr(ps->pe_locid, &ps->pe_locid_sa,
+			    &ps->pe_locid_plen, errmsgp);
+			if (retval < 0)
+				return (-1);
+			break;
+		case PS_ID_IP6:
+		case PS_ID_SUBNET6:
+			retval = in6_getaddr(ps->pe_locid, &ps->pe_locid_sa,
+			    &ps->pe_locid_plen, errmsgp);
+			if (retval < 0)
+				return (-1);
+			break;
+		case PS_ID_SUBNET:
+		{
+			boolean_t isv6 = check_if_v6(ps->pe_locid);
+			if (isv6) {
+				ps->pe_locidtype = PS_ID_SUBNET6;
+				retval = in6_getaddr(ps->pe_locid,
+				    &ps->pe_locid_sa, &ps->pe_locid_plen,
+				    errmsgp);
+			} else {
+				ps->pe_locidtype = PS_ID_SUBNET4;
+				retval = in_getaddr(ps->pe_locid,
+				    &ps->pe_locid_sa, &ps->pe_locid_plen,
+				    errmsgp);
+			}
+			if (retval < 0)
+				return (-1);
+		}
+		break;
+		case PS_ID_RANGE:
+			break;
+		case PS_ID_RANGE4:
+			break;
+		case PS_ID_RANGE6:
+			break;
+		case PS_ID_ASN1DN:
+			break;
+		case PS_ID_ASN1GN:
+			break;
+		case PS_ID_KEYID:
+			break;
+		case PS_ID_FQDN:
+			break;
+		case PS_ID_USER_FQDN:
+			break;
+		}
+	}
+	if (ps->pe_flds_mask & PS_FLD_REMID_TYPE) {
+		int retval;
+
+		if (ps->pe_remid == NULL) {
+			*errmsgp = (char *)err_arr[ERR_MISSING_REMID];
+			return (-1);
+		}
+		switch (ps->pe_remidtype) {
+		case PS_ID_IP:
+		{
+			boolean_t isv6 = check_if_v6(ps->pe_remid);
+			if (isv6) {
+				ps->pe_remidtype = PS_ID_IP6;
+				retval = in6_getaddr(ps->pe_remid,
+				    &ps->pe_remid_sa, &ps->pe_remid_plen,
+				    errmsgp);
+			} else {
+				ps->pe_remidtype = PS_ID_IP4;
+				retval = in_getaddr(ps->pe_remid,
+				    &ps->pe_remid_sa, &ps->pe_remid_plen,
+				    errmsgp);
+			}
+			if (retval < 0)
+				return (-1);
+		}
+		break;
+		case PS_ID_IP4:
+		case PS_ID_SUBNET4:
+			retval = in_getaddr(ps->pe_remid, &ps->pe_remid_sa,
+			    &ps->pe_remid_plen, errmsgp);
+			if (retval < 0)
+				return (-1);
+			break;
+		case PS_ID_IP6:
+		case PS_ID_SUBNET6:
+			retval = in6_getaddr(ps->pe_remid, &ps->pe_remid_sa,
+			    &ps->pe_remid_plen, errmsgp);
+			if (retval < 0)
+				return (-1);
+			break;
+		case PS_ID_SUBNET:
+		{
+			boolean_t isv6 = check_if_v6(ps->pe_remid);
+			if (isv6) {
+				ps->pe_remidtype = PS_ID_SUBNET6;
+				retval = in6_getaddr(ps->pe_remid,
+				    &ps->pe_remid_sa, &ps->pe_remid_plen,
+				    errmsgp);
+			} else {
+				ps->pe_remidtype = PS_ID_SUBNET4;
+				retval = in_getaddr(ps->pe_remid,
+				    &ps->pe_remid_sa, &ps->pe_remid_plen,
+				    errmsgp);
+			}
+			if (retval < 0)
+				return (-1);
+		}
+		break;
+		case PS_ID_RANGE:
+			break;
+		case PS_ID_RANGE4:
+			break;
+		case PS_ID_RANGE6:
+			break;
+		case PS_ID_ASN1DN:
+			break;
+		case PS_ID_ASN1GN:
+			break;
+		case PS_ID_KEYID:
+			break;
+		case PS_ID_FQDN:
+			break;
+		case PS_ID_USER_FQDN:
+			break;
+		}
+	}
+
+	/*
+	 * Reality check address families
+	 * Remote and local address families must match
+	 */
+	if (check_if_v6(ps->pe_locid) != check_if_v6(ps->pe_remid)) {
+		*errmsgp = (char *)err_arr[ERR_BADADDR_MISMATCH];
+		return (-1);
+	}
+
+	/* v6 */
+	if (ps->pe_remidtype == PS_ID_IP6 ||
+	    ps->pe_remidtype == PS_ID_SUBNET6) {
+		struct sockaddr_in6 *local =
+		    (struct sockaddr_in6 *)(&ps->pe_locid_sa);
+		struct sockaddr_in6 *remote =
+		    (struct sockaddr_in6 *)(&ps->pe_remid_sa);
+
+		if (!valid_ip6_address(local, errmsgp) ||
+		    !valid_ip6_address(remote, errmsgp)) {
+			return (-1);
+		}
+	} else {
+		/* v4 */
+		struct sockaddr_in *local =
+		    (struct sockaddr_in *)(&ps->pe_locid_sa);
+		struct sockaddr_in *remote =
+		    (struct sockaddr_in *)(&ps->pe_remid_sa);
+
+		/* are either mcast */
+		if (IN_MULTICAST(ntohl(local->sin_addr.s_addr)) ||
+		    IN_MULTICAST(ntohl(remote->sin_addr.s_addr))) {
+			*errmsgp = (char *)err_arr[ERR_BADADDR_MCAST];
+			return (-1);
+		}
+	}
+
+	return (0);		/* OK return */
+}
+
+/*
+ * Note: Code stolen from ifconfig.c and adapted.
+ *
+ * If "slash" is zero this parses the whole string as
+ * an integer. With "slash" non zero it parses the tail part as an integer.
+ *
+ * If it is not a valid integer this returns BAD_ADDR.
+ * If there is /<n> present this returns PS_PLEN_NO_PREFIX.
+ */
+static int
+in_getprefixlen(char *addr, boolean_t slash, int max_plen)
+{
+	int prefixlen;
+	char *str, *end;
+
+	if (slash) {
+		str = strchr(addr, CHR_SLASH);
+		if (str == NULL)
+			return (PS_PLEN_NO_PREFIX);
+		str++;
+	} else
+		str = addr;
+
+	prefixlen = strtol(str, &end, 10);
+	if (prefixlen < 0)
+		return (PS_PLEN_BAD_ADDR);
+	if (str == end)
+		return (PS_PLEN_BAD_ADDR);
+	if (max_plen != 0 && max_plen < prefixlen)
+		return (PS_PLEN_BAD_ADDR);
+	return (prefixlen);
+}
+
+
+/*
+ * Note: code stolen from ifconfig.c and adapted
+ *
+ * If the last argument is non-NULL allow a <addr>/<n> syntax and
+ * pass out <n> in *plenp.
+ * If <n> doesn't parse return PS_PLEN_BAD_ADDR as *plenp.
+ * If no /<n> is present return PS_PLEN_NO_PREFIX as *plenp.
+ */
+static int
+in_getaddr(char *s, struct sockaddr_storage *saddr, int *plenp, char **errp)
+{
+	struct sockaddr_in *sin = (struct sockaddr_in *)saddr;
+	struct hostent *hp;
+	struct netent *np;
+	char str[BUFSIZ];
+	int error_num;
+
+	(void) strncpy(str, s, sizeof (str));
+
+	/*
+	 * Look for '/'<n> (CHR_SLASH)is plenp
+	 */
+	if (plenp != NULL) {
+		char *cp;
+
+		*plenp = in_getprefixlen(str, B_TRUE, ADDRBITS_V4);
+		if (*plenp == PS_PLEN_BAD_ADDR) {
+			*errp = (char *)err_arr[ERR_BADADDR_PREFIXLEN_PART];
+			return (-1);
+		}
+		cp = strchr(str, CHR_SLASH);
+		if (cp != NULL)
+			*cp = CHR_NULL;
+	} else if (strchr(str, CHR_SLASH) != NULL) {
+		*errp = (char *)err_arr[ERR_BADADDR_SLASH_UNEXPECTED];
+		return (-1);
+	}
+
+	(void) memset(sin, 0, sizeof (*sin));
+
+	/*
+	 *	Try to catch attempts to set the broadcast address to all 1's.
+	 */
+	if (strcmp(str, "255.255.255.255") == 0 ||
+	    (strtoul(str, (char **)NULL, 0) == 0xffffffffUL)) {
+		sin->sin_family = AF_INET;
+		sin->sin_addr.s_addr = 0xffffffff;
+		return (0);
+	}
+
+	hp = getipnodebyname(str, AF_INET, 0, &error_num);
+	if (hp) {
+		sin->sin_family = hp->h_addrtype;
+		(void) memcpy(&sin->sin_addr, hp->h_addr, hp->h_length);
+		freehostent(hp);
+		return (0);
+	}
+	np = getnetbyname(str);
+	if (np) {
+		sin->sin_family = np->n_addrtype;
+		sin->sin_addr = inet_makeaddr(np->n_net, INADDR_ANY);
+		return (0);
+	}
+	if (error_num == TRY_AGAIN) {
+		*errp = (char *)err_arr[ERR_BADADDR_TRY_AGAIN];
+	} else {
+		*errp = (char *)err_arr[ERR_BADADDR_ADDRESS];
+	}
+	return (-1);
+}
+
+/*
+ * Note: Code stolen from ifconfig.c and adapted.
+ *
+ * If the third argument is non-NULL allow a <addr>/<n> syntax and
+ * pass out <n> in *plenp.
+ * If <n> doesn't parse return PS_PLEN_BAD_ADDR as *plenp.
+ * If no /<n> is present return PS_PLEN_NO_PREFIX as *plenp.
+ */
+static int
+in6_getaddr(char *s, struct sockaddr_storage *saddr, int *plenp, char **errp)
+{
+	struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)saddr;
+	struct hostent *hp;
+	char str[BUFSIZ];
+	int error_num;
+
+	(void) strncpy(str, s, sizeof (str));
+
+	/*
+	 * Look for '/'<n> (CHR_SLASH) is plenp
+	 */
+	if (plenp != NULL) {
+		char *cp;
+
+		*plenp = in_getprefixlen(str, B_TRUE, ADDRBITS_V6);
+		if (*plenp == PS_PLEN_BAD_ADDR) {
+			*errp = (char *)err_arr[ERR_BADADDR_PREFIXLEN_PART];
+			return (-1);
+		}
+		cp = strchr(str, CHR_SLASH);
+		if (cp != NULL)
+			*cp = CHR_NULL;
+	} else if (strchr(str, CHR_SLASH) != NULL) {
+		*errp = (char *)err_arr[ERR_BADADDR_SLASH_UNEXPECTED];
+		return (-1);
+	}
+
+	(void) memset(sin6, 0, sizeof (*sin6));
+
+	hp = getipnodebyname(str, AF_INET6, 0, &error_num);
+	if (hp) {
+		sin6->sin6_family = hp->h_addrtype;
+		(void) memcpy(&sin6->sin6_addr, hp->h_addr, hp->h_length);
+		freehostent(hp);
+		return (0);
+	}
+	if (error_num == TRY_AGAIN) {
+		*errp = (char *)err_arr[ERR_BADADDR_TRY_AGAIN];
+	} else {
+		*errp = (char *)err_arr[ERR_BADADDR_ADDRESS];
+	}
+	return (-1);
+}
+
+/*
+ * char *get_next_token(cpp)
+ *	cpp - on input should point within a null terminated buffer.
+ *	return value - on output will point to past spaces to first
+ *		non-space character that starts a token
+ *	cpp - on output will point past non-space token string pointed
+ *		by return value.
+ *	Side-effects: modifies a potential space character after token
+ *		to null to form  a null terminated token unless a
+ *		double-quote has been seen in the token
+ */
+static char *
+get_next_token(char **cpp)
+{
+	char *cp = *cpp;
+	char *startcp, *endcp;
+	boolean_t quote_seen = B_FALSE;
+
+	/* skip leading whitespaces */
+	while (*cp == CHR_SPACE || *cp == CHR_TAB || *cp == CHR_NEWLINE)
+		cp++;
+
+	if (*cp == CHR_NULL) {	/* end of string */
+		*cpp = NULL;
+		return (NULL);
+	}
+
+	startcp = endcp = cp;
+	while (*endcp != CHR_NULL &&
+	    ((*endcp != CHR_SPACE && *endcp != CHR_TAB) || quote_seen) &&
+	    *endcp != CHR_NEWLINE) {
+		/*
+		 * Within quotes, ignore spaces and tabs as delimiters
+		 * and take note of start and end quotes, ignoring
+		 * backslash escaped characters.
+		 */
+		if (*endcp == CHR_DOUBLEQUOTE &&
+		    ((endcp == startcp) ||
+		    ((endcp > startcp) && *(endcp - 1) != CHR_BACKSLASH)))
+			quote_seen = !quote_seen;
+		endcp++;
+	}
+	if (*endcp != CHR_NULL)
+		*endcp++ = CHR_NULL;
+	*cpp = endcp;
+	return (startcp);
+}
+
+static char *
+readnextline(FILE *fp)
+{
+	char *cp;
+
+	while ((cp = fgets(linebuf, sizeof (linebuf), fp)) != NULL) {
+		err_line_number++; /* NOTE approx - if long lines */
+		if (*cp == CHR_NEWLINE || *cp == CHR_COMMENT_BEGIN)
+			continue;
+		break;
+	}
+	if (cp == NULL)
+		return (NULL);
+	return (linebuf);
+}
+
+
+/*
+ * static preshared_entry_t *getnextentry(fp, errmpp)
+ *	fp
+ *		file pointer to open config file.
+ *	errmpp
+ *		pointer to pointer to buffer containing error message
+ *	return value
+ *		NULL when EOF is reached
+ *		pointer to valid entry otherwise
+ *
+ *	Function scans open input file to get the next entry read from
+ *	the file and instantiated in the preshared_entry_t data structure.
+ *	In case of invalid syntax entries the function exits and does
+ *	not return and process exits.
+ *
+ *	Caller holds ps_rwlock as reader.
+ */
+static preshared_entry_t *
+getnextentry(FILE *fp, char **errmpp)
+{
+	preshared_entry_t *ps;
+	char *cp;		/* pointer to scan input */
+	char *tp;
+	char *errmsg = NULL;
+	int cur_fld_type = -1;	/* "uninitialized" */
+	int entry_done = FALSE;
+	int next_token_expected = PS_TOK_BEGIN_CURLY_BRACE;
+
+	assert(RW_LOCK_HELD(&ps_rwlock));
+
+	*errmpp = NULL;
+
+	ps = calloc(1, sizeof (preshared_entry_t));	/* Auto-zeroes... */
+	if (ps == NULL) {
+		errmsg = strerror(errno);
+		goto fatal_error;
+	}
+	ps->pe_refcnt = 1;
+nextline:
+	/* get next line  */
+
+	/* skip comment and null lines */
+	while (((cp = readnextline(fp)) != NULL) &&
+	    (*cp == CHR_COMMENT_BEGIN || *cp == CHR_NULL))
+		;
+
+	if (cp == NULL) {
+		/* EOF  */
+		PE_REFRELE(ps);
+		return (NULL);
+	}
+
+	for (;;) {
+		if (entry_done == TRUE)
+			break;
+		tp = get_next_token(&cp);
+		if (tp == NULL)
+			goto nextline;
+process_newtoken:
+		/* skip rest of line if comment token */
+		if (*tp == CHR_COMMENT_BEGIN)
+			goto nextline;
+
+		switch (next_token_expected) {
+
+		case PS_TOK_BEGIN_CURLY_BRACE:
+			if (*tp != CHR_CURLY_BRACE_OPEN) {
+				errmsg = (char *)err_arr[
+				    ERR_ENTRY_NOBEGINBRACE];
+				goto bad_syntax;
+			}
+			err_entry_number++;
+			next_token_expected = PS_TOK_FLD_TYPE;
+
+			/*
+			 * Note: We skip tokens assuming whitespace
+			 * termination but relax that for this token.
+			 *
+			 * Reset scan pointer past this token (one character)
+			 * so pointer does not miss any tokens that may
+			 * be glued to this one with no whitespaces.
+			 */
+			tp++;	/* past brace */
+			if (*tp == CHR_NULL) {
+				/* past whitespace terminated brace */
+				tp++;
+			}
+			cp = tp;
+			break;
+
+		case PS_TOK_END_CURLY_BRACE:
+			/*
+			 * Do sanity checks on entry and other
+			 * post-processing
+			 */
+			if (postprocess_entry(ps, &errmsg) < 0)
+				goto bad_semantics;
+			entry_done = TRUE;
+			break;
+
+		case PS_TOK_FLD_TYPE:
+			/*
+			 * Note: could be end-of-entry too...
+			 * here we assume the closing brace is
+			 * preceded by a whitespace. We gave some latitude to
+			 * opening brace, but not to the closing brace
+			 */
+			if (*tp == CHR_CURLY_BRACE_CLOSE) {
+				/*
+				 * End of fields, reset expected token,
+				 * Also reset scan token so this
+				 */
+				next_token_expected = PS_TOK_END_CURLY_BRACE;
+				goto process_newtoken;
+			}
+
+			/* initialize cur_fld_type */
+			if ((cur_fld_type = getfldtype(tp)) < 0) {
+				errmsg = (char *)err_arr[ERR_INVALID_FIELDNAME];
+				goto bad_syntax;
+			}
+
+			if ((ps->pe_flds_mask & cur_fld_type) != 0) {
+				errmsg = (char *)err_arr[ERR_REPEATED_FIELD];
+				goto bad_syntax;
+			}
+
+			ps->pe_flds_mask |= cur_fld_type;
+
+			next_token_expected = PS_TOK_FLD_VALUE;
+			break;
+
+		case PS_TOK_FLD_VALUE:
+
+			/*
+			 * Note: we assume all value fields do
+			 * not embed any whitespace even for complicated
+			 * value syntax such as for "range". Is that a
+			 * "reasonable" assumption ?
+			 *
+			 * Note++: All things being strdup()'d below need
+			 * to be parsed and put into context dependent data
+			 * structures at some point (after entry is read or
+			 * right here).
+			 */
+			switch (cur_fld_type) {
+			case PS_FLD_LOCID_TYPE:
+				if ((ps->pe_locidtype = getidtype(tp)) < 0) {
+					errmsg = (char *)err_arr[
+					    ERR_INVALID_LOCALID_TYPE];
+					goto bad_syntax;
+				}
+				break;
+			case PS_FLD_LOCID:
+				ps->pe_locid = strdup(tp);
+				if (ps->pe_locid == NULL) {
+					errmsg = strerror(errno);
+					goto fatal_error;
+				}
+				break;
+			case PS_FLD_REMID_TYPE:
+				if ((ps->pe_remidtype = getidtype(tp)) < 0) {
+					errmsg = (char *)err_arr[
+					    ERR_INVALID_REMID_TYPE];
+					goto bad_syntax;
+				}
+				break;
+			case PS_FLD_REMID:
+				ps->pe_remid = strdup(tp);
+				if (ps->pe_remid == NULL) {
+					errmsg = strerror(errno);
+					goto fatal_error;
+				}
+				break;
+			case PS_FLD_IKE_MODE:
+				if ((ps->pe_ike_mode = getikmtype(tp)) < 0) {
+					errmsg = (char *)err_arr[
+					    ERR_INVALID_IKE_MODE];
+					goto bad_syntax;
+				}
+				break;
+			case PS_FLD_KEY:
+				ps->pe_keybuf = parsekey(tp,
+				    &ps->pe_keybuf_bytes,
+				    &ps->pe_keybuf_lbits, &errmsg);
+				if (ps->pe_keybuf == NULL)
+					goto fatal_error;
+				else if (errmsg != NULL) {
+					/*
+					 * Utter warning on otherwise okay
+					 * input.
+					 */
+					(void) fprintf(stderr,
+					    gettext("read_preshared: %s\n"),
+					    errmsg);
+				}
+				break;
+			default:
+				/* Should never happen - assert ? */
+				errmsg = (char *)err_arr[
+				    ERR_INVALID_FIELDNAME];
+				goto fatal_error;
+			}
+
+			next_token_expected = PS_TOK_FLD_TYPE;
+			break;
+		}
+	}
+	return (ps);
+	/*
+	 * TBD any differentiation in these errors ?
+	 */
+bad_semantics:
+bad_syntax:
+fatal_error:
+	if (ps != NULL)
+		PE_REFRELE(ps);
+	*errmpp = errmsg;
+	return (NULL);
+}
+
+
+/*
+ * Load any preshared keys.
+ * Boolean parameter 'replace' determines whether the newly-read entries
+ * will replace the existing list, or be appended to it.
+ * On success, returns a linked list of preshared entries, and sets the
+ * error message pointer *errmp to NULL.
+ * On failure, returns NULL and sets *errmp to an error message string.
+ *
+ * Holds ps_rwlock as writer.
+ */
+char *
+preshared_load(const char *ps_filename, int ps_fd, boolean_t replace)
+{
+	preshared_entry_t *ps, *tmp_head = NULL, *tmp_tail = NULL;
+	char *errmp;
+	boolean_t dupfound = B_FALSE;
+
+	(void) pthread_rwlock_wrlock(&ps_rwlock);
+
+	/* TODO more paranoia/permissions checks on file needed */
+
+	if (ps_filename == NULL)
+		fp = fdopen(ps_fd, "r");
+	else
+		fp = fopen(ps_filename, "r");
+	if (fp == NULL) {
+		(void) pthread_rwlock_unlock(&ps_rwlock);
+		if (errno == ENOENT)
+			return (NULL);	/* no file == empty file */
+		return (strerror(errno));
+	}
+
+	while ((ps = getnextentry(fp, &errmp)) != NULL) {
+		/* process the new entry */
+
+		/*
+		 * For now, create a list of just the new entries
+		 */
+		if (!replace) {
+			if (has_dup(ps, &ps_head)) {
+				/* Skip duplicates in master list */
+				PE_REFRELE(ps);
+				dupfound = B_TRUE;
+				continue;
+			}
+		}
+		assert(ps->pe_refcnt >= 1);
+		if (!append_to_list(ps, &tmp_head, &tmp_tail)) {
+			/* Duplicate found within new list */
+			dupfound = B_TRUE;
+		}
+	}
+
+	(void) fclose(fp);
+
+	if (errmp == NULL) {
+		/*
+		 * we read the list in successfully; either
+		 * replace or append to global list now.
+		 */
+		if (replace || ps_tail == NULL) {
+			free_preshared_list(&ps_head, &ps_tail);
+			ps_head = tmp_head;
+			ps_tail = tmp_tail;
+		} else {
+			ps_tail->pe_next = tmp_head;
+			ps_tail = tmp_tail;
+		}
+	} else {
+		/*
+		 * had problems reading new list; free it
+		 */
+		free_preshared_list(&tmp_head, &tmp_tail);
+	}
+
+	if (dupfound && (errmp == NULL)) {
+		/* Hack to key off of later, not user visible */
+		(void) pthread_rwlock_unlock(&ps_rwlock);
+		return ("DUP");
+	}
+
+	(void) pthread_rwlock_unlock(&ps_rwlock);
+	return (errmp);
+}
+
+/*
+ * Returns 0 if requested entry not found; 1 if deleted successfully.
+ * Holds ps_rwlock as writer.
+ */
+int
+delete_ps(preshared_entry_t *delp)
+{
+	preshared_entry_t	*curp, *prevp;
+
+	(void) pthread_rwlock_wrlock(&ps_rwlock);
+	if (ps_head == NULL) {
+		(void) pthread_rwlock_unlock(&ps_rwlock);
+		return (0);
+	}
+
+	if (delp == ps_head) {
+		/* CORNER CASE: Deletion of last entry */
+		if (ps_head == ps_tail)
+			ps_tail = NULL;
+		ps_head = delp->pe_next;
+		(void) pthread_rwlock_unlock(&ps_rwlock);
+		PE_REFRELE(delp);
+		return (1);
+	}
+
+	for (prevp = ps_head, curp = ps_head->pe_next; curp != NULL;
+	    prevp = curp, curp = curp->pe_next) {
+		if (curp == delp)
+			break;
+	}
+	if (curp == NULL) {
+		(void) pthread_rwlock_unlock(&ps_rwlock);
+		return (0);
+	}
+
+	prevp->pe_next = curp->pe_next;
+	if (curp == ps_tail)
+		ps_tail = prevp;
+	(void) pthread_rwlock_unlock(&ps_rwlock);
+	PE_REFRELE(curp);
+	return (1);
+}
+
+/*
+ * return -1 on error, number of preshared entries written on success
+ * Holds ps_rwlock as reader
+ */
+int
+write_preshared(int fd, char **errmp)
+{
+	preshared_entry_t	*pep;
+	FILE	*ofile;
+	char	*keyp;
+	int	written = 0;
+
+	(void) pthread_rwlock_rdlock(&ps_rwlock);
+	if ((ofile = fdopen(fd, "w+")) == NULL) {
+		*errmp = strerror(errno);
+		(void) pthread_rwlock_unlock(&ps_rwlock);
+		return (-1);
+	}
+
+	for (pep = ps_head; pep != NULL; pep = pep->pe_next) {
+		const char *mdstr;
+
+		if ((keyp = getkeystr(pep->pe_keybuf, pep->pe_keybuf_bytes,
+		    pep->pe_keybuf_lbits)) == NULL) {
+			*errmp = strerror(errno);
+			(void) pthread_rwlock_unlock(&ps_rwlock);
+			return (-1);
+		}
+
+		if (pep->pe_locid != NULL) {
+			(void) fprintf(ofile, "{\n"
+			    "\tlocalidtype    %s\n\tlocalid        %s\n",
+			    getidstr(pep->pe_locidtype), pep->pe_locid);
+		} else {
+			(void) fprintf(ofile,
+			    "{\n\tlocalidtype    %s\n\tlocalid        ",
+			    getidstr(pep->pe_locidtype));
+			(void) dump_sockaddr(
+			    (struct sockaddr *)&pep->pe_locid_sa,
+			    (pep->pe_locid_plen > 0) ? pep->pe_locid_plen : 0,
+			    B_TRUE, ofile, B_FALSE);
+			(void) fprintf(ofile, "\n");
+		}
+
+		if (pep->pe_remid != NULL) {
+			(void) fprintf(ofile,
+			    "\tremoteidtype   %s\n\tremoteid       %s\n",
+			    getidstr(pep->pe_remidtype), pep->pe_remid);
+		} else {
+			(void) fprintf(ofile,
+			    "\tremoteidtype   %s\n\tremoteid       ",
+			    getidstr(pep->pe_remidtype));
+			(void) dump_sockaddr(
+			    (struct sockaddr *)&pep->pe_remid_sa,
+			    (pep->pe_remid_plen > 0) ? pep->pe_remid_plen : 0,
+			    B_TRUE, ofile, B_FALSE);
+			(void) fprintf(ofile, "\n");
+		}
+
+		mdstr = getikmstr(pep->pe_ike_mode);
+		if (mdstr != NULL)
+			(void) fprintf(ofile, "\tike_mode       %s\n", mdstr);
+
+		(void) fprintf(ofile, "\tkey            %s\n}\n", keyp);
+		free(memset(keyp, 0, strlen(keyp)));
+		written++;
+	}
+	(void) fclose(ofile);
+
+	(void) pthread_rwlock_unlock(&ps_rwlock);
+	return (written);
+}
+
+/*
+ * Convert a PS_ID_* to an SADB_IDENTTYPE_* constant.
+ * Returns SADB_IDENTTYPE_RESERVED on failure.
+ */
+int
+psid2sadb(int psid)
+{
+	switch (psid) {
+	case PS_ID_IP:
+	case PS_ID_IP4:
+	case PS_ID_IP6:
+		return (SADB_IDENTTYPE_RESERVED);
+	case PS_ID_SUBNET:
+	case PS_ID_SUBNET4:
+	case PS_ID_SUBNET6:
+		return (SADB_IDENTTYPE_PREFIX);
+	case PS_ID_RANGE:
+	case PS_ID_RANGE4:
+	case PS_ID_RANGE6:
+		return (SADB_X_IDENTTYPE_ADDR_RANGE);
+	case PS_ID_ASN1DN:
+		return (SADB_X_IDENTTYPE_DN);
+	case PS_ID_ASN1GN:
+		return (SADB_X_IDENTTYPE_GN);
+	case PS_ID_KEYID:
+		return (SADB_X_IDENTTYPE_KEY_ID);
+	case PS_ID_FQDN:
+		return (SADB_IDENTTYPE_FQDN);
+	case PS_ID_USER_FQDN:
+		return (SADB_IDENTTYPE_USER_FQDN);
+	}
+	return (SADB_IDENTTYPE_RESERVED);
+}
+
+int
+sadb2psid(int sadb)
+{
+	switch (sadb) {
+	case SADB_IDENTTYPE_PREFIX:
+		return (PS_ID_SUBNET);
+	case SADB_X_IDENTTYPE_ADDR_RANGE:
+		return (PS_ID_RANGE);
+	case SADB_X_IDENTTYPE_DN:
+		return (PS_ID_ASN1DN);
+	case SADB_X_IDENTTYPE_GN:
+		return (PS_ID_ASN1GN);
+	case SADB_X_IDENTTYPE_KEY_ID:
+		return (PS_ID_KEYID);
+	case SADB_IDENTTYPE_FQDN:
+		return (PS_ID_FQDN);
+	case SADB_IDENTTYPE_USER_FQDN:
+		return (PS_ID_USER_FQDN);
+	}
+	return (0);
+}
+
+/*
+ * Lookup preshared entry by ident
+ * Holds ps_rwlock as reader
+ */
+preshared_entry_t *
+lookup_ps_by_ident(sadb_ident_t *local, sadb_ident_t *remote)
+{
+	int	ltype, rtype;
+	char	*lid, *rid;
+	preshared_entry_t	*ps;
+
+	if (local == NULL || remote == NULL)
+		return (NULL);
+
+	lid = (char *)(local + 1);
+	rid = (char *)(remote + 1);
+
+	(void) pthread_rwlock_rdlock(&ps_rwlock);
+	for (ps = ps_head; ps != NULL; ps = ps->pe_next) {
+
+		/*
+		 * Have to convert for each preshared (rather than converting
+		 * the passed-in sadb ids just once to preshared-style)
+		 * because there are multiple PS_ID_* for each SADB_IDENT_*.
+		 */
+		ltype = psid2sadb(ps->pe_locidtype);
+		rtype = psid2sadb(ps->pe_remidtype);
+
+		if ((local->sadb_ident_type != ltype) ||
+		    (remote->sadb_ident_type != rtype))
+			continue;
+
+		if (ps->pe_locidtype == PS_ID_FQDN ||
+		    ps->pe_locidtype == PS_ID_USER_FQDN) {
+			/*
+			 * Check for case insensitive match.
+			 */
+			if ((strcasecmp(ps->pe_locid, lid) == 0) &&
+			    (strcasecmp(ps->pe_remid, rid) == 0))
+				break;
+		} else {
+			/*
+			 * Otherwise just go for an exact match.
+			 */
+			if ((strcmp(ps->pe_locid, lid) == 0) &&
+			    (strcmp(ps->pe_remid, rid) == 0))
+				break;
+		}
+	}
+	if (ps != NULL)
+		PE_REFHOLD(ps);
+	(void) pthread_rwlock_unlock(&ps_rwlock);
+	return (ps);
+}
+
+/*
+ * Stolen from kernel spd.c - maybe this should go in libipsecutil
+ *
+ * sleazy prefix-length-based compare.
+ */
+boolean_t
+ip_addr_match(uint8_t *addr1, int pfxlen, in6_addr_t *addr2p)
+{
+	int offset = pfxlen>>3;
+	int bitsleft = pfxlen & 7;
+	uint8_t *addr2 = (uint8_t *)addr2p;
+
+	/*
+	 * and there was much evil..
+	 * XXX should inline-expand the bcmp here and do this 32 bits
+	 * or 64 bits at a time..
+	 */
+	return ((bcmp(addr1, addr2, offset) == 0) &&
+	    ((bitsleft == 0) ||
+	    (((addr1[offset] ^ addr2[offset]) & (0xff<<(8-bitsleft))) == 0)));
+}
+
+/*
+ * Lookup preshared entry by v4 or v4 mapped v6 address
+ * Holds ps_rwlock as reader
+ */
+preshared_entry_t *
+lookup_ps_by_in_addr(struct in_addr *local, struct in_addr *remote)
+{
+	struct in_addr *inp;
+	struct in_addr in;
+	struct sockaddr_in	*loc_sin, *rem_sin;
+	struct sockaddr_in6	*loc_sin6, *rem_sin6;
+	preshared_entry_t *ps;
+	boolean_t loc_is_v6, rem_is_v6;
+	int pfxlen;
+
+	if (local == NULL || remote == NULL)
+		return (NULL);
+
+	bzero(&in, sizeof (struct in_addr));
+
+	(void) pthread_rwlock_rdlock(&ps_rwlock);
+	/*
+	 * Also looks up IPv6 id type entries for mapped addresses
+	 */
+
+	for (ps = ps_head; ps != NULL; ps = ps->pe_next) {
+
+		/* filter on relevant id type first */
+		if ((ps->pe_locidtype != PS_ID_IP4 &&
+		    ps->pe_locidtype != PS_ID_IP6 &&
+		    ps->pe_locidtype != PS_ID_IP &&
+		    ps->pe_locidtype != PS_ID_SUBNET4 &&
+		    ps->pe_locidtype != PS_ID_SUBNET6 &&
+		    ps->pe_locidtype != PS_ID_SUBNET) ||
+		    (ps->pe_remidtype != PS_ID_IP4 &&
+		    ps->pe_remidtype != PS_ID_IP6 &&
+		    ps->pe_remidtype != PS_ID_IP &&
+		    ps->pe_remidtype != PS_ID_SUBNET4 &&
+		    ps->pe_remidtype != PS_ID_SUBNET6 &&
+		    ps->pe_remidtype != PS_ID_SUBNET))
+			continue; /* local and/or remote id types invalid */
+
+		/* establish format of address */
+		if ((ps->pe_locidtype == PS_ID_IP6 ||
+		    ps->pe_locidtype == PS_ID_SUBNET6) ||
+		    ((ps->pe_locidtype == PS_ID_IP ||
+		    ps->pe_locidtype == PS_ID_SUBNET) &&
+		    check_if_v6(ps->pe_locid)))
+			loc_is_v6 = B_TRUE;
+		else
+			loc_is_v6 = B_FALSE;
+		if ((ps->pe_remidtype == PS_ID_IP6 ||
+		    ps->pe_remidtype == PS_ID_SUBNET6) ||
+		    ((ps->pe_locidtype == PS_ID_IP ||
+		    ps->pe_locidtype == PS_ID_SUBNET) &&
+		    check_if_v6(ps->pe_remid)))
+			rem_is_v6 = B_TRUE;
+		else
+			rem_is_v6 = B_FALSE;
+
+		loc_sin = (struct sockaddr_in *)&ps->pe_locid_sa;
+		rem_sin = (struct sockaddr_in *)&ps->pe_remid_sa;
+		loc_sin6 = (struct sockaddr_in6 *)&ps->pe_locid_sa;
+		rem_sin6 = (struct sockaddr_in6 *)&ps->pe_remid_sa;
+
+		/* if v6 format, it is only interesting if v4mapped */
+		if (loc_is_v6 && !IN6_IS_ADDR_V4MAPPED(&loc_sin6->sin6_addr))
+			continue;	/* not v4 mapped v6 address */
+		if (rem_is_v6 && !IN6_IS_ADDR_V4MAPPED(&rem_sin6->sin6_addr))
+			continue;	/* not v4 mapped v6 address */
+
+
+		/* match localid */
+		if (loc_is_v6) {
+			IN6_V4MAPPED_TO_INADDR(&loc_sin6->sin6_addr, &in);
+			inp = &in;
+		} else {
+			inp = &loc_sin->sin_addr;
+		}
+
+		if (ps->pe_locid_plen < 0)
+			pfxlen = ADDRBITS_V4;
+		else
+			pfxlen = ps->pe_locid_plen;
+		if (!ip_addr_match((uint8_t *)&inp->s_addr, pfxlen,
+		    (in6_addr_t *)&local->s_addr))
+			continue; /* local id mismatched */
+
+		/* match remote id */
+		if (rem_is_v6) {
+			IN6_V4MAPPED_TO_INADDR(&rem_sin6->sin6_addr, &in);
+			inp = &in;
+		} else {
+			inp = &rem_sin->sin_addr;
+		}
+
+		if (ps->pe_remid_plen < 0)
+			pfxlen = ADDRBITS_V4;
+		else
+			pfxlen = ps->pe_remid_plen;
+		if (!ip_addr_match((uint8_t *)&inp->s_addr, pfxlen,
+		    (in6_addr_t *)&remote->s_addr))
+			continue; /* remote id mismatched */
+
+		/* match found for both local and remote id */
+		break; /* out of loop */
+	}
+	if (ps != NULL)
+		PE_REFHOLD(ps);
+	(void) pthread_rwlock_unlock(&ps_rwlock);
+	return (ps); /* NULL if loop expires on its own */
+}
+
+/*
+ * Lookup preshared entry by v6 address
+ * Holds ps_rwlock as reader
+ */
+preshared_entry_t *
+lookup_ps_by_in6_addr(struct in6_addr *local, struct in6_addr *remote)
+{
+	preshared_entry_t *ps;
+	struct sockaddr_in6	*loc_sin6, *rem_sin6;
+	int pfxlen;
+
+	if (local == NULL || remote == NULL)
+		return (NULL);
+
+	(void) pthread_rwlock_rdlock(&ps_rwlock);
+	for (ps = ps_head; ps != NULL; ps = ps->pe_next) {
+
+		/* filter on relevant id type first */
+		if ((ps->pe_locidtype != PS_ID_IP6 &&
+		    ps->pe_locidtype != PS_ID_IP &&
+		    ps->pe_locidtype != PS_ID_SUBNET &&
+		    ps->pe_locidtype != PS_ID_SUBNET6) ||
+		    (ps->pe_remidtype != PS_ID_IP6 &&
+		    ps->pe_remidtype != PS_ID_IP &&
+		    ps->pe_remidtype != PS_ID_SUBNET &&
+		    ps->pe_remidtype != PS_ID_SUBNET6))
+			continue; /* local and/or remote id types invalid */
+
+		/*
+		 * if PS_ID_IP or PS_ID_SUBNET, it is
+		 * only interesting if v6 format
+		 */
+		if ((ps->pe_locidtype == PS_ID_IP ||
+		    ps->pe_locidtype == PS_ID_SUBNET) &&
+		    !check_if_v6(ps->pe_locid))
+			continue; /* not v6 address */
+		if ((ps->pe_remidtype == PS_ID_IP ||
+		    ps->pe_remidtype == PS_ID_SUBNET) &&
+		    !check_if_v6(ps->pe_remid))
+			continue; /* not v6 address */
+
+		loc_sin6 = (struct sockaddr_in6 *)&ps->pe_locid_sa;
+		rem_sin6 = (struct sockaddr_in6 *)&ps->pe_remid_sa;
+
+		if (ps->pe_locid_plen < 0)
+			pfxlen = ADDRBITS_V6;
+		else
+			pfxlen = ps->pe_locid_plen;
+		if (!ip_addr_match((uint8_t *)&loc_sin6->sin6_addr, pfxlen,
+		    (in6_addr_t *)local))
+			continue; /* local id mismatched */
+
+		if (ps->pe_remid_plen < 0)
+			pfxlen = ADDRBITS_V6;
+		else
+			pfxlen = ps->pe_remid_plen;
+		if (!ip_addr_match((uint8_t *)&rem_sin6->sin6_addr, pfxlen,
+		    (in6_addr_t *)remote))
+			continue; /* remote id mismatched */
+		/* match found for both local and remote id */
+		break; /* out of loop */
+	}
+	if (ps != NULL)
+		PE_REFHOLD(ps);
+	(void) pthread_rwlock_unlock(&ps_rwlock);
+	return (ps); /* NULL if loop expires on its own */
+}
+
+/*
+ * Lookup nth preshared key entry
+ * Holds ps_rwlock as reader
+ */
+preshared_entry_t *
+lookup_nth_ps(int n)
+{
+	preshared_entry_t	*ps;
+	int			cnt;
+
+	(void) pthread_rwlock_rdlock(&ps_rwlock);
+	for (cnt = 0, ps = ps_head; (cnt < n) && (ps != NULL);
+	    cnt++, ps = ps->pe_next)
+		;
+	if (ps != NULL)
+		PE_REFHOLD(ps);
+	(void) pthread_rwlock_unlock(&ps_rwlock);
+	return (ps);
+}
+
+/*
+ * Actual freeing function.
+ */
+void
+free_preshared(preshared_entry_t *pe)
+{
+	assert(pe->pe_refcnt == 0);
+	free(pe->pe_locid);
+	free(pe->pe_remid);
+	/* Use memset()'s return value to our advantage. */
+	free(memset(pe->pe_keybuf, 0, pe->pe_keybuf_bytes));
+	free(pe);
+}
+
+/*
+ * Read in a list of pre-shared keys.  Called from main() when the daemon first
+ * starts.
+ */
+void
+preshared_init(boolean_t ignore_errors)
+{
+	const char *filename = PRESHARED_KEY_FILE;
+	char *errorstr;
+
+	bunyan_info(log, "Loading preshared keys", BUNYAN_T_END);
+	errorstr = preshared_load(filename, -1, B_TRUE);
+
+	if (errorstr != NULL) {
+		if (strncmp(errorstr, "DUP", 3) == 0)
+			errorstr = gettext("Duplicate entries ignored\n");
+		/*
+		 * Error handling... Print to terminal, if exists.
+		 * Debug logging already taken care of by other functions.
+		 * Don't exit because we want to load other policy.
+		 */
+		bunyan_error(log, "Error reading preshared file",
+		    BUNYAN_T_STRING, "filename", filename,
+		    BUNYAN_T_STRING, "errmsg", errorstr);
+		if (!ignore_errors)
+			err(EXIT_FAILURE, "Fatal errors in %s", filename);
+	}
+}
+
+/*
+ * Called when the daemon catches SIGHUP.
+ * Currently equivalent to preshared_init().
+ */
+void
+preshared_reload(void)
+{
+	preshared_init(B_FALSE);
+}
+
+/*
+ * Random Notes:
+ * (a)
+ * Maybe a better syntax for fields is following which eliminates
+ * semantic relationships between two different fields (id and idtype) ???
+ * E.g.
+ * {
+ *	...
+ *	localid	ipv4		1.2.3.4
+ *	remoteid rangev4	1.2.3.4-5.6.7.8
+ *	...
+ *  }
+ *  Current design causes us to delay certain verifications into a
+ *  postprocess_XXX() routine which otherwise could be done while
+ *  parsing if syntax was as above.
+ *
+ * (b)
+ *	Current error handling has a generic design that prints only
+ *	error message, entry number and line number. Other options are
+ *	possible (e.g. parsekey() "original" code from danmcd prints
+ *	error messages specific to the error context which have more
+ *	detailed context). Perhaps we should change to direct printing
+ *	of specific error messages globally later, but for now stick
+ *	to the simple model coded above.
+ * (c) The getnexttoken() part can be improved by passing it some context
+ *	such as "expected token" and maybe the fieldname. This *may* help
+ *	allow a more flexible syntax for complex tokens such as ranges.
+ *	which cannot currently embed spaces but it would be nice to allow
+ *	them to do that and be delimited with a context sensitive delimiter.
+ * (d) Needs detection of duplicates in the database before inserting new
+ *	entry.
+ * (e) Can be enhanced to do hashes and better structures than a linked list
+ *	of entries.
+ */
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/preshared.h b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/preshared.h
new file mode 100644
index 0000000000..78303c3244
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/preshared.h
@@ -0,0 +1,213 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the "License").
+ * You may not use this file except in compliance with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ */
+/*
+ * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ *
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+#ifndef	_PRESHARED_H
+#define	_PRESHARED_H
+
+#ifdef	__cplusplus
+extern "C" {
+#endif
+
+#include <sys/types.h>
+#include <sys/atomic.h>
+#include <netinet/in.h>
+#include <net/pfkeyv2.h>
+
+#define	PRESHARED_KEY_FILE	"/etc/inet/secret/ike.preshared"
+
+typedef struct preshared_entry_s {
+	struct preshared_entry_s	*pe_next;
+	int				pe_flds_mask;
+	int				pe_locidtype;
+	char				*pe_locid;
+	int				pe_remidtype;
+	char				*pe_remid;
+	int				pe_ike_mode;
+	uint8_t				*pe_keybuf;
+	uint_t				pe_keybuf_bytes;
+	uint_t				pe_keybuf_lbits;
+	struct sockaddr_storage		pe_locid_sa;
+	struct sockaddr_storage		pe_remid_sa;
+	int				pe_locid_plen;
+	int				pe_remid_plen;
+	volatile uint32_t		pe_refcnt;
+} preshared_entry_t;
+
+#define	PE_REFHOLD(pe)	atomic_inc_32(&(pe)->pe_refcnt)
+
+/* Stupid C tricks stolen from <assert.h>. */
+#define	PE_REFRELE(pe)	\
+	(void) ((atomic_dec_32_nv(&(pe)->pe_refcnt) != 0) ||	\
+	    (free_preshared(pe), 0))
+
+/*
+ * Types of Fields
+ * Note: used in pe_flds_mask; values bitwise distinct, not just unique
+ */
+#define	PS_FLD_COMMENT			0x01
+#define	PS_FLD_LOCID			0x02
+#define	PS_FLD_LOCID_TYPE		0x04
+#define	PS_FLD_REMID			0x08
+#define	PS_FLD_REMID_TYPE		0x10
+#define	PS_FLD_IKE_MODE			0x20
+#define	PS_FLD_KEY			0x40
+
+/*
+ * Type of Remote/Local Ids
+ * Note: used in pe_locidtype and pe_remidtype fields.
+ */
+#define	PS_ID_IP			1
+#define	PS_ID_IP4			2
+#define	PS_ID_IP6			3
+#define	PS_ID_SUBNET			4
+#define	PS_ID_SUBNET4			5
+#define	PS_ID_SUBNET6			6
+#define	PS_ID_RANGE4			7
+#define	PS_ID_RANGE6			8
+#define	PS_ID_ASN1DN			9
+#define	PS_ID_ASN1GN			10
+#define	PS_ID_KEYID			11
+#define	PS_ID_FQDN			12
+#define	PS_ID_USER_FQDN			13
+#define	PS_ID_RANGE			14
+
+
+/*
+ * Types of IKE Modes
+ * Note: used in pe_ike_mode field.
+ */
+#define	PS_IKM_MAIN			1
+#define	PS_IKM_AGGRESSIVE		2
+#define	PS_IKM_BOTH			3
+
+/*
+ * Prefix length "special values"
+ * Note: used in pe_locid_plen and pe_remid_plen fields
+ */
+#define	PS_PLEN_BAD_ADDR	-1	/* prefix is invalid */
+#define	PS_PLEN_NO_PREFIX	-2	/* no prefix was found */
+
+/*
+ * Interface function prototypes
+ *
+ */
+void preshared_init(boolean_t);
+
+/*
+ * char *preshared_load()
+ *	args : char *ps_filename:	config file name
+ *	args : int  fd:			config file descriptor; will
+ *					be used if ps_filename is NULL.
+ *	args : boolean_t replace:	true => replace existing list;
+ *					false => append to existing list
+ * Return value
+ *	- NULL on success; pointer to error string on error.
+ *
+ *	Also on error, globals err_line_number/err_entry_number point
+ *	to approximate location of error.
+ */
+extern char *preshared_load(const char *, int, boolean_t);
+
+/*
+ * Append the given preshared_entry_t to the global list.
+ * Will NOT increase refcnt - the caller must refhold and let the list
+ * take over the reference.
+ */
+extern boolean_t append_preshared_entry(preshared_entry_t *);
+
+/*
+ * Actual freeing function.  Almost always called by the REFRELE macro.
+ */
+extern void free_preshared(preshared_entry_t *);
+
+/*
+ * psid2sadb(): convert PS_ID_* types to SADB_[X_]IDENTTYPE_* types
+ */
+extern int psid2sadb(int);
+
+/*
+ * Look up preshared entries by in_addr (IPv4)
+ *	- first arg localid
+ *	- second arg remoteid
+ *
+ * Returns a reference-held entry.
+ */
+extern preshared_entry_t *lookup_ps_by_in_addr(struct in_addr *,
+    struct in_addr *);
+
+/*
+ * Look up preshared entries by in_addr (IPv6)
+ *	- first arg localid
+ *	- second arg remoteid
+ *
+ * Returns a reference-held entry.
+ */
+extern preshared_entry_t *lookup_ps_by_in6_addr(struct in6_addr *,
+    struct in6_addr *);
+
+/*
+ * Look up preshared entries by identity
+ *	- first arg localid
+ *	- second arg remoteid
+ *
+ * Returns a reference-held entry.
+ */
+extern preshared_entry_t *lookup_ps_by_ident(sadb_ident_t *, sadb_ident_t *);
+
+/*
+ * Look up the nth preshared entry in our list
+ *	- first arg n
+ *
+ * Returns a reference-held entry.
+ */
+extern preshared_entry_t *lookup_nth_ps(int);
+
+/*
+ * Delete an entry from the list of preshareds.
+ *	- first arg points to the entry to be deleted
+ *	- returns 1 if entry successfully deleted; 0 if entry not found
+ */
+extern int delete_ps(preshared_entry_t *);
+
+/*
+ * Write the preshared entries out to a specified file
+ *	args : int  fd:			config file descriptor
+ *	args : char **errmp:		errpr message string
+ * Return value
+ *	- if the list was written successfully, returns the number
+ *	  of entries that were written; returns -1 on error.
+ *	  Also on error, errmp contains pointer to error message
+ *	  string and globals err_line_number/err_entry_number point
+ *	  to approximate location of error.
+ */
+extern int write_preshared(int, char **);
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* _PRESHARED_H */
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/prf.c b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/prf.c
new file mode 100644
index 0000000000..165ffdd127
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/prf.c
@@ -0,0 +1,431 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2014 Jason King.
+ */
+#include <bunyan.h>
+#include <limits.h>
+#include <security/cryptoki.h>
+#include <stdarg.h>
+#include <string.h>
+#include <strings.h>
+#include <sys/debug.h>
+#include <sys/md5.h>	/* For length constants */
+#include <sys/sha1.h>	/* For length constants */
+#include <sys/sha2.h>	/* For length constants */
+#include <umem.h>
+#include "defs.h"
+#include "ikev2.h"
+#include "prf.h"
+#include "pkcs11.h"
+
+/*
+ * This implements the pseudo-random function (PRF) as well as the streaming
+ * variant (prf+ or 'prfp plus') as described in RFC7296 2.13.  Briefly,
+ * the nonces from both the initiator and responder as well as the shared
+ * DH or ECC key from the IKE_SA_INIT are fed through the PRF function to
+ * generate a seed value.   The prfp+ function starts with this seed value
+ * and iteratively uses the previous values to generate new blocks of keying
+ * material.  For child SAs (either AH, ESP, or an IKE SA rekey), some
+ * additional inputs are mixed in.  RFC7206 secions 2.13 and 2.17 go into
+ * the complete details of what inputs are used when.
+ *
+ * As both the PRF and prfp+ functions use multiple disparate inputs that
+ * are concatented together to form the inputs to the functions, both prf()
+ * and prfplus_init() take a variable number of arguments which should be a
+ * sequence of uint8_t *, size_t pairs of parameters with a terminating NULL
+ * value.  The prf() and prfplus_init() functions will then take care of
+ * concatenating the inputs as required (generally the PCKS#11 C_*Update()
+ * functions do all the dirty work here for us).
+ *
+ * This is run per IKE SA, so a given prfp_t instance should never be shared
+ * between ikev2_sa_ts, and the caller must handle any synchronization of
+ * potentially simultaneous prf* calls with the same prfp_t.  Since the
+ * lifetime of any given prfp_t is currently always just the lifetime of the
+ * calling function, this shouldn't make things difficult.
+ */
+
+/*
+ * RFC7296 2.13 -- The prfp+ is only specified for 255 iterations of the
+ * underlying PRF function.
+ */
+#define	PRFP_ITER_MAX	(255)
+
+/*
+ * Output lengths of these digest algs, don't seem to have preexisting
+ * values for these anywhere.
+ */
+#define	AES_CMAC_LENGTH	(16)
+#define	AES_XCBC_LENGTH	(16)
+
+static boolean_t prfplus_update(prfp_t *);
+
+/*
+ * Run the given PRF algorithm for the given key and seed and place
+ * result into out.  The seed is passed as a sequence of uint8_t *, size_t
+ * pairs terminated by a final NULL
+ */
+boolean_t
+prf(ikev2_prf_t alg, CK_OBJECT_HANDLE key, uint8_t *restrict out, size_t outlen,
+    ...)
+{
+	CK_SESSION_HANDLE	h = p11h();
+	CK_MECHANISM		mech;
+	CK_RV			rc = CKR_OK;
+	CK_ULONG		len = outlen;
+	uint8_t			*segp = NULL;
+	va_list			ap;
+
+	VERIFY3U(outlen, >=, ikev2_prf_outlen(alg));
+
+	mech.mechanism = ikev2_prf_to_p11(alg);
+	mech.pParameter = NULL;
+	mech.ulParameterLen = 0;
+
+	if ((rc = C_SignInit(h, &mech, key)) != CKR_OK) {
+		PKCS11ERR(error, "C_SignInit", rc);
+		return (B_FALSE);
+	}
+
+	va_start(ap, outlen);
+	while ((segp = va_arg(ap, uint8_t *)) != NULL) {
+		size_t seglen = va_arg(ap, size_t);
+
+		rc = C_SignUpdate(h, segp, seglen);
+		if (rc != CKR_OK) {
+			PKCS11ERR(error, "C_SignUpdate", rc);
+			return (B_FALSE);
+		}
+	}
+	va_end(ap);
+
+	rc = C_SignFinal(h, out, &len);
+	if (rc != CKR_OK) {
+		PKCS11ERR(error, "C_SignFinal", rc,
+		    (rc == CKR_DATA_LEN_RANGE) ? BUNYAN_T_UINT64 : BUNYAN_T_END,
+		    "desiredlen", (uint64_t)len, BUNYAN_T_END);
+		return (B_FALSE);
+	}
+
+	return (B_TRUE);
+}
+
+/*
+ * Inititalize a prf+ instance for the given algorithm, key, and seed.
+ */
+boolean_t
+prfplus_init(prfp_t *restrict prfp, ikev2_prf_t alg, CK_OBJECT_HANDLE key, ...)
+{
+	uint8_t		*p = NULL;
+	size_t		len = 0;
+	va_list		ap;
+
+	bzero(prfp, sizeof (*prfp));
+
+	prfp->prfp_alg = alg;
+	prfp->prfp_key = key;
+	prfp->prfp_tbuflen = ikev2_prf_outlen(alg);
+
+	va_start(ap, key);
+	while (va_arg(ap, uint8_t *) != NULL)
+		prfp->prfp_seedlen += va_arg(ap, size_t);
+	va_end(ap);
+
+	prfp->prfp_tbuf[0] = umem_zalloc(prfp->prfp_tbuflen, UMEM_DEFAULT);
+	prfp->prfp_tbuf[1] = umem_zalloc(prfp->prfp_tbuflen, UMEM_DEFAULT);
+	prfp->prfp_seed = umem_zalloc(prfp->prfp_seedlen, UMEM_DEFAULT);
+	if (prfp->prfp_tbuf[0] == NULL || prfp->prfp_tbuf[1] == NULL ||
+	    prfp->prfp_seed == NULL) {
+		(void) bunyan_error(log, "Could not allocate memory for PRF+",
+		    BUNYAN_T_END);
+		goto fail;
+	}
+
+	va_start(ap, key);
+	while ((p = va_arg(ap, uint8_t *)) != NULL) {
+		size_t seglen = va_arg(ap, size_t);
+
+		bcopy(p, prfp->prfp_seed + len, seglen);
+		len += seglen;
+	}
+	va_end(ap);
+
+	/*
+	 * Per RFC7296 2.13, prf+(K, S) = T1 | T2 | T3 | T4 | ...
+	 *
+	 * where:
+	 *	T1 = prf (K, S | 0x01)
+	 *	T2 = prf (K, T1 | S | 0x02)
+	 *	T3 = prf (K, T2 | S | 0x03)
+	 *	T4 = prf (K, T3 | S | 0x04)
+	 *
+	 * Since the next iteration uses the previous iteration's output (plus
+	 * the seed and iteration number), we keep a copy of the output of the
+	 * current iteration as well as the previous iteration.  We use the
+	 * low bit of the current iteration number to index into prfp_tbuf
+	 * (and effectively flip flow between the two buffers).
+	 */
+	prfp->prfp_n = 1;
+
+	/*
+	 * Fill prfp->tbuf[1] with T1. T1 is defined as:
+	 *	T1 = prf (K, S | 0x01)
+	 *
+	 * Note that this is different from subsequent iterations, hence
+	 * starting at prfp->prfp_arg[1], not prfp->arg[0]
+	 */
+	if (!prf(prfp->prfp_alg, prfp->prfp_key,
+	    prfp->prfp_tbuf[1], prfp->prfp_tbuflen,		/* output */
+	    prfp->prfp_seed, prfp->prfp_seedlen,		/* S */
+	    &prfp->prfp_n, sizeof (prfp->prfp_n), NULL))	/* 0x01 */
+		goto fail;
+
+	return (B_TRUE);
+
+fail:
+	prfplus_fini(prfp);
+	return (B_FALSE);
+}
+
+/*
+ * Fill buffer with output of prf+ function.  If outlen == 0, it's explicitly
+ * a no-op.
+ */
+boolean_t
+prfplus(prfp_t *restrict prfp, uint8_t *restrict out, size_t outlen)
+{
+	size_t n = 0;
+	while (n < outlen) {
+		uint8_t *t = prfp->prfp_tbuf[prfp->prfp_n & 0x01];
+		size_t tlen = prfp->prfp_tbuflen - prfp->prfp_pos;
+		size_t amt = 0;
+
+		if (tlen == 0) {
+			if (!prfplus_update(prfp))
+				return (B_FALSE);
+
+			t = prfp->prfp_tbuf[prfp->prfp_n & 0x01];
+			tlen = prfp->prfp_tbuflen - prfp->prfp_pos;
+		}
+
+		amt = MIN(outlen - n, tlen);
+		(void) memcpy(out + n, t + prfp->prfp_pos, amt);
+		prfp->prfp_pos += amt;
+		n += amt;
+	}
+	return (B_TRUE);
+}
+
+/*
+ * Perform a prf+ iteration
+ */
+static boolean_t
+prfplus_update(prfp_t *prfp)
+{
+	uint8_t *t = NULL, *told = NULL;
+	size_t tlen = prfp->prfp_tbuflen;
+
+	/* The sequence (T##) starts with 1 */
+	VERIFY3U(prfp->prfp_n, >, 0);
+
+	if (prfp->prfp_n == PRFP_ITER_MAX) {
+		bunyan_error(log,
+		    "prf+ iteration count reached max (0xff)", BUNYAN_T_END);
+		return (B_FALSE);
+	}
+
+	told = prfp->prfp_tbuf[prfp->prfp_n++ & 0x1];
+	t = prfp->prfp_tbuf[prfp->prfp_n & 0x1];
+
+	if (!prf(prfp->prfp_alg, prfp->prfp_key,
+	    t, tlen,						/* out */
+	    told, tlen,						/* Tn-1 */
+	    prfp->prfp_seed, prfp->prfp_seedlen,		/* S */
+	    &prfp->prfp_n, sizeof (prfp->prfp_n), NULL))	/* 0xnn */
+		return (B_FALSE);
+
+	prfp->prfp_pos = 0;
+	return (B_TRUE);
+}
+
+void
+prfplus_fini(prfp_t *prfp)
+{
+	if (prfp == NULL)
+		return;
+
+	for (size_t i = 0; i < PRFP_NUM_TBUF; i++) {
+		if (prfp->prfp_tbuf[i] != NULL) {
+			explicit_bzero(prfp->prfp_tbuf[i], prfp->prfp_tbuflen);
+			umem_free(prfp->prfp_tbuf[i], prfp->prfp_tbuflen);
+			prfp->prfp_tbuf[i] = NULL;
+		}
+	}
+	prfp->prfp_tbuflen = 0;
+
+	if (prfp->prfp_seed != NULL) {
+		explicit_bzero(prfp->prfp_seed, prfp->prfp_seedlen);
+		umem_free(prfp->prfp_seed, prfp->prfp_seedlen);
+	}
+
+	prfp->prfp_seed = NULL;
+	prfp->prfp_seedlen = 0;
+}
+
+/*
+ * Take 'len' bytes from the prf+ output stream and create a PKCS#11 object
+ * for use with the given mechanism.  A descriptive name (e.g. 'SK_i') is
+ * passed for debugging purposes.
+ */
+boolean_t
+prf_to_p11key(prfp_t *restrict prfp, const char *restrict name,
+    CK_MECHANISM_TYPE alg, size_t len, CK_OBJECT_HANDLE_PTR restrict objp)
+{
+	CK_RV rc = CKR_OK;
+	/*
+	 * The largest key length we currently support is 256 bits (32 bytes),
+	 * so that is the largest possible value of len
+	 */
+	uint8_t buf[len];
+
+	if (len == 0)
+		return (B_TRUE);
+
+	if (!prfplus(prfp, buf, len)) {
+		explicit_bzero(buf, len);
+		return (B_FALSE);
+	}
+
+	rc = SUNW_C_KeyToObject(p11h(), alg, buf, len, objp);
+
+	/*
+	 * XXX: Might it be worth setting the object label attribute to 'name'
+	 * for diagnostic purposes?
+	 */
+	if (rc != CKR_OK) {
+		PKCS11ERR(error, "SUNW_C_KeyToObject", rc,
+		    BUNYAN_T_STRING, "objname", name);
+	} else {
+		size_t hexlen = len * 2 + 1;
+		char hex[hexlen];
+
+		bzero(hex, hexlen);
+		if (show_keys)
+			(void) writehex(buf, len, "", hex, hexlen);
+
+		(void) bunyan_trace(log, "Created PKCS#11 key",
+		    BUNYAN_T_STRING, "objname", name,
+		    show_keys ? BUNYAN_T_STRING : BUNYAN_T_END, "key", hex,
+		    BUNYAN_T_UINT32, "keybits", (uint32_t)SADB_8TO1(len),
+		    BUNYAN_T_END);
+
+		explicit_bzero(hex, hexlen);
+	}
+
+	explicit_bzero(buf, len);
+	return ((rc == CKR_OK) ? B_TRUE : B_FALSE);
+}
+
+CK_MECHANISM_TYPE
+ikev2_prf_to_p11(ikev2_prf_t prf)
+{
+	switch (prf) {
+	case IKEV2_PRF_HMAC_MD5:
+		return (CKM_MD5_HMAC);
+	case IKEV2_PRF_HMAC_SHA1:
+		return (CKM_SHA_1_HMAC);
+	case IKEV2_PRF_HMAC_SHA2_256:
+		return (CKM_SHA256_HMAC);
+	case IKEV2_PRF_HMAC_SHA2_384:
+		return (CKM_SHA384_HMAC);
+	case IKEV2_PRF_HMAC_SHA2_512:
+		return (CKM_SHA512_HMAC);
+	case IKEV2_PRF_AES128_CMAC:
+		return (CKM_AES_CMAC);
+	case IKEV2_PRF_AES128_XCBC:
+		return (CKM_AES_XCBC_MAC);
+	case IKEV2_PRF_HMAC_TIGER:
+		INVALID("unsupported prf function");
+	}
+
+	INVALID("invalid PRF value");
+
+	/*NOTREACHED*/
+	return (0);
+}
+
+size_t
+ikev2_prf_keylen(ikev2_prf_t prf)
+{
+	switch (prf) {
+		/*
+		 * RFC7296 2.12 -- For PRFs based on HMAC, preferred key size is
+		 * equal to the output of the underlying hash function.
+		 */
+	case IKEV2_PRF_HMAC_MD5:
+	case IKEV2_PRF_HMAC_SHA1:
+	case IKEV2_PRF_HMAC_SHA2_256:
+	case IKEV2_PRF_HMAC_SHA2_384:
+	case IKEV2_PRF_HMAC_SHA2_512:
+		/*
+		 * However these two are defined elsewhere, and while the
+		 * RFCs (RFC3664 & RFC4615 respectively) don't explicitly
+		 * state they also use the output length as the preferred
+		 * key size, they happen to be the same
+		 */
+	case IKEV2_PRF_AES128_XCBC:
+	case IKEV2_PRF_AES128_CMAC:
+		return (ikev2_prf_outlen(prf));
+	case IKEV2_PRF_HMAC_TIGER:
+		/*
+		 * We should never negotiate this, so if we try to use it,
+		 * it's a progamming bug in the SA negotiation.
+		 */
+		INVALID("TIGER is unsupported");
+	}
+	INVALID("Invalid PRF value");
+
+	/*NOTREACHED*/
+	return (0);
+}
+
+size_t
+ikev2_prf_outlen(ikev2_prf_t prf)
+{
+	switch (prf) {
+	case IKEV2_PRF_HMAC_MD5:
+		return (MD5_DIGEST_LENGTH);
+	case IKEV2_PRF_HMAC_SHA1:
+		return (SHA1_DIGEST_LENGTH);
+	case IKEV2_PRF_HMAC_SHA2_256:
+		return (SHA256_DIGEST_LENGTH);
+	case IKEV2_PRF_HMAC_SHA2_384:
+		return (SHA384_DIGEST_LENGTH);
+	case IKEV2_PRF_HMAC_SHA2_512:
+		return (SHA512_DIGEST_LENGTH);
+	case IKEV2_PRF_AES128_CMAC:
+		return (AES_CMAC_LENGTH);
+	case IKEV2_PRF_AES128_XCBC:
+		return (AES_XCBC_LENGTH);
+	case IKEV2_PRF_HMAC_TIGER:
+		/*
+		 * We should never negotiate this, so if we try to use it,
+		 * it's a progamming bug in the SA negotiation.
+		 */
+		INVALID("TIGER is unsupported");
+	}
+
+	INVALID("Invalid PRF value");
+
+	/*NOTREACHED*/
+	return (0);
+}
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/prf.h b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/prf.h
new file mode 100644
index 0000000000..313f4a1d26
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/prf.h
@@ -0,0 +1,56 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2017 Jason King
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+#ifndef _PRF_H
+#define	_PRF_H
+
+#include <sys/types.h>
+#include <security/cryptoki.h>
+#include "ikev2.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define	PRFP_NUM_TBUF	(2)
+typedef struct prfp_s {
+	CK_OBJECT_HANDLE	prfp_key;
+	ikev2_prf_t		prfp_alg;
+	uint8_t			*prfp_tbuf[PRFP_NUM_TBUF];
+	size_t			prfp_tbuflen;
+	uint8_t			*prfp_seed;
+	size_t			prfp_seedlen;
+	size_t			prfp_pos;
+	uint8_t			prfp_n;
+} prfp_t;
+
+boolean_t prf(ikev2_prf_t, CK_OBJECT_HANDLE, uint8_t *restrict, size_t, ...);
+boolean_t prfplus_init(prfp_t *restrict, ikev2_prf_t, CK_OBJECT_HANDLE, ...);
+void prfplus_fini(prfp_t *);
+boolean_t prfplus(prfp_t *restrict, uint8_t *restrict, size_t);
+
+boolean_t prf_to_p11key(prfp_t *restrict, const char *restrict,
+    CK_MECHANISM_TYPE, size_t, CK_OBJECT_HANDLE_PTR restrict);
+
+CK_MECHANISM_TYPE ikev2_prf_to_p11(ikev2_prf_t);
+size_t	ikev2_prf_keylen(ikev2_prf_t);
+size_t	ikev2_prf_outlen(ikev2_prf_t);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _PRF_H */
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ts.c b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ts.c
new file mode 100644
index 0000000000..605d59d8bb
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ts.c
@@ -0,0 +1,731 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2017 Joyent, Inc.
+ */
+
+#include <bunyan.h>
+#include <inttypes.h>
+#include <libinetutil.h>	/* For plen2mask */
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <net/pfkeyv2.h>
+#include <netdb.h>
+#include <strings.h>
+#include "defs.h"
+#include "ikev2_enum.h"
+#include "ikev2_pkt.h"
+#include "ts.h"
+
+/*
+ * Much like ts_t are fixed-sized versions of the kernel's traffic selectors,
+ * range_t's are fixed-sized versions of IKEv2 traffic selectors and can
+ * access all the data via field names instead of requiring lots of pointer
+ * math.
+ */
+typedef struct range_s {
+	union {
+		struct sockaddr		su_startsa;
+		struct sockaddr_in	su_start;
+		struct sockaddr_in6	su_start6;
+		struct sockaddr_storage su_startss;
+	} ra_startu;
+	union {
+		struct sockaddr		eu_endsa;
+		struct sockaddr_in	eu_end;
+		struct sockaddr_in6	eu_end6;
+		struct sockaddr_storage	eu_endss;
+	} ra_endu;
+	uint8_t ra_proto;
+/* Oh to have C11 anonymous unions.... */
+#define	ra_startsa ra_startu.su_startsa
+#define	ra_start ra_startu.su_start
+#define	ra_start6 ra_startu.su_start6
+#define	ra_startss ra_startu.su_startss
+#define	ra_endsa ra_endu.eu_endsa
+#define	ra_end ra_endu.eu_end
+#define	ra_end6 ra_endu.eu_end6
+#define	ra_endss ra_endu.eu_endss
+} range_t;
+
+#define	RANGE_CHECKAF(r) \
+    VERIFY3U((r)->ra_startsa.sa_family, ==, (r)->ra_endsa.sa_family);
+
+static void ts_to_range(const ts_t *restrict, range_t *restrict);
+static void range_to_ts(const range_t *restrict, ts_t *restrict);
+static boolean_t range_intersection(const range_t *restrict,
+    const range_t *restrict, range_t *restrict);
+static int range_cmp_size(const range_t *restrict,
+    const range_t *restrict);
+static boolean_t range_contains(const range_t *restrict,
+    const range_t *restrict);
+static void range_log(bunyan_logger_t *restrict, bunyan_level_t,
+    const char *restrict, const range_t *restrict);
+
+ts_t *
+sadb_to_ts(const sadb_address_t *restrict addr, ts_t *restrict ts)
+{
+	size_t len = SADB_64TO8(addr->sadb_address_len) - sizeof (*addr);
+
+	switch (addr->sadb_address_exttype) {
+	case SADB_EXT_ADDRESS_SRC:
+	case SADB_EXT_ADDRESS_DST:
+	case SADB_X_EXT_ADDRESS_INNER_SRC:
+	case SADB_X_EXT_ADDRESS_INNER_DST:
+		break;
+	default:
+		INVALID(addr->sadb_address_exttype);
+	}
+
+	bzero(ts, sizeof (*ts));
+
+	ts->ts_proto = addr->sadb_address_proto;
+	ts->ts_prefix = addr->sadb_address_prefixlen;
+	bcopy(addr + 1, &ts->ts_ss, len);
+
+	/* pf_key(7p) uses /0 for single addresses.  sigh. */
+	if (ts->ts_prefix == 0 && !addr_is_zero(&ts->ts_sa))
+		ts->ts_prefix = ss_addrbits(&ts->ts_sa);
+
+	return (ts);
+}
+
+boolean_t
+ts_add(ikev2_pkt_ts_state_t *restrict tss, const ts_t *restrict ts)
+{
+	range_t r = { 0 };
+	char msg[64] = { 0 };
+	const char *ts_name = ikev2_pay_short_str(tss->i2ts_idx->pp_type);
+
+	(void) snprintf(msg, sizeof (msg), "Added %s", ts_name);
+
+	ts_to_range(ts, &r);
+	if (!ikev2_add_ts(tss, ts->ts_proto, &r.ra_startsa, &r.ra_endsa))
+		return (B_FALSE);
+
+	ts_log(log, BUNYAN_L_TRACE, msg, ts);
+	return (B_TRUE);
+}
+
+/*
+ * Adjust our traffic selector to a range that is compatible with the
+ * selectors in the given payload.
+ *
+ *	pay		The payload (TS{i,r}) to compare
+ *	ts		Our traffic selector corresponding to selectors in pay.
+ *	narrowed	Set on return if the range of ts was narrowed.
+ *	from_init	B_TRUE if payload is from the initiator
+ *
+ * If there was no common subset of addresses between pay and ts, B_FALSE
+ * is returned.  Otherwise, B_TRUE is returned.
+ */
+static boolean_t
+ts_negotiate_one(pkt_payload_t *restrict pay, ts_t *restrict ts,
+    boolean_t *restrict narrowed, const boolean_t from_init)
+{
+	const char *ts_type = ikev2_pay_short_str(pay->pp_type);
+	char msg[128] = { 0 };
+	ikev2_ts_t *tsp = NULL;
+	ikev2_ts_iter_t iter = { 0 };
+	range_t peer = { 0 };
+	range_t ts0 = { 0 };
+	range_t us = { 0 };
+	range_t res = { 0 };
+	range_t cmp = { 0 };
+	boolean_t first = B_TRUE;
+
+	ts_to_range(ts, &us);
+	(void) snprintf(msg, sizeof (msg), "Local %s", ts_type);
+	range_log(log, BUNYAN_L_TRACE, msg, &us);
+
+	/* Get the first TS from the payload */
+	tsp = ikev2_ts_iter(pay, &iter, &ts0.ra_startss, &ts0.ra_endss);
+	ts->ts_proto = tsp->ts_protoid;
+
+	(void) snprintf(msg, sizeof (msg), "Remote %s[0]", ts_type);
+	range_log(log, BUNYAN_L_TRACE, msg, &ts0);
+
+	/*
+	 * Determine the addresses in common.  On the responder, this should
+	 * always succeed, as we first query the kernel for our policy that
+	 * covers TS[0] before attempting to negotiate the traffic selectors,
+	 * and will fail at that point if no policy is found.  On the initiator
+	 * however, a responder is supposed to send a TS_UNACCEPTABLE if the
+	 * proposed selectors are not allowed by it's policy, but we still
+	 * want to guard against a peer sending back selectors that violate
+	 * our policy.
+	 */
+	if (!range_intersection(&us, &ts0, &res)) {
+		range_log(log, BUNYAN_L_WARN,
+		    "Traffic selector from peer violates local policy", &ts0);
+		return (B_FALSE);
+	}
+
+	(void) snprintf(msg, sizeof (msg), "Local %s & Remote %s[0]", ts_type,
+	    ts_type);
+	range_log(log, BUNYAN_L_TRACE, msg, &res);
+
+	/*
+	 * For payloads from the initiator, if more than one TS is present in
+	 * a payload, the first TS is the address of the original packet
+	 * that triggered the SA creation, and the additional TS are the
+	 * selectors from the initiator's policy that cover the original packet.
+	 * This means when additional selectors are present, the intersection
+	 * of TS[0] and our selector will result in a single address.  However,
+	 * we'd like to use the broadest policy we can express that complies
+	 * with both our and our peer's policy (but still includes the address
+	 * of the original packet).
+	 */
+	while (from_init && (tsp = ikev2_ts_iter_next(&iter,
+	    &peer.ra_startss, &peer.ra_endss)) != NULL) {
+		ts_t ts_tmp = { 0 };
+
+		if (tsp->ts_protoid != ts->ts_proto) {
+			struct protoent *pe = NULL;
+			char pnum[6] = { 0 };
+
+			pe = getprotobynumber(tsp->ts_protoid);
+			if (pe == NULL) {
+				(void) snprintf(pnum, sizeof (pnum), "%hhu",
+				    tsp->ts_protoid);
+			}
+
+			(void) snprintf(msg, sizeof (msg),
+			    "Remote %s[%zu] is not the same protocol as our"
+			    "local %s", ts_type, iter.i2ti_n, ts_type);
+
+			(void) bunyan_trace(log, msg,
+			    BUNYAN_T_STRING, "protocol",
+			    (pe != NULL) ? pe->p_name : pnum,
+			    BUNYAN_T_END);
+
+			continue;
+		}
+
+		bzero(&cmp, sizeof (cmp));
+
+		if (!range_intersection(&peer, &us, &cmp)) {
+			(void) snprintf(msg, sizeof (msg),
+			    "Remote %s[%zu] has no overlap with local %s",
+			    ts_type, iter.i2ti_n, ts_type);
+			(void) bunyan_trace(log, msg, BUNYAN_T_END);
+			continue;
+		}
+
+		(void) snprintf(msg, sizeof (msg),
+		    "Remote %s[%zu] & local %s", ts_type, iter.i2ti_n, ts_type);
+		range_log(log, BUNYAN_L_TRACE, msg, &cmp);
+
+		/*
+		 * Convert the resulting intersection to an address/prefix and
+		 * back again.  Because we can only deal with subnets
+		 * (address/prefix) and not arbitrary ranges of addresses, the
+		 * conversion from a range_t to a ts_t may narrow the result.
+		 * Converting the ts_t back to a range_t then gives us a
+		 * value that we know is usable by the kernel.  This form is
+		 * what we want to use to compare the size of the range_t and
+		 * check that the range still contains the original packet.
+		 */
+		range_to_ts(&cmp, &ts_tmp);
+		ts_to_range(&ts_tmp, &cmp);
+
+		(void) strlcat(msg, " (as subnet)", sizeof (msg));
+		ts_log(log, BUNYAN_L_TRACE, msg, &ts_tmp);
+
+		if (!range_contains(&cmp, &ts0)) {
+			(void) snprintf(msg, sizeof (msg),
+			    "Remote %s[%zu] & local %s does not contain %s[0]",
+			    ts_type, iter.i2ti_n, ts_type, ts_type);
+			range_log(log, BUNYAN_L_TRACE, msg, &cmp);
+			continue;
+		}
+
+		if (range_cmp_size(&cmp, &res) > 0) {
+			/*
+			 * If more than one selector is present (excluding the
+			 * original packet as a selector), we only support
+			 * picking one, so we're definitely narrowing the
+			 * proposed selectors.
+			 *
+			 * XXX: This isn't the only case where it can happen,
+			 * need to add checks for those, however this detection
+			 * is strictly informational in nature to allow both
+			 * peers to detect mismatched policies, so it is not
+			 * fatal or even incorrect if we don't report all
+			 * instances.
+			 */
+			if (!first)
+				*narrowed = B_TRUE;
+
+			res = cmp;
+
+			(void) snprintf(msg, sizeof (msg),
+			    "Remote %s[%zu] is current largest range",
+			    ts_type, iter.i2ti_n);
+			range_log(log, BUNYAN_L_TRACE, msg, &res);
+		}
+		first = B_FALSE;
+	}
+
+	(void) snprintf(msg, sizeof (msg), "Selected %s", ts_type);
+	range_log(log, BUNYAN_L_TRACE, msg, &res);
+
+	range_to_ts(&res, ts);
+	return (B_TRUE);
+}
+
+boolean_t
+ts_negotiate(pkt_t *restrict pkt, ts_t *restrict ts_i, ts_t *restrict ts_r,
+    boolean_t *restrict narrowed)
+{
+	pkt_payload_t *ts_pay = NULL;
+	boolean_t is_init = I2P_INITIATOR(pkt);
+
+	*narrowed = B_FALSE;
+
+	if ((ts_pay = pkt_get_payload(pkt, IKEV2_PAYLOAD_TSi, NULL)) == NULL) {
+		(void) bunyan_warn(log, "TSi payload missing", BUNYAN_T_END);
+		return (B_FALSE);
+	}
+
+	if (!ts_negotiate_one(ts_pay, ts_i, narrowed, is_init))
+		return (B_FALSE);
+
+	if ((ts_pay = pkt_get_payload(pkt, IKEV2_PAYLOAD_TSr, NULL)) == NULL) {
+		(void) bunyan_warn(log, "TSr payload missing", BUNYAN_T_END);
+		return (B_FALSE);
+	}
+
+	return (ts_negotiate_one(ts_pay, ts_r, narrowed, is_init));
+}
+
+void
+ts_first(pkt_payload_t *restrict pay, ts_t *restrict ts)
+{
+	ikev2_ts_t *tsp = NULL;
+	ikev2_ts_iter_t iter = { 0 };
+	range_t r = { 0 };
+
+	VERIFY(pay->pp_type == IKEV2_PAYLOAD_TSi ||
+	    pay->pp_type == IKEV2_PAYLOAD_TSr);
+
+	tsp = ikev2_ts_iter(pay, &iter, &r.ra_startss, &r.ra_endss);
+	r.ra_proto = tsp->ts_protoid;
+	range_to_ts(&r, ts);
+}
+
+static void
+range_set_family(range_t *restrict r, sa_family_t af)
+{
+	r->ra_startsa.sa_family = r->ra_endsa.sa_family = af;
+}
+
+static void
+range_set_port(range_t *restrict r, uint16_t start_port, uint16_t end_port)
+{
+	/* Take advantage of port being at the same offset for IPv4/6 */
+	uint16_t *startp = &r->ra_start.sin_port;
+	uint16_t *endp = &r->ra_end.sin_port;
+
+	RANGE_CHECKAF(r);
+
+	VERIFY(r->ra_startss.ss_family == AF_INET ||
+	    r->ra_startss.ss_family == AF_INET6);
+
+	*startp = start_port;
+	*endp = end_port;
+}
+
+static void
+ts_to_range(const ts_t *restrict ts, range_t *restrict r)
+{
+	struct sockaddr_storage mask = { .ss_family = ts->ts_ss.ss_family };
+	const uint8_t *addrp = ss_addr(&ts->ts_sa);
+	const uint8_t *maskp = ss_addr(SSTOSA(&mask));
+	uint8_t *startp = NULL;
+	uint8_t *endp = NULL;
+	uint16_t sport = 0, eport = UINT16_MAX;
+	size_t len = 0;
+
+	VERIFY0(plen2mask(ts->ts_prefix, ts->ts_sa.sa_family, SSTOSA(&mask)));
+
+	range_set_family(r, ts->ts_sa.sa_family);
+	len = ss_addrlen(&ts->ts_sa);
+	startp = (uint8_t *)ss_addr(&r->ra_startsa);
+	endp = (uint8_t *)ss_addr(&r->ra_endsa);
+
+	for (size_t i = 0; i < len; i++) {
+		startp[i] = addrp[i] & maskp[i];
+		endp[i] = addrp[i] | ~maskp[i];
+	}
+
+	if (ss_port(&ts->ts_sa) != 0) {
+		/* ss_port returns the value in host byte order */
+		uint32_t val = ss_port(&ts->ts_sa);
+		sport = eport = htons(val);
+	}
+
+	range_set_port(r, sport, eport);
+	r->ra_proto = ts->ts_proto;
+}
+
+static boolean_t
+range_intersection_addr(const range_t *restrict r1, const range_t *restrict r2,
+    range_t *restrict r_res)
+{
+	const uint8_t *start1p = ss_addr(&r1->ra_startsa);
+	const uint8_t *start2p = ss_addr(&r2->ra_startsa);
+	const uint8_t *end1p = ss_addr(&r1->ra_endsa);
+	const uint8_t *end2p = ss_addr(&r2->ra_endsa);
+	uint8_t *res_startp = (uint8_t *)ss_addr(&r_res->ra_startsa);
+	uint8_t *res_endp = (uint8_t *)ss_addr(&r_res->ra_endsa);
+	size_t len = ss_addrlen(&r1->ra_startsa);
+
+	for (size_t i = 0; i < len; i++) {
+		res_startp[i] = MAX(start1p[i], start2p[i]);
+		res_endp[i] = MIN(end1p[i], end2p[i]);
+
+		/* If the range is disjoint, set r_res to a zero-sized range */
+		if (res_startp[i] > res_endp[i])
+			return (B_FALSE);
+	}
+
+	return (B_TRUE);
+}
+
+static boolean_t
+range_intersection_port(const range_t *restrict r1, const range_t *restrict r2,
+    range_t *restrict r_res)
+{
+	uint16_t start1 = ss_port(&r1->ra_startsa);
+	uint16_t start2 = ss_port(&r2->ra_startsa);
+	uint16_t end1 = ss_port(&r1->ra_endsa);
+	uint16_t end2 = ss_port(&r2->ra_endsa);
+	uint16_t sport = MAX(start1, start2);
+	uint16_t eport = MIN(end1, end2);
+
+	if (sport > eport)
+		return (B_FALSE);
+
+	range_set_port(r_res, sport, eport);
+	return (B_TRUE);
+}
+
+/*
+ * Compute the intersection of the two ranges.  Returns B_FALSE if the result
+ * is the empty/null set.  B_TRUE otherwise
+ */
+static boolean_t
+range_intersection(const range_t *restrict r1, const range_t *restrict r2,
+    range_t *restrict r_res)
+{
+	RANGE_CHECKAF(r1);
+	RANGE_CHECKAF(r2);
+	VERIFY3U(r1->ra_startss.ss_family, ==, r2->ra_startss.ss_family);
+
+	bzero(r_res, sizeof (*r_res));
+	range_set_family(r_res, r1->ra_startss.ss_family);
+
+	if (r1->ra_proto == 0)
+		r_res->ra_proto = r2->ra_proto;
+	else if (r2->ra_proto == 0)
+		r_res->ra_proto = r1->ra_proto;
+	else if (r1->ra_proto != r2->ra_proto)
+		goto zero;
+	else
+		r_res->ra_proto = r1->ra_proto;
+
+	if (!range_intersection_addr(r1, r2, r_res))
+		goto zero;
+
+	if (!range_intersection_port(r1, r2, r_res))
+		goto zero;
+
+	r_res->ra_proto = r1->ra_proto;
+	return (B_TRUE);
+
+zero:
+	bzero(r_res, sizeof (*r_res));
+	range_set_family(r_res, r1->ra_startss.ss_family);
+	return (B_FALSE);
+}
+
+/*
+ * Find the least significant bit set/unset in the given address.
+ */
+static size_t
+addr_lsb(const struct sockaddr *restrict addr, boolean_t set)
+{
+	const uint8_t *p = ss_addr(addr);
+	size_t len = ss_addrlen(addr);
+	int bits = len * NBBY;
+
+	for (size_t i = len; i > 0; i--) {
+		int val = p[i - 1];
+		int bit = 0;
+
+		if ((set && val == 0) || (!set && val == UINT8_MAX)) {
+			bits -= NBBY;
+			continue;
+		}
+
+		/*
+		 * We can only easily check the first set bit in an int.
+		 * For finding the first unset bit, invert then check.
+		 */
+		bit = ffs(set ? val : ~val);
+		VERIFY3S(bit, >, 0);
+
+		/* ffc(3C) uses 1-based indexes for bits */
+		bits -= bit - 1;
+		break;
+	}
+
+	VERIFY3S(bits, >=, 0);
+	return ((size_t)bits);
+}
+
+static void
+range_to_ts(const range_t *restrict r, ts_t *restrict ts)
+{
+	uint8_t *ts_addr = NULL;
+	const uint8_t *start_addr = ss_addr(&r->ra_startsa);
+	size_t start_lsb = addr_lsb(&r->ra_startsa, B_TRUE);
+	size_t end_lsb = addr_lsb(&r->ra_endsa, B_FALSE);
+	size_t len = ss_addrlen(&r->ra_startsa);
+	uint32_t start_port = ss_port(&r->ra_startsa);
+	uint32_t end_port = ss_port(&r->ra_endsa);
+
+	RANGE_CHECKAF(r);
+
+	bzero(&ts->ts_ss, sizeof (ts->ts_ss));
+
+	ts->ts_ss.ss_family = r->ra_startss.ss_family;
+	ts_addr = (uint8_t *)ss_addr(&ts->ts_sa);
+	bcopy(start_addr, ts_addr, len);
+
+	ts->ts_prefix = MAX(start_lsb, end_lsb);
+	ts->ts_proto = r->ra_proto;
+
+	/* Take advantage of the same offset for port for sin/sin6 */
+	if (start_port != 0 || end_port != UINT16_MAX)
+		ts->ts_sin.sin_port = htons(start_port);
+}
+
+/* B_TRUE if r1 contains r2 */
+static boolean_t
+range_contains_addr(const range_t *restrict r1, const range_t *restrict r2)
+{
+	const uint32_t *r1start = ss_addr(&r1->ra_startsa);
+	const uint32_t *r2start = ss_addr(&r2->ra_startsa);
+	const uint32_t *r1end = ss_addr(&r1->ra_endsa);
+	const uint32_t *r2end = ss_addr(&r2->ra_endsa);
+	size_t len = ss_addrlen(&r1->ra_startsa);
+
+	for (size_t i = 0; i < len; i++) {
+		/* Double check our invariants */
+		VERIFY3U(r1start[i], <=, r1end[i]);
+		VERIFY3U(r2start[i], <=, r2end[i]);
+
+		if (r1start[i] > r2start[i] || r1end[i] < r2end[i])
+			return (B_FALSE);
+	}
+
+	return (B_TRUE);
+}
+
+static boolean_t
+range_contains_port(const range_t *restrict r1, const range_t *restrict r2)
+{
+	uint32_t p1_start = ss_port(&r1->ra_startsa);
+	uint32_t p2_start = ss_port(&r2->ra_startsa);
+	uint32_t p1_end = ss_port(&r1->ra_endsa);
+	uint32_t p2_end = ss_port(&r2->ra_endsa);
+
+	/* Check our invariants */
+	VERIFY3U(p1_start, <=, p1_end);
+	VERIFY3U(p2_start, <=, p2_end);
+
+	if (p1_start > p2_start || p1_end < p2_end)
+		return (B_FALSE);
+
+	return (B_TRUE);
+}
+
+static boolean_t
+range_contains(const range_t *restrict r1, const range_t *restrict r2)
+{
+	RANGE_CHECKAF(r1);
+	RANGE_CHECKAF(r2);
+	VERIFY3U(r1->ra_startsa.sa_family, ==, r2->ra_startsa.sa_family);
+
+	if ((r1->ra_proto != 0) && (r1->ra_proto != r2->ra_proto))
+		return (B_FALSE);
+
+	if (!range_contains_addr(r1, r2))
+		return (B_FALSE);
+
+	return (range_contains_port(r1, r2));
+}
+
+static int
+range_cmp_size_addr(const range_t *restrict r1, const range_t *restrict r2)
+{
+	const uint32_t *r1start = ss_addr(&r1->ra_startsa);
+	const uint32_t *r2start = ss_addr(&r2->ra_startsa);
+	const uint32_t *r1end = ss_addr(&r1->ra_endsa);
+	const uint32_t *r2end = ss_addr(&r2->ra_endsa);
+	size_t len = ss_addrlen(&r1->ra_startsa);
+
+	VERIFY3U(len % sizeof (uint32_t), ==, 0);
+
+	/*
+	 * Since we currently don't have 128-bit integer support in our compiler
+	 * AFAIK, just look in 32-bit chunks.  We only care about the
+	 * relative sizes of the range versus the actual sizes, so we don't
+	 * need to do the 128-bit math.
+	 */
+	for (size_t i = 0; i < len / sizeof (uint32_t); i++) {
+		uint32_t s1 = ntohl(r1start[i]);
+		uint32_t s2 = ntohl(r2start[i]);
+		uint32_t e1 = ntohl(r1end[i]);
+		uint32_t e2 = ntohl(r2end[i]);
+		uint32_t d1 = e1 - s1;
+		uint32_t d2 = e2 - e1;
+
+		/* Can't hurt to verify our expected invariants */
+		VERIFY3U(s1, <=, e1);
+		VERIFY3U(s1, <=, e1);
+
+		if (d1 > d2)
+			return (-1);
+		if (d1 < d2)
+			return (1);
+	}
+
+	return (0);
+}
+
+static int
+range_cmp_size_port(const range_t *restrict r1, const range_t *restrict r2)
+{
+	uint32_t p1_start = ss_port(&r1->ra_startsa);
+	uint32_t p2_start = ss_port(&r2->ra_startsa);
+	uint32_t p1_end = ss_port(&r1->ra_endsa);
+	uint32_t p2_end = ss_port(&r2->ra_endsa);
+	uint32_t d1 = p1_end - p1_start;
+	uint32_t d2 = p2_end - p2_start;
+
+	/* Check our invariants */
+	VERIFY3U(p1_start, <=, p1_end);
+	VERIFY3U(p2_start, <=, p2_end);
+
+	if (d1 > d2)
+		return (-1);
+
+	if (d1 < d2)
+		return (1);
+
+	return (0);
+}
+
+/*
+ * Compares the size (number of addresses) of each range.  It does not
+ * look at the ordering of the start, end addresses of each range.   For
+ * example:
+ *
+ *	(10.0.2.0 - 10.0.255.255) > (192.168.1.0 - 192.168.2.0)
+ *
+ * Returns the usual -1, 0, 1 based on the comparison of sizes of r1 to t2.
+ */
+static int
+range_cmp_size(const range_t *restrict r1, const range_t *restrict r2)
+{
+	int cmp;
+
+	RANGE_CHECKAF(r1);
+	RANGE_CHECKAF(r2);
+	VERIFY3U(r1->ra_startsa.sa_family, ==, r2->ra_startsa.sa_family);
+
+	if ((cmp = range_cmp_size_addr(r1, r2)) != 0)
+		return (cmp);
+
+	return (range_cmp_size_port(r1, r2));
+}
+
+static void
+range_log(bunyan_logger_t *restrict blog, bunyan_level_t level,
+    const char *restrict msg, const range_t *restrict range)
+{
+	const struct sockaddr *start = &range->ra_startsa;
+	const struct sockaddr *end = &range->ra_endsa;
+	struct protoent *pe = NULL;
+	const char *protostr = NULL;
+
+	pe = getprotobynumber(range->ra_proto);
+	protostr = (pe->p_name != NULL) ?
+	    pe->p_name : enum_printf("%hhu", range->ra_proto);
+
+	(void) getlog(level)(blog, msg,
+	    BUNYAN_T_STRING, "protocol", protostr,
+	    ss_bunyan(start), "start_addr", ss_addr(start),
+	    BUNYAN_T_UINT32, "start_port", ss_port(start),
+	    ss_bunyan(end), "end_addr", ss_addr(end),
+	    BUNYAN_T_UINT32, "end_port", ss_port(end),
+	    BUNYAN_T_END);
+}
+
+void
+ts_log(bunyan_logger_t *restrict blog, bunyan_level_t level,
+    const char *restrict msg, const ts_t *restrict ts)
+{
+	const void *aptr = ss_addr(&ts->ts_sa);
+	struct protoent *pe = NULL;
+	const char *portstr = NULL;
+	const char *protostr = NULL;
+	char astr[INET6_ADDRSTRLEN + 4] = { 0 }; /* +4 for '/xxx' */
+	size_t plen = 0;
+	uint32_t port = ss_port(&ts->ts_sa);
+
+	if (inet_ntop(ts->ts_ss.ss_family, aptr, astr, sizeof (astr)) == NULL)
+		return;
+
+	if (ts->ts_prefix != ss_addrbits(&ts->ts_sa)) {
+		char pfx[5] = { 0 };
+
+		(void) snprintf(pfx, sizeof (pfx), "/%hhu", ts->ts_prefix);
+		(void) strlcat(astr, pfx, sizeof (astr));
+	}
+
+	plen++;		/* '/' */
+
+	if ((pe = getprotobynumber(ts->ts_proto)) != NULL)
+		plen += strlen(pe->p_name);
+	else
+		plen += 3;	/* 3 digit value */
+
+
+	portstr = (port == 0) ? "any" : enum_printf("%u", port);
+
+	protostr = (pe != NULL) ?
+	    pe->p_name : enum_printf("%hhu", ts->ts_proto);
+	plen = strlen(portstr) + strlen(protostr) + 2; /* '/' + NUL */
+
+	char pstr[plen];
+
+	(void) snprintf(pstr, plen, "%s/%s", protostr, portstr);
+
+	(void) getlog(level)(blog, msg,
+	    BUNYAN_T_STRING, "ts", astr,
+	    BUNYAN_T_STRING, "ts_port", pstr,
+	    BUNYAN_T_END);
+}
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ts.h b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ts.h
new file mode 100644
index 0000000000..57545ae292
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ts.h
@@ -0,0 +1,71 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2017 Joyent, Inc.
+ */
+
+#ifndef _TS_H
+#define	_TS_H
+
+#include <netinet/in.h>
+#include <inttypes.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct pkt_s;
+struct pkt_payload;
+struct ikev2_ts;
+struct ikev2_pkt_ts_state;
+struct sadb_address;
+struct sockaddr_storage;
+struct bunyan_logger;
+enum bunyan_level;
+
+/*
+ * A representation of traffic selectors that better matches what the kernel
+ * uses (i.e. ([proto], address/prefix, [port])).  This is similar to an
+ * sadb_address_t except that the total size of this structure is fixed.
+ */
+typedef struct ts_s {
+	uint8_t ts_proto;
+	uint8_t	ts_prefix;
+	union {
+		struct sockaddr_in	tsu_sin;
+		struct sockaddr_in6	tsu_sin6;
+		struct sockaddr_storage tsu_ss;
+		struct sockaddr		tsu_sa;
+	} ts_addru;
+#define	ts_sin	ts_addru.tsu_sin
+#define	ts_sin6 ts_addru.tsu_sin6
+#define	ts_ss	ts_addru.tsu_ss
+#define	ts_sa	ts_addru.tsu_sa
+} ts_t;
+
+/* pf_key(7P) uses /0 to represent single addresses */
+#define	TS_SADB_PREFIX(_t) \
+    ((_t)->ts_prefix == ss_addrbits(&(_t)->ts_sa) ? 0 : (_t)->ts_prefix)
+
+ts_t *sadb_to_ts(const struct sadb_address *restrict, ts_t *restrict);
+boolean_t ts_add(struct ikev2_pkt_ts_state *restrict, const ts_t *restrict);
+boolean_t ts_negotiate(struct pkt_s *restrict, ts_t *restrict, ts_t *restrict,
+    boolean_t *restrict);
+void ts_first(struct pkt_payload *restrict, ts_t *restrict);
+void ts_log(struct bunyan_logger *restrict, enum bunyan_level,
+    const char *restrict, const ts_t *restrict);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _TS_H */
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/util.c b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/util.c
new file mode 100644
index 0000000000..b34b50c300
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/util.c
@@ -0,0 +1,445 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2017 Joyent, Inc.
+ */
+
+#include <arpa/inet.h>
+#include <dlfcn.h>
+#include <inet/ip.h>	/* for IP[V6]_ABITS */
+#include <inttypes.h>
+#include <libinetutil.h>
+#include <netinet/in.h>
+#include <port.h>
+#include <stdarg.h>
+#include <string.h>
+#include <strings.h>
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <thread.h>
+#include <umem.h>
+#include "config.h"
+#include "ike.h"
+#include "defs.h"
+
+#define	ENUMBUF_NUM	8	/* Num of enumbufs that can be used at a time */
+#define	ENUMBUF_SZ	11	/* Large enough to hold a 32-bit number + NUL */
+
+struct enumbuf_s {
+	uint	eb_idx;
+	char	eb_buf[ENUMBUF_NUM][ENUMBUF_SZ];
+};
+
+/* XXX: Probably should change this to dynamic allocation */
+__thread struct enumbuf_s enumbuf;
+
+/* Pick a bunyan log function based on level */
+bunyan_logfn_t
+getlog(bunyan_level_t level)
+{
+	switch (level) {
+	case BUNYAN_L_TRACE:
+		return (bunyan_trace);
+	case BUNYAN_L_DEBUG:
+		return (bunyan_debug);
+	case BUNYAN_L_INFO:
+		return (bunyan_info);
+	case BUNYAN_L_WARN:
+		return (bunyan_warn);
+	case BUNYAN_L_ERROR:
+		return (bunyan_error);
+	case BUNYAN_L_FATAL:
+		return (bunyan_fatal);
+	}
+
+	return (NULL);
+}
+
+const char *
+enum_printf(const char *fmt, ...)
+{
+	char *buf = enumbuf.eb_buf[enumbuf.eb_idx++];
+	va_list ap;
+
+	enumbuf.eb_idx %= ENUMBUF_NUM;
+
+	va_start(ap, fmt);
+	(void) vsnprintf(buf, ENUMBUF_SZ, fmt, ap);
+	va_end(ap);
+
+	return (buf);
+}
+
+const char *
+symstr(void *addr, char *buf, size_t buflen)
+{
+	Dl_info_t dlinfo = { 0 };
+
+	if (dladdr(addr, &dlinfo) != 0)
+		return (dlinfo.dli_sname);
+
+	(void) snprintf(buf, buflen, "0x%p", addr);
+	return (buf);
+}
+
+const char *
+afstr(sa_family_t af)
+{
+	switch (af) {
+	case AF_INET:
+		return ("AF_INET");
+	case AF_INET6:
+		return ("AF_INET6");
+	}
+
+	return (enum_printf("%hhu", af));
+}
+
+#define	STR(x) case x: return (#x)
+const char *
+event_str(event_t evt)
+{
+	switch (evt) {
+	STR(EVENT_NONE);
+	STR(EVENT_SIGNAL);
+	}
+
+	return (enum_printf("%d", evt));
+}
+
+const char *
+port_source_str(ushort_t src)
+{
+	switch (src) {
+	STR(PORT_SOURCE_AIO);
+	STR(PORT_SOURCE_FD);
+	STR(PORT_SOURCE_MQ);
+	STR(PORT_SOURCE_TIMER);
+	STR(PORT_SOURCE_USER);
+	STR(PORT_SOURCE_ALERT);
+	STR(PORT_SOURCE_FILE);
+	}
+
+	return (enum_printf("%hhu", src));
+}
+#undef STR
+
+int
+ss_bunyan(const struct sockaddr *sa)
+{
+	switch (sa->sa_family) {
+	case AF_INET:
+		return (BUNYAN_T_IP);
+	case AF_INET6:
+		return (BUNYAN_T_IP6);
+	default:
+		INVALID(sa->sa_family);
+		/*NOTREACHED*/
+		return (0);
+	}
+}
+
+/* Returns uint32_t to avoid lots of casts w/ libbunyan */
+uint32_t
+ss_port(const struct sockaddr *sa)
+{
+	const sockaddr_u_t sau = { .sau_sa = (struct sockaddr *)sa };
+
+	switch (sa->sa_family) {
+	case AF_INET:
+		return (ntohs(sau.sau_sin->sin_port));
+	case AF_INET6:
+		return (ntohs(sau.sau_sin6->sin6_port));
+	default:
+		INVALID(sa->sa_family);
+		/*NOTREACHED*/
+		return (0);
+	}
+}
+
+const void *
+ss_addr(const struct sockaddr *sa)
+{
+	sockaddr_u_t sau = { .sau_sa = (struct sockaddr *)sa };
+
+	switch (sa->sa_family) {
+	case AF_INET:
+		return (&sau.sau_sin->sin_addr);
+	case AF_INET6:
+		return (&sau.sau_sin6->sin6_addr);
+	default:
+		INVALID(sa->sa_family);
+		/*NOTREACHED*/
+		return (0);
+	}
+}
+
+size_t
+ss_addrlen(const struct sockaddr *sa)
+{
+	switch (sa->sa_family) {
+	case AF_INET:
+		return (sizeof (in_addr_t));
+	case AF_INET6:
+		return (sizeof (in6_addr_t));
+	default:
+		INVALID(sa->sa_family);
+		/*NOTREACHED*/
+		return (0);
+	}
+}
+
+uint8_t
+ss_addrbits(const struct sockaddr *sa)
+{
+	switch (sa->sa_family) {
+	case AF_INET:
+		return (IP_ABITS);
+	case AF_INET6:
+		return (IPV6_ABITS);
+	default:
+		INVALID(sa->sa_family);
+		/*NOTREACHED*/
+		return (0);
+	}
+}
+
+static const char *log_keys[] = {
+	LOG_KEY_ERRMSG,
+	LOG_KEY_ERRNO,
+	LOG_KEY_FILE,
+	LOG_KEY_FUNC,
+	LOG_KEY_LINE,
+	LOG_KEY_I2SA,
+	LOG_KEY_LADDR,
+	LOG_KEY_RADDR,
+	LOG_KEY_LSPI,
+	LOG_KEY_RSPI,
+	LOG_KEY_INITIATOR,
+	LOG_KEY_REQ,
+	LOG_KEY_RESP,
+	LOG_KEY_VERSION,
+	LOG_KEY_MSGID,
+	LOG_KEY_EXCHTYPE,
+	LOG_KEY_LOCAL_ID,
+	LOG_KEY_LOCAL_ID_TYPE,
+	LOG_KEY_REMOTE_ID,
+	LOG_KEY_REMOTE_ID_TYPE,
+};
+
+void
+log_reset_keys(void)
+{
+	for (size_t i = 0; i < ARRAY_SIZE(log_keys); i++)
+		(void) bunyan_key_remove(log, log_keys[i]);
+}
+
+void
+key_add_ike_spi(const char *name, uint64_t spi)
+{
+	char buf[19] = { 0 };	/* 0x + 64bit hex + NUL */
+
+	if (spi != 0)
+		(void) snprintf(buf, sizeof (buf), "0x%016" PRIX64, spi);
+	else
+		(void) strlcpy(buf, "0x0", sizeof (buf));
+
+	(void) bunyan_key_add(log, BUNYAN_T_STRING, name, buf, BUNYAN_T_END);
+}
+
+void
+key_add_id(const char *name, const char *typename, config_id_t *id)
+{
+	bunyan_type_t btype = BUNYAN_T_END;
+
+	switch (id->cid_type) {
+	case CFG_AUTH_ID_DNS:
+	case CFG_AUTH_ID_EMAIL:
+		btype = BUNYAN_T_STRING;
+		break;
+	case CFG_AUTH_ID_IPV4:
+	case CFG_AUTH_ID_IPV4_PREFIX:
+	case CFG_AUTH_ID_IPV4_RANGE:
+		btype = BUNYAN_T_IP;
+		break;
+	case CFG_AUTH_ID_IPV6:
+	case CFG_AUTH_ID_IPV6_PREFIX:
+	case CFG_AUTH_ID_IPV6_RANGE:
+		btype = BUNYAN_T_IP6;
+		break;
+	case CFG_AUTH_ID_DN:
+	case CFG_AUTH_ID_GN:
+		/*NOTYET*/
+		INVALID(id->cid_type);
+		break;
+	}
+
+	(void) bunyan_key_add(log,
+	    BUNYAN_T_STRING, typename, config_id_type_str(id->cid_type),
+	    btype, name, id->cid_data,
+	    BUNYAN_T_END);
+}
+
+void
+key_add_addr(const char *name, const struct sockaddr *addr)
+{
+	const void *ptr = NULL;
+	int af = addr->sa_family;
+	uint32_t port = 0;
+	char addrbuf[INET6_ADDRSTRLEN];
+
+	ptr = ss_addr(addr);
+	port = ss_port(addr);
+
+	if (inet_ntop(af, ptr, addrbuf, sizeof (addrbuf)) == NULL)
+		return;
+
+	if (port == 0) {
+		(void) bunyan_key_add(log,
+		    BUNYAN_T_STRING, name, addrbuf, BUNYAN_T_END);
+		return;
+	}
+
+	/* address + [ + ] + / + 16-bit port */
+	char buf[INET6_ADDRSTRLEN + 8];
+
+	switch (af) {
+	case AF_INET:
+		(void) snprintf(buf, sizeof (buf), "%s:%" PRIu32, addrbuf,
+		    port);
+		break;
+	case AF_INET6:
+		(void) snprintf(buf, sizeof (buf), "[%s]:%" PRIu32, addrbuf,
+		    port);
+		break;
+	default:
+		INVALID(af);
+	}
+
+	(void) bunyan_key_add(log, BUNYAN_T_STRING, name, buf, BUNYAN_T_END);
+}
+
+void
+key_add_ike_version(const char *name, uint8_t version)
+{
+	char buf[6] = { 0 }; /* NN.NN + NUL */
+
+	(void) snprintf(buf, sizeof (buf), "%hhu.%hhu", IKE_GET_MAJORV(version),
+	    IKE_GET_MINORV(version));
+	(void) bunyan_key_add(log, BUNYAN_T_STRING, name, buf, BUNYAN_T_END);
+}
+
+char *
+writehex(uint8_t *data, size_t datalen, char *sep, char *buf, size_t buflen)
+{
+	if (datalen == 0) {
+		if (buflen > 0)
+			buf[0] = '\0';
+		return (buf);
+	}
+
+	size_t seplen = 0;
+	size_t total = 0;
+
+	if (sep == NULL)
+		sep = "";
+	else
+		seplen = strlen(sep);
+
+	for (size_t i = 0; i < datalen; i++) {
+		size_t len = (i > 0) ? seplen + 2 : 2;
+
+		/*
+		 * Check if next byte (w/ separator) will fit to prevent
+		 * partial writing of byte
+		 */
+		if (len + 1 > buflen)
+			break;
+
+		total += snprintf(buf + total, buflen - total, "%s%02hhx",
+		    (i > 0) ? sep : "", data[i]);
+	}
+
+	return (buf);
+}
+
+void
+sockaddr_copy(const struct sockaddr *src, struct sockaddr_storage *dst,
+    boolean_t copy_port)
+{
+	bcopy(src, dst, sizeof (*src));
+
+	/* Take advantage of port being at the same offset */
+	if (!copy_port)
+		((struct sockaddr_in *)dst)->sin_port = 0;
+}
+
+/*
+ * Compare two addresses.  NOTE: This only looks at the af + address, and
+ * does NOT look at the port.
+ */
+int
+sockaddr_cmp(const struct sockaddr *l, const struct sockaddr *r)
+{
+	const uint8_t *lp = ss_addr(l);
+	const uint8_t *rp = ss_addr(r);
+	size_t addrlen = ss_addrlen(l);
+	int cmp = 0;
+
+	if (l->sa_family < r->sa_family)
+		return (-1);
+	if (l->sa_family > r->sa_family)
+		return (1);
+
+	return (memcmp(lp, rp, addrlen));
+}
+
+boolean_t
+addr_is_zero(const struct sockaddr *addr)
+{
+	const uint8_t *p = ss_addr(addr);
+	size_t len = ss_addrlen(addr);
+
+	for (size_t i = 0; i < len; i++) {
+		if (p[i] != 0)
+			return (B_FALSE);
+	}
+
+	if (ss_port(addr) != 0)
+		return (B_FALSE);
+
+	return (B_TRUE);
+}
+
+/* XXX: Might these (possibly renamed) be better moved to libumem? */
+char *
+ustrdup(const char *src, int umflag)
+{
+	size_t len = strlen(src) + 1;
+	char *str = umem_alloc(len, umflag);
+
+	if (str != NULL)
+		(void) strlcpy(str, src, len);
+
+	return (str);
+}
+
+void
+ustrfree(char *str)
+{
+	if (str == NULL)
+		return;
+
+	size_t len = strlen(str) + 1;
+
+	umem_free(str, len);
+}
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/worker.c b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/worker.c
new file mode 100644
index 0000000000..addd93cc5c
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/worker.c
@@ -0,0 +1,505 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017 Joyent, Inc.
+ */
+
+#include <bunyan.h>
+#include <err.h>
+#include <errno.h>
+#include <libperiodic.h>
+#include <port.h>
+#include <string.h>
+#include <synch.h>
+#include <sys/debug.h>
+#include <sys/list.h>
+#include <thread.h>
+#include <time.h>
+#include <umem.h>
+#include "defs.h"
+#include "ikev2_proto.h"
+#include "ikev2_sa.h"
+#include "pkcs11.h"
+#include "pkt.h"
+#include "worker.h"
+
+/*
+ * Virtually all work in in.ikev2d is done via a pool of worker threads.
+ * Each worker in the worker pool has an event loop that broadly waits for
+ * an event to arrive on the event port, gets it, and processes the event.
+ * Events can be things like inbound IKE/ISAKMP datagrams, SADB messages
+ * from our pfkey socket, timer events, or administrative requests.
+ *
+ * Each worker thread has a number of items allocated for it during thread
+ * creation (the members of worker_t).  These items are things that for
+ * debugging purposes, or things where we don't want to worry about allocation
+ * failures during processing (such as a PKCS#11 session handle).
+ */
+
+/* The state of the worker pool */
+typedef enum worker_state {
+	WS_NORMAL = 0,
+	WS_SUSPENDING,
+	WS_SUSPENDED,
+	WS_RESUMING,
+	WS_QUITTING,
+} worker_state_t;
+
+typedef enum worker_alert {
+	WA_NONE,
+	WA_SUSPEND,
+} worker_alert_t;
+
+/* Our per-worker thread items */
+__thread worker_t *worker = NULL;
+
+int wk_evport = -1;
+size_t wk_nworkers = 0;
+periodic_handle_t *wk_periodic = NULL;
+
+/*
+ * worker_lock protects access to workers, worker_state- and wk_nsuspended.
+ *
+ * NOTE: workers itself is largely a diagnostic construct to make it easier to
+ * see the per-worker values of things in worker_t.  Once a worker_t has been
+ * assigned to a worker thread, no other threads should access the values of
+ * another thread's worker_t.
+ */
+static mutex_t worker_lock = ERRORCHECKMUTEX;
+static cond_t worker_cv = DEFAULTCV; /* used to coordinate suspend/resume */
+static list_t workers;
+/* Global state of all workers */
+static worker_state_t worker_state;
+static volatile uint_t wk_nsuspended;
+
+static worker_t *worker_new(void);
+static void worker_free(worker_t *);
+static void *worker_main(void *);
+static const char *worker_cmd_str(worker_cmd_t);
+
+static void do_alert(int, void *);
+static void do_user(int, void *);
+
+/*
+ * Create a pool of worker threads with the given number of threads.
+ */
+void
+worker_init(size_t n)
+{
+	if ((wk_evport = port_create()) == -1)
+		err(EXIT_FAILURE, "port_create() failed");
+
+	wk_periodic = periodic_init(wk_evport, NULL, CLOCK_MONOTONIC);
+	if (wk_periodic == NULL)
+		err(EXIT_FAILURE, "could not create periodic");
+
+	mutex_enter(&worker_lock);
+	list_create(&workers, sizeof (worker_t), offsetof (worker_t, w_node));
+	mutex_exit(&worker_lock);
+
+	for (size_t i = 0; i < n; i++) {
+		if (!worker_add())
+			err(EXIT_FAILURE, "Unable to create workers");
+	}
+
+	(void) bunyan_trace(log, "Worker threads created",
+	    BUNYAN_T_UINT32, "numworkers", (uint32_t)wk_nworkers,
+	    BUNYAN_T_END);
+}
+
+boolean_t
+worker_add(void)
+{
+	worker_t *w = NULL;
+	int rc;
+
+	VERIFY(!IS_WORKER);
+
+	/*
+	 * Lock out any other global activity until after the add has
+	 * succeeded or failed.
+	 */
+	mutex_enter(&worker_lock);
+	while (worker_state != WS_NORMAL && worker_state != WS_QUITTING)
+		VERIFY0(cond_wait(&worker_cv, &worker_lock));
+
+	/* If we're shutting down, don't bother creating the worker */
+	if (worker_state == WS_QUITTING)
+		goto fail;
+
+	if ((w = umem_zalloc(sizeof (worker_t), UMEM_DEFAULT)) == NULL)
+		goto fail;
+
+	if (bunyan_child(main_log, &w->w_log, BUNYAN_T_END) != 0)
+		goto fail;
+
+	if ((w->w_p11 = pkcs11_new_session()) == CK_INVALID_HANDLE)
+		goto fail;
+
+again:
+	rc = thr_create(NULL, 0, worker_main, w, 0, &w->w_tid);
+	switch (rc) {
+	case 0:
+		break;
+	case EAGAIN:
+		goto again;
+	case ENOMEM:
+		TSTDERR(rc, warn, "No memory to create worker");
+		goto fail;
+	default:
+		TSTDERR(rc, fatal, "Cannot create additional worker thread");
+		abort();
+	}
+
+	list_insert_tail(&workers, w);
+	VERIFY0(cond_broadcast(&worker_cv));
+	wk_nworkers++;
+	mutex_exit(&worker_lock);
+
+	return (B_TRUE);
+
+fail:
+	worker_free(w);
+	mutex_enter(&worker_lock);
+	VERIFY0(cond_broadcast(&worker_cv));
+	mutex_exit(&worker_lock);
+	return (B_FALSE);
+}
+
+static void
+worker_free(worker_t *w)
+{
+	if (w == NULL)
+		return;
+
+	if (w->w_log != NULL)
+		bunyan_fini(w->w_log);
+
+	pkcs11_session_free(w->w_p11);
+	umem_free(w, sizeof (*w));
+}
+
+/*
+ * Pause all the workers.  The current planned use is when we need to resize
+ * the IKE SA hashes -- it's far simpler to make sure all the workers are
+ * quiesced and rearrange things then restart.
+ */
+void
+worker_suspend(void)
+{
+	/*
+	 * We currently do not support workers suspending all the workers.
+	 * This must be called from a non-worker thread such as the main thread.
+	 */
+	VERIFY(!IS_WORKER);
+
+	mutex_enter(&worker_lock);
+
+again:
+	switch (worker_state) {
+	case WS_NORMAL:
+		break;
+	/* No point in suspending if we are quitting */
+	case WS_QUITTING:
+	/*
+	 * Ignore additional attempts to suspend if already in progress or
+	 * already suspended.
+	 */
+	case WS_SUSPENDING:
+	case WS_SUSPENDED:
+		mutex_exit(&worker_lock);
+		return;
+	/* If we're resuming, wait until it's finished and retry */
+	case WS_RESUMING:
+		cond_wait(&worker_cv, &worker_lock);
+		goto again;
+	}
+
+	VERIFY(MUTEX_HELD(&worker_lock));
+
+	worker_state = WS_SUSPENDING;
+	(void) bunyan_debug(log, "Suspending workers", BUNYAN_T_END);
+
+	if (port_alert(wk_evport, PORT_ALERT_SET, WA_SUSPEND, NULL) == -1) {
+		/*
+		 * While EBUSY (alert mode already set) can in some instances
+		 * not be a fatal error, we never intentionally try set a port
+		 * into alert mode once it is already there.  If we encounter
+		 * that, something has gone wrong, so treat it as a fatal
+		 * condition.
+		 */
+		STDERR(fatal, "port_alert() failed");
+		abort();
+	}
+
+	while (wk_nsuspended != wk_nworkers)
+		VERIFY0(cond_wait(&worker_cv, &worker_lock));
+
+	worker_state = WS_SUSPENDED;
+
+	if (port_alert(wk_evport, PORT_ALERT_SET, WC_NONE, NULL) == -1) {
+		STDERR(fatal, "port_alert() failed");
+		abort();
+	}
+
+	VERIFY0(cond_broadcast(&worker_cv));
+	mutex_exit(&worker_lock);
+
+	(void) bunyan_trace(log, "Finished suspending workers", BUNYAN_T_END);
+}
+
+static void
+worker_do_suspend(worker_t *w)
+{
+	VERIFY(IS_WORKER);
+
+	(void) bunyan_debug(log, "Worker suspending", BUNYAN_T_END);
+
+	mutex_enter(&worker_lock);
+	if (++wk_nsuspended == wk_nworkers) {
+		(void) bunyan_trace(log, "Last one in, signaling",
+		    BUNYAN_T_END);
+		VERIFY0(cond_broadcast(&worker_cv));
+	}
+	mutex_exit(&worker_lock);
+
+	mutex_enter(&worker_lock);
+	while (worker_state != WS_RESUMING)
+		VERIFY0(cond_wait(&worker_cv, &worker_lock));
+
+	VERIFY3U(wk_nsuspended, >, 0);
+	if (--wk_nsuspended == 0)
+		VERIFY0(cond_broadcast(&worker_cv));
+
+	mutex_exit(&worker_lock);
+
+	(void) bunyan_debug(log, "Worker resuming", BUNYAN_T_END);
+}
+
+void
+worker_resume(void)
+{
+	/* Similar to worker_suspend(), can not be called from a worker */
+	VERIFY(!IS_WORKER);
+
+	mutex_enter(&worker_lock);
+
+again:
+	switch (worker_state) {
+	case WS_NORMAL:
+	case WS_RESUMING:
+	case WS_QUITTING:
+		mutex_exit(&worker_lock);
+		return;
+	case WS_SUSPENDING:
+		VERIFY0(cond_wait(&worker_cv, &worker_lock));
+		goto again;
+	case WS_SUSPENDED:
+		break;
+	}
+
+	(void) bunyan_debug(log, "Resuming workers", BUNYAN_T_END);
+
+	worker_state = WS_RESUMING;
+
+	while (wk_nsuspended > 0)
+		VERIFY0(cond_wait(&worker_cv, &worker_lock));
+
+	worker_state = WS_NORMAL;
+	VERIFY0(cond_broadcast(&worker_cv));
+	mutex_exit(&worker_lock);
+
+	(void) bunyan_trace(log, "Finished resuming workers", BUNYAN_T_END);
+}
+
+static void *
+worker_main(void *arg)
+{
+	worker_t *w = arg;
+
+	worker = w;
+	log = w->w_log;
+
+	(void) bunyan_trace(log, "Worker starting", BUNYAN_T_END);
+
+	while (!w->w_quit) {
+		port_event_t pe = { 0 };
+
+		log_reset_keys();
+
+		if (port_get(wk_evport, &pe, NULL) == -1) {
+			if (errno == EINTR) {
+				/*
+				 * This should not happen, but if it does,
+				 * we can just ignore it, but at least make note
+				 * of it.
+				 */
+				(void) bunyan_warn(log,
+				    "port_get() failed with EINTR",
+				    BUNYAN_T_END);
+				continue;
+			}
+
+			STDERR(fatal, "port_get() failed");
+			abort();
+		}
+
+		(void) bunyan_trace(log, "Received event",
+		    BUNYAN_T_INT32, "evport", (int32_t)wk_evport,
+		    BUNYAN_T_STRING, "source",
+		    port_source_str(pe.portev_source),
+		    BUNYAN_T_INT32, "events", (int32_t)pe.portev_events,
+		    BUNYAN_T_UINT64, "object", (uint64_t)pe.portev_object,
+		    BUNYAN_T_POINTER, "cookie", pe.portev_user,
+		    BUNYAN_T_END);
+
+		switch (pe.portev_source) {
+		case PORT_SOURCE_TIMER:
+			periodic_fire(wk_periodic);
+			continue;
+		case PORT_SOURCE_FD: {
+			char buf[20] = { 0 };
+
+			void (*fn)(int) = (void (*)(int))pe.portev_user;
+			int fd = (int)pe.portev_object;
+
+			(void) bunyan_trace(log,
+			    "Dispatching fd event to handler",
+			    BUNYAN_T_INT32, "fd", (int32_t)fd,
+			    BUNYAN_T_STRING, "handler",
+			    symstr(fn, buf, sizeof (buf)),
+			    BUNYAN_T_END);
+
+			fn(fd);
+			continue;
+		}
+		case PORT_SOURCE_USER:
+			do_user(pe.portev_events, pe.portev_user);
+			continue;
+		case PORT_SOURCE_ALERT:
+			do_alert(pe.portev_events, pe.portev_user);
+			continue;
+		}
+	}
+
+	mutex_enter(&worker_lock);
+	list_remove(&workers, w);
+	wk_nworkers--;
+	VERIFY0(cond_broadcast(&worker_cv));
+	mutex_exit(&worker_lock);
+
+	worker = NULL;
+	worker_free(w);
+	return (NULL);
+}
+
+static void
+do_alert(int events, void *user)
+{
+	NOTE(ARGUNUSED(user))
+
+	VERIFY(IS_WORKER);
+
+	switch ((worker_alert_t)events) {
+	case WA_NONE:
+		return;
+	case WA_SUSPEND:
+		worker_do_suspend(worker);
+		return;
+	}
+}
+
+static void
+do_user(int events, void *user)
+{
+	VERIFY(IS_WORKER);
+
+	ikev2_sa_t *sa = user;
+
+	(void) bunyan_trace(log, "Received user event",
+	    BUNYAN_T_STRING, "event", worker_cmd_str(events),
+	    BUNYAN_T_POINTER, "arg", user,
+	    BUNYAN_T_END);
+
+	switch((worker_cmd_t)events) {
+	case WC_NONE:
+		return;
+	case WC_QUIT:
+		/*
+		 * Unless we are shutting down, must always have at least
+		 * one worker running.
+		 */
+		mutex_enter(&worker_lock);
+		if (worker_state == WS_QUITTING || wk_nworkers > 1)
+			worker->w_quit = B_TRUE;
+		mutex_exit(&worker_lock);
+		return;
+	case WC_PFKEY:
+		ikev2_pfkey(user);
+		return;
+	case WC_START:
+		ikev2_sa_init_cfg(user);
+		return;
+	}
+}
+
+boolean_t
+worker_send_cmd(worker_cmd_t cmd, void *arg)
+{
+again:
+	if (port_send(wk_evport, (int)cmd, arg) == 0)
+		return (B_TRUE);
+
+	switch (errno) {
+	case EAGAIN:
+		/* This shouldn't happen, but if it does, we can try again */
+		STDERR(warn, "port_send() failed with EAGAIN",
+		    BUNYAN_T_STRING, "cmd", worker_cmd_str(cmd),
+		    BUNYAN_T_POINTER, "arg", arg);
+		goto again;
+	case ENOMEM:
+		STDERR(warn, "Out of memory trying to send command",
+		    BUNYAN_T_STRING, "cmd", worker_cmd_str(cmd),
+		    BUNYAN_T_POINTER, "arg", arg);
+		break;
+	default:
+		STDERR(fatal,
+		    "Unexpected error trying to send command",
+		    BUNYAN_T_STRING, "cmd", worker_cmd_str(cmd),
+		    BUNYAN_T_POINTER, "arg", arg);
+		abort();
+	}
+
+	return (B_FALSE);
+}
+
+boolean_t
+worker_del(void)
+{
+	return (worker_send_cmd(WC_QUIT, NULL));
+}
+
+#define	STR(x) case x: return (#x)
+static const char *
+worker_cmd_str(worker_cmd_t wc)
+{
+	switch (wc) {
+	STR(WC_NONE);
+	STR(WC_QUIT);
+	STR(WC_START);
+	STR(WC_PFKEY);
+	}
+
+	INVALID(wc);
+	return (NULL);
+}
+#undef STR
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/worker.h b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/worker.h
new file mode 100644
index 0000000000..ba53161255
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/worker.h
@@ -0,0 +1,75 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2017 Joyent, Inc.
+ */
+
+#ifndef _WORKER_H
+#define	_WORKER_H
+
+#include <inttypes.h>
+#include <thread.h>
+#include <security/cryptoki.h>
+#include <sys/list.h>
+#include "pkt.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct bunyan_logger;
+struct periodic_handle;
+
+typedef enum worker_cmd {
+	WC_NONE = 0,
+	WC_QUIT,
+	WC_PFKEY,
+	WC_START,
+} worker_cmd_t;
+
+typedef struct worker {
+	list_node_t		w_node;
+	thread_t		w_tid;
+	struct bunyan_logger	*w_log;
+	CK_SESSION_HANDLE	w_p11;
+	boolean_t		w_quit;
+				/*
+				 * We create a per-worker buffer for inbound
+				 * datagrams so we are always guaranteed we
+				 * can receive the datagram and drain it
+				 * from the kernel's queue and if we're lucky
+				 * be able to log information about it, even
+				 * if we have to discard it due to allocation
+				 * failures.
+				 */
+	uint64_t		w_buf[SADB_8TO64(MAX_PACKET_SIZE)];
+} worker_t;
+
+extern __thread worker_t *worker;
+#define	IS_WORKER	(worker != NULL)
+
+extern struct periodic_handle *wk_periodic;
+extern size_t wk_nworkers;
+extern int wk_evport;
+
+void worker_init(size_t);
+void worker_suspend(void);
+void worker_resume(void);
+boolean_t worker_add(void);
+boolean_t worker_del(void);
+boolean_t worker_send_cmd(worker_cmd_t, void *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _WORKER_H */
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/i386/Makefile b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/i386/Makefile
new file mode 100644
index 0000000000..55f47cd939
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/i386/Makefile
@@ -0,0 +1,29 @@
+#
+# CDDL HEADER START
+#
+# The contents of this file are subject to the terms of the
+# Common Development and Distribution License (the "License").
+# You may not use this file except in compliance with the License.
+#
+# You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+# or http://www.opensolaris.org/os/licensing.
+# See the License for the specific language governing permissions
+# and limitations under the License.
+#
+# When distributing Covered Code, include this CDDL HEADER in each
+# file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+# If applicable, add the following below this CDDL HEADER, with the
+# fields enclosed by brackets "[]" replaced with your own identifying
+# information: Portions Copyright [yyyy] [name of copyright owner]
+#
+# CDDL HEADER END
+#
+
+#
+# Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
+# Use is subject to license terms.
+#
+
+include ../Makefile.com
+
+install: all $(ROOTLIBINETPROG32)
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/sparcv9/Makefile b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/sparcv9/Makefile
new file mode 100644
index 0000000000..930b865dd8
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/sparcv9/Makefile
@@ -0,0 +1,30 @@
+#
+# CDDL HEADER START
+#
+# The contents of this file are subject to the terms of the
+# Common Development and Distribution License (the "License").
+# You may not use this file except in compliance with the License.
+#
+# You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+# or http://www.opensolaris.org/os/licensing.
+# See the License for the specific language governing permissions
+# and limitations under the License.
+#
+# When distributing Covered Code, include this CDDL HEADER in each
+# file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+# If applicable, add the following below this CDDL HEADER, with the
+# fields enclosed by brackets "[]" replaced with your own identifying
+# information: Portions Copyright [yyyy] [name of copyright owner]
+#
+# CDDL HEADER END
+#
+
+#
+# Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
+# Use is subject to license terms.
+#
+
+include ../Makefile.com
+include ../../../../Makefile.cmd.64
+
+install: all $(ROOTLIBINETPROG64)
diff --git a/usr/src/lib/libipsecutil/common/ikedoor.h b/usr/src/lib/libipsecutil/common/ikedoor.h
index 95e71012d7..108a9d77d2 100644
--- a/usr/src/lib/libipsecutil/common/ikedoor.h
+++ b/usr/src/lib/libipsecutil/common/ikedoor.h
@@ -33,6 +33,7 @@ extern "C" {
 #include <sys/sysmacros.h>
 #include <net/pfkeyv2.h>
 #include <door.h>
+#include <sys/socket.h>
 
 /*
  * This version number is intended to stop the calling process from
diff --git a/usr/src/lib/libipsecutil/common/ipsec_util.h b/usr/src/lib/libipsecutil/common/ipsec_util.h
index 44154e5c33..271ebe7cbc 100644
--- a/usr/src/lib/libipsecutil/common/ipsec_util.h
+++ b/usr/src/lib/libipsecutil/common/ipsec_util.h
@@ -458,6 +458,9 @@ extern void ipsec_convert_bslabel_to_hex(bslabel_t *, char **);
 #define	EXIT_BADPERM2(x, y) \
 	ipsecutil_exit(SERVICE_BADPERM, my_fmri, debugfile, \
 	dgettext(TEXT_DOMAIN, x), y)
+#define	EXIT_BADPERM3(x, y, z) \
+	ipsecutil_exit(SERVICE_BADPERM, my_fmri, debugfile, \
+	dgettext(TEXT_DOMAIN, x), y, z)
 #define	EXIT_FATAL(x) \
 	ipsecutil_exit(SERVICE_FATAL, my_fmri, debugfile, \
 	dgettext(TEXT_DOMAIN, x))
@@ -467,6 +470,9 @@ extern void ipsec_convert_bslabel_to_hex(bslabel_t *, char **);
 #define	EXIT_FATAL3(x, y, z) \
 	ipsecutil_exit(SERVICE_FATAL, my_fmri, debugfile, \
 	dgettext(TEXT_DOMAIN, x), y, z)
+#define	EXIT_FATAL4(x, y, z, z2) \
+	ipsecutil_exit(SERVICE_FATAL, my_fmri, debugfile, \
+	dgettext(TEXT_DOMAIN, x), y, z, z2)
 #define	EXIT_RESTART(x) \
 	ipsecutil_exit(SERVICE_RESTART, my_fmri, debugfile, \
 	dgettext(TEXT_DOMAIN, x))
