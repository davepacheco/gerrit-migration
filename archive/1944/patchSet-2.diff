From 1f75eaffe8900b0dee3f22104dcc383b9d5b87f2 Mon Sep 17 00:00:00 2001
From: Cody Peter Mello <cody.mello@joyent.com>
Date: Thu, 4 May 2017 22:04:41 +0000
Subject: [PATCH] NAPI-403 Allow creating network pools whose networks vary in
 "nic_tag" values

---
 docs/index.md                          |   5 +
 lib/models/network-pool.js             |  35 ++--
 lib/models/network.js                  |  15 ++
 lib/models/nic/common.js               |  11 +
 lib/models/nic/create.js               |   1 +
 lib/models/nic/provision.js            |  98 ++++++++-
 lib/models/nic/update.js               |   1 +
 lib/util/constants.js                  |   7 +-
 lib/util/errors.js                     |  20 ++
 lib/util/intersect.js                  | 116 ++++++++++
 test/integration/network-owner.test.js |   1 +
 test/integration/network-pools.test.js |   3 +
 test/unit/network-owner.test.js        |   1 +
 test/unit/network-pools.test.js        | 280 ++++++++++++++++++++-----
 test/unit/util-intersect.js            | 256 ++++++++++++++++++++++
 15 files changed, 765 insertions(+), 85 deletions(-)
 create mode 100644 lib/util/intersect.js
 create mode 100644 test/unit/util-intersect.js

diff --git a/docs/index.md b/docs/index.md
index 75cb481..9115732 100644
--- a/docs/index.md
+++ b/docs/index.md
@@ -1269,6 +1269,7 @@ if it matches *all* of the input parameters.
         "uuid": "3b5913ec-42e6-4803-9c0b-c9b1c5603520",
         "name": "internal networks",
         "nic_tag": "internal",
+        "nic_tags_present": [ "internal" ],
         "family": "ipv4",
         "networks": [
           "0e70de36-a40b-4ac0-9429-819f5ff822bd",
@@ -1280,6 +1281,7 @@ if it matches *all* of the input parameters.
         "name": "external v6 networks",
         "description": "Logical pool of public IPv6 addresses",
         "nic_tag": "external",
+        "nic_tags_present": [ "external" ],
         "family": "ipv6",
         "networks": [
           "57a83e2b-527c-41c1-983c-be9b792011dc",
@@ -1318,6 +1320,7 @@ Creates a new logical network provisioning pool.
       "uuid": "3b5913ec-42e6-4803-9c0b-c9b1c5603520",
       "name": "internal networks",
       "nic_tag": "internal",
+      "nic_tags_present": [ "internal" ],
       "family": "ipv4",
       "networks": [
         "0e70de36-a40b-4ac0-9429-819f5ff822bd",
@@ -1337,6 +1340,7 @@ Gets a logical network provisioning pool by UUID.
       "uuid": "3b5913ec-42e6-4803-9c0b-c9b1c5603520",
       "name": "internal networks",
       "nic_tag": "internal",
+      "nic_tags_present": [ "internal" ],
       "family": "ipv4",
       "networks": [
         "0e70de36-a40b-4ac0-9429-819f5ff822bd",
@@ -1368,6 +1372,7 @@ Must specify at least one of:
       "uuid": "3b5913ec-42e6-4803-9c0b-c9b1c5603520",
       "name": "internal-pool",
       "nic_tag": "internal",
+      "nic_tags_present": [ "internal" ],
       "family": "ipv4",
       "networks": [
         "0e70de36-a40b-4ac0-9429-819f5ff822bd",
diff --git a/lib/models/network-pool.js b/lib/models/network-pool.js
index f1c37f9..fe81c23 100644
--- a/lib/models/network-pool.js
+++ b/lib/models/network-pool.js
@@ -209,8 +209,6 @@ function validateNetworks(opts, name, value, callback) {
 function _validateNetworks(opts, name, uuids, callback) {
     var nets = [];
     var notFound = [];
-    var tag;
-    var tagsNotMatching = [];
     var pool_family;
     var poolTypeNotMatching = [];
     var validated = [];
@@ -256,16 +254,6 @@ function _validateNetworks(opts, name, uuids, callback) {
                     return;
                 }
 
-                if (tag === undefined) {
-                    tag = net.nic_tag;
-                }
-
-                if (net.nic_tag !== tag) {
-                    tagsNotMatching.push(uuid);
-                    cb();
-                    return;
-                }
-
                 if (pool_family === undefined) {
                     pool_family = net.family;
                 }
@@ -296,12 +284,6 @@ function _validateNetworks(opts, name, uuids, callback) {
             return;
         }
 
-        if (tagsNotMatching.length !== 0) {
-            callback(errors.invalidParam(name,
-                constants.POOL_TAGS_MATCH_MSG));
-            return;
-        }
-
         if (poolTypeNotMatching.length !== 0) {
             callback(errors.invalidParam(name,
                 constants.POOL_AF_MATCH_MSG));
@@ -371,7 +353,13 @@ function NetworkPool(params) {
     if (params._networks && util.isArray(params._networks) &&
         params._networks.length !== 0) {
         params.family = params._networks[0].family;
-        params.nic_tag = params._networks[0].params.nic_tag;
+        params.nic_tags_present = [];
+        params._networks.forEach(function (network) {
+            var nic_tag = network.nic_tag;
+            if (params.nic_tags_present.indexOf(nic_tag) === -1) {
+                params.nic_tags_present.push(nic_tag);
+            }
+        });
     }
 
     mod_moray.valToArray(params, 'owner_uuids');
@@ -394,6 +382,10 @@ Object.defineProperty(NetworkPool.prototype, 'networks', {
     get: function () { return this.params.networks.sort(); }
 });
 
+Object.defineProperty(NetworkPool.prototype, '_networks', {
+    get: function () { return this.params._networks; }
+});
+
 Object.defineProperty(NetworkPool.prototype, 'family', {
     get: function () {
         if (this.params.family !== undefined) {
@@ -459,8 +451,9 @@ NetworkPool.prototype.serialize = function poolSerialize() {
         networks: this.params.networks.sort()
     };
 
-    if (this.params.hasOwnProperty('nic_tag')) {
-        ser.nic_tag = this.params.nic_tag;
+    if (this.params.hasOwnProperty('nic_tags_present')) {
+        ser.nic_tag = this.params.nic_tags_present[0];
+        ser.nic_tags_present = this.params.nic_tags_present;
     }
 
     if (this.params.owner_uuids) {
diff --git a/lib/models/network.js b/lib/models/network.js
index a0115dd..e12cbb9 100644
--- a/lib/models/network.js
+++ b/lib/models/network.js
@@ -1349,6 +1349,21 @@ Network.prototype.isOwner = function networkHasOwner(owner) {
 };
 
 
+/**
+ * Check that the properties of this network match under one of the
+ * intersections from a network pool.
+ */
+Network.prototype.matches = function matchesIntersection(intersection) {
+    for (var prop in intersection) {
+        if (this[prop] !== intersection[prop]) {
+            return false;
+        }
+    }
+
+    return true;
+};
+
+
 
 // --- Exported functions
 
diff --git a/lib/models/nic/common.js b/lib/models/nic/common.js
index a56beb7..40da038 100644
--- a/lib/models/nic/common.js
+++ b/lib/models/nic/common.js
@@ -23,6 +23,7 @@ var mod_nicTag = require('../nic-tag');
 var mod_pool = require('../network-pool');
 var mod_portolan_moray = require('portolan-moray');
 var util = require('util');
+var util_intersect = require('../../util/intersect');
 var validate = require('../../util/validate');
 
 
@@ -304,6 +305,16 @@ function validateNetworkParams(opts, _, parsedParams, callback) {
         }
     }
 
+    if (parsedParams.network_pool) {
+        try {
+            parsedParams.intersections = util_intersect.pools('network_uuid',
+                parsedParams, [ parsedParams.network_pool ]);
+        } catch (e) {
+            callback(e);
+            return;
+        }
+    }
+
     if (!parsedParams.ip) {
         callback();
         return;
diff --git a/lib/models/nic/create.js b/lib/models/nic/create.js
index 1ec5d40..d028100 100644
--- a/lib/models/nic/create.js
+++ b/lib/models/nic/create.js
@@ -46,6 +46,7 @@ var CREATE_SCHEMA = {
         model: validate.string,
         network_uuid: common.validateIPv4Network,
         nic_tag: common.validateNicTag,
+        nic_tags_available: mod_nicTag.validateExists.bind(null, false),
         nic_tags_provided: mod_nicTag.validateExists.bind(null, false),
         primary: validate.bool,
         reserved: validate.bool,
diff --git a/lib/models/nic/provision.js b/lib/models/nic/provision.js
index a352a60..8997561 100644
--- a/lib/models/nic/provision.js
+++ b/lib/models/nic/provision.js
@@ -112,6 +112,19 @@ function Provisioner() {
 }
 
 
+/**
+ * Intersections are only used when provisioning an adress on a network pool.
+ * This base method is only used by non-pool provisioning strategies and is
+ * effectively a no-op, but we do take the opportunity to assert that the
+ * network is valid with the intersection.
+ */
+Provisioner.prototype.setIntersection =
+    function validIntersection(intersection) {
+    assert.ok(this.network, 'network selected');
+    assert.ok(this.network.matches(intersection), 'valid under intersection');
+};
+
+
 /**
  * Grab the next available IP address on the currently selected network.
  *
@@ -242,7 +255,9 @@ function NetworkPoolProvision(pool, field) {
 
     this.ip = null;
     this.network = null;
-    this.networks = pool.params._networks.slice();
+    this.networks = null;
+    this.intersection = null;
+
     this.pool = pool;
     this.field = field;
 
@@ -251,25 +266,43 @@ function NetworkPoolProvision(pool, field) {
 util.inherits(NetworkPoolProvision, Provisioner);
 
 
+/**
+ * Reset the Provisioner to use a new subset of the networks.
+ */
+NetworkPoolProvision.prototype.setIntersection =
+    function setNewIntersection(intersection) {
+    this.ip = null;
+    this.network = null;
+    this.networks = null;
+    this.intersection = intersection;
+};
+
+
+
 /**
  * Move on to the next network pool, and provision an IP from it.
  */
 NetworkPoolProvision.prototype.nextNetwork =
     function nextNetworkPool(opts, callback) {
-    var next = this.networks.shift();
-    if (!next) {
-        var fullErr = new errors.InvalidParamsError('Invalid parameters',
-            [ errors.invalidParam(this.field,
-                constants.POOL_FULL_MSG) ]);
-        fullErr.stop = true;
-        callback(fullErr);
+    var self = this;
+
+    if (self.networks === null) {
+        assert.object(self.intersection, 'intersection set');
+        self.networks = self.pool._networks.filter(function (network) {
+            return network.matches(self.intersection);
+        });
+        assert.ok(self.networks.length > 0, 'networks available');
+    } else if (self.networks.length === 0) {
+        callback(new errors.PoolFullError(self.field, self.pool.uuid));
         return;
     }
 
+    var next = self.networks.shift();
+
     opts.log.debug({ nextUUID: next.uuid }, 'Trying next network in pool');
 
-    this.network = next;
-    this.fetchNextIP(opts, true, callback);
+    self.network = next;
+    self.fetchNextIP(opts, true, callback);
 };
 
 
@@ -507,6 +540,16 @@ function listVnetCns(opts, callback) {
 }
 
 
+/**
+ * Reset the chosen intersection for every Provisioner.
+ */
+function resetIntersections(provisioners, intersection) {
+    provisioners.forEach(function (provisioner) {
+        provisioner.setIntersection(intersection);
+    });
+}
+
+
 /**
  * Run all of the IP Provisioners for this NIC provision.
  */
@@ -515,8 +558,41 @@ function runProvisions(opts, callback) {
     assert.array(opts.provisioners, 'opts.provisioners');
     assert.func(callback, 'callback');
 
+    var provisioners = opts.provisioners;
+    var intersections = opts.validated.intersections;
+
+    /*
+     * If any intersections are present and we haven't yet selected one, then
+     * initialize the Provisioners to use the first one.
+     */
+    if (intersections && !opts.intersection) {
+        assert.ok(intersections.length > 0, 'have intersections');
+        opts.intersection = intersections.shift();
+        resetIntersections(provisioners, opts.intersection);
+    }
+
+    /*
+     * If a pool is full, grab the next intersection and update everyone to
+     * use it. If there are none left, there's nothing more we can do, so we
+     * abort the provision attempt.
+     */
+    if (opts.err instanceof errors.PoolFullError) {
+        opts.intersection = intersections.shift();
+        if (!opts.intersection) {
+            opts.err.stop = true;
+            callback(opts.err);
+            return;
+        }
+        resetIntersections(provisioners, opts.intersection);
+    }
+
+    /*
+     * By this point, all of the Provisioners should be ready to attempt to
+     * select an address. We run each one until each has either selected an
+     * address, or we hit an error.
+     */
     vasync.forEachPipeline({
-        inputs: opts.provisioners,
+        inputs: provisioners,
         func: function (provisioner, cb) {
             provisioner.provision(opts, cb);
         }
diff --git a/lib/models/nic/update.js b/lib/models/nic/update.js
index fb088e4..928d644 100644
--- a/lib/models/nic/update.js
+++ b/lib/models/nic/update.js
@@ -79,6 +79,7 @@ var UPDATE_SCHEMA = {
         model: validate.string,
         network_uuid: common.validateIPv4Network,
         nic_tag: common.validateNicTag,
+        nic_tags_available: mod_nicTag.validateExists.bind(null, false),
         nic_tags_provided: mod_nicTag.validateExists.bind(null, false),
         primary: validate.bool,
         reserved: validate.bool,
diff --git a/lib/util/constants.js b/lib/util/constants.js
index bd5884e..2fe9836 100644
--- a/lib/util/constants.js
+++ b/lib/util/constants.js
@@ -37,6 +37,8 @@ var MESSAGES = {
     NET_ON_VLAN: 'VLAN must have no networks',
     NIC_ON_NET: 'network must have no NICs provisioned',
     NIC_TAG_SLASH: 'only one slash is allowed after the tag name',
+    NO_POOL_INTERSECTION: 'Specified pools do not contain networks ' +
+        'that can be used together',
     OBJ: 'must be an object',
     OFFSET: 'invalid value, offset must be an integer greater than or ' +
         'equal to 0',
@@ -73,6 +75,10 @@ var FORMAT_MESSAGES = {
     IP_MULTI: 'Multiple (overlapping) networks (%s) matching this nic_tag ' +
         'and vlan_id contain the IP address %s',
     NET_BAD_AF: 'The network UUID is valid, but its address family must be %s',
+    POOL_FAILS_CONSTRAINTS: 'No networks in network pool %s match ' +
+        'provisioning constraints',
+    POOL_FULL_MSG: 'All networks in pool %s are full',
+    POOL_NIC_TAGS_AMBIGUOUS: 'Network pool %s has mixed nic_tag values',
     NIC_TAGS_DIFFER: 'The nic_tag of all specified IPv4 and IPv6 networks ' +
         'must match (have "%s" and "%s")',
     VLAN_IDS_DIFFER: 'The vlan_id of all specified IPv4 and IPv6 networks ' +
@@ -153,7 +159,6 @@ module.exports = {
     MTU_NICTAG_UPDATE_MSG: 'nic_tag mtu update must support existing networks',
     NIC_PROVISION_RETRIES: 100,
     OWNER_MATCH_MSG: 'network owner_uuids do not match',
-    POOL_FULL_MSG: 'all networks in pool are full',
     POOL_IP_MSG: 'IP cannot be specified with a network pool',
     POOL_MIN_NETS_MSG:
         'network pool must contain at least one network',
diff --git a/lib/util/errors.js b/lib/util/errors.js
index 5606fed..0fa6fd0 100644
--- a/lib/util/errors.js
+++ b/lib/util/errors.js
@@ -136,6 +136,25 @@ function SubnetFullError(network_uuid) {
 util.inherits(SubnetFullError, restify.RestError);
 
 
+/**
+ * Base error class for when all networks in a pool are full.
+ */
+function PoolFullError(field, pool_uuid) {
+    assert.string(field, 'field');
+    assert.uuid(pool_uuid, 'network_uuid');
+
+    var msg = util.format(constants.fmt.POOL_FULL_MSG, pool_uuid);
+    InvalidParamsError.call(this, 'Invalid parameters',
+        [ invalidParam(field, msg) ]);
+
+    this.pool_uuid = pool_uuid;
+
+    // "stop" gets updated to true once all intersections are exhausted.
+    this.stop = false;
+}
+
+util.inherits(PoolFullError, InvalidParamsError);
+
 
 // --- Functions for building elements in a response's errors array
 
@@ -300,6 +319,7 @@ module.exports = {
     msg: MSG,
     networkOverlapParams: networkOverlapParams,
     nictagMtuInvalidForNetworks: nictagMtuInvalidForNetworks,
+    PoolFullError: PoolFullError,
     SubnetFullError: SubnetFullError,
     unknownParams: unknownParams,
     usedBy: usedBy,
diff --git a/lib/util/intersect.js b/lib/util/intersect.js
new file mode 100644
index 0000000..852bb86
--- /dev/null
+++ b/lib/util/intersect.js
@@ -0,0 +1,116 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2017, Joyent, Inc.
+ */
+
+/*
+ * Code for finding the intersection of network parameters in network pools
+ * during provisioning.
+ */
+
+'use strict';
+
+var assert = require('assert-plus');
+var constants = require('./constants');
+var errors = require('./errors');
+var jsprim = require('jsprim');
+var util = require('util');
+
+
+// --- Exports
+
+function getPoolIntersections(name, params, pools) {
+    assert.string(name, 'name');
+    assert.object(params, 'params');
+    assert.array(pools, 'pools');
+
+    var missing_nictags = !(params.nic_tag || params.nic_tags_available);
+
+    var constraints = [];
+
+    pools.forEach(function (pool) {
+        var options = {};
+
+        if (missing_nictags && pool.params.nic_tags_present.length > 1) {
+            throw errors.missingParam('nic_tags_available',
+                util.format(constants.fmt.POOL_NIC_TAGS_AMBIGUOUS, pool.uuid));
+        }
+
+        pool._networks.forEach(function (network) {
+            if (params.nic_tag !== undefined &&
+                params.nic_tag !== network.nic_tag) {
+                return;
+            }
+
+            if (params.nic_tags_available !== undefined &&
+                params.nic_tags_available.indexOf(network.nic_tag) === -1) {
+                return;
+            }
+
+            if (params.mtu !== undefined && params.mtu !== network.mtu) {
+                return;
+            }
+
+            if (params.vlan_id !== undefined &&
+                params.vlan_id !== network.vlan_id) {
+                return;
+            }
+
+            if (params.vnet_id !== undefined &&
+                params.vnet_id !== network.vnet_id) {
+                return;
+            }
+
+            var key =
+                network.nic_tag + '/' +
+                network.mtu + '/' +
+                network.vlan_id + '/' +
+                network.vnet_id;
+
+            options[key] = {
+                mtu: network.mtu,
+                nic_tag: network.nic_tag,
+                vlan_id: network.vlan_id,
+                vnet_id: network.vnet_id
+            };
+        });
+
+        if (jsprim.isEmpty(options)) {
+            throw errors.invalidParam(name,
+                util.format(constants.fmt.POOL_FAILS_CONSTRAINTS, pool.uuid));
+        }
+
+        constraints.push(options);
+    });
+
+    var result = constraints.shift();
+
+    constraints.forEach(function (constraint) {
+        var suggestions = Object.keys(result);
+        suggestions.forEach(function (suggestion) {
+            if (!constraint.hasOwnProperty(suggestion)) {
+                delete result[suggestion];
+            }
+        });
+    });
+
+    if (jsprim.isEmpty(result)) {
+        throw errors.invalidParam(name, constants.msg.NO_POOL_INTERSECTION);
+    }
+
+    var okay = [];
+    for (var k in result) {
+        okay.push(result[k]);
+    }
+    return okay;
+}
+
+
+module.exports = {
+    pools: getPoolIntersections
+};
diff --git a/test/integration/network-owner.test.js b/test/integration/network-owner.test.js
index 15dbb84..5956190 100644
--- a/test/integration/network-owner.test.js
+++ b/test/integration/network-owner.test.js
@@ -101,6 +101,7 @@ function createNetworkPool(t, name, type, params) {
         params.networks.sort();
         params.uuid = res.uuid;
         params.nic_tag = state.nicTag.name;
+        params.nic_tags_present = [ state.nicTag.name ];
         params.family = type;
 
         t.deepEqual(res, params, 'network pool ' + name);
diff --git a/test/integration/network-pools.test.js b/test/integration/network-pools.test.js
index 8d0f371..e690891 100644
--- a/test/integration/network-pools.test.js
+++ b/test/integration/network-pools.test.js
@@ -96,6 +96,7 @@ test('POST /network_pools', function (t) {
             exp: {
                 family: 'ipv4',
                 networks: [ state.network.uuid ].sort(),
+                nic_tags_present: [ state.network.nic_tag ],
                 nic_tag: state.network.nic_tag
             },
             state: state
@@ -111,6 +112,7 @@ test('POST /network_pools', function (t) {
             exp: {
                 family: 'ipv4',
                 networks: [ state.network.uuid, state.network2.uuid ].sort(),
+                nic_tags_present: [ state.network.nic_tag ],
                 nic_tag: state.network.nic_tag
             },
             state: state
@@ -152,6 +154,7 @@ test('PUT /network_pools/:uuid', function (t) {
 
         params.uuid = state.pools[0].uuid;
         params.nic_tag = state.network.nic_tag;
+        params.nic_tags_present = [ state.network.nic_tag ];
         params.family = 'ipv4';
         t.deepEqual(res, params, 'update params');
 
diff --git a/test/unit/network-owner.test.js b/test/unit/network-owner.test.js
index 514dffc..cd8d19a 100644
--- a/test/unit/network-owner.test.js
+++ b/test/unit/network-owner.test.js
@@ -268,6 +268,7 @@ function createPool(name, params, type, t) {
         params.uuid = res.uuid;
         params.name = name;
         params.nic_tag = netParams.nic_tag;
+        params.nic_tags_present = [ netParams.nic_tag ];
         params.family = type;
         t.deepEqual(res, params, 'result');
         pools.push(res);
diff --git a/test/unit/network-pools.test.js b/test/unit/network-pools.test.js
index 21be0e2..93bb58e 100644
--- a/test/unit/network-pools.test.js
+++ b/test/unit/network-pools.test.js
@@ -42,6 +42,9 @@ var NAPI;
 var NETS = [];
 var POOLS = [];
 
+var NIC_TAG1 = 'nictag1p' + process.pid;
+var NIC_TAG2 = 'nictag2p' + process.pid;
+var NIC_TAG3 = 'nictag3p' + process.pid;
 
 
 // --- Internal helpers
@@ -58,6 +61,7 @@ function netParams(extra) {
 
     var params = {
         name: 'net' + l,
+        nic_tag: NIC_TAG1,
         subnet: util.format('10.0.%d.0/28', l),
         provision_end_ip: util.format('10.0.%d.12', l),
         provision_start_ip: util.format('10.0.%d.9', l),
@@ -83,6 +87,7 @@ function v6netParams(extra) {
 
     var params = {
         name: 'net' + l,
+        nic_tag: NIC_TAG1,
         // Ensure the networks sort in order of creation:
         uuid: util.format('%d%d%d%d7862-54fa-4667-89ae-c981cd5ada9a',
             l, l, l, l)
@@ -102,12 +107,14 @@ function createNet(t, extra) {
     }
 
     NAPI.createNetwork(netParams(extra), function (err, res) {
-        t.ifErr(err);
-        if (res) {
-            NETS.push(res);
+        if (h.ifErr(t, err, 'createNetwork() error')) {
+            t.end();
+            return;
         }
 
-        return t.end();
+        NETS.push(res);
+
+        t.end();
     });
 }
 
@@ -137,18 +144,21 @@ test('Initial setup', function (t) {
             provision_start_ip: '10.0.0.2',
             provision_end_ip: '10.0.0.5'
         });
-        var otherTag = 'othertag' + process.pid;
 
         t.test('delete previous', function (t2) {
             mod_pool.delAll(t2, {});
         });
 
         t.test('create nic tag 1', function (t2) {
-            mod_tag.create(t2, { name: net1Params.nic_tag });
+            mod_tag.create(t2, { name: NIC_TAG1 });
         });
 
-        t.test('create other nic tag', function (t2) {
-            mod_tag.create(t2, { name: otherTag });
+        t.test('create nic tag 2', function (t2) {
+            mod_tag.create(t2, { name: NIC_TAG2 });
+        });
+
+        t.test('create nic tag 3', function (t2) {
+            mod_tag.create(t2, { name: NIC_TAG3 });
         });
 
         t.test('create net0', function (t2) {
@@ -171,7 +181,7 @@ test('Initial setup', function (t) {
         });
 
         t.test('create net3', function (t2) {
-            createNet(t2, { nic_tag: otherTag });
+            createNet(t2, { nic_tag: NIC_TAG2 });
         });
 
         t.test('create net4', function (t2) {
@@ -204,6 +214,10 @@ test('Initial setup', function (t) {
             });
         });
 
+        t.test('create net8', function (t2) {
+            createNet(t2);
+        });
+
         t.test('create pool1', function (t2) {
             var name = 'pool1-' + process.pid;
             var params = {
@@ -217,8 +231,9 @@ test('Initial setup', function (t) {
                     params.name = name;
                     params.uuid = res2.uuid;
                     params.nic_tag = NETS[0].nic_tag;
+                    params.nic_tags_present = [ NETS[0].nic_tag ];
                     params.family = 'ipv4';
-                    t2.deepEqual(res2, params, 'result');
+                    t2.deepEqual(res2, params, 'result for ' + res2.uuid);
                 }
 
                 t2.ifErr(err2);
@@ -239,8 +254,9 @@ test('Initial setup', function (t) {
                     params.name = name;
                     params.uuid = res2.uuid;
                     params.nic_tag = NETS[4].nic_tag;
+                    params.nic_tags_present = [ NETS[4].nic_tag ];
                     params.family = 'ipv4';
-                    t2.deepEqual(res2, params, 'result');
+                    t2.deepEqual(res2, params, 'result for ' + res2.uuid);
                 }
 
                 t2.ifErr(err2);
@@ -261,8 +277,9 @@ test('Initial setup', function (t) {
                     params.name = name;
                     params.uuid = res2.uuid;
                     params.nic_tag = NETS[6].nic_tag;
+                    params.nic_tags_present = [ NETS[6].nic_tag ];
                     params.family = 'ipv6';
-                    t2.deepEqual(res2, params, 'result');
+                    t2.deepEqual(res2, params, 'result for ' + res2.uuid);
                 }
 
                 t2.ifErr(err2);
@@ -282,8 +299,33 @@ test('Initial setup', function (t) {
                     params.name = name;
                     params.uuid = res2.uuid;
                     params.nic_tag = NETS[0].nic_tag;
+                    params.nic_tags_present = [ NETS[0].nic_tag ];
+                    params.family = 'ipv4';
+                    t2.deepEqual(res2, params, 'result for ' + res2.uuid);
+                }
+
+                t2.ifErr(err2);
+                t2.end();
+            });
+        });
+
+
+        t.test('create pool5', function (t2) {
+            var name = 'pool5-' + process.pid;
+            var params = {
+                networks: [ NETS[3].uuid, NETS[8].uuid ]
+            };
+
+            NAPI.createNetworkPool(name, params, function (err2, res2) {
+                if (res2) {
+                    POOLS.push(res2);
+                    params.name = name;
+                    params.uuid = res2.uuid;
+                    params.nic_tag = NETS[3].nic_tag;
+                    params.nic_tags_present =
+                        [ NETS[3].nic_tag, NETS[8].nic_tag ];
                     params.family = 'ipv4';
-                    t2.deepEqual(res2, params, 'result');
+                    t2.deepEqual(res2, params, 'result for ' + res2.uuid);
                 }
 
                 t2.ifErr(err2);
@@ -291,6 +333,31 @@ test('Initial setup', function (t) {
             });
         });
 
+
+        t.test('create pool6', function (t2) {
+            var name = 'pool6-' + process.pid;
+            var params = {
+                networks: [ NETS[0].uuid, NETS[3].uuid ]
+            };
+
+            NAPI.createNetworkPool(name, params, function (err2, res2) {
+                if (res2) {
+                    POOLS.push(res2);
+                    params.name = name;
+                    params.uuid = res2.uuid;
+                    params.nic_tag = NETS[0].nic_tag;
+                    params.nic_tags_present =
+                        [ NETS[0].nic_tag, NETS[3].nic_tag ];
+                    params.family = 'ipv4';
+                    t2.deepEqual(res2, params, 'result for ' + res2.uuid);
+                }
+
+                t2.ifErr(err2);
+                t2.end();
+            });
+        });
+
+
         t.end();
     });
 });
@@ -351,29 +418,6 @@ test('Create pool - too many networks', function (t) {
 });
 
 
-test('Create pool - mismatched nic tags', function (t) {
-    var params = {
-        networks: [ NETS[0].uuid, NETS[3].uuid ]
-    };
-
-    NAPI.createNetworkPool('pool-fail-2-' + process.pid, params,
-        function (err, res) {
-        t.ok(err, 'error returned');
-        if (!err) {
-            return t.end();
-        }
-
-        t.equal(err.statusCode, 422, 'status code');
-        t.deepEqual(err.body, h.invalidParamErr({
-            errors: [ mod_err.invalidParam('networks',
-                constants.POOL_TAGS_MATCH_MSG) ]
-        }), 'error body');
-
-        return t.end();
-    });
-});
-
-
 test('Create pool - invalid params (non-objects)', function (t) {
     vasync.forEachParallel({
         inputs: h.NON_OBJECT_PARAMS,
@@ -762,7 +806,7 @@ test('provisionable_by network pools: owner', function (t) {
 
     t.test('create network', function (t2) {
         owners = [ mod_uuid.v4(), mod_uuid.v4() ];
-        var params = h.validNetworkParams({
+        var params = netParams({
             owner_uuids: [ owners[0] ]
         });
 
@@ -850,7 +894,14 @@ test('List pools - filter for "ipv4" pools', function (t) {
             family: 'ipv4'
         },
         deepEqual: true,
-        present: [ POOLS[0], POOLS[1], POOLS[3], POOLS[4] ]
+        present: [
+            POOLS[0],
+            POOLS[1],
+            POOLS[3],
+            POOLS[4],
+            POOLS[5],
+            POOLS[6]
+        ]
     });
 });
 
@@ -909,13 +960,17 @@ test('List pools - single network filter', function (t) {
     });
 });
 
-test('List pools - filter with two networks', function (t) {
+test('List pools - filter returns multiple networks', function (t) {
     mod_pool.list(t, {
         params: {
             networks: [ POOLS[3].networks[0] ]
         },
         deepEqual: true,
-        present: [ POOLS[0], POOLS[3] ]
+        present: [
+            POOLS[0],
+            POOLS[3],
+            POOLS[5]
+        ]
     });
 });
 
@@ -1028,19 +1083,14 @@ test('Provision nic - on network pool', function (t) {
             owner_uuid: mod_uuid.v4()
         };
 
-        NAPI.provisionNic(POOLS[0].uuid, params, function (err, res) {
-            t.ok(err);
-            if (!err) {
-                return t.end();
-            }
-
-            t.equal(err.statusCode, 422, 'status code');
-            t.deepEqual(err.body, h.invalidParamErr({
+        mod_nic.provision(t, {
+            net: POOLS[0].uuid,
+            params: params,
+            expCode: 422,
+            expErr: h.invalidParamErr({
                 errors: [ mod_err.invalidParam('network_uuid',
-                                    constants.POOL_FULL_MSG) ]
-            }), 'error body');
-
-            return t.end();
+                    util.format(constants.fmt.POOL_FULL_MSG, POOLS[0].uuid)) ]
+            })
         });
     });
 });
@@ -1092,6 +1142,132 @@ test('Provision NIC on pool: Retry after QueryTimeoutErrors', function (t) {
 });
 
 
+test('Provision NIC on pool: pool has multiple NIC tags', function (t) {
+    t.test('Provision with "nic_tags_available"', function (t2) {
+        var params = {
+            belongs_to_type: 'zone',
+            belongs_to_uuid: mod_uuid.v4(),
+            owner_uuid: mod_uuid.v4(),
+            nic_tags_available: [ NIC_TAG1, NIC_TAG3 ]
+        };
+
+        mod_nic.provision(t2, {
+            net: POOLS[4].uuid,
+            params: params,
+            partialExp: mod_net.addNetParams(NETS[8], {
+                belongs_to_type: 'zone',
+                belongs_to_uuid: params.belongs_to_uuid,
+                owner_uuid: params.owner_uuid,
+                ip: h.nextProvisionableIP(NETS[8])
+            })
+        });
+    });
+
+    t.test('Provision with "nic_tags_available"', function (t2) {
+        var params = {
+            belongs_to_type: 'zone',
+            belongs_to_uuid: mod_uuid.v4(),
+            owner_uuid: mod_uuid.v4(),
+            nic_tags_available: [ NIC_TAG2, NIC_TAG3 ]
+        };
+
+        mod_nic.provision(t2, {
+            net: POOLS[4].uuid,
+            params: params,
+            partialExp: mod_net.addNetParams(NETS[3], {
+                belongs_to_type: 'zone',
+                belongs_to_uuid: params.belongs_to_uuid,
+                owner_uuid: params.owner_uuid,
+                ip: h.nextProvisionableIP(NETS[3])
+            })
+        });
+    });
+
+    t.test('Provision with "nic_tag"', function (t2) {
+        var params = {
+            belongs_to_type: 'zone',
+            belongs_to_uuid: mod_uuid.v4(),
+            owner_uuid: mod_uuid.v4(),
+            nic_tag: NIC_TAG2
+        };
+
+        mod_nic.provision(t2, {
+            net: POOLS[4].uuid,
+            params: params,
+            partialExp: mod_net.addNetParams(NETS[3], {
+                belongs_to_type: 'zone',
+                belongs_to_uuid: params.belongs_to_uuid,
+                owner_uuid: params.owner_uuid,
+                ip: h.nextProvisionableIP(NETS[3])
+            })
+        });
+    });
+
+    t.test('Provision with no nic_tag hints', function (t2) {
+        var params = {
+            belongs_to_type: 'zone',
+            belongs_to_uuid: mod_uuid.v4(),
+            owner_uuid: mod_uuid.v4()
+        };
+
+        mod_nic.provision(t2, {
+            net: POOLS[4].uuid,
+            params: params,
+            expCode: 422,
+            expErr: h.missingParamErr({
+                errors: [ h.missingParam('nic_tags_available',
+                    util.format(constants.fmt.POOL_NIC_TAGS_AMBIGUOUS,
+                        POOLS[4].uuid)) ]
+            })
+        });
+    });
+
+    t.test('Provision with no matching networks in pool', function (t2) {
+        var params = {
+            belongs_to_type: 'zone',
+            belongs_to_uuid: mod_uuid.v4(),
+            owner_uuid: mod_uuid.v4(),
+            nic_tags_available: [ NIC_TAG3 ]
+        };
+
+        mod_nic.provision(t2, {
+            net: POOLS[4].uuid,
+            params: params,
+            expCode: 422,
+            expErr: h.invalidParamErr({
+                errors: [ mod_err.invalidParam('network_uuid',
+                    util.format(constants.fmt.POOL_FAILS_CONSTRAINTS,
+                        POOLS[4].uuid)) ]
+            })
+        });
+    });
+});
+
+
+test('Provision NIC on pool: First intersection fails', function (t) {
+    var params = {
+        belongs_to_type: 'zone',
+        belongs_to_uuid: mod_uuid.v4(),
+        owner_uuid: mod_uuid.v4(),
+        nic_tags_available: POOLS[5].nic_tags_present
+    };
+
+    /*
+     * NETS[0] was exhausted earlier, so provisioning on it will fail, and
+     * we'll end up provisioning onto NETS[3] instead.
+     */
+    mod_nic.provision(t, {
+        net: POOLS[5].uuid,
+        params: params,
+        partialExp: mod_net.addNetParams(NETS[3], {
+            belongs_to_type: 'zone',
+            belongs_to_uuid: params.belongs_to_uuid,
+            owner_uuid: params.owner_uuid,
+            ip: h.nextProvisionableIP(NETS[3])
+        })
+    });
+});
+
 
 
 // --- Delete tests
diff --git a/test/unit/util-intersect.js b/test/unit/util-intersect.js
new file mode 100644
index 0000000..8e418f5
--- /dev/null
+++ b/test/unit/util-intersect.js
@@ -0,0 +1,256 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2017, Joyent, Inc.
+ */
+
+'use strict';
+
+var constants = require('../../lib/util/constants');
+var errors = require('../../lib/util/errors');
+var mod_uuid = require('node-uuid');
+var test = require('tape');
+var util = require('util');
+var util_intersect = require('../../lib/util/intersect');
+
+
+// --- Globals
+
+function mkNet(nic_tag, vlan_id, vnet_id, mtu) {
+    return {
+        mtu: mtu,
+        nic_tag: nic_tag,
+        vlan_id: vlan_id,
+        vnet_id: vnet_id
+    };
+}
+
+function mkPool(networks) {
+    var nic_tags = [];
+    networks.forEach(function (network) {
+        var nic_tag = network.nic_tag;
+        if (nic_tags.indexOf(nic_tag) === -1) {
+            nic_tags.push(nic_tag);
+        }
+    });
+
+    return {
+        uuid: mod_uuid.v4(),
+        _networks: networks,
+        params: {
+            nic_tags_present: nic_tags
+        }
+    };
+}
+
+var a_0 = mkNet('a', 0);
+var a_1 = mkNet('a', 1);
+var b_0 = mkNet('b', 0);
+var b_1 = mkNet('b', 1);
+var b_0_1 = mkNet('b', 0, 1);
+var c_2 = mkNet('c', 2, undefined, 9000);
+var c_3_200 = mkNet('c', 3, 200);
+var c_4 = mkNet('c', 4);
+var c_5_1234 = mkNet('c', 5, 1234);
+var q_60_8000 = mkNet('q', 60, 8000);
+
+// --- Internal helpers
+
+
+function mixedError(pool) {
+    return errors.missingParam('nic_tags_available',
+        util.format(constants.fmt.POOL_NIC_TAGS_AMBIGUOUS, pool.uuid));
+}
+
+function testInvalid(t, filter, pools, exp) {
+    try {
+        util_intersect.pools('addresses_updates', filter, pools);
+        t.fail('Expected intersection calculation to fail');
+    } catch (e) {
+        t.deepEqual(e, exp, 'proper error thrown');
+    }
+}
+
+// --- Tests
+
+test('single pool', function (t) {
+    var setA = [ a_0, a_1, b_0, c_2 ];
+    var input = [
+        mkPool(setA)
+    ];
+
+    t.deepEqual(util_intersect.pools('addresses_updates',
+        { vlan_id: 0, nic_tags_available: [ 'a', 'b' ] },
+        input), [ a_0, b_0 ], 'nic_tags_available=[a,b] filter');
+
+    t.deepEqual(util_intersect.pools('addresses_updates',
+        { nic_tags_available: [ 'a', 'c' ] },
+        input), [ a_0, a_1, c_2 ], 'nic_tags_available=[a,c] filter');
+
+    t.deepEqual(util_intersect.pools('addresses_updates',
+        { nic_tags_available: [ 'a', 'd' ] },
+        input), [ a_0, a_1 ], 'nic_tags_available=[a,d] filter');
+
+    t.deepEqual(util_intersect.pools('addresses_updates', { nic_tag: 'a' },
+        input), [ a_0, a_1 ], 'vlan_id=0 filter');
+
+    t.deepEqual(util_intersect.pools('addresses_updates',
+        { nic_tag: 'a', vlan_id: 0 },
+        input), [ a_0 ], 'nic_tag=a, vlan_id=0 filter');
+
+    t.end();
+});
+
+
+test('two pools', function (t) {
+    var setA = [ a_0, a_1, b_0, b_1, q_60_8000 ];
+    var setB = [ a_1, c_2, a_0, c_3_200, q_60_8000 ];
+    var input = [
+        mkPool(setA),
+        mkPool(setB)
+    ];
+
+    testInvalid(t, {}, input, mixedError(input[0]));
+
+    testInvalid(t, { vlan_id: 0 }, input, mixedError(input[0]));
+
+    testInvalid(t, { vnet_id: 8000 }, input, mixedError(input[0]));
+
+    t.deepEqual(util_intersect.pools('addresses_updates', { nic_tag: 'a' },
+        input), [ a_0, a_1 ], 'nic_tag=a filter');
+
+    t.deepEqual(util_intersect.pools('addresses_updates', { nic_tag: 'q' },
+        input), [ q_60_8000 ], 'nic_tag=q filter');
+
+    t.deepEqual(util_intersect.pools('addresses_updates',
+        { nic_tags_available: [ 'q', 'a' ] },
+        input), [ a_0, a_1, q_60_8000 ], 'nic_tags_available=[q,a] filter');
+
+    t.deepEqual(util_intersect.pools('addresses_updates',
+        { nic_tags_available: [ 'a', 'b' ] },
+        input), [ a_0, a_1 ], 'nic_tags_available=[a,b] filter');
+
+    t.deepEqual(util_intersect.pools('addresses_updates',
+        { nic_tag: 'a', vlan_id: 0 },
+        input), [ a_0 ], 'nic_tag=a, vlan_id=0 filter');
+
+    t.end();
+});
+
+
+test('five pools', function (t) {
+    var setA = [ a_0, c_2, c_3_200 ];
+    var setB = [ b_0_1, c_2, c_3_200, a_0 ];
+    var setC = [ b_0_1, c_2, a_0, b_0_1 ];
+    var setD = [ a_1, b_0_1, c_2, a_0 ];
+    var setE = [ q_60_8000, c_2, a_0 ];
+    var input = [
+        mkPool(setA),
+        mkPool(setB),
+        mkPool(setC),
+        mkPool(setD),
+        mkPool(setE)
+    ];
+
+    testInvalid(t, {}, input, mixedError(input[0]));
+
+    testInvalid(t, { vlan_id: 0 }, input, mixedError(input[0]));
+
+    testInvalid(t, { vlan_id: 2 }, input, mixedError(input[0]));
+
+    t.deepEqual(util_intersect.pools('addresses_updates', { nic_tag: 'a' },
+        input), [ a_0 ], 'nic_tag=a filter');
+
+    t.deepEqual(util_intersect.pools('addresses_updates',
+        { nic_tags_available: [ 'a', 'c' ] },
+        input), [ a_0, c_2 ], 'nic_tags_available=[a,c] filter');
+
+    t.deepEqual(util_intersect.pools('addresses_updates',
+        { nic_tags_available: [ 'c' ] },
+        input), [ c_2 ], 'nic_tags_available=[c] filter');
+
+    t.deepEqual(util_intersect.pools('addresses_updates',
+        { nic_tags_available: [ 'c', 'q' ] },
+        input), [ c_2 ], 'nic_tags_available=[c,q] filter');
+
+    t.deepEqual(util_intersect.pools('addresses_updates', { nic_tag: 'c' },
+        input), [ c_2 ], 'nic_tag=c filter');
+
+    t.end();
+});
+
+
+test('missing nic_tag hints okay w/ homogenous pools', function (t) {
+    var setA = [ c_2, c_3_200, c_5_1234 ];
+    var setB = [ c_2, c_4, c_5_1234 ];
+    var setC = [ c_2, c_3_200, c_4, c_5_1234 ];
+    var setD = [ c_2, c_5_1234 ];
+    var input = [
+        mkPool(setA),
+        mkPool(setB),
+        mkPool(setC),
+        mkPool(setD)
+    ];
+
+    t.deepEqual(util_intersect.pools('addresses_updates', {}, input),
+        [ c_2, c_5_1234 ], 'no filter given');
+
+    t.deepEqual(util_intersect.pools('addresses_updates', { vlan_id: 2 },
+        input), [ c_2 ], 'vlan_id filter given');
+
+    t.deepEqual(util_intersect.pools('addresses_updates', { vlan_id: 5 },
+        input), [ c_5_1234 ], 'vlan_id filter given');
+
+    t.deepEqual(util_intersect.pools('addresses_updates', { vnet_id: 1234 },
+        input), [ c_5_1234 ], 'vnet_id filter given');
+
+    t.deepEqual(util_intersect.pools('addresses_updates', { mtu: 9000 },
+        input), [ c_2 ], 'mtu filter given');
+
+    t.end();
+});
+
+
+test('no intersection', function (t) {
+    // All of these have c_2 except for the last
+    var setA = [ c_2 ];
+    var setB = [ b_0_1, c_2, c_3_200, a_0 ];
+    var setC = [ b_0_1, c_2, a_0, b_0_1 ];
+    var setD = [ a_1, b_0_1, c_2, a_0 ];
+    var setE = [ q_60_8000 ];
+    var input = [
+        mkPool(setA),
+        mkPool(setB),
+        mkPool(setC),
+        mkPool(setD),
+        mkPool(setE)
+    ];
+
+    var all_tags = [ 'a', 'b', 'c', 'd', 'q' ];
+
+    var ambiguous = errors.missingParam('nic_tags_available',
+        util.format(constants.fmt.POOL_NIC_TAGS_AMBIGUOUS, input[1].uuid));
+
+    var constrained = errors.invalidParam('addresses_updates',
+        util.format(constants.fmt.POOL_FAILS_CONSTRAINTS, input[4].uuid));
+
+    testInvalid(t, {}, input, ambiguous);
+
+    testInvalid(t, { vlan_id: 2 }, input, ambiguous);
+
+    testInvalid(t, { nic_tags_available: all_tags }, input,
+        errors.invalidParam('addresses_updates',
+            constants.msg.NO_POOL_INTERSECTION));
+
+    testInvalid(t, { nic_tags_available: [ 'c' ] }, input,
+        constrained);
+
+    testInvalid(t, { vlan_id: 2, nic_tags_available: all_tags }, input,
+        constrained);
+
+    t.end();
+});
-- 
2.21.0

