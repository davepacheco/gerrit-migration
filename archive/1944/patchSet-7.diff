commit 6d628d76b49bb399eaa977fdadebc8cab00978e1 (refs/changes/44/1944/7)
Author: Cody Peter Mello <cody.mello@joyent.com>
Date:   2017-06-01T17:08:50+00:00 (2 years, 4 months ago)
    
    NAPI-403 Allow creating network pools whose networks vary in "nic_tag" values
    Reviewed by: Jason King <jason.king@joyent.com>
    Reviewed by: Richard Kiene <richard.kiene@joyent.com>
    Approved by: Richard Kiene <richard.kiene@joyent.com>

diff --git a/docs/index.md b/docs/index.md
index dfa0565..3ce0723 100644
--- a/docs/index.md
+++ b/docs/index.md
@@ -1276,6 +1276,7 @@ if it matches *all* of the input parameters.
         "uuid": "3b5913ec-42e6-4803-9c0b-c9b1c5603520",
         "name": "internal networks",
         "nic_tag": "internal",
+        "nic_tags_present": [ "internal" ],
         "family": "ipv4",
         "networks": [
           "0e70de36-a40b-4ac0-9429-819f5ff822bd",
@@ -1287,6 +1288,7 @@ if it matches *all* of the input parameters.
         "name": "external v6 networks",
         "description": "Logical pool of public IPv6 addresses",
         "nic_tag": "external",
+        "nic_tags_present": [ "external" ],
         "family": "ipv6",
         "networks": [
           "57a83e2b-527c-41c1-983c-be9b792011dc",
@@ -1325,6 +1327,7 @@ Creates a new logical network provisioning pool.
       "uuid": "3b5913ec-42e6-4803-9c0b-c9b1c5603520",
       "name": "internal networks",
       "nic_tag": "internal",
+      "nic_tags_present": [ "internal" ],
       "family": "ipv4",
       "networks": [
         "0e70de36-a40b-4ac0-9429-819f5ff822bd",
@@ -1344,6 +1347,7 @@ Gets a logical network provisioning pool by UUID.
       "uuid": "3b5913ec-42e6-4803-9c0b-c9b1c5603520",
       "name": "internal networks",
       "nic_tag": "internal",
+      "nic_tags_present": [ "internal" ],
       "family": "ipv4",
       "networks": [
         "0e70de36-a40b-4ac0-9429-819f5ff822bd",
@@ -1375,6 +1379,7 @@ Must specify at least one of:
       "uuid": "3b5913ec-42e6-4803-9c0b-c9b1c5603520",
       "name": "internal-pool",
       "nic_tag": "internal",
+      "nic_tags_present": [ "internal" ],
       "family": "ipv4",
       "networks": [
         "0e70de36-a40b-4ac0-9429-819f5ff822bd",
diff --git a/lib/models/network-pool.js b/lib/models/network-pool.js
index f1c37f9..8936520 100644
--- a/lib/models/network-pool.js
+++ b/lib/models/network-pool.js
@@ -209,8 +209,6 @@ function validateNetworks(opts, name, value, callback) {
 function _validateNetworks(opts, name, uuids, callback) {
     var nets = [];
     var notFound = [];
-    var tag;
-    var tagsNotMatching = [];
     var pool_family;
     var poolTypeNotMatching = [];
     var validated = [];
@@ -256,16 +254,6 @@ function _validateNetworks(opts, name, uuids, callback) {
                     return;
                 }
 
-                if (tag === undefined) {
-                    tag = net.nic_tag;
-                }
-
-                if (net.nic_tag !== tag) {
-                    tagsNotMatching.push(uuid);
-                    cb();
-                    return;
-                }
-
                 if (pool_family === undefined) {
                     pool_family = net.family;
                 }
@@ -296,19 +284,13 @@ function _validateNetworks(opts, name, uuids, callback) {
             return;
         }
 
-        if (tagsNotMatching.length !== 0) {
-            callback(errors.invalidParam(name,
-                constants.POOL_TAGS_MATCH_MSG));
-            return;
-        }
-
         if (poolTypeNotMatching.length !== 0) {
             callback(errors.invalidParam(name,
                 constants.POOL_AF_MATCH_MSG));
             return;
         }
 
-        var toReturn = { _networks: nets };
+        var toReturn = { _netobjs: nets };
         toReturn[name] = validated;
 
         callback(null, null, toReturn);
@@ -321,9 +303,9 @@ function _validateNetworks(opts, name, uuids, callback) {
  * match that owner_uuid or have no owner_uuid.
  */
 function validateNetworkOwners(_opts, _, parsed, callback) {
-    if (!parsed.owner_uuids || !parsed._networks ||
+    if (!parsed.owner_uuids || !parsed._netobjs ||
         parsed.owner_uuids.length === 0 ||
-        parsed._networks.length === 0) {
+        parsed._netobjs.length === 0) {
         callback();
         return;
     }
@@ -334,7 +316,7 @@ function validateNetworkOwners(_opts, _, parsed, callback) {
     });
 
     var notMatching = [];
-    parsed._networks.forEach(function (net) {
+    parsed._netobjs.forEach(function (net) {
         if (net.params.hasOwnProperty('owner_uuids')) {
             for (var o in net.params.owner_uuids) {
                 if (owners.hasOwnProperty(net.params.owner_uuids[o])) {
@@ -367,11 +349,26 @@ function validateNetworkOwners(_opts, _, parsed, callback) {
  * Network pool model constructor
  */
 function NetworkPool(params) {
+    assert.object(params, 'params');
+
     delete params.nic_tag;
-    if (params._networks && util.isArray(params._networks) &&
-        params._networks.length !== 0) {
-        params.family = params._networks[0].family;
-        params.nic_tag = params._networks[0].params.nic_tag;
+
+    /*
+     * If we're migrating the network pool objects in Moray after a bucket
+     * upgrade, then the "_netobjs" array won't be present. If we're
+     * responding to a request, then we'll have the networks, and can set
+     * fields based on that information.
+     */
+    if (params._netobjs && Array.isArray(params._netobjs) &&
+        params._netobjs.length !== 0) {
+        params.family = params._netobjs[0].family;
+        params.nic_tags_present = [];
+        params._netobjs.forEach(function (network) {
+            var nic_tag = network.nic_tag;
+            if (params.nic_tags_present.indexOf(nic_tag) === -1) {
+                params.nic_tags_present.push(nic_tag);
+            }
+        });
     }
 
     mod_moray.valToArray(params, 'owner_uuids');
@@ -391,7 +388,7 @@ function NetworkPool(params) {
 }
 
 Object.defineProperty(NetworkPool.prototype, 'networks', {
-    get: function () { return this.params.networks.sort(); }
+    get: function () { return this.params._netobjs; }
 });
 
 Object.defineProperty(NetworkPool.prototype, 'family', {
@@ -459,8 +456,14 @@ NetworkPool.prototype.serialize = function poolSerialize() {
         networks: this.params.networks.sort()
     };
 
-    if (this.params.hasOwnProperty('nic_tag')) {
-        ser.nic_tag = this.params.nic_tag;
+    if (this.params.hasOwnProperty('nic_tags_present')) {
+        ser.nic_tags_present = this.params.nic_tags_present;
+
+        /*
+         * Set a representative "nic_tag" to provide backwards
+         * compatibility with older NAPI consumers:
+         */
+        ser.nic_tag = this.params.nic_tags_present[0];
     }
 
     if (this.params.owner_uuids) {
@@ -546,7 +549,7 @@ function getNetworkPool(app, log, params, callback) {
                     return;
                 }
 
-                rec.value._networks = res;
+                rec.value._netobjs = res;
                 callback(null, new NetworkPool(rec.value));
             });
         });
@@ -625,7 +628,7 @@ function listNetworkPools(app, log, oparams, callback) {
 
                     getAllNetworks(app, log, nets, function (err, res) {
                         if (res) {
-                            val._networks = res;
+                            val._netobjs = res;
                         }
 
                         cb(err);
@@ -687,7 +690,7 @@ function updateNetworkPool(app, log, params, callback) {
             }
 
             var updatedParams = oldPool.raw();
-            updatedParams._networks = oldPool.params._networks;
+            updatedParams._netobjs = oldPool.params._netobjs;
 
             for (var p in validatedParams) {
                 updatedParams[p] = validatedParams[p];
diff --git a/lib/models/network.js b/lib/models/network.js
index a0115dd..a5a7d65 100644
--- a/lib/models/network.js
+++ b/lib/models/network.js
@@ -1138,6 +1138,10 @@ Object.defineProperty(Network.prototype, 'family', {
     get: function () { return this.params.subnet_type; }
 });
 
+Object.defineProperty(Network.prototype, 'mtu', {
+    get: function () { return this.params.mtu; }
+});
+
 Object.defineProperty(Network.prototype, 'uuid', {
     get: function () { return this.params.uuid; }
 });
@@ -1146,6 +1150,10 @@ Object.defineProperty(Network.prototype, 'vnet_id', {
     get: function () { return this.params.vnet_id; }
 });
 
+Object.defineProperty(Network.prototype, 'vlan_id', {
+    get: function () { return this.params.vlan_id; }
+});
+
 
 /**
  * Raw form suitable for adding to a moray batch
@@ -1349,6 +1357,28 @@ Network.prototype.isOwner = function networkHasOwner(owner) {
 };
 
 
+/**
+ * Check whether the properties of this network match under the given
+ * intersection. Fields that get checked are:
+ *
+ * - "mtu"
+ * - "nic_tag"
+ * - "vlan_id"
+ * - "vnet_id"
+ *
+ * See lib/util/intersect.js for more information.
+ */
+Network.prototype.matches = function matchesIntersection(intersection) {
+    for (var prop in intersection) {
+        if (this[prop] !== intersection[prop]) {
+            return false;
+        }
+    }
+
+    return true;
+};
+
+
 
 // --- Exported functions
 
diff --git a/lib/models/nic/common.js b/lib/models/nic/common.js
index a56beb7..71f4c7e 100644
--- a/lib/models/nic/common.js
+++ b/lib/models/nic/common.js
@@ -23,6 +23,7 @@ var mod_nicTag = require('../nic-tag');
 var mod_pool = require('../network-pool');
 var mod_portolan_moray = require('portolan-moray');
 var util = require('util');
+var util_intersect = require('../../util/intersect');
 var validate = require('../../util/validate');
 
 
@@ -32,6 +33,7 @@ var BUCKET = require('./bucket').BUCKET;
 var BELONGS_TO_TYPES = [ 'other', 'server', 'zone' ];
 var VALID_NIC_STATES = [ 'provisioning', 'stopped', 'running' ];
 
+var getPoolIntersections = util_intersect.getPoolIntersections;
 
 // --- Internal helpers
 
@@ -304,6 +306,16 @@ function validateNetworkParams(opts, _, parsedParams, callback) {
         }
     }
 
+    if (parsedParams.network_pool) {
+        try {
+            parsedParams.intersections = getPoolIntersections('network_uuid',
+                parsedParams, [ parsedParams.network_pool ]);
+        } catch (e) {
+            callback(e);
+            return;
+        }
+    }
+
     if (!parsedParams.ip) {
         callback();
         return;
diff --git a/lib/models/nic/create.js b/lib/models/nic/create.js
index b735655..67f0481 100644
--- a/lib/models/nic/create.js
+++ b/lib/models/nic/create.js
@@ -46,6 +46,7 @@ var CREATE_SCHEMA = {
         model: validate.string,
         network_uuid: common.validateIPv4Network,
         nic_tag: common.validateNicTag,
+        nic_tags_available: mod_nicTag.validateExists.bind(null, false),
         nic_tags_provided: mod_nicTag.validateExists.bind(null, false),
         primary: validate.bool,
         reserved: validate.bool,
diff --git a/lib/models/nic/provision.js b/lib/models/nic/provision.js
index 601f828..c211812 100644
--- a/lib/models/nic/provision.js
+++ b/lib/models/nic/provision.js
@@ -112,6 +112,22 @@ function Provisioner() {
 }
 
 
+/**
+ * Intersections are only used when provisioning an address on a network pool.
+ * This base method is only used by non-pool provisioning strategies and is
+ * effectively a no-op, but we do take the opportunity to assert that the
+ * network is valid with the intersection.
+ *
+ * See lib/util/intersect.js for more information on intersections and what
+ * fields are checked here.
+ */
+Provisioner.prototype.setIntersection =
+    function validIntersection(intersection) {
+    assert.ok(this.network, 'network selected');
+    assert.ok(this.network.matches(intersection), 'valid under intersection');
+};
+
+
 /**
  * Grab the next available IP address on the currently selected network.
  *
@@ -242,7 +258,9 @@ function NetworkPoolProvision(pool, field) {
 
     this.ip = null;
     this.network = null;
-    this.networks = pool.params._networks.slice();
+    this.networks = null;
+    this.intersection = null;
+
     this.pool = pool;
     this.field = field;
 
@@ -251,25 +269,43 @@ function NetworkPoolProvision(pool, field) {
 util.inherits(NetworkPoolProvision, Provisioner);
 
 
+/**
+ * Reset the Provisioner to use a new subset of the networks.
+ */
+NetworkPoolProvision.prototype.setIntersection =
+    function setNewIntersection(intersection) {
+    this.ip = null;
+    this.network = null;
+    this.networks = null;
+    this.intersection = intersection;
+};
+
+
+
 /**
  * Move on to the next network pool, and provision an IP from it.
  */
 NetworkPoolProvision.prototype.nextNetwork =
     function nextNetworkPool(opts, callback) {
-    var next = this.networks.shift();
-    if (!next) {
-        var fullErr = new errors.InvalidParamsError('Invalid parameters',
-            [ errors.invalidParam(this.field,
-                constants.POOL_FULL_MSG) ]);
-        fullErr.stop = true;
-        callback(fullErr);
+    var self = this;
+
+    if (self.networks === null) {
+        assert.object(self.intersection, 'intersection set');
+        self.networks = self.pool.networks.filter(function (network) {
+            return network.matches(self.intersection);
+        });
+        assert.ok(self.networks.length > 0, 'networks available');
+    } else if (self.networks.length === 0) {
+        callback(new errors.PoolFullError(self.field, self.pool.uuid));
         return;
     }
 
+    var next = self.networks.shift();
+
     opts.log.debug({ nextUUID: next.uuid }, 'Trying next network in pool');
 
-    this.network = next;
-    this.fetchNextIP(opts, true, callback);
+    self.network = next;
+    self.fetchNextIP(opts, true, callback);
 };
 
 
@@ -511,6 +547,16 @@ function listVnetCns(opts, callback) {
 }
 
 
+/**
+ * Reset the chosen intersection for every Provisioner.
+ */
+function resetIntersections(provisioners, intersection) {
+    provisioners.forEach(function (provisioner) {
+        provisioner.setIntersection(intersection);
+    });
+}
+
+
 /**
  * Run all of the IP Provisioners for this NIC provision.
  */
@@ -519,8 +565,41 @@ function runProvisions(opts, callback) {
     assert.array(opts.provisioners, 'opts.provisioners');
     assert.func(callback, 'callback');
 
+    var provisioners = opts.provisioners;
+    var intersections = opts.validated.intersections;
+
+    /*
+     * If any intersections are present and we haven't yet selected one, then
+     * initialize the Provisioners to use the first one.
+     */
+    if (intersections && !opts.intersection) {
+        assert.ok(intersections.length > 0, 'have intersections');
+        opts.intersection = intersections.shift();
+        resetIntersections(provisioners, opts.intersection);
+    }
+
+    /*
+     * If a pool is full, grab the next intersection and update everyone to
+     * use it. If there are none left, there's nothing more we can do, so we
+     * abort the provision attempt.
+     */
+    if (opts.err instanceof errors.PoolFullError) {
+        opts.intersection = intersections.shift();
+        if (!opts.intersection) {
+            opts.err.stop = true;
+            callback(opts.err);
+            return;
+        }
+        resetIntersections(provisioners, opts.intersection);
+    }
+
+    /*
+     * By this point, all of the Provisioners should be ready to attempt to
+     * select an address. We run each one until each has either selected an
+     * address, or we hit an error.
+     */
     vasync.forEachPipeline({
-        inputs: opts.provisioners,
+        inputs: provisioners,
         func: function (provisioner, cb) {
             provisioner.provision(opts, cb);
         }
diff --git a/lib/models/nic/update.js b/lib/models/nic/update.js
index 05d8db9..0688761 100644
--- a/lib/models/nic/update.js
+++ b/lib/models/nic/update.js
@@ -79,6 +79,7 @@ var UPDATE_SCHEMA = {
         model: validate.string,
         network_uuid: common.validateIPv4Network,
         nic_tag: common.validateNicTag,
+        nic_tags_available: mod_nicTag.validateExists.bind(null, false),
         nic_tags_provided: mod_nicTag.validateExists.bind(null, false),
         primary: validate.bool,
         reserved: validate.bool,
diff --git a/lib/util/constants.js b/lib/util/constants.js
index bd5884e..2fe9836 100644
--- a/lib/util/constants.js
+++ b/lib/util/constants.js
@@ -37,6 +37,8 @@ var MESSAGES = {
     NET_ON_VLAN: 'VLAN must have no networks',
     NIC_ON_NET: 'network must have no NICs provisioned',
     NIC_TAG_SLASH: 'only one slash is allowed after the tag name',
+    NO_POOL_INTERSECTION: 'Specified pools do not contain networks ' +
+        'that can be used together',
     OBJ: 'must be an object',
     OFFSET: 'invalid value, offset must be an integer greater than or ' +
         'equal to 0',
@@ -73,6 +75,10 @@ var FORMAT_MESSAGES = {
     IP_MULTI: 'Multiple (overlapping) networks (%s) matching this nic_tag ' +
         'and vlan_id contain the IP address %s',
     NET_BAD_AF: 'The network UUID is valid, but its address family must be %s',
+    POOL_FAILS_CONSTRAINTS: 'No networks in network pool %s match ' +
+        'provisioning constraints',
+    POOL_FULL_MSG: 'All networks in pool %s are full',
+    POOL_NIC_TAGS_AMBIGUOUS: 'Network pool %s has mixed nic_tag values',
     NIC_TAGS_DIFFER: 'The nic_tag of all specified IPv4 and IPv6 networks ' +
         'must match (have "%s" and "%s")',
     VLAN_IDS_DIFFER: 'The vlan_id of all specified IPv4 and IPv6 networks ' +
@@ -153,7 +159,6 @@ module.exports = {
     MTU_NICTAG_UPDATE_MSG: 'nic_tag mtu update must support existing networks',
     NIC_PROVISION_RETRIES: 100,
     OWNER_MATCH_MSG: 'network owner_uuids do not match',
-    POOL_FULL_MSG: 'all networks in pool are full',
     POOL_IP_MSG: 'IP cannot be specified with a network pool',
     POOL_MIN_NETS_MSG:
         'network pool must contain at least one network',
diff --git a/lib/util/errors.js b/lib/util/errors.js
index 5606fed..0fa6fd0 100644
--- a/lib/util/errors.js
+++ b/lib/util/errors.js
@@ -136,6 +136,25 @@ function SubnetFullError(network_uuid) {
 util.inherits(SubnetFullError, restify.RestError);
 
 
+/**
+ * Base error class for when all networks in a pool are full.
+ */
+function PoolFullError(field, pool_uuid) {
+    assert.string(field, 'field');
+    assert.uuid(pool_uuid, 'network_uuid');
+
+    var msg = util.format(constants.fmt.POOL_FULL_MSG, pool_uuid);
+    InvalidParamsError.call(this, 'Invalid parameters',
+        [ invalidParam(field, msg) ]);
+
+    this.pool_uuid = pool_uuid;
+
+    // "stop" gets updated to true once all intersections are exhausted.
+    this.stop = false;
+}
+
+util.inherits(PoolFullError, InvalidParamsError);
+
 
 // --- Functions for building elements in a response's errors array
 
@@ -300,6 +319,7 @@ module.exports = {
     msg: MSG,
     networkOverlapParams: networkOverlapParams,
     nictagMtuInvalidForNetworks: nictagMtuInvalidForNetworks,
+    PoolFullError: PoolFullError,
     SubnetFullError: SubnetFullError,
     unknownParams: unknownParams,
     usedBy: usedBy,
diff --git a/lib/util/intersect.js b/lib/util/intersect.js
new file mode 100644
index 0000000..c71a7ae
--- /dev/null
+++ b/lib/util/intersect.js
@@ -0,0 +1,163 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2017, Joyent, Inc.
+ */
+
+/*
+ * This file contains the logic for finding the intersections of network pools
+ * during provisioning. Network pools intersect when they contain networks that
+ * have the same values for the following properties:
+ *
+ * - "mtu"
+ * - "nic_tag"
+ * - "vlan_id"
+ * - "vnet_id"
+ *
+ * The significance of these properties is that a VNIC can only have them set to
+ * a single value, so we can't select addresses from networks that differ.
+ *
+ * Given multiple pools, we search for all combinations of these properties
+ * that would provide a subset of usable networks from every pool. For example,
+ * consider an attempt to provision a NIC on the following two network pools,
+ * one IPv4 and the other IPv6:
+ *
+ * [
+ *   { subnet: "10.0.0.0/24", nic_tag: "r1internal", mtu: 1500, vlan_id: 21 },
+ *   { subnet: "10.0.1.0/24", nic_tag: "r2internal", mtu: 1500, vlan_id: 22 },
+ *   { subnet: "10.0.2.0/24", nic_tag: "r2internal", mtu: 1500, vlan_id: 23 },
+ *   { subnet: "10.0.3.0/24", nic_tag: "r2internal", mtu: 8500, vlan_id: 23 }
+ * ]
+ *
+ * [
+ *   { subnet: "fd00::/64", nic_tag: "r1internal", mtu: 1500, vlan_id: 21 },
+ *   { subnet: "fd01::/64", nic_tag: "r2internal", mtu: 1500, vlan_id: 22 },
+ *   { subnet: "fd02::/64", nic_tag: "r2internal", mtu: 1500, vlan_id: 23 }
+ * ]
+ *
+ * One of the IPv4 networks can't be used with any of the IPv6 networks due to
+ * its higher MTU, and all of the others can only be paired with one of the IPv6
+ * networks due to their different nic_tag/vlan_id values. To represent where
+ * these two network pools intersect, getPoolIntersections() would return the
+ * following array:
+ *
+ * [
+ *   { nic_tag: "r1internal", mtu: 1500, vlan_id: 21, vnet_id: undefined },
+ *   { nic_tag: "r2internal", mtu: 1500, vlan_id: 22, vnet_id: undefined },
+ *   { nic_tag: "r2internal", mtu: 1500, vlan_id: 23, vnet_id: undefined }
+ * ]
+ *
+ * This array is then used in lib/models/nic/provision.js to help inform the IP
+ * selection process, to make sure we are only considering compatible networks
+ * at any given moment (see runProvisions() and NetworkPoolProvision).
+ *
+ * This means that we might try selecting addresses from 10.0.0.0/24 and
+ * fd00::/64 for a new NIC, but never 10.0.1.0/24 and fd02::/64, since that
+ * would require the NIC to be on two different VLANs at once.
+ */
+
+'use strict';
+
+var assert = require('assert-plus');
+var constants = require('./constants');
+var errors = require('./errors');
+var jsprim = require('jsprim');
+var util = require('util');
+
+
+// --- Exports
+
+function getPoolIntersections(name, params, pools) {
+    assert.string(name, 'name');
+    assert.object(params, 'params');
+    assert.array(pools, 'pools');
+
+    var missing_nictags = !(params.nic_tag || params.nic_tags_available);
+
+    var constraints = [];
+
+    pools.forEach(function (pool) {
+        var options = {};
+
+        if (missing_nictags && pool.params.nic_tags_present.length > 1) {
+            throw errors.missingParam('nic_tags_available',
+                util.format(constants.fmt.POOL_NIC_TAGS_AMBIGUOUS, pool.uuid));
+        }
+
+        pool.networks.forEach(function (network) {
+            if (params.nic_tag !== undefined &&
+                params.nic_tag !== network.nic_tag) {
+                return;
+            }
+
+            if (params.nic_tags_available !== undefined &&
+                params.nic_tags_available.indexOf(network.nic_tag) === -1) {
+                return;
+            }
+
+            if (params.mtu !== undefined && params.mtu !== network.mtu) {
+                return;
+            }
+
+            if (params.vlan_id !== undefined &&
+                params.vlan_id !== network.vlan_id) {
+                return;
+            }
+
+            if (params.vnet_id !== undefined &&
+                params.vnet_id !== network.vnet_id) {
+                return;
+            }
+
+            var key =
+                network.nic_tag + '/' +
+                network.mtu + '/' +
+                network.vlan_id + '/' +
+                network.vnet_id;
+
+            options[key] = {
+                mtu: network.mtu,
+                nic_tag: network.nic_tag,
+                vlan_id: network.vlan_id,
+                vnet_id: network.vnet_id
+            };
+        });
+
+        if (jsprim.isEmpty(options)) {
+            throw errors.invalidParam(name,
+                util.format(constants.fmt.POOL_FAILS_CONSTRAINTS, pool.uuid));
+        }
+
+        constraints.push(options);
+    });
+
+    var result = constraints.shift();
+
+    constraints.forEach(function (constraint) {
+        var suggestions = Object.keys(result);
+        suggestions.forEach(function (suggestion) {
+            if (!constraint.hasOwnProperty(suggestion)) {
+                delete result[suggestion];
+            }
+        });
+    });
+
+    if (jsprim.isEmpty(result)) {
+        throw errors.invalidParam(name, constants.msg.NO_POOL_INTERSECTION);
+    }
+
+    var okay = [];
+    for (var k in result) {
+        okay.push(result[k]);
+    }
+    return okay;
+}
+
+
+module.exports = {
+    getPoolIntersections: getPoolIntersections
+};
diff --git a/test/integration/network-owner.test.js b/test/integration/network-owner.test.js
index 669783b..f4f0902 100644
--- a/test/integration/network-owner.test.js
+++ b/test/integration/network-owner.test.js
@@ -102,6 +102,7 @@ function createNetworkPool(t, name, type, params) {
         params.networks.sort();
         params.uuid = res.uuid;
         params.nic_tag = state.nicTag.name;
+        params.nic_tags_present = [ state.nicTag.name ];
         params.family = type;
 
         t.deepEqual(res, params, 'network pool ' + name);
diff --git a/test/integration/network-pools.test.js b/test/integration/network-pools.test.js
index 8d0f371..e690891 100644
--- a/test/integration/network-pools.test.js
+++ b/test/integration/network-pools.test.js
@@ -96,6 +96,7 @@ test('POST /network_pools', function (t) {
             exp: {
                 family: 'ipv4',
                 networks: [ state.network.uuid ].sort(),
+                nic_tags_present: [ state.network.nic_tag ],
                 nic_tag: state.network.nic_tag
             },
             state: state
@@ -111,6 +112,7 @@ test('POST /network_pools', function (t) {
             exp: {
                 family: 'ipv4',
                 networks: [ state.network.uuid, state.network2.uuid ].sort(),
+                nic_tags_present: [ state.network.nic_tag ],
                 nic_tag: state.network.nic_tag
             },
             state: state
@@ -152,6 +154,7 @@ test('PUT /network_pools/:uuid', function (t) {
 
         params.uuid = state.pools[0].uuid;
         params.nic_tag = state.network.nic_tag;
+        params.nic_tags_present = [ state.network.nic_tag ];
         params.family = 'ipv4';
         t.deepEqual(res, params, 'update params');
 
diff --git a/test/unit/network-owner.test.js b/test/unit/network-owner.test.js
index 514dffc..cd8d19a 100644
--- a/test/unit/network-owner.test.js
+++ b/test/unit/network-owner.test.js
@@ -268,6 +268,7 @@ function createPool(name, params, type, t) {
         params.uuid = res.uuid;
         params.name = name;
         params.nic_tag = netParams.nic_tag;
+        params.nic_tags_present = [ netParams.nic_tag ];
         params.family = type;
         t.deepEqual(res, params, 'result');
         pools.push(res);
diff --git a/test/unit/network-pools.test.js b/test/unit/network-pools.test.js
index 673954c..9e653f0 100644
--- a/test/unit/network-pools.test.js
+++ b/test/unit/network-pools.test.js
@@ -42,6 +42,9 @@ var NAPI;
 var NETS = [];
 var POOLS = [];
 
+var NIC_TAG1 = 'nictag1p' + process.pid;
+var NIC_TAG2 = 'nictag2p' + process.pid;
+var NIC_TAG3 = 'nictag3p' + process.pid;
 
 
 // --- Internal helpers
@@ -58,6 +61,7 @@ function netParams(extra) {
 
     var params = {
         name: 'net' + l,
+        nic_tag: NIC_TAG1,
         subnet: util.format('10.0.%d.0/28', l),
         provision_end_ip: util.format('10.0.%d.12', l),
         provision_start_ip: util.format('10.0.%d.9', l),
@@ -83,6 +87,7 @@ function v6netParams(extra) {
 
     var params = {
         name: 'net' + l,
+        nic_tag: NIC_TAG1,
         // Ensure the networks sort in order of creation:
         uuid: util.format('%d%d%d%d7862-54fa-4667-89ae-c981cd5ada9a',
             l, l, l, l)
@@ -102,12 +107,14 @@ function createNet(t, extra) {
     }
 
     NAPI.createNetwork(netParams(extra), function (err, res) {
-        t.ifErr(err);
-        if (res) {
-            NETS.push(res);
+        if (h.ifErr(t, err, 'createNetwork() error')) {
+            t.end();
+            return;
         }
 
-        return t.end();
+        NETS.push(res);
+
+        t.end();
     });
 }
 
@@ -137,18 +144,21 @@ test('Initial setup', function (t) {
             provision_start_ip: '10.0.0.2',
             provision_end_ip: '10.0.0.5'
         });
-        var otherTag = 'othertag' + process.pid;
 
         t.test('delete previous', function (t2) {
             mod_pool.delAll(t2, {});
         });
 
         t.test('create nic tag 1', function (t2) {
-            mod_tag.create(t2, { name: net1Params.nic_tag });
+            mod_tag.create(t2, { name: NIC_TAG1 });
         });
 
-        t.test('create other nic tag', function (t2) {
-            mod_tag.create(t2, { name: otherTag });
+        t.test('create nic tag 2', function (t2) {
+            mod_tag.create(t2, { name: NIC_TAG2 });
+        });
+
+        t.test('create nic tag 3', function (t2) {
+            mod_tag.create(t2, { name: NIC_TAG3 });
         });
 
         t.test('create net0', function (t2) {
@@ -171,7 +181,7 @@ test('Initial setup', function (t) {
         });
 
         t.test('create net3', function (t2) {
-            createNet(t2, { nic_tag: otherTag });
+            createNet(t2, { nic_tag: NIC_TAG2 });
         });
 
         t.test('create net4', function (t2) {
@@ -204,6 +214,10 @@ test('Initial setup', function (t) {
             });
         });
 
+        t.test('create net8', function (t2) {
+            createNet(t2);
+        });
+
         t.test('create pool1', function (t2) {
             var name = 'pool1-' + process.pid;
             var params = {
@@ -217,8 +231,9 @@ test('Initial setup', function (t) {
                     params.name = name;
                     params.uuid = res2.uuid;
                     params.nic_tag = NETS[0].nic_tag;
+                    params.nic_tags_present = [ NETS[0].nic_tag ];
                     params.family = 'ipv4';
-                    t2.deepEqual(res2, params, 'result');
+                    t2.deepEqual(res2, params, 'result for ' + res2.uuid);
                 }
 
                 t2.ifErr(err2);
@@ -239,8 +254,9 @@ test('Initial setup', function (t) {
                     params.name = name;
                     params.uuid = res2.uuid;
                     params.nic_tag = NETS[4].nic_tag;
+                    params.nic_tags_present = [ NETS[4].nic_tag ];
                     params.family = 'ipv4';
-                    t2.deepEqual(res2, params, 'result');
+                    t2.deepEqual(res2, params, 'result for ' + res2.uuid);
                 }
 
                 t2.ifErr(err2);
@@ -261,8 +277,9 @@ test('Initial setup', function (t) {
                     params.name = name;
                     params.uuid = res2.uuid;
                     params.nic_tag = NETS[6].nic_tag;
+                    params.nic_tags_present = [ NETS[6].nic_tag ];
                     params.family = 'ipv6';
-                    t2.deepEqual(res2, params, 'result');
+                    t2.deepEqual(res2, params, 'result for ' + res2.uuid);
                 }
 
                 t2.ifErr(err2);
@@ -282,8 +299,33 @@ test('Initial setup', function (t) {
                     params.name = name;
                     params.uuid = res2.uuid;
                     params.nic_tag = NETS[0].nic_tag;
+                    params.nic_tags_present = [ NETS[0].nic_tag ];
+                    params.family = 'ipv4';
+                    t2.deepEqual(res2, params, 'result for ' + res2.uuid);
+                }
+
+                t2.ifErr(err2);
+                t2.end();
+            });
+        });
+
+
+        t.test('create pool5', function (t2) {
+            var name = 'pool5-' + process.pid;
+            var params = {
+                networks: [ NETS[3].uuid, NETS[8].uuid ]
+            };
+
+            NAPI.createNetworkPool(name, params, function (err2, res2) {
+                if (res2) {
+                    POOLS.push(res2);
+                    params.name = name;
+                    params.uuid = res2.uuid;
+                    params.nic_tag = NETS[3].nic_tag;
+                    params.nic_tags_present =
+                        [ NETS[3].nic_tag, NETS[8].nic_tag ];
                     params.family = 'ipv4';
-                    t2.deepEqual(res2, params, 'result');
+                    t2.deepEqual(res2, params, 'result for ' + res2.uuid);
                 }
 
                 t2.ifErr(err2);
@@ -291,6 +333,31 @@ test('Initial setup', function (t) {
             });
         });
 
+
+        t.test('create pool6', function (t2) {
+            var name = 'pool6-' + process.pid;
+            var params = {
+                networks: [ NETS[0].uuid, NETS[3].uuid ]
+            };
+
+            NAPI.createNetworkPool(name, params, function (err2, res2) {
+                if (res2) {
+                    POOLS.push(res2);
+                    params.name = name;
+                    params.uuid = res2.uuid;
+                    params.nic_tag = NETS[0].nic_tag;
+                    params.nic_tags_present =
+                        [ NETS[0].nic_tag, NETS[3].nic_tag ];
+                    params.family = 'ipv4';
+                    t2.deepEqual(res2, params, 'result for ' + res2.uuid);
+                }
+
+                t2.ifErr(err2);
+                t2.end();
+            });
+        });
+
+
         t.end();
     });
 });
@@ -351,29 +418,6 @@ test('Create pool - too many networks', function (t) {
 });
 
 
-test('Create pool - mismatched nic tags', function (t) {
-    var params = {
-        networks: [ NETS[0].uuid, NETS[3].uuid ]
-    };
-
-    NAPI.createNetworkPool('pool-fail-2-' + process.pid, params,
-        function (err, res) {
-        t.ok(err, 'error returned');
-        if (!err) {
-            return t.end();
-        }
-
-        t.equal(err.statusCode, 422, 'status code');
-        t.deepEqual(err.body, h.invalidParamErr({
-            errors: [ mod_err.invalidParam('networks',
-                constants.POOL_TAGS_MATCH_MSG) ]
-        }), 'error body');
-
-        return t.end();
-    });
-});
-
-
 test('Create pool - invalid params (non-objects)', function (t) {
     vasync.forEachParallel({
         inputs: h.NON_OBJECT_PARAMS,
@@ -762,7 +806,7 @@ test('provisionable_by network pools: owner', function (t) {
 
     t.test('create network', function (t2) {
         owners = [ mod_uuid.v4(), mod_uuid.v4() ];
-        var params = h.validNetworkParams({
+        var params = netParams({
             owner_uuids: [ owners[0] ]
         });
 
@@ -850,7 +894,14 @@ test('List pools - filter for "ipv4" pools', function (t) {
             family: 'ipv4'
         },
         deepEqual: true,
-        present: [ POOLS[0], POOLS[1], POOLS[3], POOLS[4] ]
+        present: [
+            POOLS[0],
+            POOLS[1],
+            POOLS[3],
+            POOLS[4],
+            POOLS[5],
+            POOLS[6]
+        ]
     });
 });
 
@@ -909,13 +960,17 @@ test('List pools - single network filter', function (t) {
     });
 });
 
-test('List pools - filter with two networks', function (t) {
+test('List pools - filter returns multiple networks', function (t) {
     mod_pool.list(t, {
         params: {
             networks: [ POOLS[3].networks[0] ]
         },
         deepEqual: true,
-        present: [ POOLS[0], POOLS[3] ]
+        present: [
+            POOLS[0],
+            POOLS[3],
+            POOLS[5]
+        ]
     });
 });
 
@@ -1032,19 +1087,14 @@ test('Provision nic - on network pool', function (t) {
             owner_uuid: mod_uuid.v4()
         };
 
-        NAPI.provisionNic(POOLS[0].uuid, params, function (err, res) {
-            t.ok(err);
-            if (!err) {
-                return t.end();
-            }
-
-            t.equal(err.statusCode, 422, 'status code');
-            t.deepEqual(err.body, h.invalidParamErr({
+        mod_nic.provision(t, {
+            net: POOLS[0].uuid,
+            params: params,
+            expCode: 422,
+            expErr: h.invalidParamErr({
                 errors: [ mod_err.invalidParam('network_uuid',
-                                    constants.POOL_FULL_MSG) ]
-            }), 'error body');
-
-            return t.end();
+                    util.format(constants.fmt.POOL_FULL_MSG, POOLS[0].uuid)) ]
+            })
         });
     });
 });
@@ -1096,6 +1146,132 @@ test('Provision NIC on pool: Retry after QueryTimeoutErrors', function (t) {
 });
 
 
+test('Provision NIC on pool: pool has multiple NIC tags', function (t) {
+    t.test('Provision with "nic_tags_available"', function (t2) {
+        var params = {
+            belongs_to_type: 'zone',
+            belongs_to_uuid: mod_uuid.v4(),
+            owner_uuid: mod_uuid.v4(),
+            nic_tags_available: [ NIC_TAG1, NIC_TAG3 ]
+        };
+
+        mod_nic.provision(t2, {
+            net: POOLS[4].uuid,
+            params: params,
+            partialExp: mod_net.addNetParams(NETS[8], {
+                belongs_to_type: 'zone',
+                belongs_to_uuid: params.belongs_to_uuid,
+                owner_uuid: params.owner_uuid,
+                ip: h.nextProvisionableIP(NETS[8])
+            })
+        });
+    });
+
+    t.test('Provision with "nic_tags_available"', function (t2) {
+        var params = {
+            belongs_to_type: 'zone',
+            belongs_to_uuid: mod_uuid.v4(),
+            owner_uuid: mod_uuid.v4(),
+            nic_tags_available: [ NIC_TAG2, NIC_TAG3 ]
+        };
+
+        mod_nic.provision(t2, {
+            net: POOLS[4].uuid,
+            params: params,
+            partialExp: mod_net.addNetParams(NETS[3], {
+                belongs_to_type: 'zone',
+                belongs_to_uuid: params.belongs_to_uuid,
+                owner_uuid: params.owner_uuid,
+                ip: h.nextProvisionableIP(NETS[3])
+            })
+        });
+    });
+
+    t.test('Provision with "nic_tag"', function (t2) {
+        var params = {
+            belongs_to_type: 'zone',
+            belongs_to_uuid: mod_uuid.v4(),
+            owner_uuid: mod_uuid.v4(),
+            nic_tag: NIC_TAG2
+        };
+
+        mod_nic.provision(t2, {
+            net: POOLS[4].uuid,
+            params: params,
+            partialExp: mod_net.addNetParams(NETS[3], {
+                belongs_to_type: 'zone',
+                belongs_to_uuid: params.belongs_to_uuid,
+                owner_uuid: params.owner_uuid,
+                ip: h.nextProvisionableIP(NETS[3])
+            })
+        });
+    });
+
+    t.test('Provision with no nic_tag hints', function (t2) {
+        var params = {
+            belongs_to_type: 'zone',
+            belongs_to_uuid: mod_uuid.v4(),
+            owner_uuid: mod_uuid.v4()
+        };
+
+        mod_nic.provision(t2, {
+            net: POOLS[4].uuid,
+            params: params,
+            expCode: 422,
+            expErr: h.missingParamErr({
+                errors: [ h.missingParam('nic_tags_available',
+                    util.format(constants.fmt.POOL_NIC_TAGS_AMBIGUOUS,
+                        POOLS[4].uuid)) ]
+            })
+        });
+    });
+
+    t.test('Provision with no matching networks in pool', function (t2) {
+        var params = {
+            belongs_to_type: 'zone',
+            belongs_to_uuid: mod_uuid.v4(),
+            owner_uuid: mod_uuid.v4(),
+            nic_tags_available: [ NIC_TAG3 ]
+        };
+
+        mod_nic.provision(t2, {
+            net: POOLS[4].uuid,
+            params: params,
+            expCode: 422,
+            expErr: h.invalidParamErr({
+                errors: [ mod_err.invalidParam('network_uuid',
+                    util.format(constants.fmt.POOL_FAILS_CONSTRAINTS,
+                        POOLS[4].uuid)) ]
+            })
+        });
+    });
+});
+
+
+test('Provision NIC on pool: First intersection fails', function (t) {
+    var params = {
+        belongs_to_type: 'zone',
+        belongs_to_uuid: mod_uuid.v4(),
+        owner_uuid: mod_uuid.v4(),
+        nic_tags_available: POOLS[5].nic_tags_present
+    };
+
+    /*
+     * NETS[0] was exhausted earlier, so provisioning on it will fail, and
+     * we'll end up provisioning onto NETS[3] instead.
+     */
+    mod_nic.provision(t, {
+        net: POOLS[5].uuid,
+        params: params,
+        partialExp: mod_net.addNetParams(NETS[3], {
+            belongs_to_type: 'zone',
+            belongs_to_uuid: params.belongs_to_uuid,
+            owner_uuid: params.owner_uuid,
+            ip: h.nextProvisionableIP(NETS[3])
+        })
+    });
+});
+
 
 
 // --- Delete tests
diff --git a/test/unit/util-intersect.test.js b/test/unit/util-intersect.test.js
new file mode 100644
index 0000000..488361f
--- /dev/null
+++ b/test/unit/util-intersect.test.js
@@ -0,0 +1,269 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2017, Joyent, Inc.
+ */
+
+'use strict';
+
+var assert = require('assert-plus');
+var constants = require('../../lib/util/constants');
+var errors = require('../../lib/util/errors');
+var mod_jsprim = require('jsprim');
+var Network = require('../../lib/models/network').Network;
+var NetworkPool = require('../../lib/models/network-pool').NetworkPool;
+var test = require('tape');
+var util = require('util');
+var util_intersect = require('../../lib/util/intersect');
+
+
+// --- Globals
+
+var getPoolIntersections = util_intersect.getPoolIntersections;
+
+function mkNet(nic_tag, vlan_id, vnet_id, mtu) {
+    assert.string(nic_tag, 'nic_tag');
+    assert.number(vlan_id, 'vlan_id');
+
+    return {
+        mtu: mtu || constants.MTU_DEFAULT,
+        nic_tag: nic_tag,
+        vlan_id: vlan_id,
+        vnet_id: vnet_id
+    };
+}
+
+function mkPool(networks) {
+    var nic_tags = [];
+    networks.forEach(function (network) {
+        var nic_tag = network.nic_tag;
+        if (nic_tags.indexOf(nic_tag) === -1) {
+            nic_tags.push(nic_tag);
+        }
+    });
+
+    return new NetworkPool({
+        _netobjs: networks.map(function (network) {
+            // Add fields to make the parameters valid:
+            var params = mod_jsprim.mergeObjects({
+                subnet: '10.0.0.0/24',
+                subnet_start_ip: '10.0.0.0',
+                fabric: network.vnet_id !== undefined
+            }, network);
+
+            return new Network(params);
+        })
+    });
+}
+
+var a_0 = mkNet('a', 0);
+var a_1 = mkNet('a', 1);
+var b_0 = mkNet('b', 0);
+var b_1 = mkNet('b', 1);
+var b_0_1 = mkNet('b', 0, 1);
+var c_2 = mkNet('c', 2, undefined, 9000);
+var c_3_200 = mkNet('c', 3, 200);
+var c_4 = mkNet('c', 4);
+var c_5_1234 = mkNet('c', 5, 1234);
+var q_60_8000 = mkNet('q', 60, 8000);
+
+// --- Internal helpers
+
+
+function mixedError(pool) {
+    return errors.missingParam('nic_tags_available',
+        util.format(constants.fmt.POOL_NIC_TAGS_AMBIGUOUS, pool.uuid));
+}
+
+function testInvalid(t, filter, pools, exp) {
+    try {
+        getPoolIntersections('addresses_updates', filter, pools);
+        t.fail('Expected intersection calculation to fail');
+    } catch (e) {
+        t.deepEqual(e, exp, 'proper error thrown');
+    }
+}
+
+// --- Tests
+
+test('single pool', function (t) {
+    var setA = [ a_0, a_1, b_0, c_2 ];
+    var input = [
+        mkPool(setA)
+    ];
+
+    t.deepEqual(getPoolIntersections('addresses_updates',
+        { vlan_id: 0, nic_tags_available: [ 'a', 'b' ] },
+        input), [ a_0, b_0 ], 'nic_tags_available=[a,b] filter');
+
+    t.deepEqual(getPoolIntersections('addresses_updates',
+        { nic_tags_available: [ 'a', 'c' ] },
+        input), [ a_0, a_1, c_2 ], 'nic_tags_available=[a,c] filter');
+
+    t.deepEqual(getPoolIntersections('addresses_updates',
+        { nic_tags_available: [ 'a', 'd' ] },
+        input), [ a_0, a_1 ], 'nic_tags_available=[a,d] filter');
+
+    t.deepEqual(getPoolIntersections('addresses_updates', { nic_tag: 'a' },
+        input), [ a_0, a_1 ], 'vlan_id=0 filter');
+
+    t.deepEqual(getPoolIntersections('addresses_updates',
+        { nic_tag: 'a', vlan_id: 0 },
+        input), [ a_0 ], 'nic_tag=a, vlan_id=0 filter');
+
+    t.end();
+});
+
+
+test('two pools', function (t) {
+    var setA = [ a_0, a_1, b_0, b_1, q_60_8000 ];
+    var setB = [ a_1, c_2, a_0, c_3_200, q_60_8000 ];
+    var input = [
+        mkPool(setA),
+        mkPool(setB)
+    ];
+
+    testInvalid(t, {}, input, mixedError(input[0]));
+
+    testInvalid(t, { vlan_id: 0 }, input, mixedError(input[0]));
+
+    testInvalid(t, { vnet_id: 8000 }, input, mixedError(input[0]));
+
+    t.deepEqual(getPoolIntersections('addresses_updates', { nic_tag: 'a' },
+        input), [ a_0, a_1 ], 'nic_tag=a filter');
+
+    t.deepEqual(getPoolIntersections('addresses_updates', { nic_tag: 'q' },
+        input), [ q_60_8000 ], 'nic_tag=q filter');
+
+    t.deepEqual(getPoolIntersections('addresses_updates',
+        { nic_tags_available: [ 'q', 'a' ] },
+        input), [ a_0, a_1, q_60_8000 ], 'nic_tags_available=[q,a] filter');
+
+    t.deepEqual(getPoolIntersections('addresses_updates',
+        { nic_tags_available: [ 'a', 'b' ] },
+        input), [ a_0, a_1 ], 'nic_tags_available=[a,b] filter');
+
+    t.deepEqual(getPoolIntersections('addresses_updates',
+        { nic_tag: 'a', vlan_id: 0 },
+        input), [ a_0 ], 'nic_tag=a, vlan_id=0 filter');
+
+    t.end();
+});
+
+
+test('five pools', function (t) {
+    var setA = [ a_0, c_2, c_3_200 ];
+    var setB = [ b_0_1, c_2, c_3_200, a_0 ];
+    var setC = [ b_0_1, c_2, a_0, b_0_1 ];
+    var setD = [ a_1, b_0_1, c_2, a_0 ];
+    var setE = [ q_60_8000, c_2, a_0 ];
+    var input = [
+        mkPool(setA),
+        mkPool(setB),
+        mkPool(setC),
+        mkPool(setD),
+        mkPool(setE)
+    ];
+
+    testInvalid(t, {}, input, mixedError(input[0]));
+
+    testInvalid(t, { vlan_id: 0 }, input, mixedError(input[0]));
+
+    testInvalid(t, { vlan_id: 2 }, input, mixedError(input[0]));
+
+    t.deepEqual(getPoolIntersections('addresses_updates', { nic_tag: 'a' },
+        input), [ a_0 ], 'nic_tag=a filter');
+
+    t.deepEqual(getPoolIntersections('addresses_updates',
+        { nic_tags_available: [ 'a', 'c' ] },
+        input), [ a_0, c_2 ], 'nic_tags_available=[a,c] filter');
+
+    t.deepEqual(getPoolIntersections('addresses_updates',
+        { nic_tags_available: [ 'c' ] },
+        input), [ c_2 ], 'nic_tags_available=[c] filter');
+
+    t.deepEqual(getPoolIntersections('addresses_updates',
+        { nic_tags_available: [ 'c', 'q' ] },
+        input), [ c_2 ], 'nic_tags_available=[c,q] filter');
+
+    t.deepEqual(getPoolIntersections('addresses_updates', { nic_tag: 'c' },
+        input), [ c_2 ], 'nic_tag=c filter');
+
+    t.end();
+});
+
+
+test('missing nic_tag hints okay w/ homogenous pools', function (t) {
+    var setA = [ c_2, c_3_200, c_5_1234 ];
+    var setB = [ c_2, c_4, c_5_1234 ];
+    var setC = [ c_2, c_3_200, c_4, c_5_1234 ];
+    var setD = [ c_2, c_5_1234 ];
+    var input = [
+        mkPool(setA),
+        mkPool(setB),
+        mkPool(setC),
+        mkPool(setD)
+    ];
+
+    t.deepEqual(getPoolIntersections('addresses_updates', {}, input),
+        [ c_2, c_5_1234 ], 'no filter given');
+
+    t.deepEqual(getPoolIntersections('addresses_updates', { vlan_id: 2 },
+        input), [ c_2 ], 'vlan_id filter given');
+
+    t.deepEqual(getPoolIntersections('addresses_updates', { vlan_id: 5 },
+        input), [ c_5_1234 ], 'vlan_id filter given');
+
+    t.deepEqual(getPoolIntersections('addresses_updates', { vnet_id: 1234 },
+        input), [ c_5_1234 ], 'vnet_id filter given');
+
+    t.deepEqual(getPoolIntersections('addresses_updates', { mtu: 9000 },
+        input), [ c_2 ], 'mtu filter given');
+
+    t.end();
+});
+
+
+test('no intersection', function (t) {
+    // All of these have c_2 except for the last
+    var setA = [ c_2 ];
+    var setB = [ b_0_1, c_2, c_3_200, a_0 ];
+    var setC = [ b_0_1, c_2, a_0, b_0_1 ];
+    var setD = [ a_1, b_0_1, c_2, a_0 ];
+    var setE = [ q_60_8000 ];
+    var input = [
+        mkPool(setA),
+        mkPool(setB),
+        mkPool(setC),
+        mkPool(setD),
+        mkPool(setE)
+    ];
+
+    var all_tags = [ 'a', 'b', 'c', 'd', 'q' ];
+
+    var ambiguous = errors.missingParam('nic_tags_available',
+        util.format(constants.fmt.POOL_NIC_TAGS_AMBIGUOUS, input[1].uuid));
+
+    var constrained = errors.invalidParam('addresses_updates',
+        util.format(constants.fmt.POOL_FAILS_CONSTRAINTS, input[4].uuid));
+
+    testInvalid(t, {}, input, ambiguous);
+
+    testInvalid(t, { vlan_id: 2 }, input, ambiguous);
+
+    testInvalid(t, { nic_tags_available: all_tags }, input,
+        errors.invalidParam('addresses_updates',
+            constants.msg.NO_POOL_INTERSECTION));
+
+    testInvalid(t, { nic_tags_available: [ 'c' ] }, input,
+        constrained);
+
+    testInvalid(t, { vlan_id: 2, nic_tags_available: all_tags }, input,
+        constrained);
+
+    t.end();
+});
