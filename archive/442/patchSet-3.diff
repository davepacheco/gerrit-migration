commit 0b078b221c5b11ecfb7835f881ec6f027086c3a6 (refs/changes/42/442/3)
Author: Todd Whiteman <todd.whiteman@joyent.com>
Date:   2016-09-13T13:27:30-07:00 (3 years, 1 month ago)
    
    DOCKER-929 Support the docker v2.2 manifest format
    * bump version
    * add changelog
    * re-instate v1.dockerio.test.js, but change to an available v1 image
    * nits and tweaks
    Reviewed By: Trent Mick <trentm@gmail.com>

diff --git a/CHANGES.md b/CHANGES.md
index 292ea55..307a350 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -1,6 +1,12 @@
 # node-docker-registry-client Changelog
 
-## 3.1.6 (not yet released)
+## 3.1.7 (not yet released)
+
+- DOCKER-929: Support the docker v2.2 manifest format. The getManifest function
+  now has an optional `allowV2Schemas` argument to get a manifest in the v2.2
+  schema format. Default is to use the v2.1 schema format.
+
+## 3.1.6
 
 - #8 Fix usage against a *http* registry.
 - #7 Fix test suite against Docker Hub.
diff --git a/lib/registry-client-v2.js b/lib/registry-client-v2.js
index 49f68fb..710bfcd 100644
--- a/lib/registry-client-v2.js
+++ b/lib/registry-client-v2.js
@@ -1185,6 +1185,7 @@ RegistryClientV2.prototype.getManifest = function getManifest(opts, cb) {
     var self = this;
     assert.object(opts, 'opts');
     assert.string(opts.ref, 'opts.ref');
+    assert.optionalBool(opts.allowV2Schemas, 'opts.allowV2Schemas');
     assert.func(cb, 'cb');
 
     var res, manifest;
@@ -1193,36 +1194,54 @@ RegistryClientV2.prototype.getManifest = function getManifest(opts, cb) {
             self.login(next);
         },
         function call(_, next) {
+            var headers = self._headers;
+            if (opts.allowV2Schemas) {
+                // TODO: Eventually we may want to allow fatties (aka manifest
+                //       lists) too, which uses:
+                // 'application/vnd.docker.distribution.manifest.list.v2+json'
+                headers = common.objMerge({}, self._headers, {accept: [
+                    'application/vnd.docker.distribution.manifest.v2+json'
+                ]});
+            }
             self._api.get({
                 path: fmt('/v2/%s/manifests/%s',
                     encodeURI(self.repo.remoteName),
                     encodeURIComponent(opts.ref)),
-                headers: self._headers
+                headers: headers
             }, function _afterCall(err, req, res_, manifest_, body) {
                 if (err) {
                     return next(err);
                 }
 
-                try {
-                    var jws = _jwsFromManifest(manifest_, body);
-                    _verifyManifestDockerContentDigest(res_, jws);
-                    _verifyJws(jws);
-                } catch (verifyErr) {
-                    return next(verifyErr);
+                if (manifest_.schemaVersion === 1) {
+                    try {
+                        var jws = _jwsFromManifest(manifest_, body);
+                        _verifyManifestDockerContentDigest(res_, jws);
+                        _verifyJws(jws);
+                    } catch (verifyErr) {
+                        return next(verifyErr);
+                    }
                 }
 
-                if (manifest_.schemaVersion !== 1) {
+                if (manifest_.schemaVersion !== 1 &&
+                    (manifest_.schemaVersion !== 2 ||
+                    !opts.allowV2Schemas)) {
                     throw new restify.InvalidContentError(fmt(
                         'unsupported schema version %s in %s:%s manifest',
                         manifest_.schemaVersion, self.repo.localName,
                         opts.ref));
                 }
-                if (manifest_.fsLayers.length !== manifest_.history.length) {
-                    throw new restify.InvalidContentError(fmt(
-                        'length of history not equal to number of layers in ' +
-                        '%s:%s manifest', self.repo.localName, opts.ref));
+                var layers = manifest_.fsLayers;
+                if (manifest_.schemaVersion === 1) {
+                    if (layers.length !== manifest_.history.length) {
+                        throw new restify.InvalidContentError(fmt(
+                            'history length not equal to layers length in ' +
+                            '%s:%s manifest', self.repo.localName, opts.ref));
+                    }
+                } else if (manifest_.schemaVersion === 2) {
+                    layers = manifest_.layers;
                 }
-                if (manifest_.fsLayers.length === 0) {
+                if (layers.length === 0) {
                     throw new restify.InvalidContentError(fmt(
                         'no layers in %s:%s manifest', self.repo.localName,
                         opts.ref));
diff --git a/package.json b/package.json
index 8a21ef7..6ad0cae 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
     "name": "docker-registry-client",
-    "version": "3.1.6",
+    "version": "3.1.7",
     "description": "node.js client for the Docker Registry API",
     "author": "Joyent (joyent.com)",
     "main": "./lib/index.js",
diff --git a/test/v1.dockerio.test.js b/test/v1.dockerio.test.js
index 8eda795..9efb4b0 100644
--- a/test/v1.dockerio.test.js
+++ b/test/v1.dockerio.test.js
@@ -65,7 +65,9 @@ test('v1 docker.io', function (tt) {
         });
     });
 
-    var tag = 'latest';
+    // Note: 'latest' is no longer available in docker.io, use '2.7' which is
+    //       still available and in the v1 registry format.
+    var tag = '2.7';
     var repoTags;
 
     tt.test('  listRepoTags', function (t) {
diff --git a/test/v2.dockerio.test.js b/test/v2.dockerio.test.js
index c25f5e6..4f97ca3 100644
--- a/test/v2.dockerio.test.js
+++ b/test/v2.dockerio.test.js
@@ -23,6 +23,15 @@ var REPO = 'busybox';
 var TAG = 'latest';
 
 
+// --- Helper functions.
+
+function getFirstLayerDigestFromManifest(manifest_) {
+    if (manifest_.schemaVersion === 1) {
+        return manifest_.fsLayers[0].blobSum;
+    }
+    return manifest_.layers[0].digest;
+}
+
 
 // --- Tests
 
@@ -83,34 +92,71 @@ test('v2 docker.io', function (tt) {
      *      "signature": <JWS>
      *  }
      */
+    tt.test('  getManifest (v2.1)', function (t) {
+        client.getManifest({ref: TAG}, function (err, manifest_, res) {
+            t.ifErr(err);
+            t.ok(manifest_);
+            t.equal(manifest_.schemaVersion, 1);
+            t.equal(manifest_.name, repo.remoteName);
+            t.equal(manifest_.tag, TAG);
+            t.ok(manifest_.architecture);
+            t.ok(manifest_.fsLayers);
+            t.ok(manifest_.history[0].v1Compatibility);
+            t.ok(manifest_.signatures[0].signature);
+            t.end();
+        });
+    });
+
+    /*
+     * {
+     *   "schemaVersion": 2,
+     *   "mediaType": "application/vnd.docker.distribution.manifest.v2+json",
+     *   "config": {
+     *     "mediaType": "application/octet-stream",
+     *     "size": 1459,
+     *     "digest": "sha256:2b8fd9751c4c0f5dd266fc...01"
+     *   },
+     *   "layers": [
+     *     {
+     *       "mediaType": "application/vnd.docker.image.rootfs.diff.tar.gzip",
+     *       "size": 667590,
+     *       "digest": "sha256:8ddc19f16526912237dd8af...a9"
+     *     }
+     *   ]
+     * }
+     */
     var manifest;
     var manifestDigest;
-    tt.test('  getManifest', function (t) {
-        client.getManifest({ref: TAG}, function (err, manifest_, res) {
+    tt.test('  getManifest (v2.2)', function (t) {
+        var getOpts = {ref: TAG, allowV2Schemas: true};
+        client.getManifest(getOpts, function (err, manifest_, res) {
             t.ifErr(err);
             manifest = manifest_;
             manifestDigest = res.headers['docker-content-digest'];
             t.ok(manifest);
-            t.equal(manifest.schemaVersion, 1);
-            t.equal(manifest.name, repo.remoteName);
-            t.equal(manifest.tag, TAG);
-            t.ok(manifest.architecture);
-            t.ok(manifest.fsLayers);
-            t.ok(manifest.history[0].v1Compatibility);
-            t.ok(manifest.signatures[0].signature);
+            t.equal(manifest.schemaVersion, 2);
+            t.ok(manifest.config);
+            t.ok(manifest.config.digest, manifest.config.digest);
+            t.ok(manifest.layers);
+            t.ok(manifest.layers.length > 0);
+            t.ok(manifest.layers[0].digest);
             t.end();
         });
     });
 
+    /*
+     * Note this test requires that the manifest be pulled in the v2.2 format,
+     * otherwise you will get a manifest not found error.
+     */
     tt.test('  getManifest (by digest)', function (t) {
-        client.getManifest({ref: manifestDigest}, function (err, manifest_) {
+        var getOpts = {ref: manifestDigest, allowV2Schemas: true};
+        client.getManifest(getOpts, function (err, manifest_) {
             t.ifErr(err);
             t.ok(manifest);
             ['schemaVersion',
-             'name',
-             'tag',
-             'architecture'].forEach(function (k) {
-                t.equal(manifest_[k], manifest[k], k);
+             'config',
+             'layers'].forEach(function (k) {
+                t.deepEqual(manifest_[k], manifest[k], k);
             });
             t.end();
         });
@@ -126,7 +172,7 @@ test('v2 docker.io', function (tt) {
     });
 
     tt.test('  headBlob', function (t) {
-        var digest = manifest.fsLayers[0].blobSum;
+        var digest = getFirstLayerDigestFromManifest(manifest);
         client.headBlob({digest: digest}, function (err, ress) {
             t.ifErr(err, 'no headBlob err');
             t.ok(ress, 'got a "ress"');
@@ -168,7 +214,7 @@ test('v2 docker.io', function (tt) {
     });
 
     tt.test('  createBlobReadStream', function (t) {
-        var digest = manifest.fsLayers[0].blobSum;
+        var digest = getFirstLayerDigestFromManifest(manifest);
         client.createBlobReadStream({digest: digest},
                 function (err, stream, ress) {
             t.ifErr(err, 'createBlobReadStream err');
