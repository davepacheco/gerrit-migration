commit 7e52e341dce76f5f305735470d50c80e03c774e0 (refs/changes/42/442/7)
Author: Todd Whiteman <todd.whiteman@joyent.com>
Date:   2016-09-21T09:18:43-07:00 (3 years, 1 month ago)
    
    DOCKER-929 Support the docker v2.2 manifest format
    Reviewed by: Trent Mick <trentm@gmail.com>

diff --git a/CHANGES.md b/CHANGES.md
index 292ea55..013e2e4 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -1,7 +1,12 @@
 # node-docker-registry-client Changelog
 
-## 3.1.6 (not yet released)
+## 3.2.0 (not yet released)
 
+- DOCKER-929: Support the docker v2.2 manifest format. The `createClientV2` and
+  `getManifest` functions now allow an optional `maxSchemaVersion` argument to
+  allow you to specify the maximum manifest schema version you will receive for
+  getManifest calls. Default is 1 for a schemaVersion 1 format (aka v2.1), a
+  value of 2 means schemaVersion 2 (aka v2.2).
 - #8 Fix usage against a *http* registry.
 - #7 Fix test suite against Docker Hub.
 
diff --git a/examples/mainline.js b/examples/mainline.js
index f7b2ebb..f45045a 100644
--- a/examples/mainline.js
+++ b/examples/mainline.js
@@ -79,9 +79,15 @@ function fail(cmd, err, opts) {
 function mainline(config, cb) {
     assert.string(config.cmd, 'config.cmd');
     assert.optionalBool(config.excludeAuth, 'config.excludeAuth');
+    assert.optionalObject(config.options, 'config.options');
 
+    var dashOpts = (config.excludeAuth ? optionsNoAuth : options);
+    if (config.options) {
+        // Add to existing options.
+        dashOpts = dashOpts.concat(config.options);
+    }
     var parser = dashdash.createParser({
-        options: (config.excludeAuth ? optionsNoAuth : options)
+        options: dashOpts
     });
     try {
         var opts = parser.parse(process.argv);
diff --git a/examples/v2/getManifest.js b/examples/v2/getManifest.js
index 60a4318..25186bd 100644
--- a/examples/v2/getManifest.js
+++ b/examples/v2/getManifest.js
@@ -15,7 +15,14 @@ var mainline = require('../mainline');
 
 // Shared mainline with examples/foo.js to get CLI opts.
 var cmd = 'getManifest';
-mainline({cmd: cmd}, function (log, parser, opts, args) {
+var dashOpts = [
+    {
+        names: ['schema', 's'],
+        type: 'number',
+        help: 'Schema version to request (1 or 2, defaults to 1)'
+    }
+];
+mainline({cmd: cmd, options: dashOpts}, function (log, parser, opts, args) {
     var name = args[0];
     if (!name) {
         console.error('usage: node examples/v2/%s.js REPO[:TAG|@DIGEST]\n' +
@@ -35,8 +42,11 @@ mainline({cmd: cmd}, function (log, parser, opts, args) {
         username: opts.username,
         password: opts.password
     });
-    client.getManifest({ref: rar.tag || rar.digest},
-            function (err, manifest, res) {
+    var getOpts = {
+        ref: rar.tag || rar.digest,
+        maxSchemaVersion: (opts.schema || 1)
+    };
+    client.getManifest(getOpts, function (err, manifest, res) {
         client.close();
         if (err) {
             mainline.fail(cmd, err, opts);
diff --git a/lib/registry-client-v2.js b/lib/registry-client-v2.js
index 49f68fb..109377b 100644
--- a/lib/registry-client-v2.js
+++ b/lib/registry-client-v2.js
@@ -928,6 +928,7 @@ function RegistryClientV2(opts) {
     assert.optionalString(opts.token, 'opts.token');  // for Bearer auth
     assert.optionalBool(opts.insecure, 'opts.insecure');
     assert.optionalString(opts.scheme, 'opts.scheme');
+    assert.optionalNumber(opts.maxSchemaVersion, 'opts.maxSchemaVersion');
     // TODO: options to control the trust db for CA verification
     // TODO add passing through other restify options: userAgent, ...
     // Restify/Node HTTP client options.
@@ -954,6 +955,7 @@ function RegistryClientV2(opts) {
         this.repo.index.scheme = 'http';
     }
 
+    this.maxSchemaVersion = opts.maxSchemaVersion || 1;
     this.username = opts.username;
     this.password = opts.password;
     this._loggedIn = false;
@@ -1185,44 +1187,62 @@ RegistryClientV2.prototype.getManifest = function getManifest(opts, cb) {
     var self = this;
     assert.object(opts, 'opts');
     assert.string(opts.ref, 'opts.ref');
+    assert.optionalNumber(opts.maxSchemaVersion, 'opts.maxSchemaVersion');
     assert.func(cb, 'cb');
 
     var res, manifest;
+    var maxSchemaVersion = (opts.maxSchemaVersion || self.maxSchemaVersion);
     vasync.pipeline({arg: this, funcs: [
         function doLogin(_, next) {
             self.login(next);
         },
         function call(_, next) {
+            var headers = self._headers;
+            if (maxSchemaVersion === 2) {
+                // TODO: Eventually we may want to allow fatties (aka manifest
+                //       lists) too, which uses:
+                // 'application/vnd.docker.distribution.manifest.list.v2+json'
+                headers = common.objMerge({}, self._headers, {accept: [
+                    'application/vnd.docker.distribution.manifest.v2+json'
+                ]});
+            }
             self._api.get({
                 path: fmt('/v2/%s/manifests/%s',
                     encodeURI(self.repo.remoteName),
                     encodeURIComponent(opts.ref)),
-                headers: self._headers
+                headers: headers
             }, function _afterCall(err, req, res_, manifest_, body) {
                 if (err) {
                     return next(err);
                 }
 
-                try {
-                    var jws = _jwsFromManifest(manifest_, body);
-                    _verifyManifestDockerContentDigest(res_, jws);
-                    _verifyJws(jws);
-                } catch (verifyErr) {
-                    return next(verifyErr);
+                if (manifest_.schemaVersion === 1) {
+                    try {
+                        var jws = _jwsFromManifest(manifest_, body);
+                        _verifyManifestDockerContentDigest(res_, jws);
+                        _verifyJws(jws);
+                    } catch (verifyErr) {
+                        return next(verifyErr);
+                    }
                 }
 
-                if (manifest_.schemaVersion !== 1) {
+                if (manifest_.schemaVersion > maxSchemaVersion) {
                     throw new restify.InvalidContentError(fmt(
                         'unsupported schema version %s in %s:%s manifest',
                         manifest_.schemaVersion, self.repo.localName,
                         opts.ref));
                 }
-                if (manifest_.fsLayers.length !== manifest_.history.length) {
-                    throw new restify.InvalidContentError(fmt(
-                        'length of history not equal to number of layers in ' +
-                        '%s:%s manifest', self.repo.localName, opts.ref));
+                var layers = manifest_.fsLayers;
+                if (manifest_.schemaVersion === 1) {
+                    if (layers.length !== manifest_.history.length) {
+                        throw new restify.InvalidContentError(fmt(
+                            'history length not equal to layers length in ' +
+                            '%s:%s manifest', self.repo.localName, opts.ref));
+                    }
+                } else if (manifest_.schemaVersion === 2) {
+                    layers = manifest_.layers;
                 }
-                if (manifest_.fsLayers.length === 0) {
+                if (layers.length === 0) {
                     throw new restify.InvalidContentError(fmt(
                         'no layers in %s:%s manifest', self.repo.localName,
                         opts.ref));
diff --git a/package.json b/package.json
index 8a21ef7..d4342b1 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
     "name": "docker-registry-client",
-    "version": "3.1.6",
+    "version": "3.2.0",
     "description": "node.js client for the Docker Registry API",
     "author": "Joyent (joyent.com)",
     "main": "./lib/index.js",
diff --git a/test/v1.dockerio.test.js b/test/v1.dockerio.test.js
index 8eda795..9efb4b0 100644
--- a/test/v1.dockerio.test.js
+++ b/test/v1.dockerio.test.js
@@ -65,7 +65,9 @@ test('v1 docker.io', function (tt) {
         });
     });
 
-    var tag = 'latest';
+    // Note: 'latest' is no longer available in docker.io, use '2.7' which is
+    //       still available and in the v1 registry format.
+    var tag = '2.7';
     var repoTags;
 
     tt.test('  listRepoTags', function (t) {
diff --git a/test/v2.dockerio.test.js b/test/v2.dockerio.test.js
index c25f5e6..4cf109f 100644
--- a/test/v2.dockerio.test.js
+++ b/test/v2.dockerio.test.js
@@ -23,6 +23,15 @@ var REPO = 'busybox';
 var TAG = 'latest';
 
 
+// --- Helper functions.
+
+function getFirstLayerDigestFromManifest(manifest_) {
+    if (manifest_.schemaVersion === 1) {
+        return manifest_.fsLayers[0].blobSum;
+    }
+    return manifest_.layers[0].digest;
+}
+
 
 // --- Tests
 
@@ -83,34 +92,71 @@ test('v2 docker.io', function (tt) {
      *      "signature": <JWS>
      *  }
      */
+    tt.test('  getManifest (v2.1)', function (t) {
+        client.getManifest({ref: TAG}, function (err, manifest_, res) {
+            t.ifErr(err);
+            t.ok(manifest_);
+            t.equal(manifest_.schemaVersion, 1);
+            t.equal(manifest_.name, repo.remoteName);
+            t.equal(manifest_.tag, TAG);
+            t.ok(manifest_.architecture);
+            t.ok(manifest_.fsLayers);
+            t.ok(manifest_.history[0].v1Compatibility);
+            t.ok(manifest_.signatures[0].signature);
+            t.end();
+        });
+    });
+
+    /*
+     * {
+     *   "schemaVersion": 2,
+     *   "mediaType": "application/vnd.docker.distribution.manifest.v2+json",
+     *   "config": {
+     *     "mediaType": "application/octet-stream",
+     *     "size": 1459,
+     *     "digest": "sha256:2b8fd9751c4c0f5dd266fc...01"
+     *   },
+     *   "layers": [
+     *     {
+     *       "mediaType": "application/vnd.docker.image.rootfs.diff.tar.gzip",
+     *       "size": 667590,
+     *       "digest": "sha256:8ddc19f16526912237dd8af...a9"
+     *     }
+     *   ]
+     * }
+     */
     var manifest;
     var manifestDigest;
-    tt.test('  getManifest', function (t) {
-        client.getManifest({ref: TAG}, function (err, manifest_, res) {
+    tt.test('  getManifest (v2.2)', function (t) {
+        var getOpts = {ref: TAG, maxSchemaVersion: 2};
+        client.getManifest(getOpts, function (err, manifest_, res) {
             t.ifErr(err);
             manifest = manifest_;
             manifestDigest = res.headers['docker-content-digest'];
             t.ok(manifest);
-            t.equal(manifest.schemaVersion, 1);
-            t.equal(manifest.name, repo.remoteName);
-            t.equal(manifest.tag, TAG);
-            t.ok(manifest.architecture);
-            t.ok(manifest.fsLayers);
-            t.ok(manifest.history[0].v1Compatibility);
-            t.ok(manifest.signatures[0].signature);
+            t.equal(manifest.schemaVersion, 2);
+            t.ok(manifest.config);
+            t.ok(manifest.config.digest, manifest.config.digest);
+            t.ok(manifest.layers);
+            t.ok(manifest.layers.length > 0);
+            t.ok(manifest.layers[0].digest);
             t.end();
         });
     });
 
+    /*
+     * Note this test requires that the manifest be pulled in the v2.2 format,
+     * otherwise you will get a manifest not found error.
+     */
     tt.test('  getManifest (by digest)', function (t) {
-        client.getManifest({ref: manifestDigest}, function (err, manifest_) {
+        var getOpts = {ref: manifestDigest, maxSchemaVersion: 2};
+        client.getManifest(getOpts, function (err, manifest_) {
             t.ifErr(err);
             t.ok(manifest);
             ['schemaVersion',
-             'name',
-             'tag',
-             'architecture'].forEach(function (k) {
-                t.equal(manifest_[k], manifest[k], k);
+             'config',
+             'layers'].forEach(function (k) {
+                t.deepEqual(manifest_[k], manifest[k], k);
             });
             t.end();
         });
@@ -126,7 +172,7 @@ test('v2 docker.io', function (tt) {
     });
 
     tt.test('  headBlob', function (t) {
-        var digest = manifest.fsLayers[0].blobSum;
+        var digest = getFirstLayerDigestFromManifest(manifest);
         client.headBlob({digest: digest}, function (err, ress) {
             t.ifErr(err, 'no headBlob err');
             t.ok(ress, 'got a "ress"');
@@ -168,7 +214,7 @@ test('v2 docker.io', function (tt) {
     });
 
     tt.test('  createBlobReadStream', function (t) {
-        var digest = manifest.fsLayers[0].blobSum;
+        var digest = getFirstLayerDigestFromManifest(manifest);
         client.createBlobReadStream({digest: digest},
                 function (err, stream, ress) {
             t.ifErr(err, 'createBlobReadStream err');
