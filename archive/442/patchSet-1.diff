From 0c6124800cf1f9179cc4e941d72390f8091e5662 Mon Sep 17 00:00:00 2001
From: Todd Whiteman <todd.whiteman@joyent.com>
Date: Fri, 9 Sep 2016 11:13:19 -0700
Subject: [PATCH] DOCKER-929 Support the docker v2.2 manifest format

---
 lib/registry-client-v2.js |  45 ++++++++----
 test/v1.dockerio.test.js  | 142 --------------------------------------
 test/v2.dockerio.test.js  |  77 ++++++++++++++++-----
 3 files changed, 93 insertions(+), 171 deletions(-)
 delete mode 100644 test/v1.dockerio.test.js

diff --git a/lib/registry-client-v2.js b/lib/registry-client-v2.js
index 49f68fb..710bfcd 100644
--- a/lib/registry-client-v2.js
+++ b/lib/registry-client-v2.js
@@ -1185,6 +1185,7 @@ RegistryClientV2.prototype.getManifest = function getManifest(opts, cb) {
     var self = this;
     assert.object(opts, 'opts');
     assert.string(opts.ref, 'opts.ref');
+    assert.optionalBool(opts.allowV2Schemas, 'opts.allowV2Schemas');
     assert.func(cb, 'cb');
 
     var res, manifest;
@@ -1193,36 +1194,54 @@ RegistryClientV2.prototype.getManifest = function getManifest(opts, cb) {
             self.login(next);
         },
         function call(_, next) {
+            var headers = self._headers;
+            if (opts.allowV2Schemas) {
+                // TODO: Eventually we may want to allow fatties (aka manifest
+                //       lists) too, which uses:
+                // 'application/vnd.docker.distribution.manifest.list.v2+json'
+                headers = common.objMerge({}, self._headers, {accept: [
+                    'application/vnd.docker.distribution.manifest.v2+json'
+                ]});
+            }
             self._api.get({
                 path: fmt('/v2/%s/manifests/%s',
                     encodeURI(self.repo.remoteName),
                     encodeURIComponent(opts.ref)),
-                headers: self._headers
+                headers: headers
             }, function _afterCall(err, req, res_, manifest_, body) {
                 if (err) {
                     return next(err);
                 }
 
-                try {
-                    var jws = _jwsFromManifest(manifest_, body);
-                    _verifyManifestDockerContentDigest(res_, jws);
-                    _verifyJws(jws);
-                } catch (verifyErr) {
-                    return next(verifyErr);
+                if (manifest_.schemaVersion === 1) {
+                    try {
+                        var jws = _jwsFromManifest(manifest_, body);
+                        _verifyManifestDockerContentDigest(res_, jws);
+                        _verifyJws(jws);
+                    } catch (verifyErr) {
+                        return next(verifyErr);
+                    }
                 }
 
-                if (manifest_.schemaVersion !== 1) {
+                if (manifest_.schemaVersion !== 1 &&
+                    (manifest_.schemaVersion !== 2 ||
+                    !opts.allowV2Schemas)) {
                     throw new restify.InvalidContentError(fmt(
                         'unsupported schema version %s in %s:%s manifest',
                         manifest_.schemaVersion, self.repo.localName,
                         opts.ref));
                 }
-                if (manifest_.fsLayers.length !== manifest_.history.length) {
-                    throw new restify.InvalidContentError(fmt(
-                        'length of history not equal to number of layers in ' +
-                        '%s:%s manifest', self.repo.localName, opts.ref));
+                var layers = manifest_.fsLayers;
+                if (manifest_.schemaVersion === 1) {
+                    if (layers.length !== manifest_.history.length) {
+                        throw new restify.InvalidContentError(fmt(
+                            'history length not equal to layers length in ' +
+                            '%s:%s manifest', self.repo.localName, opts.ref));
+                    }
+                } else if (manifest_.schemaVersion === 2) {
+                    layers = manifest_.layers;
                 }
-                if (manifest_.fsLayers.length === 0) {
+                if (layers.length === 0) {
                     throw new restify.InvalidContentError(fmt(
                         'no layers in %s:%s manifest', self.repo.localName,
                         opts.ref));
diff --git a/test/v1.dockerio.test.js b/test/v1.dockerio.test.js
deleted file mode 100644
index 8eda795..0000000
--- a/test/v1.dockerio.test.js
+++ /dev/null
@@ -1,142 +0,0 @@
-/*
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/.
- */
-
-/*
- * Copyright (c) 2015, Joyent, Inc.
- */
-
-var test = require('tape');
-
-var drc = require('..');
-
-
-// --- globals
-
-var log = require('./lib/log');
-
-
-// --- Tests
-
-test('v1 docker.io', function (tt) {
-    var client;
-
-    tt.test('  createClient', function (t) {
-        client = drc.createClientV1({
-            name: 'alpine',
-            log: log
-        });
-        t.ok(client);
-        t.equal(client.version, 1);
-        t.end();
-    });
-
-    tt.test('  ping', function (t) {
-        client.ping(function (err, status, res) {
-            t.ifErr(err);
-            t.equal(status, true);
-            t.end();
-        });
-    });
-
-    tt.test('  search', function (t) {
-        client.search({term: 'busy'}, function (err, results, res) {
-            t.ifErr(err);
-            t.ok(results);
-            t.ok(results.num_pages);
-            t.ok(results.num_results);
-            var busybox = results.results.filter(
-                function (r) { return r.name === 'busybox'; })[0];
-            t.ok(busybox);
-            t.ok(busybox.is_official);
-            t.end();
-        });
-    });
-
-    tt.test('  listRepoImgs', function (t) {
-        client.listRepoImgs(function (err, imgs) {
-            t.ifErr(err);
-            t.ok(Array.isArray(imgs));
-            t.ok(imgs.length > 0);
-            t.ok(/[0-9a-f]{64}/.test(imgs[0].id));
-            t.end();
-        });
-    });
-
-    var tag = 'latest';
-    var repoTags;
-
-    tt.test('  listRepoTags', function (t) {
-        client.listRepoTags(function (err, repoTags_) {
-            repoTags = repoTags_;
-            t.ifErr(err);
-            t.equal(typeof (repoTags), 'object');
-            t.ok(repoTags[tag]);
-            t.ok(/[0-9a-f]{64}/.test(repoTags[tag]));
-            t.end();
-        });
-    });
-
-    tt.test('  getImgId', function (t) {
-        client.getImgId({tag: tag}, function (err, imgId) {
-            t.ifErr(err);
-            t.ok(imgId);
-            t.ok(/[0-9a-f]{64}/.test(imgId));
-            t.equal(imgId, repoTags[tag]);
-            t.end();
-        });
-    });
-
-    tt.test('  getImgAncestry', function (t) {
-        client.getImgAncestry({imgId: repoTags[tag]}, function (err, ancestry) {
-            t.ifErr(err);
-            t.ok(Array.isArray(ancestry));
-            t.ok(ancestry.length > 0);
-            t.equal(ancestry[0], repoTags[tag]);
-            t.end();
-        });
-    });
-
-    tt.test('  getImgJson', function (t) {
-        var imgId = repoTags[tag];
-        client.getImgJson({imgId: imgId}, function (err, imgJson, res) {
-            t.ifErr(err);
-            t.equal(imgJson.id, imgId);
-            t.ok(imgJson.config);
-            t.end();
-        });
-    });
-
-    tt.test('  getImgLayerStream', function (t) {
-        var imgId = repoTags[tag];
-        client.getImgLayerStream({imgId: imgId}, function (getErr, stream) {
-            t.ifErr(getErr, 'no error');
-            if (getErr) {
-                return t.end();
-            }
-
-            t.ok(stream.headers, 'have headers');
-
-            var numBytes = 0;
-            stream.on('data', function (chunk) {
-                numBytes += chunk.length;
-            });
-            stream.on('error', function (err) {
-                t.ifErr(err);
-                t.end();
-            });
-            stream.on('end', function () {
-                t.ok(numBytes > 0, 'downloaded ' + numBytes + ' bytes');
-                t.end();
-            });
-            stream.resume();
-        });
-    });
-
-    tt.test('  close', function (t) {
-        client.close();
-        t.end();
-    });
-});
diff --git a/test/v2.dockerio.test.js b/test/v2.dockerio.test.js
index c25f5e6..d73b318 100644
--- a/test/v2.dockerio.test.js
+++ b/test/v2.dockerio.test.js
@@ -69,6 +69,35 @@ test('v2 docker.io', function (tt) {
         });
     });
 
+    /*
+     *  {
+     *      "name": <name>,
+     *      "tag": <tag>,
+     *      "fsLayers": [
+     *         {
+     *            "blobSum": <tarsum>
+     *         },
+     *         ...
+     *      ],
+     *      "history": <v1 images>,
+     *      "signature": <JWS>
+     *  }
+     */
+    tt.test('  getManifest (v2.1)', function (t) {
+        client.getManifest({ref: TAG}, function (err, manifest_, res) {
+            t.ifErr(err);
+            t.ok(manifest_);
+            t.equal(manifest_.schemaVersion, 1);
+            t.equal(manifest_.name, repo.remoteName);
+            t.equal(manifest_.tag, TAG);
+            t.ok(manifest_.architecture);
+            t.ok(manifest_.fsLayers);
+            t.ok(manifest_.history[0].v1Compatibility);
+            t.ok(manifest_.signatures[0].signature);
+            t.end();
+        });
+    });
+
     /*
      *  {
      *      "name": <name>,
@@ -85,32 +114,36 @@ test('v2 docker.io', function (tt) {
      */
     var manifest;
     var manifestDigest;
-    tt.test('  getManifest', function (t) {
-        client.getManifest({ref: TAG}, function (err, manifest_, res) {
+    tt.test('  getManifest (v2.2)', function (t) {
+        var getOpts = {ref: TAG, allowV2Schemas: true};
+        client.getManifest(getOpts, function (err, manifest_, res) {
             t.ifErr(err);
             manifest = manifest_;
             manifestDigest = res.headers['docker-content-digest'];
             t.ok(manifest);
-            t.equal(manifest.schemaVersion, 1);
-            t.equal(manifest.name, repo.remoteName);
-            t.equal(manifest.tag, TAG);
-            t.ok(manifest.architecture);
-            t.ok(manifest.fsLayers);
-            t.ok(manifest.history[0].v1Compatibility);
-            t.ok(manifest.signatures[0].signature);
+            t.equal(manifest.schemaVersion, 2);
+            t.ok(manifest.config);
+            t.ok(manifest.config.digest, manifest.config.digest);
+            t.ok(manifest.layers);
+            t.ok(manifest.layers.length > 0);
+            t.ok(manifest.layers[0].digest);
             t.end();
         });
     });
 
+    /*
+     * Note this test requires that the manifest be pulled in the v2.2 format,
+     * otherwise you will get a manifest not found error.
+     */
     tt.test('  getManifest (by digest)', function (t) {
-        client.getManifest({ref: manifestDigest}, function (err, manifest_) {
+        var getOpts = {ref: manifestDigest, allowV2Schemas: true};
+        client.getManifest(getOpts, function (err, manifest_) {
             t.ifErr(err);
             t.ok(manifest);
             ['schemaVersion',
-             'name',
-             'tag',
-             'architecture'].forEach(function (k) {
-                t.equal(manifest_[k], manifest[k], k);
+             'config',
+             'layers'].forEach(function (k) {
+                t.deepEqual(manifest_[k], manifest[k], k);
             });
             t.end();
         });
@@ -126,7 +159,7 @@ test('v2 docker.io', function (tt) {
     });
 
     tt.test('  headBlob', function (t) {
-        var digest = manifest.fsLayers[0].blobSum;
+        var digest = getFirstLayerDigestFromManifest(manifest);
         client.headBlob({digest: digest}, function (err, ress) {
             t.ifErr(err, 'no headBlob err');
             t.ok(ress, 'got a "ress"');
@@ -168,7 +201,7 @@ test('v2 docker.io', function (tt) {
     });
 
     tt.test('  createBlobReadStream', function (t) {
-        var digest = manifest.fsLayers[0].blobSum;
+        var digest = getFirstLayerDigestFromManifest(manifest);
         client.createBlobReadStream({digest: digest},
                 function (err, stream, ress) {
             t.ifErr(err, 'createBlobReadStream err');
@@ -228,3 +261,15 @@ test('v2 docker.io', function (tt) {
         t.end();
     });
 });
+
+
+/*
+ * Helper functions.
+ */
+
+function getFirstLayerDigestFromManifest(manifest_) {
+    if (manifest_.schemaVersion === 1) {
+        return manifest_.fsLayers[0].blobSum;
+    }
+    return manifest_.layers[0].digest;
+}
-- 
2.21.0

