commit e5b87d13c97391db5fb1a9ac67dc5b1aae6b164b (refs/changes/24/4424/1)
Author: Jason King <jason.king@joyent.com>
Date:   2018-06-25T10:35:24-05:00 (1 year, 3 months ago)
    
    Fix (hopefully) lock ott_lock and ote_lock inversion

diff --git a/usr/src/uts/common/io/overlay/overlay_target.c b/usr/src/uts/common/io/overlay/overlay_target.c
index b5230ba72d..569e22ed95 100644
--- a/usr/src/uts/common/io/overlay/overlay_target.c
+++ b/usr/src/uts/common/io/overlay/overlay_target.c
@@ -591,22 +591,15 @@ overlay_target_try_queue(overlay_target_entry_t *entry, mblk_t *mp)
 }
 
 static int
-overlay_route_lookup_vl2(overlay_target_t *ott, overlay_target_entry_t *vl3e,
-    uint64_t *vidp, struct sockaddr_in6 *v6, socklen_t *slenp, mblk_t *mp)
+overlay_route_lookup_vl2(overlay_target_entry_t *vl3e,
+    overlay_target_entry_t *vl2e, uint64_t *vidp, struct sockaddr_in6 *v6,
+    socklen_t *slenp, mblk_t *mp)
 {
-	overlay_target_entry_t *vl2e;
 	overlay_target_vl2_t *vl2p;
 	int ret;
 
 	ASSERT(MUTEX_HELD(&vl3e->ote_lock));
 
-	mutex_enter(&ott->ott_lock);
-	if ((vl2e = sarc_lookup(ott->ott_u.ott_dyn.ott_dhash,
-	    &vl3e->ote_u.ote_vl3.otvl3_vl2)) != NULL) {
-		sarc_hold(ott->ott_u.ott_dyn.ott_dhash, vl2e);
-	}
-	mutex_exit(&ott->ott_lock);
-
 	if (vl2e == NULL) {
 		vl3e->ote_flags &= ~OVERLAY_ENTRY_F_VALID;
 		return (overlay_target_try_queue(vl3e, mp));
@@ -618,10 +611,6 @@ overlay_route_lookup_vl2(overlay_target_t *ott, overlay_target_entry_t *vl3e,
 
 		mutex_exit(&vl2e->ote_lock);
 
-		mutex_enter(&ott->ott_lock);
-		sarc_rele(ott->ott_u.ott_dyn.ott_dhash, vl2e);
-		mutex_exit(&ott->ott_lock);
-
 		if (flags & OVERLAY_ENTRY_F_DROP) {
 			OVERLAY_DROP(mp, "VL2 target marked drop");
 		} else {
@@ -638,12 +627,7 @@ overlay_route_lookup_vl2(overlay_target_t *ott, overlay_target_entry_t *vl3e,
 	if ((vl2e->ote_flags & OVERLAY_ENTRY_F_HAS_ROUTE) == 0) {
 		mutex_exit(&vl2e->ote_lock);
 
-		mutex_enter(&ott->ott_lock);
-		sarc_rele(ott->ott_u.ott_dyn.ott_dhash, vl2e);
-		mutex_exit(&ott->ott_lock);
-
 		vl3e->ote_flags &= ~OVERLAY_ENTRY_F_VALID;
-
 		return (overlay_target_try_queue(vl3e, mp));
 	}
 
@@ -674,11 +658,6 @@ overlay_route_lookup_vl2(overlay_target_t *ott, overlay_target_entry_t *vl3e,
 
 		ret = overlay_target_try_queue(queue_e, mp);
 		mutex_exit(&vl2e->ote_lock);
-
-		mutex_enter(&ott->ott_lock);
-		sarc_rele(ott->ott_u.ott_dyn.ott_dhash, vl2e);
-		mutex_exit(&ott->ott_lock);
-
 		return (ret);
 	}
 
@@ -696,10 +675,6 @@ overlay_route_lookup_vl2(overlay_target_t *ott, overlay_target_entry_t *vl3e,
 	    &vl2p->otvl2_mac);
 	mutex_exit(&vl2e->ote_lock);
 
-	mutex_enter(&ott->ott_lock);
-	sarc_rele(ott->ott_u.ott_dyn.ott_dhash, vl2e);
-	mutex_exit(&ott->ott_lock);
-
 	return (ret);
 }
 
@@ -708,7 +683,7 @@ overlay_route_lookup(overlay_dev_t *odd, mblk_t *mp, uint16_t vlan,
     struct sockaddr *sock, socklen_t *slenp, uint64_t *vidp)
 {
 	overlay_target_t *ott = odd->odd_target;
-	overlay_target_entry_t *entry;
+	overlay_target_entry_t *entry, *vl2_entry = NULL;
 	struct sockaddr_in6 *v6 = (struct sockaddr_in6 *)sock;
 	overlay_target_vl3_t vl3 = { 0 };
 	int ret = OVERLAY_TARGET_DROP;
@@ -753,9 +728,22 @@ overlay_route_lookup(overlay_dev_t *odd, mblk_t *mp, uint16_t vlan,
 		return (OVERLAY_TARGET_ASYNC);
 	}
 	sarc_hold(ott->ott_u.ott_dyn.ott_l3dhash, entry);
+	mutex_enter(&entry->ote_lock);
+
+	/*
+	 * A bit ugly, but if we need the VL2 entry, we want to look it up
+	 * while we still hold ott_lock.
+	 */
+	if ((entry->ote_flags &
+	    (OVERLAY_ENTRY_F_DROP|OVERLAY_ENTRY_F_ROUTER|
+	    OVERLAY_ENTRY_F_VALID)) == OVERLAY_ENTRY_F_VALID) {
+		vl2_entry = sarc_lookup(ott->ott_u.ott_dyn.ott_dhash,
+		    &entry->ote_u.ote_vl3.otvl3_vl2);
+		if (vl2_entry != NULL)
+			sarc_hold(ott->ott_u.ott_dyn.ott_dhash, vl2_entry);
+	}
 	mutex_exit(&ott->ott_lock);
 
-	mutex_enter(&entry->ote_lock);
 	ASSERT(entry->ote_flags & OVERLAY_ENTRY_F_VL3);
 
 	if (entry->ote_flags & OVERLAY_ENTRY_F_DROP) {
@@ -771,12 +759,15 @@ overlay_route_lookup(overlay_dev_t *odd, mblk_t *mp, uint16_t vlan,
 	} else if ((entry->ote_flags & OVERLAY_ENTRY_F_VALID) == 0) {
 		ret = overlay_target_try_queue(entry, mp);
 	} else {
-		ret = overlay_route_lookup_vl2(ott, entry, vidp, v6, slenp, mp);
+		ret = overlay_route_lookup_vl2(entry, vl2_entry, vidp, v6,
+		    slenp, mp);
 	}
 	mutex_exit(&entry->ote_lock);
 
 	mutex_enter(&ott->ott_lock);
 	sarc_rele(ott->ott_u.ott_dyn.ott_l3dhash, entry);
+	if (vl2_entry != NULL)
+		sarc_rele(ott->ott_u.ott_dyn.ott_dhash, vl2_entry);
 	mutex_exit(&ott->ott_lock);
 	return (ret);
 }
