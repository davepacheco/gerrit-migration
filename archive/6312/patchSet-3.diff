From 2d1e890a0f88a3aa984e8f8a907a03f32eaa4cc9 Mon Sep 17 00:00:00 2001
From: Dave Eddy <dave@daveeddy.com>
Date: Mon, 3 Jun 2019 14:59:40 -0400
Subject: [PATCH] MANTA-4169 Add full complement of metrics to boray

---
 src/bucket.rs  | 30 ++++++++++------
 src/lib.rs     | 54 +++++++++++++++++++++--------
 src/metrics.rs | 13 ++++++-
 src/object.rs  | 59 +++++++++++++++++++-------------
 src/sql.rs     | 93 ++++++++++++++++++++++++++++++++++++++++++++++++++
 5 files changed, 200 insertions(+), 49 deletions(-)
 create mode 100644 src/sql.rs

diff --git a/src/bucket.rs b/src/bucket.rs
index 47e068a..88b35b5 100644
--- a/src/bucket.rs
+++ b/src/bucket.rs
@@ -17,6 +17,7 @@ use slog::{Logger, debug};
 use uuid::Uuid;
 
 use crate::util::Rows;
+use crate::sql;
 
 type Timestamptz = chrono::DateTime<chrono::Utc>;
 
@@ -189,7 +190,10 @@ pub fn list_handler(msg_id: u32,
     let list_sql = list_sql(payload.vnode, payload.limit,
         payload.offset, &payload.order_by);
 
-    for row in txn.query(list_sql.as_str(), &[&payload.owner, &prefix]).unwrap().iter() {
+    for row in sql::txn_query(&"bucket list (list_sql)", &mut txn, &list_sql,
+                          &[&payload.owner,
+                          &prefix]).unwrap().iter() {
+
         let resp = BucketResponse {
             id: row.get(0),
             owner: row.get(1),
@@ -364,8 +368,10 @@ fn get(payload: GetBucketPayload,
 {
     let mut conn = pool.claim().unwrap();
     let sql = get_sql(payload.vnode);
-    (*conn).query(sql.as_str(), &[&payload.owner,
-                                  &payload.name])
+
+    sql::query(&"bucket get (get_sql)", &mut conn, &sql,
+               &[&payload.owner,
+               &payload.name])
         .map_err(|e| {
            let pg_err = format!("{}", e);
             IOError::new(IOErrorKind::Other, pg_err)
@@ -383,9 +389,10 @@ fn create(payload: CreateBucketPayload,
     let create_sql = create_sql(payload.vnode);
 
     let insert_result =
-        txn.query(create_sql.as_str(), &[&Uuid::new_v4(),
-                                      &payload.owner,
-                                      &payload.name])
+        sql::txn_query(&"bucket create (create_sql)", &mut txn, &create_sql,
+                   &[&Uuid::new_v4(),
+                   &payload.owner,
+                   &payload.name])
         .map_err(|e| {
            let pg_err = format!("{}", e);
             IOError::new(IOErrorKind::Other, pg_err)
@@ -427,11 +434,14 @@ fn delete(payload: DeleteBucketPayload,
     let mut txn = (*conn).transaction().unwrap();
     let move_sql = insert_delete_table_sql(payload.vnode);
     let delete_sql = delete_sql(payload.vnode);
-    txn.execute(move_sql.as_str(), &[&payload.owner,
-                                     &payload.name])
+
+    sql::txn_execute(&"bucket delete (move_sql)", &mut txn, &move_sql,
+                 &[&payload.owner,
+                 &payload.name])
         .and_then(|_moved_rows| {
-            txn.execute(delete_sql.as_str(), &[&payload.owner,
-                                               &payload.name])
+            sql::txn_execute(&"bucket delete (delete_sql)", &mut txn, &delete_sql,
+                         &[&payload.owner,
+                         &payload.name])
         })
         .and_then(|row_count| {
             txn.commit().unwrap();
diff --git a/src/lib.rs b/src/lib.rs
index 44e6f03..7a41083 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -6,9 +6,11 @@ pub mod bucket;
 pub mod metrics;
 pub mod object;
 pub mod opts;
+pub mod sql;
 
 pub mod util {
     use std::io::{Error, ErrorKind};
+    use std::time::Instant;
 
     use cueball::connection_pool::ConnectionPool;
     use cueball::backend::Backend;
@@ -35,25 +37,47 @@ pub mod util {
                        pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>,
                        log: &Logger) -> Result<Vec<FastMessage>, Error>
     {
+        let now = Instant::now();
         let response: Vec<FastMessage> = vec![];
 
         metrics::INCOMING_REQUEST_COUNTER.inc();
 
-        match msg.data.d {
-            Value::Array(ref args) => {
-                match msg.data.m.name.as_str() {
-                    "getobject"    => object::get_handler(msg.id, &args, response, &pool, &log),
-                    "createobject" => object::create_handler(msg.id, &args, response, &pool, &log),
-                    "deleteobject" => object::delete_handler(msg.id, &args, response, &pool, &log),
-                    "listobjects"  => object::list_handler(msg.id, &args, response, &pool, &log),
-                    "getbucket"    => bucket::get_handler(msg.id, &args, response, &pool, &log),
-                    "createbucket" => bucket::create_handler(msg.id, &args, response, &pool, &log),
-                    "deletebucket" => bucket::delete_handler(msg.id, &args, response, &pool, &log),
-                    "listbuckets"  => bucket::list_handler(msg.id, &args, response, &pool, &log),
-                    _ => Err(Error::new(ErrorKind::Other, format!("Unsupported functon: {}", msg.data.m.name)))
-                }
+        let args = match msg.data.d {
+            Value::Array(ref args) => args,
+            _ => {
+                return Err(other_error("Expected JSON array"));
             }
-            _ => Err(other_error("Expected JSON array"))
-        }
+        };
+
+        let method = msg.data.m.name.as_str();
+        let ret = match method {
+            "getobject"    => object::get_handler(msg.id, &args, response, &pool, &log),
+            "createobject" => object::create_handler(msg.id, &args, response, &pool, &log),
+            "deleteobject" => object::delete_handler(msg.id, &args, response, &pool, &log),
+            "listobjects"  => object::list_handler(msg.id, &args, response, &pool, &log),
+            "getbucket"    => bucket::get_handler(msg.id, &args, response, &pool, &log),
+            "createbucket" => bucket::create_handler(msg.id, &args, response, &pool, &log),
+            "deletebucket" => bucket::delete_handler(msg.id, &args, response, &pool, &log),
+            "listbuckets"  => bucket::list_handler(msg.id, &args, response, &pool, &log),
+            _ => return Err(Error::new(ErrorKind::Other, format!("Unsupported functon: {}", method)))
+        };
+
+        // If we are here, then the method name was valid, and the request may or
+        // may not have been successful.
+
+        // Generate metrics for the request
+        let duration = now.elapsed();
+        let secs = duration.as_secs() as f64;
+        let ms = duration.subsec_millis() as f64 / 1000 as f64;
+        let t = secs + ms;
+
+        let success = match ret.is_ok() {
+            true => "true",
+            false => "false"
+        };
+
+        metrics::FAST_REQUESTS.with_label_values(&[&method, success]).observe(t);
+
+        ret
     }
 }
diff --git a/src/metrics.rs b/src/metrics.rs
index 304b1d8..ae520f3 100644
--- a/src/metrics.rs
+++ b/src/metrics.rs
@@ -12,7 +12,8 @@ use hyper::server::Server;
 use hyper::service::service_fn_ok;
 use hyper::StatusCode;
 use lazy_static::lazy_static;
-use prometheus::{Counter, Encoder, TextEncoder, labels, opts, register_counter};
+use prometheus::{HistogramVec, Counter, Encoder, TextEncoder, labels, opts, register_counter,
+register_histogram_vec, histogram_opts};
 use slog::{Logger, error, info};
 
 
@@ -27,6 +28,16 @@ lazy_static! {
         "Total number of metrics requests received.",
         labels! {"handler" => "all",}
     )).unwrap();
+    pub static ref FAST_REQUESTS: HistogramVec = register_histogram_vec!(
+        "fast_requests",
+        "Latency of all fast requests processed.",
+        &["method", "success"]
+    ).unwrap();
+    pub static ref POSTGRES_REQUESTS: HistogramVec = register_histogram_vec!(
+        "postgres_requests",
+        "Latency of all postgres requests processed.",
+        &["method", "success"]
+    ).unwrap();
 }
 
 pub fn start_server(address: String, port: u16, log: Logger) {
diff --git a/src/object.rs b/src/object.rs
index 09c07d4..0447904 100644
--- a/src/object.rs
+++ b/src/object.rs
@@ -24,6 +24,7 @@ use cueball_postgres_connection::PostgresConnection;
 use rust_fast::protocol::{FastMessage, FastMessageData};
 
 use crate::util::Rows;
+use crate::sql;
 
 type Hstore = HashMap<String, Option<String>>;
 type Timestamptz = chrono::DateTime<chrono::Utc>;
@@ -244,7 +245,11 @@ pub fn list_handler(msg_id: u32,
     let list_sql = list_sql(payload.vnode, payload.limit, payload.offset,
         &payload.order_by);
 
-    for row in txn.query(list_sql.as_str(), &[&payload.owner, &payload.bucket_id, &prefix]).unwrap().iter() {
+    for row in sql::txn_query(&"object list (list_sql)", &mut txn, &list_sql,
+                         &[&payload.owner,
+                         &payload.bucket_id,
+                         &prefix]).unwrap().iter() {
+
         let content_md5_bytes: Vec<u8> = row.get(7);
         let content_md5 = base64::encode(&content_md5_bytes);
         let resp = ObjectResponse {
@@ -373,9 +378,11 @@ fn get(payload: GetObjectPayload,
 {
     let mut conn = pool.claim().unwrap();
     let sql = get_sql(payload.vnode);
-    (*conn).query(sql.as_str(), &[&payload.owner,
-                                  &payload.bucket_id,
-                                  &payload.name])
+
+    sql::query(&"object get (get_sql)", &mut conn, &sql,
+               &[&payload.owner,
+               &payload.bucket_id,
+               &payload.name])
         .map_err(|e| {
             let pg_err = format!("{}", e);
             IOError::new(IOErrorKind::Other, pg_err)
@@ -444,20 +451,23 @@ fn create(payload: CreateObjectPayload,
     let create_sql = create_sql(payload.vnode);
     let move_sql = insert_delete_table_sql(payload.vnode);
     let content_md5_bytes = base64::decode(&payload.content_md5).unwrap();
-    txn.execute(move_sql.as_str(), &[&payload.owner,
-                                     &payload.bucket_id,
-                                     &payload.name])
+
+    sql::txn_execute(&"object create (move_sql)", &mut txn, &move_sql,
+                &[&payload.owner,
+                &payload.bucket_id,
+                &payload.name])
         .and_then(|_moved_rows| {
-            txn.query(create_sql.as_str(), &[&payload.id,
-                                             &payload.owner,
-                                             &payload.bucket_id,
-                                             &payload.name,
-                                             &payload.content_length,
-                                             &content_md5_bytes,
-                                             &payload.content_type,
-                                             &payload.headers,
-                                             &payload.sharks,
-                                             &payload.properties])
+            sql::txn_query(&"object create (create_sql)", &mut txn, &create_sql,
+                      &[&payload.id,
+                      &payload.owner,
+                      &payload.bucket_id,
+                      &payload.name,
+                      &payload.content_length,
+                      &content_md5_bytes,
+                      &payload.content_type,
+                      &payload.headers,
+                      &payload.sharks,
+                      &payload.properties])
         })
         .map_err(|e| {
             let pg_err = format!("{}", e);
@@ -528,13 +538,16 @@ fn delete(payload: DeleteObjectPayload,
     let mut txn = (*conn).transaction().unwrap();
     let move_sql = insert_delete_table_sql(payload.vnode);
     let delete_sql = delete_sql(payload.vnode);
-    txn.execute(move_sql.as_str(), &[&payload.owner,
-                                     &payload.bucket_id,
-                                     &payload.name])
+
+    sql::txn_execute(&"object delete (insert_delete_table_sql)", &mut txn, &move_sql,
+                &[&payload.owner,
+                &payload.bucket_id,
+                &payload.name])
         .and_then(|_moved_rows| {
-            txn.execute(delete_sql.as_str(), &[&payload.owner,
-                                               &payload.bucket_id,
-                                               &payload.name])
+            sql::txn_execute(&"object delete (delete_sql)", &mut txn, &delete_sql,
+                        &[&payload.owner,
+                        &payload.bucket_id,
+                        &payload.name])
         })
         .and_then(|row_count| {
             txn.commit().unwrap();
diff --git a/src/sql.rs b/src/sql.rs
new file mode 100644
index 0000000..1b9b96f
--- /dev/null
+++ b/src/sql.rs
@@ -0,0 +1,93 @@
+/*
+ * Copyright 2019 Joyent, Inc.
+ */
+
+use std::time::Instant;
+use std::vec::Vec;
+
+use postgres::{Transaction, Client};
+use postgres::types::ToSql;
+use tokio_postgres::Error as PGError;
+use tokio_postgres::Row as PGRow;
+
+use crate::metrics;
+
+// conn.execute wrapper that posts metrics
+pub fn execute(method: &str,
+       conn: &mut Client,
+       sql: &str,
+       items: &[&dyn ToSql])
+       -> Result<u64, PGError>
+{
+    let now = Instant::now();
+
+    let res = conn.execute(sql, items);
+
+    post_timer_metrics(&method, now, res.is_ok());
+
+    res
+}
+
+// txn.execute wrapper that posts metrics
+pub fn txn_execute(method: &str,
+       txn: &mut Transaction,
+       sql: &str,
+       items: &[&dyn ToSql])
+       -> Result<u64, PGError>
+{
+    let now = Instant::now();
+
+    let res = txn.execute(sql, items);
+
+    post_timer_metrics(&method, now, res.is_ok());
+
+    res
+}
+
+// conn.query wrapper that posts metrics
+pub fn query(method: &str,
+       conn: &mut Client,
+       sql: &str,
+       items: &[&dyn ToSql])
+       -> Result<Vec<PGRow>, PGError>
+{
+    let now = Instant::now();
+
+    let res = conn.query(sql, items);
+
+    post_timer_metrics(&method, now, res.is_ok());
+
+    res
+}
+
+// txn.query wrapper that posts metrics
+pub fn txn_query(method: &str,
+       txn: &mut Transaction,
+       sql: &str,
+       items: &[&dyn ToSql])
+       -> Result<Vec<PGRow>, PGError>
+{
+    let now = Instant::now();
+
+    let res = txn.query(sql, items);
+
+    post_timer_metrics(&method, now, res.is_ok());
+
+    res
+}
+
+fn post_timer_metrics(method: &str, now: Instant, success: bool)
+{
+    // Generate metrics for the request
+    let duration = now.elapsed();
+    let secs = duration.as_secs() as f64;
+    let ms = duration.subsec_millis() as f64 / 1000 as f64;
+    let t = secs + ms;
+
+    let success = match success {
+        true => "true",
+        false => "false"
+    };
+
+    metrics::POSTGRES_REQUESTS.with_label_values(&[&method, success]).observe(t);
+}
-- 
2.21.0

