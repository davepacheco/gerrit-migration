commit 09a36fb9345d1e24c96c75d0a8a88d81d52c2585
Author: Dave Eddy <dave@daveeddy.com>
Date:   2019-06-05T14:18:34-04:00 (4 months ago)
    
    MANTA-4169 Add full complement of metrics to boray

diff --git a/src/bucket.rs b/src/bucket.rs
index 47e068a..8bdd0cc 100644
--- a/src/bucket.rs
+++ b/src/bucket.rs
@@ -17,6 +17,7 @@ use slog::{Logger, debug};
 use uuid::Uuid;
 
 use crate::util::Rows;
+use crate::sql;
 
 type Timestamptz = chrono::DateTime<chrono::Utc>;
 
@@ -189,7 +190,10 @@ pub fn list_handler(msg_id: u32,
     let list_sql = list_sql(payload.vnode, payload.limit,
         payload.offset, &payload.order_by);
 
-    for row in txn.query(list_sql.as_str(), &[&payload.owner, &prefix]).unwrap().iter() {
+    for row in sql::txn_query(sql::Method::BucketList, &mut txn, list_sql.as_str(),
+                              &[&payload.owner,
+                              &prefix]).unwrap().iter() {
+
         let resp = BucketResponse {
             id: row.get(0),
             owner: row.get(1),
@@ -364,8 +368,10 @@ fn get(payload: GetBucketPayload,
 {
     let mut conn = pool.claim().unwrap();
     let sql = get_sql(payload.vnode);
-    (*conn).query(sql.as_str(), &[&payload.owner,
-                                  &payload.name])
+
+    sql::query(sql::Method::BucketGet, &mut conn, sql.as_str(),
+               &[&payload.owner,
+               &payload.name])
         .map_err(|e| {
            let pg_err = format!("{}", e);
             IOError::new(IOErrorKind::Other, pg_err)
@@ -383,9 +389,10 @@ fn create(payload: CreateBucketPayload,
     let create_sql = create_sql(payload.vnode);
 
     let insert_result =
-        txn.query(create_sql.as_str(), &[&Uuid::new_v4(),
-                                      &payload.owner,
-                                      &payload.name])
+        sql::txn_query(sql::Method::BucketCreate, &mut txn, create_sql.as_str(),
+                       &[&Uuid::new_v4(),
+                       &payload.owner,
+                       &payload.name])
         .map_err(|e| {
            let pg_err = format!("{}", e);
             IOError::new(IOErrorKind::Other, pg_err)
@@ -427,11 +434,14 @@ fn delete(payload: DeleteBucketPayload,
     let mut txn = (*conn).transaction().unwrap();
     let move_sql = insert_delete_table_sql(payload.vnode);
     let delete_sql = delete_sql(payload.vnode);
-    txn.execute(move_sql.as_str(), &[&payload.owner,
-                                     &payload.name])
+
+    sql::txn_execute(sql::Method::BucketDeleteMove, &mut txn, move_sql.as_str(),
+                     &[&payload.owner,
+                     &payload.name])
         .and_then(|_moved_rows| {
-            txn.execute(delete_sql.as_str(), &[&payload.owner,
-                                               &payload.name])
+            sql::txn_execute(sql::Method::BucketDelete, &mut txn, delete_sql.as_str(),
+                             &[&payload.owner,
+                             &payload.name])
         })
         .and_then(|row_count| {
             txn.commit().unwrap();
diff --git a/src/lib.rs b/src/lib.rs
index 44e6f03..7a41083 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -6,9 +6,11 @@ pub mod bucket;
 pub mod metrics;
 pub mod object;
 pub mod opts;
+pub mod sql;
 
 pub mod util {
     use std::io::{Error, ErrorKind};
+    use std::time::Instant;
 
     use cueball::connection_pool::ConnectionPool;
     use cueball::backend::Backend;
@@ -35,25 +37,47 @@ pub mod util {
                        pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>,
                        log: &Logger) -> Result<Vec<FastMessage>, Error>
     {
+        let now = Instant::now();
         let response: Vec<FastMessage> = vec![];
 
         metrics::INCOMING_REQUEST_COUNTER.inc();
 
-        match msg.data.d {
-            Value::Array(ref args) => {
-                match msg.data.m.name.as_str() {
-                    "getobject"    => object::get_handler(msg.id, &args, response, &pool, &log),
-                    "createobject" => object::create_handler(msg.id, &args, response, &pool, &log),
-                    "deleteobject" => object::delete_handler(msg.id, &args, response, &pool, &log),
-                    "listobjects"  => object::list_handler(msg.id, &args, response, &pool, &log),
-                    "getbucket"    => bucket::get_handler(msg.id, &args, response, &pool, &log),
-                    "createbucket" => bucket::create_handler(msg.id, &args, response, &pool, &log),
-                    "deletebucket" => bucket::delete_handler(msg.id, &args, response, &pool, &log),
-                    "listbuckets"  => bucket::list_handler(msg.id, &args, response, &pool, &log),
-                    _ => Err(Error::new(ErrorKind::Other, format!("Unsupported functon: {}", msg.data.m.name)))
-                }
+        let args = match msg.data.d {
+            Value::Array(ref args) => args,
+            _ => {
+                return Err(other_error("Expected JSON array"));
             }
-            _ => Err(other_error("Expected JSON array"))
-        }
+        };
+
+        let method = msg.data.m.name.as_str();
+        let ret = match method {
+            "getobject"    => object::get_handler(msg.id, &args, response, &pool, &log),
+            "createobject" => object::create_handler(msg.id, &args, response, &pool, &log),
+            "deleteobject" => object::delete_handler(msg.id, &args, response, &pool, &log),
+            "listobjects"  => object::list_handler(msg.id, &args, response, &pool, &log),
+            "getbucket"    => bucket::get_handler(msg.id, &args, response, &pool, &log),
+            "createbucket" => bucket::create_handler(msg.id, &args, response, &pool, &log),
+            "deletebucket" => bucket::delete_handler(msg.id, &args, response, &pool, &log),
+            "listbuckets"  => bucket::list_handler(msg.id, &args, response, &pool, &log),
+            _ => return Err(Error::new(ErrorKind::Other, format!("Unsupported functon: {}", method)))
+        };
+
+        // If we are here, then the method name was valid, and the request may or
+        // may not have been successful.
+
+        // Generate metrics for the request
+        let duration = now.elapsed();
+        let secs = duration.as_secs() as f64;
+        let ms = duration.subsec_millis() as f64 / 1000 as f64;
+        let t = secs + ms;
+
+        let success = match ret.is_ok() {
+            true => "true",
+            false => "false"
+        };
+
+        metrics::FAST_REQUESTS.with_label_values(&[&method, success]).observe(t);
+
+        ret
     }
 }
diff --git a/src/metrics.rs b/src/metrics.rs
index 304b1d8..ae520f3 100644
--- a/src/metrics.rs
+++ b/src/metrics.rs
@@ -12,7 +12,8 @@ use hyper::server::Server;
 use hyper::service::service_fn_ok;
 use hyper::StatusCode;
 use lazy_static::lazy_static;
-use prometheus::{Counter, Encoder, TextEncoder, labels, opts, register_counter};
+use prometheus::{HistogramVec, Counter, Encoder, TextEncoder, labels, opts, register_counter,
+register_histogram_vec, histogram_opts};
 use slog::{Logger, error, info};
 
 
@@ -27,6 +28,16 @@ lazy_static! {
         "Total number of metrics requests received.",
         labels! {"handler" => "all",}
     )).unwrap();
+    pub static ref FAST_REQUESTS: HistogramVec = register_histogram_vec!(
+        "fast_requests",
+        "Latency of all fast requests processed.",
+        &["method", "success"]
+    ).unwrap();
+    pub static ref POSTGRES_REQUESTS: HistogramVec = register_histogram_vec!(
+        "postgres_requests",
+        "Latency of all postgres requests processed.",
+        &["method", "success"]
+    ).unwrap();
 }
 
 pub fn start_server(address: String, port: u16, log: Logger) {
diff --git a/src/object.rs b/src/object.rs
index 09c07d4..6f721f5 100644
--- a/src/object.rs
+++ b/src/object.rs
@@ -24,6 +24,7 @@ use cueball_postgres_connection::PostgresConnection;
 use rust_fast::protocol::{FastMessage, FastMessageData};
 
 use crate::util::Rows;
+use crate::sql;
 
 type Hstore = HashMap<String, Option<String>>;
 type Timestamptz = chrono::DateTime<chrono::Utc>;
@@ -244,7 +245,11 @@ pub fn list_handler(msg_id: u32,
     let list_sql = list_sql(payload.vnode, payload.limit, payload.offset,
         &payload.order_by);
 
-    for row in txn.query(list_sql.as_str(), &[&payload.owner, &payload.bucket_id, &prefix]).unwrap().iter() {
+    for row in sql::txn_query(sql::Method::ObjectList, &mut txn, list_sql.as_str(),
+                              &[&payload.owner,
+                              &payload.bucket_id,
+                              &prefix]).unwrap().iter() {
+
         let content_md5_bytes: Vec<u8> = row.get(7);
         let content_md5 = base64::encode(&content_md5_bytes);
         let resp = ObjectResponse {
@@ -373,9 +378,11 @@ fn get(payload: GetObjectPayload,
 {
     let mut conn = pool.claim().unwrap();
     let sql = get_sql(payload.vnode);
-    (*conn).query(sql.as_str(), &[&payload.owner,
-                                  &payload.bucket_id,
-                                  &payload.name])
+
+    sql::query(sql::Method::ObjectGet, &mut conn, sql.as_str(),
+               &[&payload.owner,
+               &payload.bucket_id,
+               &payload.name])
         .map_err(|e| {
             let pg_err = format!("{}", e);
             IOError::new(IOErrorKind::Other, pg_err)
@@ -444,20 +451,23 @@ fn create(payload: CreateObjectPayload,
     let create_sql = create_sql(payload.vnode);
     let move_sql = insert_delete_table_sql(payload.vnode);
     let content_md5_bytes = base64::decode(&payload.content_md5).unwrap();
-    txn.execute(move_sql.as_str(), &[&payload.owner,
-                                     &payload.bucket_id,
-                                     &payload.name])
+
+    sql::txn_execute(sql::Method::ObjectCreateMove, &mut txn, move_sql.as_str(),
+                     &[&payload.owner,
+                     &payload.bucket_id,
+                     &payload.name])
         .and_then(|_moved_rows| {
-            txn.query(create_sql.as_str(), &[&payload.id,
-                                             &payload.owner,
-                                             &payload.bucket_id,
-                                             &payload.name,
-                                             &payload.content_length,
-                                             &content_md5_bytes,
-                                             &payload.content_type,
-                                             &payload.headers,
-                                             &payload.sharks,
-                                             &payload.properties])
+            sql::txn_query(sql::Method::ObjectCreate, &mut txn, create_sql.as_str(),
+                           &[&payload.id,
+                           &payload.owner,
+                           &payload.bucket_id,
+                           &payload.name,
+                           &payload.content_length,
+                           &content_md5_bytes,
+                           &payload.content_type,
+                           &payload.headers,
+                           &payload.sharks,
+                           &payload.properties])
         })
         .map_err(|e| {
             let pg_err = format!("{}", e);
@@ -528,13 +538,16 @@ fn delete(payload: DeleteObjectPayload,
     let mut txn = (*conn).transaction().unwrap();
     let move_sql = insert_delete_table_sql(payload.vnode);
     let delete_sql = delete_sql(payload.vnode);
-    txn.execute(move_sql.as_str(), &[&payload.owner,
-                                     &payload.bucket_id,
-                                     &payload.name])
+
+    sql::txn_execute(sql::Method::BucketDeleteMove, &mut txn, move_sql.as_str(),
+                     &[&payload.owner,
+                     &payload.bucket_id,
+                     &payload.name])
         .and_then(|_moved_rows| {
-            txn.execute(delete_sql.as_str(), &[&payload.owner,
-                                               &payload.bucket_id,
-                                               &payload.name])
+            sql::txn_execute(sql::Method::BucketDelete, &mut txn, delete_sql.as_str(),
+                             &[&payload.owner,
+                             &payload.bucket_id,
+                             &payload.name])
         })
         .and_then(|row_count| {
             txn.commit().unwrap();
diff --git a/src/sql.rs b/src/sql.rs
new file mode 100644
index 0000000..c19fa9f
--- /dev/null
+++ b/src/sql.rs
@@ -0,0 +1,119 @@
+/*
+ * Copyright 2019 Joyent, Inc.
+ */
+
+use std::time::Instant;
+use std::vec::Vec;
+
+use postgres::{Transaction, Client, ToStatement};
+use postgres::types::ToSql;
+use tokio_postgres::Error as PGError;
+use tokio_postgres::Row as PGRow;
+
+use crate::metrics;
+
+pub enum Method {
+    BucketCreate,
+    BucketGet,
+    BucketList,
+    BucketDeleteMove,
+    BucketDelete,
+    ObjectCreate,
+    ObjectCreateMove,
+    ObjectGet,
+    ObjectList,
+    ObjectDelete,
+    ObjectDeleteMove
+}
+
+impl Method {
+    fn as_str(&self) -> &str {
+        match self {
+            Method::BucketCreate => "BucketCreate",
+            Method::BucketGet => "BucketGet",
+            Method::BucketList => "BucketList",
+            Method::BucketDeleteMove => "BucketDeleteMove",
+            Method::BucketDelete => "BucketDelete",
+            Method::ObjectCreate => "ObjectCreate",
+            Method::ObjectCreateMove => "ObjectCreateMove",
+            Method::ObjectGet => "ObjectGet",
+            Method::ObjectList => "ObjectList",
+            Method::ObjectDelete => "ObjectDelete",
+            Method::ObjectDeleteMove => "ObjectDeleteMove"
+        }
+    }
+}
+
+// conn.execute wrapper that posts metrics
+pub fn execute<T>(method: Method,
+       conn: &mut Client,
+       sql: &T,
+       items: &[&dyn ToSql])
+       -> Result<u64, PGError>
+       where T: ?Sized + ToStatement,
+{
+    sql_with_metrics(method, || conn.execute(sql, items))
+}
+
+// txn.execute wrapper that posts metrics
+pub fn txn_execute<T>(method: Method,
+       txn: &mut Transaction,
+       sql: &T,
+       items: &[&dyn ToSql])
+       -> Result<u64, PGError>
+       where T: ?Sized + ToStatement,
+{
+    sql_with_metrics(method, || txn.execute(sql, items))
+}
+
+// conn.query wrapper that posts metrics
+pub fn query<T>(method: Method,
+       conn: &mut Client,
+       sql: &T,
+       items: &[&dyn ToSql])
+       -> Result<Vec<PGRow>, PGError>
+       where T: ?Sized + ToStatement,
+{
+    sql_with_metrics(method, || conn.query(sql, items))
+}
+
+// txn.query wrapper that posts metrics
+pub fn txn_query<T>(method: Method,
+       txn: &mut Transaction,
+       sql: &T,
+       items: &[&dyn ToSql])
+       -> Result<Vec<PGRow>, PGError>
+       where T: ?Sized + ToStatement,
+{
+    sql_with_metrics(method, || txn.query(sql, items))
+}
+
+fn sql_with_metrics<F, T>(method: Method,
+    f: F)
+    -> Result<T, PGError>
+    where F: FnOnce() -> Result<T, PGError>,
+{
+    let now = Instant::now();
+
+    let res = f();
+
+    post_timer_metrics(method, now, res.is_ok());
+
+    res
+}
+
+fn post_timer_metrics(method: Method, now: Instant, success: bool)
+{
+    // Generate metrics for the request
+    let duration = now.elapsed();
+    let secs = duration.as_secs() as f64;
+    let ms = duration.subsec_millis() as f64 / 1000 as f64;
+    let t = secs + ms;
+
+    let success = match success {
+        true => "true",
+        false => "false"
+    };
+
+    metrics::POSTGRES_REQUESTS.with_label_values(&[&method.as_str(), success]).observe(t);
+}
