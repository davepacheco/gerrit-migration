commit 46f8347ef2704a099df610666a4ca49f88dabf80 (refs/changes/67/4567/5)
Author: Hans Rosenfeld <hans.rosenfeld@joyent.com>
Date:   2018-08-17T16:32:19+02:00 (1 year, 2 months ago)
    
    OS-6620 bhyve reboot should reuse existing process
    Reviewed by: Patrick Mooney <patrick.mooney@joyent.com>
    Reviewed by: John Levon <john.levon@joyent.com>
    Reviewed by: Jerry Jelinek <jerry.jelinek@joyent.com>
    Approved by: Patrick Mooney <patrick.mooney@joyent.com>

diff --git a/usr/src/lib/brand/bhyve/zone/boot.c b/usr/src/lib/brand/bhyve/zone/boot.c
index 1e2c6771be..4a8b6562a2 100644
--- a/usr/src/lib/brand/bhyve/zone/boot.c
+++ b/usr/src/lib/brand/bhyve/zone/boot.c
@@ -585,8 +585,7 @@ setup_reboot(void)
 		return (-1);
 	}
 
-	if (zone_setattr(zoneid, ZONE_ATTR_INITREBOOT, NULL, 0) < 0 ||
-	    zone_setattr(zoneid, ZONE_ATTR_INITRESTART0, NULL, 0) < 0) {
+	if (zone_setattr(zoneid, ZONE_ATTR_INITRESTART0, NULL, 0) < 0) {
 		(void) printf("Error: bhyve zoneid %ld setattr failed: %s\n",
 		    zoneid, strerror(errno));
 		return (-1);
diff --git a/usr/src/uts/i86pc/io/vmm/vm/vm_object.h b/usr/src/uts/i86pc/io/vmm/vm/vm_object.h
index 9aa7d91cf9..1f16fa9b83 100644
--- a/usr/src/uts/i86pc/io/vmm/vm/vm_object.h
+++ b/usr/src/uts/i86pc/io/vmm/vm/vm_object.h
@@ -22,6 +22,7 @@ vm_object_t vm_object_allocate(objtype_t, vm_pindex_t);
 void vm_object_deallocate(vm_object_t);
 void vm_object_reference(vm_object_t);
 int vm_object_set_memattr(vm_object_t, vm_memattr_t);
+void vm_object_clear(vm_object_t);
 
 
 #define	VM_OBJECT_WLOCK(vmo)	mutex_enter(&(vmo)->vmo_lock)
diff --git a/usr/src/uts/i86pc/io/vmm/vmm.c b/usr/src/uts/i86pc/io/vmm/vmm.c
index 164227cc5e..21ebb38995 100644
--- a/usr/src/uts/i86pc/io/vmm/vmm.c
+++ b/usr/src/uts/i86pc/io/vmm/vmm.c
@@ -276,6 +276,8 @@ static bool sysmem_mapping(struct vm *vm, struct mem_map *mm);
 static void vcpu_notify_event_locked(struct vcpu *vcpu, bool lapic_intr);
 
 #ifndef __FreeBSD__
+static void vm_clear_memseg(struct vm *, int);
+
 typedef struct vm_ioport_hook {
 	list_node_t	vmih_node;
 	uint_t		vmih_ioport;
@@ -661,6 +663,17 @@ vm_cleanup(struct vm *vm, bool destroy)
 		mm = &vm->mem_maps[i];
 		if (destroy || !sysmem_mapping(vm, mm))
 			vm_free_memmap(vm, i);
+#ifndef __FreeBSD__
+		else {
+			/*
+			 * We need to reset the IOMMU flag so this mapping can
+			 * be reused when a VM is rebooted. Since the IOMMU
+			 * domain has already been destroyed we can just reset
+			 * the flag here.
+			 */
+			mm->flags &= ~VM_MEMMAP_F_IOMMU;
+		}
+#endif
 	}
 
 	if (destroy) {
@@ -670,6 +683,15 @@ vm_cleanup(struct vm *vm, bool destroy)
 		VMSPACE_FREE(vm->vmspace);
 		vm->vmspace = NULL;
 	}
+#ifndef __FreeBSD__
+	else {
+		/*
+		 * Clear the first memory segment (low mem), old memory contents
+		 * could confuse the UEFI firmware.
+		 */
+		vm_clear_memseg(vm, 0);
+	}
+#endif
 }
 
 void
@@ -812,6 +834,22 @@ vm_get_memseg(struct vm *vm, int ident, size_t *len, bool *sysmem,
 	return (0);
 }
 
+#ifndef __FreeBSD__
+static void
+vm_clear_memseg(struct vm *vm, int ident)
+{
+	struct mem_seg *seg;
+
+	KASSERT(ident >= 0 && ident < VM_MAX_MEMSEGS,
+	    ("%s: invalid memseg ident %d", __func__, ident));
+
+	seg = &vm->mem_segs[ident];
+
+	if (seg->object != NULL)
+		vm_object_clear(seg->object);
+}
+#endif
+
 void
 vm_free_memseg(struct vm *vm, int ident)
 {
diff --git a/usr/src/uts/i86pc/io/vmm/vmm_sol_vm.c b/usr/src/uts/i86pc/io/vmm/vmm_sol_vm.c
index 11f4c52fd1..520ebf9a22 100644
--- a/usr/src/uts/i86pc/io/vmm/vmm_sol_vm.c
+++ b/usr/src/uts/i86pc/io/vmm/vmm_sol_vm.c
@@ -966,6 +966,15 @@ vm_reserve_pages(size_t npages)
 	}
 }
 
+void
+vm_object_clear(vm_object_t vmo)
+{
+	ASSERT(vmo->vmo_type == OBJT_DEFAULT);
+
+	/* XXXJOY: Better zeroing approach? */
+	bzero(vmo->vmo_data, vmo->vmo_size);
+}
+
 vm_object_t
 vm_object_allocate(objtype_t type, vm_pindex_t psize)
 {
@@ -991,8 +1000,7 @@ vm_object_allocate(objtype_t type, vm_pindex_t psize)
 			kmem_free(vmo, sizeof (*vmo));
 			return (NULL);
 		}
-		/* XXXJOY: Better zeroing approach? */
-		bzero(vmo->vmo_data, size);
+		vm_object_clear(vmo);
 		vmo->vmo_pager = vm_object_pager_heap;
 	}
 		break;
