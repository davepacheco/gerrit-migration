From bdaa8fb1de5abd6f28f68a7685a7b91a1fbb0aa6 Mon Sep 17 00:00:00 2001
From: Hans Rosenfeld <hans.rosenfeld@joyent.com>
Date: Thu, 19 Jul 2018 16:32:24 +0200
Subject: [PATCH] OS-6620 bhyve reboot should reuse existing process

---
 usr/src/lib/brand/bhyve/zone/boot.c     |  3 +--
 usr/src/uts/i86pc/io/vmm/vm/vm_object.h |  1 +
 usr/src/uts/i86pc/io/vmm/vmm.c          | 36 +++++++++++++++++++++++++
 usr/src/uts/i86pc/io/vmm/vmm_sol_vm.c   | 10 +++++--
 usr/src/uts/i86pc/sys/vmm.h             |  3 +++
 5 files changed, 49 insertions(+), 4 deletions(-)

diff --git a/usr/src/lib/brand/bhyve/zone/boot.c b/usr/src/lib/brand/bhyve/zone/boot.c
index e29616a748..29f7c8db49 100644
--- a/usr/src/lib/brand/bhyve/zone/boot.c
+++ b/usr/src/lib/brand/bhyve/zone/boot.c
@@ -579,8 +579,7 @@ setup_reboot(void)
 		return (-1);
 	}
 
-	if (zone_setattr(zoneid, ZONE_ATTR_INITREBOOT, NULL, 0) < 0 ||
-	    zone_setattr(zoneid, ZONE_ATTR_INITRESTART0, NULL, 0) < 0) {
+	if (zone_setattr(zoneid, ZONE_ATTR_INITRESTART0, NULL, 0) < 0) {
 		(void) printf("Error: bhyve zoneid %ld setattr failed: %s\n",
 		    zoneid, strerror(errno));
 		return (-1);
diff --git a/usr/src/uts/i86pc/io/vmm/vm/vm_object.h b/usr/src/uts/i86pc/io/vmm/vm/vm_object.h
index 9aa7d91cf9..1f16fa9b83 100644
--- a/usr/src/uts/i86pc/io/vmm/vm/vm_object.h
+++ b/usr/src/uts/i86pc/io/vmm/vm/vm_object.h
@@ -22,6 +22,7 @@ vm_object_t vm_object_allocate(objtype_t, vm_pindex_t);
 void vm_object_deallocate(vm_object_t);
 void vm_object_reference(vm_object_t);
 int vm_object_set_memattr(vm_object_t, vm_memattr_t);
+void vm_object_clear(vm_object_t);
 
 
 #define	VM_OBJECT_WLOCK(vmo)	mutex_enter(&(vmo)->vmo_lock)
diff --git a/usr/src/uts/i86pc/io/vmm/vmm.c b/usr/src/uts/i86pc/io/vmm/vmm.c
index a4b669ab81..cd50b268f7 100644
--- a/usr/src/uts/i86pc/io/vmm/vmm.c
+++ b/usr/src/uts/i86pc/io/vmm/vmm.c
@@ -661,6 +661,17 @@ vm_cleanup(struct vm *vm, bool destroy)
 		mm = &vm->mem_maps[i];
 		if (destroy || !sysmem_mapping(vm, mm))
 			vm_free_memmap(vm, i);
+#ifndef __FreeBSD__
+		else {
+			/*
+			 * We need to reset the IOMMU flag so this mapping can
+			 * be reused when a VM is rebooted. Since the IOMMU
+			 * domain has already been destroyed we can just reset
+			 * the flag here.
+			 */
+			mm->flags &= ~VM_MEMMAP_F_IOMMU;
+		}
+#endif
 	}
 
 	if (destroy) {
@@ -670,6 +681,15 @@ vm_cleanup(struct vm *vm, bool destroy)
 		VMSPACE_FREE(vm->vmspace);
 		vm->vmspace = NULL;
 	}
+#ifndef __FreeBSD__
+	else {
+		/*
+		 * Clear the first memory segment (low mem), old memory contents
+		 * could confuse the UEFI firmware.
+		 */
+		vm_clear_memseg(vm, 0);
+	}
+#endif
 }
 
 void
@@ -812,6 +832,22 @@ vm_get_memseg(struct vm *vm, int ident, size_t *len, bool *sysmem,
 	return (0);
 }
 
+#ifndef __FreeBSD__
+void
+vm_clear_memseg(struct vm *vm, int ident)
+{
+	struct mem_seg *seg;
+
+	KASSERT(ident >= 0 && ident < VM_MAX_MEMSEGS,
+	    ("%s: invalid memseg ident %d", __func__, ident));
+
+	seg = &vm->mem_segs[ident];
+
+	if (seg->object != NULL)
+		vm_object_clear(seg->object);
+}
+#endif
+
 void
 vm_free_memseg(struct vm *vm, int ident)
 {
diff --git a/usr/src/uts/i86pc/io/vmm/vmm_sol_vm.c b/usr/src/uts/i86pc/io/vmm/vmm_sol_vm.c
index 11f4c52fd1..4a3d894be4 100644
--- a/usr/src/uts/i86pc/io/vmm/vmm_sol_vm.c
+++ b/usr/src/uts/i86pc/io/vmm/vmm_sol_vm.c
@@ -966,6 +966,13 @@ vm_reserve_pages(size_t npages)
 	}
 }
 
+void
+vm_object_clear(vm_object_t vmo)
+{
+	/* XXXJOY: Better zeroing approach? */
+	bzero(vmo->vmo_data, vmo->vmo_size);
+}
+
 vm_object_t
 vm_object_allocate(objtype_t type, vm_pindex_t psize)
 {
@@ -991,8 +998,7 @@ vm_object_allocate(objtype_t type, vm_pindex_t psize)
 			kmem_free(vmo, sizeof (*vmo));
 			return (NULL);
 		}
-		/* XXXJOY: Better zeroing approach? */
-		bzero(vmo->vmo_data, size);
+		vm_object_clear(vmo);
 		vmo->vmo_pager = vm_object_pager_heap;
 	}
 		break;
diff --git a/usr/src/uts/i86pc/sys/vmm.h b/usr/src/uts/i86pc/sys/vmm.h
index bd8126cc0d..a2cb22f378 100644
--- a/usr/src/uts/i86pc/sys/vmm.h
+++ b/usr/src/uts/i86pc/sys/vmm.h
@@ -220,6 +220,9 @@ int vm_set_topology(struct vm *vm, uint16_t sockets, uint16_t cores,
 int vm_mmap_memseg(struct vm *vm, vm_paddr_t gpa, int segid, vm_ooffset_t off,
     size_t len, int prot, int flags);
 int vm_alloc_memseg(struct vm *vm, int ident, size_t len, bool sysmem);
+#ifndef __FreeBSD__
+void vm_clear_memseg(struct vm *vm, int ident);
+#endif
 void vm_free_memseg(struct vm *vm, int ident);
 int vm_map_mmio(struct vm *vm, vm_paddr_t gpa, size_t len, vm_paddr_t hpa);
 int vm_unmap_mmio(struct vm *vm, vm_paddr_t gpa, size_t len);
-- 
2.21.0

