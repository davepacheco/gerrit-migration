commit 9966073ff1bccd55c517460987a9c209d4f534a5
Author: Kelly McLaughlin <kelly.mclaughlin@joyent.com>
Date:   2019-07-30T10:29:47-06:00 (10 weeks ago)
    
    MANTA-4396 Revisit and address uses of unwrap function

diff --git a/Cargo.lock b/Cargo.lock
index 9386ba8..68af16d 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -131,6 +131,8 @@ dependencies = [
  "md5 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)",
  "postgres 0.16.0-rc.1 (registry+https://github.com/rust-lang/crates.io-index)",
  "prometheus 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "quickcheck 0.8.5 (registry+https://github.com/rust-lang/crates.io-index)",
+ "quickcheck_helpers 0.1.0 (git+https://github.com/joyent/rust-quickcheck-helpers)",
  "rust_fast 0.1.0 (git+https://github.com/joyent/rust-fast)",
  "serde 1.0.88 (registry+https://github.com/rust-lang/crates.io-index)",
  "serde_derive 1.0.88 (registry+https://github.com/rust-lang/crates.io-index)",
@@ -316,7 +318,7 @@ dependencies = [
 [[package]]
 name = "cueball"
 version = "0.1.0"
-source = "git+https://github.com/joyent/rust-cueball#a6bfbc762cbeb1b363dd3b9b54485f12535b5b6b"
+source = "git+https://github.com/joyent/rust-cueball#d971425c4535448a69b216d91e8b6cfce200b204"
 dependencies = [
  "base64 0.10.1 (registry+https://github.com/rust-lang/crates.io-index)",
  "derive_more 0.14.0 (registry+https://github.com/rust-lang/crates.io-index)",
@@ -1069,7 +1071,7 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 
 [[package]]
 name = "quickcheck"
-version = "0.8.2"
+version = "0.8.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 dependencies = [
  "env_logger 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)",
@@ -1078,6 +1080,15 @@ dependencies = [
  "rand_core 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
+[[package]]
+name = "quickcheck_helpers"
+version = "0.1.0"
+source = "git+https://github.com/joyent/rust-quickcheck-helpers#52a286ced9d285988deab2738a72b73a4ba81dd3"
+dependencies = [
+ "quickcheck 0.8.5 (registry+https://github.com/rust-lang/crates.io-index)",
+ "rand 0.6.5 (git+https://github.com/rust-random/rand)",
+]
+
 [[package]]
 name = "quote"
 version = "0.6.11"
@@ -1322,7 +1333,7 @@ dependencies = [
  "num 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)",
  "num-derive 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)",
  "num-traits 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)",
- "quickcheck 0.8.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "quickcheck 0.8.5 (registry+https://github.com/rust-lang/crates.io-index)",
  "rand 0.6.5 (git+https://github.com/rust-random/rand)",
  "serde 1.0.88 (registry+https://github.com/rust-lang/crates.io-index)",
  "serde_derive 1.0.88 (registry+https://github.com/rust-lang/crates.io-index)",
@@ -2110,7 +2121,8 @@ dependencies = [
 "checksum prometheus 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)" = "48e3f33ff50a88c73ad8458fa6c22931aa7a6e19bb4a95d62816618c153b3f02"
 "checksum protobuf 2.4.0 (registry+https://github.com/rust-lang/crates.io-index)" = "24d5d73d2b88fddb8b8141f2730d950d88772c940ac4f8f3e93230b9a99d92df"
 "checksum quick-error 1.2.2 (registry+https://github.com/rust-lang/crates.io-index)" = "9274b940887ce9addde99c4eee6b5c44cc494b182b97e73dc8ffdcb3397fd3f0"
-"checksum quickcheck 0.8.2 (registry+https://github.com/rust-lang/crates.io-index)" = "3568ae5409428feef71bf062778bf5acfadc3d496b7696afa829f9eef70e17dc"
+"checksum quickcheck 0.8.5 (registry+https://github.com/rust-lang/crates.io-index)" = "9c35d9c36a562f37eca96e79f66d5fd56eefbc22560dacc4a864cabd2d277456"
+"checksum quickcheck_helpers 0.1.0 (git+https://github.com/joyent/rust-quickcheck-helpers)" = "<none>"
 "checksum quote 0.6.11 (registry+https://github.com/rust-lang/crates.io-index)" = "cdd8e04bd9c52e0342b406469d494fcb033be4bdbe5c606016defbb1681411e1"
 "checksum rand 0.6.5 (git+https://github.com/rust-random/rand)" = "<none>"
 "checksum rand 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)" = "d47eab0e83d9693d40f825f86948aa16eff6750ead4bdffc4ab95b8b3a7f052c"
diff --git a/Cargo.toml b/Cargo.toml
index 8370378..7b39db5 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,7 +22,7 @@ serde = "1.0.84"
 serde_derive = "1.0.84"
 serde_json = "1.0.36"
 slog = { version = "2.4.1", features = [ "max_level_trace" ] }
-slog-bunyan = { git = "https://github.com/slog-rs/bunyan", commmit = "f47d8d77b2017900cc186db0edd07e0be3b8797c" }
+slog-bunyan = { git = "https://github.com/slog-rs/bunyan" }
 tokio = "0.1.14"
 tokio-postgres = "0.4.0-rc.2"
 toml = "0.5"
@@ -32,5 +32,7 @@ uuid = { version = "0.7", features = ["serde", "v4"] }
 rand = { git = 'https://github.com/rust-random/rand' }
 
 [dev-dependencies]
+quickcheck = "0.8.5"
+quickcheck_helpers = { git = "https://github.com/joyent/rust-quickcheck-helpers" }
 slog-term = "2.4.0"
 url = "1.7.2"
diff --git a/src/bucket.rs b/src/bucket.rs
index 6d219d1..def2e12 100644
--- a/src/bucket.rs
+++ b/src/bucket.rs
@@ -1,9 +1,4 @@
-/*
- * Copyright 2019 Joyent, Inc.
- */
-
-use std::io::Error as IOError;
-use std::io::ErrorKind as IOErrorKind;
+// Copyright 2019 Joyent, Inc.
 
 use chrono;
 use serde_derive::{Deserialize, Serialize};
@@ -20,7 +15,7 @@ pub mod list;
 
 type Timestamptz = chrono::DateTime<chrono::Utc>;
 
-#[derive(Serialize, Deserialize)]
+#[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
 pub struct GetBucketPayload {
     pub owner      : Uuid,
     pub name       : String,
@@ -28,9 +23,9 @@ pub struct GetBucketPayload {
     pub request_id : Uuid
 }
 
-type DeleteBucketPayload = GetBucketPayload;
+pub type DeleteBucketPayload = GetBucketPayload;
 
-#[derive(Serialize, Deserialize, Debug)]
+#[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
 pub struct BucketResponse {
     pub id         : Uuid,
     pub owner      : Uuid,
@@ -38,6 +33,14 @@ pub struct BucketResponse {
     pub created    : Timestamptz
 }
 
+pub(self) fn to_json(br: BucketResponse) -> Value {
+    // This conversion can fail if the implementation of Serialize decides to
+    // fail, or if the type contains a map with non-string keys. There is no
+    // reason for the former to occur and we have JSON roundtrip quickcheck
+    // testing to verify this. The BucketResponse type does not contain any maps
+    // so the latter reason for failure is not a concern either.
+    serde_json::to_value(br).expect("failed to serialize BucketResponse")
+}
 
 pub(self) fn bucket_not_found() -> Value {
     // The data for this JSON conversion is locally controlled
@@ -53,23 +56,158 @@ pub(self) fn bucket_already_exists() -> Value {
         .expect("failed to encode a BucketAlreadyExists error")
 }
 
-pub(self) fn response(rows: Rows) -> Result<Option<BucketResponse>, IOError> {
+pub(self) fn response(
+    method: &str,
+    rows: Rows
+) -> Result<Option<BucketResponse>, String>
+{
     if rows.is_empty() {
         Ok(None)
     } else if rows.len() == 1 {
         let row = &rows[0];
+        let cols = row.len();
 
-        //TODO: Valdate # of cols
-        let resp = BucketResponse {
-            id             : row.get(0),
-            owner          : row.get(1),
-            name           : row.get(2),
-            created        : row.get(3)
-        };
-        Ok(Some(resp))
+        if cols >= 4 {
+            let resp = BucketResponse {
+                id             : row.get("id"),
+                owner          : row.get("owner"),
+                name           : row.get("name"),
+                created        : row.get("created")
+            };
+            Ok(Some(resp))
+        } else {
+            let err = format!("{} query returned a row with only {} columns, \
+                               but 4 were expected .", method, cols);
+            Err(err.to_string())
+        }
     } else {
-        let err = format!("Get query found {} results, but expected only 1.",
-                          rows.len());
-        Err(IOError::new(IOErrorKind::Other, err))
+        // The schema should prevent there ever being multiple rows in the query result
+        let err = format!("{} query found {} results, but expected only 1.",
+                          method, rows.len());
+        Err(err.to_string())
+    }
+}
+
+
+#[cfg(test)]
+mod test {
+    use super::*;
+
+    use chrono::prelude::*;
+    use quickcheck::{quickcheck, Arbitrary, Gen};
+    use quickcheck_helpers::random;
+    use serde_json;
+    use serde_json::Map;
+
+    #[derive(Clone, Debug)]
+    struct GetBucketJson(Value);
+    #[derive(Clone, Debug)]
+    struct BucketJson(Value);
+
+    impl Arbitrary for GetBucketJson {
+        fn arbitrary<G: Gen>(g: &mut G) -> Self {
+            let owner = serde_json::to_value(Uuid::new_v4())
+                .expect("failed to convert owner field to Value");
+            let name = serde_json::to_value(random::string(g, 63))
+                .expect("failed to convert name field to Value");
+            let vnode = serde_json::to_value(u64::arbitrary(g))
+                .expect("failed to convert vnode field to Value");
+            let request_id = serde_json::to_value(Uuid::new_v4())
+                .expect("failed to convert request_id field to Value");
+
+            let mut obj = Map::new();
+            obj.insert("owner".into(), owner);
+            obj.insert("name".into(), name);
+            obj.insert("vnode".into(), vnode);
+            obj.insert("request_id".into(), request_id);
+            GetBucketJson(Value::Object(obj))
+        }
+    }
+
+    impl Arbitrary for GetBucketPayload {
+        fn arbitrary<G: Gen>(g: &mut G) -> Self {
+            let owner = Uuid::new_v4();
+            let name = random::string(g, 32);
+            let vnode = u64::arbitrary(g);
+            let request_id = Uuid::new_v4();
+
+            GetBucketPayload {
+                owner,
+                name,
+                vnode,
+                request_id
+            }
+        }
+    }
+
+    impl Arbitrary for BucketResponse {
+        fn arbitrary<G: Gen>(g: &mut G) -> Self {
+            let id = Uuid::new_v4();
+            let owner = Uuid::new_v4();
+            let name = random::string(g, 32);
+            let created = Utc::now();
+
+            BucketResponse {
+                id,
+                owner,
+                name,
+                created
+            }
+        }
+    }
+
+    quickcheck! {
+        fn prop_get_bucket_payload_roundtrip(msg: GetBucketPayload) -> bool {
+            match serde_json::to_string(&msg) {
+                Ok(create_str) => {
+                    let decode_result: Result<GetBucketPayload, _> =
+                        serde_json::from_str(&create_str);
+                    match decode_result {
+                        Ok(decoded_msg) => decoded_msg == msg,
+                        Err(_) => false
+                    }
+                },
+                Err(_) => false
+            }
+        }
+    }
+
+    quickcheck! {
+        fn prop_bucket_response_roundtrip(msg: BucketResponse) -> bool {
+            match serde_json::to_string(&msg) {
+                Ok(response_str) => {
+                    let decode_result: Result<BucketResponse, _> =
+                        serde_json::from_str(&response_str);
+                    match decode_result {
+                        Ok(decoded_msg) => decoded_msg == msg,
+                        Err(_) => false
+                    }
+                },
+                Err(_) => false
+            }
+        }
+    }
+
+    quickcheck! {
+        fn prop_getbucket_payload_from_json(json: GetBucketJson) -> bool {
+            let decode_result1: Result<GetBucketPayload, _> =
+                serde_json::from_value(json.0.clone());
+            let res1 = decode_result1.is_ok();
+
+            let decode_result2: Result<Vec<GetBucketPayload>, _> =
+                serde_json::from_value(Value::Array(vec![json.0]));
+            let res2 = decode_result2.is_ok();
+
+            res1 && res2
+        }
+    }
+
+    quickcheck! {
+        fn prop_bucket_response_to_json(br: BucketResponse) -> bool {
+            // Test the conversion to JSON. A lack of a panic in the call the
+            // `to_json` indicates success.
+            let _ = to_json(br);
+            true
+        }
     }
 }
diff --git a/src/bucket/create.rs b/src/bucket/create.rs
index 54c2d28..55ecafe 100644
--- a/src/bucket/create.rs
+++ b/src/bucket/create.rs
@@ -1,33 +1,30 @@
-/*
- * Copyright 2019 Joyent, Inc.
- */
-
-use std::io::Error as IOError;
-use std::io::ErrorKind as IOErrorKind;
+// Copyright 2019 Joyent, Inc.
 
 use serde_derive::{Deserialize, Serialize};
-use serde_json::Value;
-use slog::{Logger, debug};
+use serde_json::{Value, json};
+use slog::{Logger, debug, error, warn};
 use uuid::Uuid;
 
-use cueball::backend::Backend;
-use cueball::connection_pool::ConnectionPool;
 use cueball_postgres_connection::PostgresConnection;
-use cueball_static_resolver::StaticIpResolver;
 use rust_fast::protocol::{FastMessage, FastMessageData};
 
 use crate::bucket::{
     BucketResponse,
     bucket_already_exists,
-    response
+    response,
+    to_json
 };
 use crate::sql;
 use crate::util::{
+    HandlerError,
+    HandlerResponse,
     array_wrap,
     other_error
 };
 
-#[derive(Serialize, Deserialize)]
+const METHOD: &str = "createbucket";
+
+#[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
 pub struct CreateBucketPayload {
     pub owner      : Uuid,
     pub name       : String,
@@ -35,77 +32,94 @@ pub struct CreateBucketPayload {
     pub request_id : Uuid
 }
 
-pub fn handler(msg_id: u32,
-               args: &[Value],
-               mut response: Vec<FastMessage>,
-               pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>,
-               log: &Logger) -> Result<Vec<FastMessage>, IOError> {
-    debug!(log, "handling createbucket function request");
-
-    let arg0 = match &args[0] {
-        Value::Object(_) => &args[0],
-        _ => return Err(other_error("Expected JSON object"))
-    };
-
-    let data_clone = arg0.clone();
-    let payload_result: Result<CreateBucketPayload, _> =
-        serde_json::from_value(data_clone);
-
-    let payload = match payload_result {
-        Ok(o) => o,
-        Err(_) => return Err(other_error("Failed to parse JSON data as payload for createbucket function"))
-    };
-
-    debug!(log, "parsed CreateBucketPayload, req_id: {}", payload.request_id);
-
-    // Make db request and form response
-    create(payload, pool)
-        .and_then(|maybe_resp| {
-            let method = String::from("createbucket");
-            match maybe_resp {
-                Some(resp) => {
-                    let value = array_wrap(serde_json::to_value(resp).unwrap());
-                    let msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
-                    response.push(msg);
-                    Ok(response)
-                },
-                None => {
-                    let value = array_wrap(bucket_already_exists());
-                    let err_msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
-                    response.push(err_msg);
-                    Ok(response)
-                }
+pub(crate) fn handler(
+    msg_id: u32,
+    data: &Value,
+    mut conn: &mut PostgresConnection,
+    log: &Logger)
+    -> Result<HandlerResponse, HandlerError>
+{
+    debug!(log, "handling {} function request", &METHOD);
+
+    serde_json::from_value::<Vec<CreateBucketPayload>>(data.clone())
+        .map_err(|e| e.to_string())
+        .and_then(|mut arr| {
+            // Remove outer JSON array required by Fast
+            if !arr.is_empty() {
+                Ok(arr.remove(0))
+            } else {
+                let err_msg = "Failed to parse JSON data as payload for \
+                               createbucket function";
+                warn!(log, "{}: {}", err_msg, data);
+                Err(err_msg.to_string())
             }
         })
-        //TODO: Proper error handling
-        .map_err(|_e| other_error("postgres error"))
+        .and_then(|payload| {
+            // Make database request
+            let req_id = payload.request_id;
+            debug!(log, "parsed CreateBucketPayload, req_id: {}", &req_id);
+
+            create(payload, &mut conn)
+                .and_then(|maybe_resp| {
+                    // Handle the successful database response
+                    debug!(log, "{} operation was successful, req_id: {}", &METHOD, &req_id);
+                    let value =
+                        match maybe_resp {
+                            Some(resp) => to_json(resp),
+                            None => bucket_already_exists()
+                        };
+                    let msg_data =
+                        FastMessageData::new(METHOD.into(), array_wrap(value));
+                    let msg: HandlerResponse =
+                        FastMessage::data(msg_id, msg_data).into();
+                    Ok(msg)
+                })
+                .or_else(|e| {
+                    // Handle database error response
+                    error!(log, "{} operation failed: {}, req_id: {}", &METHOD, &e, &req_id);
+
+                    // Database errors are returned to as regular Fast messages
+                    // to be handled by the calling application
+                    let value = array_wrap(json!({
+                        "name": "PostgresError",
+                        "message": e
+                    }));
+
+                    let msg_data = FastMessageData::new(METHOD.into(), value);
+                    let msg: HandlerResponse =
+                        FastMessage::data(msg_id, msg_data).into();
+                    Ok(msg)
+                })
+        })
+        .map_err(|e| HandlerError::IO(other_error(&e)))
 }
 
-fn create(payload: CreateBucketPayload,
-          pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>)
-          -> Result<Option<BucketResponse>, IOError>
+fn create(
+    payload: CreateBucketPayload,
+    conn: &mut PostgresConnection
+) -> Result<Option<BucketResponse>, String>
 {
-    let mut conn = pool.claim().unwrap();
-    let mut txn = (*conn).transaction().unwrap();
+    let mut txn = (*conn).transaction().map_err(|e| e.to_string())?;
     let create_sql = create_sql(payload.vnode);
 
-    let insert_result =
-        sql::txn_query(sql::Method::BucketCreate, &mut txn, create_sql.as_str(),
-                       &[&Uuid::new_v4(),
-                       &payload.owner,
-                       &payload.name])
-        .map_err(|e| {
-           let pg_err = format!("{}", e);
-            IOError::new(IOErrorKind::Other, pg_err)
+    sql::txn_query(sql::Method::BucketCreate, &mut txn, create_sql.as_str(),
+                   &[&Uuid::new_v4(),
+                     &payload.owner,
+                     &payload.name])
+        .and_then(|rows| {
+            txn.commit()?;
+            Ok(rows)
+        })
+        .map_err(|e| e.to_string())
+        .and_then(|rows| {
+            response(METHOD, rows)
         })
-        .and_then(response);
-
-    txn.commit().unwrap();
-
-    insert_result
 }
 
-fn create_sql(vnode: u64) -> String {
+fn create_sql(
+    vnode: u64
+) -> String
+{
     ["INSERT INTO manta_bucket_",
      &vnode.to_string(),
      &".manta_bucket \
@@ -114,3 +128,83 @@ fn create_sql(vnode: u64) -> String {
        ON CONFLICT DO NOTHING \
        RETURNING id, owner, name, created"].concat()
 }
+
+
+#[cfg(test)]
+mod test {
+    use super::*;
+
+    use quickcheck::{quickcheck, Arbitrary, Gen};
+    use quickcheck_helpers::random;
+    use serde_json;
+    use serde_json::Map;
+
+    #[derive(Clone, Debug)]
+    struct CreateBucketJson(Value);
+
+    impl Arbitrary for CreateBucketJson {
+        fn arbitrary<G: Gen>(g: &mut G) -> Self {
+            let owner = serde_json::to_value(Uuid::new_v4())
+                .expect("failed to convert owner field to Value");
+            let name = serde_json::to_value(random::string(g, 63))
+                .expect("failed to convert name field to Value");
+            let vnode = serde_json::to_value(u64::arbitrary(g))
+                .expect("failed to convert vnode field to Value");
+            let request_id = serde_json::to_value(Uuid::new_v4())
+                .expect("failed to convert request_id field to Value");
+
+            let mut obj = Map::new();
+            obj.insert("owner".into(), owner);
+            obj.insert("name".into(), name);
+            obj.insert("vnode".into(), vnode);
+            obj.insert("request_id".into(), request_id);
+            CreateBucketJson(Value::Object(obj))
+        }
+    }
+
+    impl Arbitrary for CreateBucketPayload {
+        fn arbitrary<G: Gen>(g: &mut G) -> Self {
+            let owner = Uuid::new_v4();
+            let name = random::string(g, 32);
+            let vnode = u64::arbitrary(g);
+            let request_id = Uuid::new_v4();
+
+            CreateBucketPayload {
+                owner,
+                name,
+                vnode,
+                request_id
+            }
+        }
+    }
+
+    quickcheck! {
+        fn prop_create_bucket_payload_roundtrip(msg: CreateBucketPayload) -> bool {
+            match serde_json::to_string(&msg) {
+                Ok(create_str) => {
+                    let decode_result: Result<CreateBucketPayload, _> =
+                        serde_json::from_str(&create_str);
+                    match decode_result {
+                        Ok(decoded_msg) => decoded_msg == msg,
+                        Err(_) => false
+                    }
+                },
+                Err(_) => false
+            }
+        }
+    }
+
+    quickcheck! {
+        fn prop_createbucket_payload_from_json(json: CreateBucketJson) -> bool {
+            let decode_result1: Result<CreateBucketPayload, _> =
+                serde_json::from_value(json.0.clone());
+            let res1 = decode_result1.is_ok();
+
+            let decode_result2: Result<Vec<CreateBucketPayload>, _> =
+                serde_json::from_value(Value::Array(vec![json.0]));
+            let res2 = decode_result2.is_ok();
+
+            res1 && res2
+        }
+    }
+}
diff --git a/src/bucket/delete.rs b/src/bucket/delete.rs
index 39d18a5..44ae04d 100644
--- a/src/bucket/delete.rs
+++ b/src/bucket/delete.rs
@@ -1,17 +1,9 @@
-/*
- * Copyright 2019 Joyent, Inc.
- */
+// Copyright 2019 Joyent, Inc.
 
-use std::io::Error as IOError;
-use std::io::ErrorKind as IOErrorKind;
-
-use slog::{Logger, debug};
+use slog::{Logger, debug, error, warn};
 use serde_json::{json, Value};
 
-use cueball::backend::Backend;
-use cueball::connection_pool::ConnectionPool;
 use cueball_postgres_connection::PostgresConnection;
-use cueball_static_resolver::StaticIpResolver;
 use rust_fast::protocol::{FastMessage, FastMessageData};
 
 use crate::bucket::{
@@ -20,96 +12,112 @@ use crate::bucket::{
 };
 use crate::sql;
 use crate::util::{
+    HandlerError,
+    HandlerResponse,
     array_wrap,
     other_error
 };
 
-pub fn handler(msg_id: u32,
-               args: &[Value],
-               mut response: Vec<FastMessage>,
-               pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>,
-               log: &Logger) -> Result<Vec<FastMessage>, IOError> {
-    debug!(log, "handling deletebucket function request");
-
-    let arg0 = match &args[0] {
-        Value::Object(_) => &args[0],
-        _ => return Err(other_error("Expected JSON object"))
-    };
-
-    let data_clone = arg0.clone();
-    let payload_result: Result<DeleteBucketPayload, _> =
-        serde_json::from_value(data_clone);
+const METHOD: &str = "deletebucket";
 
-    let payload = match payload_result {
-        Ok(o) => o,
-        Err(_) => return Err(other_error("Failed to parse JSON data as payload \
-                                          for deletebucket function"))
-    };
-
-    debug!(log, "parsed DeleteBucketPayload, req_id: {}", payload.request_id);
+pub(crate) fn handler(
+    msg_id: u32,
+    data: &Value,
+    mut conn: &mut PostgresConnection,
+    log: &Logger
+) -> Result<HandlerResponse, HandlerError>
+{
+    debug!(log, "handling {} function request", &METHOD);
 
-    // Make db request and form response
-    let response_msg: Result<FastMessage, IOError> =
-        delete(payload, pool)
-        .and_then(|affected_rows| {
-            let method = String::from("deletebucket");
-            if affected_rows > 0 {
-                let value = array_wrap(serde_json::to_value(affected_rows).unwrap());
-                let msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
-                Ok(msg)
+    serde_json::from_value::<Vec<DeleteBucketPayload>>(data.clone())
+        .map_err(|e| e.to_string())
+        .and_then(|mut arr| {
+            // Remove outer JSON array required by Fast
+            if !arr.is_empty(){
+                Ok(arr.remove(0))
             } else {
-                let value = array_wrap(bucket_not_found());
-                let err_msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
-                Ok(err_msg)
+                let err_msg = "Failed to parse JSON data as payload for \
+                               deletebucket function";
+                warn!(log, "{}: {}", err_msg, data);
+                Err(err_msg.to_string())
             }
         })
-        .or_else(|e| {
-            // TODO: Write a helper function to deconstruct the postgres::Error
-            // and populate meaningful name and message fields for the error
-            // dependent on the details of the postgres error.
-            let err_str = format!("{}", e);
-            let value = array_wrap(json!({
-                "name": "PostgresError",
-                "message": err_str
-            }));
-            let method = String::from("deletebucket");
-            let err_msg_data = FastMessageData::new(method, value);
-            let err_msg = FastMessage::error(msg_id, err_msg_data);
-            Ok(err_msg)
-        });
+        .and_then(|payload| {
+            // Make database request
+            let req_id = payload.request_id;
+            debug!(log, "parsed DeleteBucketPayload, req_id: {}", &req_id);
+
+            delete(payload, &mut conn)
+                .and_then(|affected_rows| {
+                    // Handle the successful database response
+                    debug!(log, "deletebucket operation was successful, req_id: {}", &req_id);
+                    let value =
+                        if affected_rows > 0 {
+                            // This conversion can fail if the implementation of
+                            // Serialize decides to fail, or if the type
+                            // contains a map with non-string keys. There is no
+                            // reason for the former to occur and the latter
+                            // reason for failure is not a concern here since
+                            // the type of `affected_rows` is u64.
+                            serde_json::to_value(affected_rows).unwrap()
+                        } else {
+                            bucket_not_found()
+                        };
 
-    response.push(response_msg.unwrap());
-    Ok(response)
+                    let msg_data =
+                        FastMessageData::new(METHOD.into(), array_wrap(value));
+                    let msg: HandlerResponse =
+                        FastMessage::data(msg_id, msg_data).into();
+                    Ok(msg)
+                })
+                .or_else(|e| {
+                    // Handle database error response
+                    error!(log, "{} operation failed: {}, req_id: {}", &METHOD, &e, &req_id);
+
+                    // Database errors are returned to as regular Fast messages
+                    // to be handled by the calling application
+                    let value = array_wrap(json!({
+                        "name": "PostgresError",
+                        "message": e
+                    }));
+
+                    let msg_data = FastMessageData::new(METHOD.into(), value);
+                    let msg: HandlerResponse =
+                        FastMessage::data(msg_id, msg_data).into();
+                    Ok(msg)
+                })
+        })
+        .map_err(|e| HandlerError::IO(other_error(&e)))
 }
 
-fn delete(payload: DeleteBucketPayload,
-          pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>)
-          -> Result<u64, IOError>
+fn delete(
+    payload: DeleteBucketPayload,
+    conn: &mut PostgresConnection
+) -> Result<u64, String>
 {
-    let mut conn = pool.claim().unwrap();
-    let mut txn = (*conn).transaction().unwrap();
+    let mut txn = (*conn).transaction().map_err(|e| e.to_string())?;
     let move_sql = insert_delete_table_sql(payload.vnode);
     let delete_sql = delete_sql(payload.vnode);
 
     sql::txn_execute(sql::Method::BucketDeleteMove, &mut txn, move_sql.as_str(),
                      &[&payload.owner,
-                     &payload.name])
+                       &payload.name])
         .and_then(|_moved_rows| {
             sql::txn_execute(sql::Method::BucketDelete, &mut txn, delete_sql.as_str(),
                              &[&payload.owner,
-                             &payload.name])
+                               &payload.name])
         })
         .and_then(|row_count| {
-            txn.commit().unwrap();
+            txn.commit()?;
             Ok(row_count)
         })
-        .map_err(|e| {
-            let pg_err = format!("{}", e);
-            IOError::new(IOErrorKind::Other, pg_err)
-        })
+        .map_err(|e| e.to_string())
 }
 
-fn insert_delete_table_sql(vnode: u64) -> String {
+fn insert_delete_table_sql(
+    vnode: u64
+) -> String
+{
     let vnode_str = vnode.to_string();
     ["INSERT INTO manta_bucket_",
      &vnode_str,
@@ -123,7 +131,10 @@ fn insert_delete_table_sql(vnode: u64) -> String {
        AND name = $2"].concat()
 }
 
-fn delete_sql(vnode: u64) -> String {
+fn delete_sql(
+    vnode: u64
+) -> String
+{
     ["DELETE FROM manta_bucket_",
      &vnode.to_string(),
      &".manta_bucket \
diff --git a/src/bucket/get.rs b/src/bucket/get.rs
index ef12591..b280182 100644
--- a/src/bucket/get.rs
+++ b/src/bucket/get.rs
@@ -1,93 +1,110 @@
-/*
- * Copyright 2019 Joyent, Inc.
- */
+// Copyright 2019 Joyent, Inc.
 
-use std::io::Error as IOError;
-use std::io::ErrorKind as IOErrorKind;
+use slog::{Logger, debug, error, warn};
+use serde_json::{Value, json};
 
-use slog::{Logger, debug};
-use serde_json::Value;
-
-use cueball::backend::Backend;
-use cueball::connection_pool::ConnectionPool;
 use cueball_postgres_connection::PostgresConnection;
-use cueball_static_resolver::StaticIpResolver;
 use rust_fast::protocol::{FastMessage, FastMessageData};
 
-use crate::bucket::{GetBucketPayload, BucketResponse, bucket_not_found, response};
+use crate::bucket::{
+    GetBucketPayload,
+    BucketResponse,
+    bucket_not_found,
+    response,
+    to_json
+};
 use crate::util::{
+    HandlerError,
+    HandlerResponse,
     array_wrap,
     other_error
 };
 use crate::sql;
 
-pub fn handler(msg_id: u32,
-               args: &[Value],
-               mut response: Vec<FastMessage>,
-               pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>,
-               log: &Logger) -> Result<Vec<FastMessage>, IOError> {
-    debug!(log, "handling getbucket function request");
+const METHOD: &str = "getbucket";
 
-    let arg0 = match &args[0] {
-        Value::Object(_) => &args[0],
-        _ => return Err(other_error("Expected JSON object"))
-    };
+pub(crate) fn handler(
+    msg_id: u32,
+    data: &Value,
+    mut conn: &mut PostgresConnection,
+    log: &Logger
+) -> Result<HandlerResponse, HandlerError>
+{
+    debug!(log, "handling {} function request", &METHOD);
 
-    let data_clone = arg0.clone();
-    let payload_result: Result<GetBucketPayload, _> =
-        serde_json::from_value(data_clone);
+    serde_json::from_value::<Vec<GetBucketPayload>>(data.clone())
+        .map_err(|e| e.to_string())
+        .and_then(|mut arr| {
+            // Remove outer JSON array required by Fast
+            if !arr.is_empty() {
+                Ok(arr.remove(0))
+            } else {
+                let err_msg = "Failed to parse JSON data as payload for \
+                               getbucket function";
+                warn!(log, "{}: {}", err_msg, data);
+                Err(err_msg.to_string())
+            }
+        })
+        .and_then(|payload| {
+            // Make database request
+            let req_id = payload.request_id;
+            debug!(log, "parsed GetBucketPayload, req_id: {}", &req_id);
 
-    let payload = match payload_result {
-        Ok(o) => o,
-        Err(_) => return Err(other_error("Failed to parse JSON data as payload for getbucket function"))
-    };
+            get(payload, &mut conn)
+                .and_then(|maybe_resp| {
+                    // Handle the successful database response
+                    debug!(log, "{} operation was successful, req_id: {}", &METHOD, &req_id);
+                    let value =
+                        match maybe_resp {
+                            Some(resp) => to_json(resp),
+                            None => bucket_not_found()
+                        };
+                    let msg_data =
+                        FastMessageData::new(METHOD.into(), array_wrap(value));
+                    let msg: HandlerResponse =
+                        FastMessage::data(msg_id, msg_data).into();
+                    Ok(msg)
+                })
+                .or_else(|e| {
+                    // Handle database error response
+                    error!(log, "{} operation failed: {}, req_id: {}", &METHOD, &e, &req_id);
 
-    debug!(log, "parsed GetBucketPayload, req_id: {}", payload.request_id);
+                    // Database errors are returned to as regular Fast messages
+                    // to be handled by the calling application
+                    let value = array_wrap(json!({
+                        "name": "PostgresError",
+                        "message": e
+                    }));
 
-    // Make db request and form response
-    get(payload, pool)
-        .and_then(|maybe_resp| {
-            let method = String::from("getbucket");
-            match maybe_resp {
-                Some(resp) => {
-                    let value = array_wrap(serde_json::to_value(resp).unwrap());
-                    let msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
-                    response.push(msg);
-                    Ok(response)
-                },
-                None => {
-                    let value = array_wrap(bucket_not_found());
-                    let err_msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
-                    response.push(err_msg);
-                    Ok(response)
-                }
-            }
-        })
-        //TODO: Proper error handling
-        .map_err(|e| {
-            println!("Error: {}", e);
-            other_error("postgres error")
+                    let msg_data = FastMessageData::new(METHOD.into(), value);
+                    let msg: HandlerResponse =
+                        FastMessage::data(msg_id, msg_data).into();
+                    Ok(msg)
+                })
         })
+        .map_err(|e| HandlerError::IO(other_error(&e)))
 }
 
-fn get(payload: GetBucketPayload,
-       pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>)
-       -> Result<Option<BucketResponse>, IOError>
+fn get(
+    payload: GetBucketPayload,
+    mut conn: &mut PostgresConnection
+) -> Result<Option<BucketResponse>, String>
 {
-    let mut conn = pool.claim().unwrap();
     let sql = get_sql(payload.vnode);
 
     sql::query(sql::Method::BucketGet, &mut conn, sql.as_str(),
                &[&payload.owner,
-               &payload.name])
-        .map_err(|e| {
-           let pg_err = format!("{}", e);
-            IOError::new(IOErrorKind::Other, pg_err)
+                 &payload.name])
+        .map_err(|e| e.to_string())
+        .and_then(|rows| {
+            response(METHOD, rows)
         })
-        .and_then(response)
 }
 
-fn get_sql(vnode: u64) -> String {
+fn get_sql(
+    vnode: u64
+) -> String
+{
     ["SELECT id, owner, name, created \
       FROM manta_bucket_",
      &vnode.to_string(),
diff --git a/src/bucket/list.rs b/src/bucket/list.rs
index 7167c4d..b79f4ef 100644
--- a/src/bucket/list.rs
+++ b/src/bucket/list.rs
@@ -1,31 +1,28 @@
-/*
- * Copyright 2019 Joyent, Inc.
- */
-
-use std::io::Error as IOError;
+// Copyright 2019 Joyent, Inc.
 
 use serde_derive::{Deserialize, Serialize};
-use serde_json::Value;
-use slog::{Logger, debug};
+use serde_json::{Value, json};
+use slog::{Logger, debug, error, warn};
 use uuid::Uuid;
 
-use cueball::backend::Backend;
-use cueball::connection_pool::ConnectionPool;
 use cueball_postgres_connection::PostgresConnection;
-use cueball_static_resolver::StaticIpResolver;
 use rust_fast::protocol::{FastMessage, FastMessageData};
 
-use tokio_postgres::Error as PGError;
-use tokio_postgres::Row as PGRow;
-
-use crate::bucket::BucketResponse;
+use crate::bucket::{
+    BucketResponse,
+    to_json
+};
 use crate::sql;
 use crate::util::{
+    HandlerError,
+    HandlerResponse,
     array_wrap,
     other_error
 };
 
-#[derive(Serialize, Deserialize)]
+const METHOD: &str = "listbuckets";
+
+#[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
 pub struct ListBucketsPayload {
     pub owner      : Uuid,
     pub vnode      : u64,
@@ -35,78 +32,128 @@ pub struct ListBucketsPayload {
     pub request_id : Uuid
 }
 
-pub fn handler(msg_id: u32,
-               args: &[Value],
-               mut response: Vec<FastMessage>,
-               pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>,
-               log: &Logger) -> Result<Vec<FastMessage>, IOError> {
-    debug!(log, "handling listbuckets function request");
-
-    let arg0 = match &args[0] {
-        Value::Object(_) => &args[0],
-        _ => return Err(other_error("Expected JSON object"))
-    };
-
-    let data_clone = arg0.clone();
-    let payload_result: Result<ListBucketsPayload, _> =
-        serde_json::from_value(data_clone);
-
-    let payload = match payload_result {
-        Ok(o) => o,
-        Err(_) => return Err(other_error("Failed to parse JSON data as payload for listbuckets function"))
-    };
-
-    debug!(log, "parsed ListBucketPayload, req_id: {}", payload.request_id);
-
-    // TODO catch these as errors and return to the caller
-    assert!(payload.limit > 0);
-    assert!(payload.limit <= 1000);
-
-    // Make db request and form response
-    // TODO: make this call safe
-    let mut conn = pool.claim().unwrap();
-    let mut txn = (*conn).transaction().unwrap();
-    let query: Result<Vec<PGRow>, PGError>;
-
-    match (payload.marker, payload.prefix) {
-        (Some(marker), Some(prefix)) => {
-            let sql = list_sql_prefix_marker(payload.vnode, payload.limit);
-            let prefix = format!("{}%", prefix);
-            query = sql::txn_query(sql::Method::BucketList, &mut txn, sql.as_str(),
-                &[&payload.owner, &prefix, &marker]);
-        }
-        (Some(marker), None) => {
-            let sql = list_sql_marker(payload.vnode, payload.limit);
-            query = sql::txn_query(sql::Method::BucketList, &mut txn, sql.as_str(),
-                &[&payload.owner, &marker]);
-        }
-        (None, Some(prefix)) => {
-            let sql = list_sql_prefix(payload.vnode, payload.limit);
-            let prefix = format!("{}%", prefix);
-            query = sql::txn_query(sql::Method::BucketList, &mut txn, sql.as_str(),
-                &[&payload.owner, &prefix]);
-        }
-        (None, None) => {
-            let sql = list_sql(payload.vnode, payload.limit);
-            query = sql::txn_query(sql::Method::BucketList, &mut txn, sql.as_str(),
-                &[&payload.owner]);
-        }
-    }
+pub(crate) fn handler(
+    msg_id: u32,
+    data: &Value,
+    mut conn: &mut PostgresConnection,
+    log: &Logger
+) -> Result<HandlerResponse, HandlerError>
+{
+    debug!(log, "handling {} function request", &METHOD);
+
+    serde_json::from_value::<Vec<ListBucketsPayload>>(data.clone())
+        .map_err(|e| e.to_string())
+        .and_then(|mut arr| {
+            // Remove outer JSON array required by Fast
+            if !arr.is_empty() {
+                Ok(arr.remove(0))
+            } else {
+                let err_msg = "Failed to parse JSON data as payload for \
+                               getbucket function";
+                warn!(log, "{}: {}", err_msg, data);
+                Err(err_msg.to_string())
+            }
+        })
+        .and_then(|payload| {
+            // Make database request
+            let req_id = payload.request_id;
+            debug!(log, "parsed ListBucketsPayload, req_id: {}", &req_id);
 
-    for row in query.unwrap().iter() {
-        let resp = BucketResponse {
-            id: row.get(0),
-            owner: row.get(1),
-            name: row.get(2),
-            created: row.get(3)
+            if payload.limit > 0 && payload.limit <= 1024 {
+                list(msg_id, payload, &mut conn)
+                    .and_then(|resp| {
+                        // Handle the successful database response
+                        debug!(log, "{} operation was successful, req_id: {}", &METHOD, &req_id);
+                        Ok(HandlerResponse::from(resp))
+                    })
+                    .or_else(|e| {
+                        // Handle database error response
+                        error!(log, "{} operation failed: {}, req_id: {}", &METHOD, &e, &req_id);
+
+                        // Database errors are returned to as regular Fast messages
+                        // to be handled by the calling application
+                        let value = array_wrap(json!({
+                            "name": "PostgresError",
+                            "message": e
+                        }));
+                        let msg_data = FastMessageData::new(METHOD.into(), value);
+                        let msg: HandlerResponse =
+                            FastMessage::data(msg_id, msg_data).into();
+                        Ok(msg)
+                    })
+            } else {
+                // Limit constraint violations are returned to as regular
+                // Fast messages to be handled by the calling application
+                let e = format!("the {} limit option must be a value between 1 \
+                                 and 1024. the requested limit was {}, req_id: \
+                                 {}", &METHOD, &payload.limit, &req_id);
+                let value = array_wrap(json!({
+                    "name": "LimitConstraintError",
+                    "message": e
+                }));
+                let msg_data = FastMessageData::new(METHOD.into(), value);
+                let msg: HandlerResponse =
+                    FastMessage::data(msg_id, msg_data).into();
+                Ok(msg)
+            }
+        })
+        .map_err(|e| HandlerError::IO(other_error(&e)))
+}
+
+fn list(
+    msg_id: u32,
+    payload: ListBucketsPayload,
+    mut conn: &mut PostgresConnection
+) -> Result<Vec<FastMessage>, String>
+{
+    let query_result =
+        match (payload.marker, payload.prefix) {
+            (Some(marker), Some(prefix)) => {
+                let sql = list_sql_prefix_marker(payload.vnode, payload.limit);
+                let prefix = format!("{}%", prefix);
+                sql::query(sql::Method::BucketList, &mut conn, sql.as_str(),
+                           &[&payload.owner, &prefix, &marker])
+            }
+            (Some(marker), None) => {
+                let sql = list_sql_marker(payload.vnode, payload.limit);
+                sql::query(sql::Method::BucketList, &mut conn, sql.as_str(),
+                           &[&payload.owner, &marker])
+            }
+            (None, Some(prefix)) => {
+                let sql = list_sql_prefix(payload.vnode, payload.limit);
+                let prefix = format!("{}%", prefix);
+                sql::query(sql::Method::BucketList, &mut conn, sql.as_str(),
+                           &[&payload.owner, &prefix])
+            }
+            (None, None) => {
+                let sql = list_sql(payload.vnode, payload.limit);
+                sql::query(sql::Method::BucketList, &mut conn, sql.as_str(),
+                           &[&payload.owner])
+            }
         };
 
-        let value = array_wrap(serde_json::to_value(resp).unwrap());
-        let msg = FastMessage::data(msg_id, FastMessageData::new(String::from("listbuckets"), value));
-        response.push(msg);
-    }
+    let mut msgs: Vec<FastMessage> = Vec::with_capacity(1024);
+
+    query_result
+        .map_err(|e| e.to_string())
+        .and_then(|rows| {
+            for row in rows.iter() {
+                let resp = BucketResponse {
+                    id: row.get("id"),
+                    owner: row.get("owner"),
+                    name: row.get("name"),
+                    created: row.get("created")
+                };
 
-    Ok(response)
+                let value = to_json(resp);
+                let msg_data =
+                    FastMessageData::new(METHOD.into(), array_wrap(value));
+                let msg = FastMessage::data(msg_id, msg_data);
+
+                msgs.push(msg);
+            }
+            Ok(msgs)
+        })
 }
 
 fn list_sql_prefix_marker(vnode: u64, limit: u64) -> String {
@@ -143,3 +190,93 @@ fn list_sql(vnode: u64, limit: u64) -> String {
         LIMIT {}",
         vnode, limit)
 }
+
+
+#[cfg(test)]
+mod test {
+    use super::*;
+
+    use quickcheck::{quickcheck, Arbitrary, Gen};
+    use quickcheck_helpers::random;
+    use serde_json;
+    use serde_json::Map;
+
+    #[derive(Clone, Debug)]
+    struct ListBucketsJson(Value);
+
+    impl Arbitrary for ListBucketsJson {
+        fn arbitrary<G: Gen>(g: &mut G) -> Self {
+            let owner = serde_json::to_value(Uuid::new_v4())
+                .expect("failed to convert owner field to Value");
+            let vnode = serde_json::to_value(u64::arbitrary(g))
+                .expect("failed to convert vnode field to Value");
+            let prefix = serde_json::to_value(random::string(g, 32))
+                .expect("failed to convert prefix field to Value");
+            let limit = serde_json::to_value(u64::arbitrary(g))
+                .expect("failed to convert limit field to Value");
+            let marker = serde_json::to_value(random::string(g, 32))
+                .expect("failed to convert marker field to Value");
+            let request_id = serde_json::to_value(Uuid::new_v4())
+                .expect("failed to convert request_id field to Value");
+
+            let mut obj = Map::new();
+            obj.insert("owner".into(), owner);
+            obj.insert("vnode".into(), vnode);
+            obj.insert("prefix".into(), prefix);
+            obj.insert("limit".into(), limit);
+            obj.insert("marker".into(), marker);
+            obj.insert("request_id".into(), request_id);
+            ListBucketsJson(Value::Object(obj))
+        }
+    }
+
+    impl Arbitrary for ListBucketsPayload {
+        fn arbitrary<G: Gen>(g: &mut G) -> Self {
+            let owner = Uuid::new_v4();
+            let vnode = u64::arbitrary(g);
+            let prefix = Some(random::string(g, 32));
+            let limit = u64::arbitrary(g);
+            let marker = Some(random::string(g, 32));
+            let request_id = Uuid::new_v4();
+
+            ListBucketsPayload {
+                owner,
+                vnode,
+                prefix,
+                limit,
+                marker,
+                request_id
+            }
+        }
+    }
+
+    quickcheck! {
+        fn prop_list_bucket_payload_roundtrip(msg: ListBucketsPayload) -> bool {
+            match serde_json::to_string(&msg) {
+                Ok(list_str) => {
+                    let decode_result: Result<ListBucketsPayload, _> =
+                        serde_json::from_str(&list_str);
+                    match decode_result {
+                        Ok(decoded_msg) => decoded_msg == msg,
+                        Err(_) => false
+                    }
+                },
+                Err(_) => false
+            }
+        }
+    }
+
+    quickcheck! {
+        fn prop_listbucket_payload_from_json(json: ListBucketsJson) -> bool {
+            let decode_result1: Result<ListBucketsPayload, _> =
+                serde_json::from_value(json.0.clone());
+            let res1 = decode_result1.is_ok();
+
+            let decode_result2: Result<Vec<ListBucketsPayload>, _> =
+                serde_json::from_value(Value::Array(vec![json.0]));
+            let res2 = decode_result2.is_ok();
+
+            res1 && res2
+        }
+    }
+}
diff --git a/src/config.rs b/src/config.rs
index 250b953..9037a70 100644
--- a/src/config.rs
+++ b/src/config.rs
@@ -9,7 +9,7 @@
 /// file specified with `-c <config>`, and then overridden again by specific
 /// command line arguments.
 
-
+use std::convert::Into;
 use std::ffi::OsStr;
 use std::fs;
 use std::path::{Path, PathBuf};
@@ -231,24 +231,32 @@ pub fn read_file<F: AsRef<OsStr> + ?Sized>(f: &F) -> Config
 
 pub fn read_cli_args(matches: &ArgMatches, config: &mut Config) {
     value_t!(matches, "level", LogLevel)
-        .map(|l| config.log.level = l.into())
+        .map(|l| config.log.level = l)
         .unwrap_or_else(|_| ());
 
-    matches.value_of("address").map(|a| config.server.host = a.into());
+    if let Some(a) = matches.value_of("address") {
+        config.server.host = a.into();
+    }
 
     value_t!(matches, "port", u16)
         .map(|p| config.server.port = p)
         .unwrap_or_else(|_| ());
 
-    matches.value_of("pg ip").map(|h| config.database.host = h.into());
+    if let Some(h) = matches.value_of("pg ip") {
+        config.database.host = h.into();
+    }
 
     value_t!(matches, "pg port", u16)
         .map(|p| config.database.port = p)
         .unwrap_or_else(|_| ());
 
-    matches.value_of("pg database").map(|db| config.database.database = db.into());
+    if let Some(db) = matches.value_of("pg database") {
+        config.database.database = db.into();
+    }
 
-    matches.value_of("metrics-address").map(|h| config.metrics.host = h.into());
+    if let Some(h) = matches.value_of("metrics-address") {
+        config.metrics.host = h.into();
+    }
 
     value_t!(matches, "metrics-port", u16)
         .map(|p| config.metrics.port = p)
@@ -347,13 +355,13 @@ pub mod tls {
 
         o_p.ok_or(TlsError::NoCertificate)
             .and_then(|p| {
-                File::open(p).map_err(|e| e.into())
+                File::open(p).map_err(Into::into)
             })
             .and_then(|mut f| {
-                f.read_to_end(&mut buf).map_err(|e| e.into())
+                f.read_to_end(&mut buf).map_err(Into::into)
             })
             .and_then(|_| {
-                read_certificate(&buf).map_err(|e| e.into())
+                read_certificate(&buf).map_err(Into::into)
             })
     }
 
diff --git a/src/lib.rs b/src/lib.rs
index 5a4f269..d83d433 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -1,6 +1,4 @@
-/*
- * Copyright 2019 Joyent, Inc.
- */
+// Copyright 2019 Joyent, Inc.
 
 pub mod bucket;
 pub mod error;
@@ -11,19 +9,21 @@ pub mod sql;
 
 pub mod util {
     use std::collections::HashMap;
-    use std::io::{Error, ErrorKind};
+    use std::io::Error as IOError;
+    use std::io::ErrorKind;
     use std::time::{Duration, Instant};
 
     use postgres::error::Error as PGError;
     use postgres::row::Row;
-    use serde_json::Value;
-    use slog::Logger;
+    use serde_json::{Value, json};
+    use slog::{Logger, error, warn};
 
-    use cueball::connection_pool::ConnectionPool;
     use cueball::backend::Backend;
+    use cueball::connection_pool::ConnectionPool;
+    use cueball::error::Error as CueballError;
     use cueball_postgres_connection::PostgresConnection;
     use cueball_static_resolver::StaticIpResolver;
-    use rust_fast::protocol::FastMessage;
+    use rust_fast::protocol::{FastMessage, FastMessageData};
 
     use crate::bucket;
     use crate::metrics;
@@ -34,63 +34,152 @@ pub mod util {
     pub type Hstore = HashMap<String, Option<String>>;
     pub type Timestamptz = chrono::DateTime<chrono::Utc>;
 
-    pub fn msg_handler(msg: &FastMessage,
-                       pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>,
-                       log: &Logger) -> Result<Vec<FastMessage>, Error>
+    pub(crate) enum HandlerError {
+        Cueball(CueballError),
+        IO(IOError)
+    }
+
+    pub(crate) enum HandlerResponse {
+        Message(FastMessage),
+        Messages(Vec<FastMessage>)
+    }
+
+    impl From<FastMessage> for HandlerResponse {
+        fn from(fm: FastMessage) -> Self {
+            HandlerResponse::Message(fm)
+        }
+    }
+
+    impl From<Vec<FastMessage>> for HandlerResponse {
+        fn from(fms: Vec<FastMessage>) -> Self {
+            HandlerResponse::Messages(fms)
+        }
+    }
+
+    pub fn msg_handler(
+        msg: &FastMessage,
+        pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>,
+        log: &Logger
+    ) -> Result<Vec<FastMessage>, IOError>
     {
         let now = Instant::now();
-        let response: Vec<FastMessage> = vec![];
+        let mut response: Vec<FastMessage> = vec![];
 
         metrics::INCOMING_REQUEST_COUNTER.inc();
 
-        let args = match msg.data.d {
-            Value::Array(ref args) => args,
-            _ => {
-                return Err(other_error("Expected JSON array"));
-            }
-        };
-
+        let mut connection_acquired = true;
         let method = msg.data.m.name.as_str();
-        let ret = match method {
-            "getobject"    =>
-                object::get::handler(msg.id, &args, response, &pool, &log),
-            "createobject" =>
-                object::create::handler(msg.id, &args, response, &pool, &log),
-            "updateobject" =>
-                object::update::handler(msg.id, &args, response, &pool, &log),
-            "deleteobject" =>
-                object::delete::handler(msg.id, &args, response, &pool, &log),
-            "listobjects"  =>
-                object::list::handler(msg.id, &args, response, &pool, &log),
-            "getbucket"    =>
-                bucket::get::handler(msg.id, &args, response, &pool, &log),
-            "createbucket" =>
-                bucket::create::handler(msg.id, &args, response, &pool, &log),
-            "deletebucket" =>
-                bucket::delete::handler(msg.id, &args, response, &pool, &log),
-            "listbuckets"  =>
-                bucket::list::handler(msg.id, &args, response, &pool, &log),
-            _ => {
-                let err_msg = format!("Unsupported functon: {}", method);
-                return Err(Error::new(ErrorKind::Other, err_msg))
-            }
-        };
-
-        // If we are here, then the method name was valid, and the request may or
-        // may not have been successful.
-
-        // Generate metrics for the request
-        let duration = now.elapsed();
-        let t = duration_to_seconds(duration);
-
-        let success = match ret.is_ok() {
-            true => "true",
-            false => "false"
-        };
-
-        metrics::FAST_REQUESTS.with_label_values(&[&method, success]).observe(t);
-
-        ret
+
+        pool.claim()
+            .map_err(HandlerError::Cueball)
+            .and_then(|mut conn| {
+                // Dispatch the request to the proper handler
+                match method {
+                    "getobject"    =>
+                        object::get::handler(msg.id, &msg.data.d, &mut conn, &log),
+                    "createobject" =>
+                        object::create::handler(msg.id, &msg.data.d, &mut conn, &log),
+                    "updateobject" =>
+                        object::update::handler(msg.id, &msg.data.d, &mut conn, &log),
+                    "deleteobject" =>
+                        object::delete::handler(msg.id, &msg.data.d, &mut conn, &log),
+                    "listobjects"  =>
+                        object::list::handler(msg.id, &msg.data.d, &mut conn, &log),
+                    "getbucket"    =>
+                        bucket::get::handler(msg.id, &msg.data.d, &mut conn, &log),
+                    "createbucket" =>
+                        bucket::create::handler(msg.id, &msg.data.d, &mut conn, &log),
+                    "deletebucket" =>
+                        bucket::delete::handler(msg.id, &msg.data.d, &mut conn, &log),
+                    "listbuckets"  =>
+                        bucket::list::handler(msg.id, &msg.data.d, &mut conn, &log),
+                    _ => {
+                        let err_msg = format!("Unsupported functon: {}", method);
+                        Err(HandlerError::IO(other_error(&err_msg)))
+                    }
+                }
+            })
+            .or_else(|err| {
+                // An error occurred while attempting to acquire a connection
+                // from the connection pool.
+                connection_acquired = false;
+                match err {
+                    HandlerError::Cueball(CueballError::ClaimFailure) => {
+                        // If the error was due to a claim timeout return an
+                        // application level error indicating the service is
+                        // overloade as a normal Fast message so the calling
+                        // application can take appropriate action.
+                        warn!(log, "{}", CueballError::ClaimFailure);
+                        let value = array_wrap(json!({
+                            "name": "OverloadedError",
+                            "message": CueballError::ClaimFailure.to_string()
+                        }));
+
+                        let msg_data = FastMessageData::new(method.into(), value);
+                        let msg: HandlerResponse =
+                            FastMessage::data(msg.id, msg_data).into();
+                        Ok(msg)
+                    },
+                    HandlerError::Cueball(err) => {
+                        // Any other connection pool errors are unexpected in
+                        // this context so log loudly and return an error.
+                        error!(log, "{}", err);
+                        Err(HandlerError::Cueball(err))
+                    },
+                    err => Err(err)
+                }
+            })
+            .and_then(|res| {
+                // Add application level response to the `response` vector
+                match res {
+                    HandlerResponse::Message(msg) =>
+                        response.push(msg),
+                    HandlerResponse::Messages(mut msgs) =>
+                        response.append(&mut msgs)
+                }
+                Ok(response)
+            })
+            .and_then(|res| {
+                // If we are here the request was successful or we failed to get
+                // a connection prior to the connection claim timeout.
+
+                // Generate metrics for the request
+                let duration = now.elapsed();
+                let t = duration_to_seconds(duration);
+
+                let success =
+                    if connection_acquired {
+                        "true"
+                    } else {
+                        "false"
+                    };
+
+                metrics::FAST_REQUESTS
+                    .with_label_values(&[&method, success])
+                    .observe(t);
+
+                Ok(res)
+            })
+            .or_else(|err| {
+                // If we are here, then the request failed
+
+                // Generate metrics for the request
+                let duration = now.elapsed();
+                let t = duration_to_seconds(duration);
+
+                metrics::FAST_REQUESTS
+                    .with_label_values(&[&method, "false"])
+                    .observe(t);
+
+                let ret_err = match err {
+                    HandlerError::Cueball(cueball_err) => {
+                        other_error(cueball_err.to_string().as_str())
+                    },
+                    HandlerError::IO(io_err) => io_err
+                };
+
+                Err(ret_err)
+            })
     }
 
     pub(crate) fn duration_to_seconds(d: Duration) -> f64 {
@@ -102,7 +191,7 @@ pub mod util {
         Value::Array(vec![v])
     }
 
-    pub(crate) fn other_error(msg: &str) -> Error {
-        Error::new(ErrorKind::Other, String::from(msg))
+    pub(crate) fn other_error(msg: &str) -> IOError {
+        IOError::new(ErrorKind::Other, String::from(msg))
     }
 }
diff --git a/src/main.rs b/src/main.rs
index 683af72..aee1c6e 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,6 +1,4 @@
-/*
- * Copyright 2019 Joyent, Inc.
- */
+// Copyright 2019 Joyent, Inc.
 
 pub mod config;
 
@@ -61,7 +59,7 @@ fn main() {
     // Configure and start metrics server
     let metrics_log = root_log.clone();
     let metrics_host = config.metrics.host.clone();
-    let metrics_port = config.metrics.port.clone();
+    let metrics_port = config.metrics.port;
     thread::spawn(move || boray::metrics::start_server(metrics_host,
                                                        metrics_port,
                                                        metrics_log));
@@ -72,7 +70,7 @@ fn main() {
         config::tls::tls_config(config.database.tls_mode,
                                 config.database.certificate)
         .unwrap_or_else(|e| {
-            eprintln!("TLS configuration error: {}", e);
+            error!(root_log, "TLS configuration error: {}", e);
             std::process::exit(1);
         });
 
@@ -83,7 +81,7 @@ fn main() {
         port: Some(config.database.port),
         database: Some(config.database.database),
         application_name: Some(config.database.application_name),
-        tls_config: tls_config
+        tls_config
     };
 
     let connection_creator = PostgresConnection::connection_creator(pg_config);
diff --git a/src/object.rs b/src/object.rs
index d5a1584..035ab4d 100644
--- a/src/object.rs
+++ b/src/object.rs
@@ -1,10 +1,6 @@
-/*
- * Copyright 2019 Joyent, Inc.
- */
+// Copyright 2019 Joyent, Inc.
 
 use std::error::Error;
-use std::io::Error as IOError;
-use std::io::ErrorKind as IOErrorKind;
 use std::vec::Vec;
 
 use base64;
@@ -27,7 +23,7 @@ pub mod get;
 pub mod list;
 pub mod update;
 
-#[derive(Debug, Serialize, Deserialize)]
+#[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
 pub struct GetObjectPayload {
     pub owner      : Uuid,
     pub bucket_id  : Uuid,
@@ -50,7 +46,7 @@ type DeleteObjectPayload = GetObjectPayload;
 /// Likewise, the custom FromSql instance for the type converts the members of
 /// the text array format stored in the database back into an instance of
 /// StorageNodeIdentifier.
-#[derive(Debug, Serialize, Deserialize)]
+#[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
 pub struct StorageNodeIdentifier {
     pub datacenter: String,
     pub manta_storage_id: String
@@ -95,7 +91,7 @@ impl<'a> FromSql<'a> for StorageNodeIdentifier {
     accepts!(TEXT);
 }
 
-#[derive(Debug, Serialize, Deserialize)]
+#[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
 pub struct ObjectResponse {
     pub id             : Uuid,
     pub owner          : Uuid,
@@ -111,6 +107,15 @@ pub struct ObjectResponse {
     pub properties     : Option<Value>
 }
 
+pub(self) fn to_json(objr: ObjectResponse) -> Value {
+    // This conversion can fail if the implementation of Serialize decides to
+    // fail, or if the type contains a map with non-string keys. There is no
+    // reason for the former to occur and we have JSON roundtrip quickcheck
+    // testing to verify this. The ObjectResponse type does not contain any maps
+    // so the latter reason for failure is not a concern either.
+    serde_json::to_value(objr).expect("failed to serialize ObjectResponse")
+}
+
 pub(self) fn object_not_found() -> Value {
     // The data for this JSON conversion is locally controlled
     // so unwrapping the result is ok here.
@@ -118,33 +123,44 @@ pub(self) fn object_not_found() -> Value {
         .expect("failed to encode a ObjectNotFound error")
 }
 
-pub(self) fn response(rows: Rows) -> Result<Option<ObjectResponse>, IOError> {
+pub(self) fn response(
+    method: &str,
+    rows: Rows
+) -> Result<Option<ObjectResponse>, String>
+{
     if rows.is_empty() {
         Ok(None)
     } else if rows.len() == 1 {
         let row = &rows[0];
-        let content_md5_bytes: Vec<u8> = row.get(7);
-        let content_md5 = base64::encode(&content_md5_bytes);
-        //TODO: Valdate # of cols
-        let resp = ObjectResponse {
-            id             : row.get(0),
-            owner          : row.get(1),
-            bucket_id      : row.get(2),
-            name           : row.get(3),
-            created        : row.get(4),
-            modified       : row.get(5),
-            content_length : row.get(6),
-            content_md5,
-            content_type   : row.get(8),
-            headers        : row.get(9),
-            sharks         : row.get(10),
-            properties     : row.get(11),
-        };
-        Ok(Some(resp))
+        let cols = row.len();
+
+        if cols >= 12 {
+            let content_md5_bytes: Vec<u8> = row.get("content_md5");
+            let content_md5 = base64::encode(&content_md5_bytes);
+            let resp = ObjectResponse {
+                id             : row.get("id"),
+                owner          : row.get("owner"),
+                bucket_id      : row.get("bucket_id"),
+                name           : row.get("name"),
+                created        : row.get("created"),
+                modified       : row.get("modified"),
+                content_length : row.get("content_length"),
+                content_md5,
+                content_type   : row.get("content_type"),
+                headers        : row.get("headers"),
+                sharks         : row.get("sharks"),
+                properties     : row.get("properties")
+            };
+            Ok(Some(resp))
+        } else {
+            let err = format!("{} query returned a row with only {} columns, \
+                               but 12 were expected .", method, cols);
+            Err(err.to_string())
+        }
     } else {
-        let err = format!("Get query found {} results, but expected only 1.",
-                          rows.len());
-        Err(IOError::new(IOErrorKind::Other, err))
+        let err = format!("{} query found {} results, but expected only 1.",
+                          method, rows.len());
+        Err(err.to_string())
     }
 }
 
@@ -166,3 +182,167 @@ pub(self) fn insert_delete_table_sql(vnode: u64) -> String {
        AND bucket_id = $2 \
        AND name = $3"].concat()
 }
+
+
+#[cfg(test)]
+mod test {
+    use super::*;
+
+    use std::collections::HashMap;
+
+    use chrono::prelude::*;
+    use quickcheck::{quickcheck, Arbitrary, Gen};
+    use quickcheck_helpers::random;
+    use serde_json;
+    use serde_json::Map;
+
+    #[derive(Clone, Debug)]
+    struct GetObjectJson(Value);
+    #[derive(Clone, Debug)]
+    struct ObjectJson(Value);
+
+    impl Arbitrary for GetObjectJson {
+        fn arbitrary<G: Gen>(g: &mut G) -> Self {
+            let owner = serde_json::to_value(Uuid::new_v4())
+                .expect("failed to convert owner field to Value");
+            let bucket_id = serde_json::to_value(Uuid::new_v4())
+                .expect("failed to convert bucket_id field to Value");
+            let name = serde_json::to_value(random::string(g, 1024))
+                .expect("failed to convert name field to Value");
+            let vnode = serde_json::to_value(u64::arbitrary(g))
+                .expect("failed to convert vnode field to Value");
+            let request_id = serde_json::to_value(Uuid::new_v4())
+                .expect("failed to convert request_id field to Value");
+
+            let mut obj = Map::new();
+            obj.insert("owner".into(), owner);
+            obj.insert("bucket_id".into(), bucket_id);
+            obj.insert("name".into(), name);
+            obj.insert("vnode".into(), vnode);
+            obj.insert("request_id".into(), request_id);
+            GetObjectJson(Value::Object(obj))
+        }
+    }
+
+    impl Arbitrary for GetObjectPayload {
+        fn arbitrary<G: Gen>(g: &mut G) -> Self {
+            let owner = Uuid::new_v4();
+            let bucket_id = Uuid::new_v4();
+            let name = random::string(g, 32);
+            let vnode = u64::arbitrary(g);
+            let request_id = Uuid::new_v4();
+
+            GetObjectPayload {
+                owner,
+                bucket_id,
+                name,
+                vnode,
+                request_id
+            }
+        }
+    }
+
+    impl Arbitrary for ObjectResponse {
+        fn arbitrary<G: Gen>(g: &mut G) -> Self {
+            let id = Uuid::new_v4();
+            let owner = Uuid::new_v4();
+            let bucket_id = Uuid::new_v4();
+            let name = random::string(g, 32);
+            let created = Utc::now();
+            let modified = Utc::now();
+            let content_length = i64::arbitrary(g);
+            let content_md5 = random::string(g, 32);
+            let content_type = random::string(g, 32);
+            let mut headers = HashMap::new();
+            let _ = headers.insert(
+                random::string(g, 32),
+                Some(random::string(g, 32))
+            );
+            let _ = headers.insert(
+                random::string(g, 32),
+                Some(random::string(g, 32))
+            );
+
+            let shark1 = StorageNodeIdentifier {
+                datacenter: random::string(g, 32),
+                manta_storage_id: random::string(g, 32)
+            };
+            let shark2 = StorageNodeIdentifier {
+                datacenter: random::string(g, 32),
+                manta_storage_id: random::string(g, 32)
+            };
+            let sharks = vec![shark1, shark2];
+            let properties = None;
+
+            ObjectResponse {
+                id,
+                owner,
+                bucket_id,
+                name,
+                created,
+                modified,
+                content_length,
+                content_md5,
+                content_type,
+                headers,
+                sharks,
+                properties
+            }
+        }
+    }
+
+    quickcheck! {
+        fn prop_get_object_payload_roundtrip(msg: GetObjectPayload) -> bool {
+            match serde_json::to_string(&msg) {
+                Ok(get_str) => {
+                    let decode_result: Result<GetObjectPayload, _> =
+                        serde_json::from_str(&get_str);
+                    match decode_result {
+                        Ok(decoded_msg) => decoded_msg == msg,
+                        Err(_) => false
+                    }
+                },
+                Err(_) => false
+            }
+        }
+    }
+
+    quickcheck! {
+        fn prop_object_response_roundtrip(msg: ObjectResponse) -> bool {
+            match serde_json::to_string(&msg) {
+                Ok(response_str) => {
+                    let decode_result: Result<ObjectResponse, _> =
+                        serde_json::from_str(&response_str);
+                    match decode_result {
+                        Ok(decoded_msg) => decoded_msg == msg,
+                        Err(_) => false
+                    }
+                },
+                Err(_) => false
+            }
+        }
+    }
+
+    quickcheck! {
+        fn prop_getobject_payload_from_json(json: GetObjectJson) -> bool {
+            let decode_result1: Result<GetObjectPayload, _> =
+                serde_json::from_value(json.0.clone());
+            let res1 = decode_result1.is_ok();
+
+            let decode_result2: Result<Vec<GetObjectPayload>, _> =
+                serde_json::from_value(Value::Array(vec![json.0]));
+            let res2 = decode_result2.is_ok();
+
+            res1 && res2
+        }
+    }
+
+    quickcheck! {
+        fn prop_object_response_to_json(objr: ObjectResponse) -> bool {
+            // Test the conversion to JSON. A lack of a panic in the call the
+            // `to_json` indicates success.
+            let _ = to_json(objr);
+            true
+        }
+    }
+}
diff --git a/src/object/create.rs b/src/object/create.rs
index 36028d8..ca62235 100644
--- a/src/object/create.rs
+++ b/src/object/create.rs
@@ -1,20 +1,13 @@
-/*
- * Copyright 2019 Joyent, Inc.
- */
+// Copyright 2019 Joyent, Inc.
 
-use std::io::Error as IOError;
-use std::io::ErrorKind as IOErrorKind;
 use std::vec::Vec;
 
 use base64;
 use serde_derive::{Deserialize, Serialize};
-use serde_json::Value;
-use slog::{Logger, debug};
+use serde_json::{Value, json};
+use slog::{Logger, debug, error, warn};
 use uuid::Uuid;
 
-use cueball::connection_pool::ConnectionPool;
-use cueball::backend::Backend;
-use cueball_static_resolver::StaticIpResolver;
 use cueball_postgres_connection::PostgresConnection;
 use rust_fast::protocol::{FastMessage, FastMessageData};
 
@@ -22,16 +15,21 @@ use crate::object::{
     ObjectResponse,
     StorageNodeIdentifier,
     insert_delete_table_sql,
-    response
+    response,
+    to_json
 };
 use crate::sql;
 use crate::util::{
+    HandlerError,
+    HandlerResponse,
     Hstore,
     array_wrap,
     other_error
 };
 
-#[derive(Debug, Serialize, Deserialize)]
+const METHOD: &str = "createobject";
+
+#[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
 pub struct CreateObjectPayload {
     pub owner          : Uuid,
     pub bucket_id      : Uuid,
@@ -47,55 +45,92 @@ pub struct CreateObjectPayload {
     pub request_id     : Uuid
 }
 
-pub fn handler(msg_id: u32,
-                   args: &[Value],
-                   mut response: Vec<FastMessage>,
-                   pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>,
-                   log: &Logger) -> Result<Vec<FastMessage>, IOError> {
-    debug!(log, "handling createobject function request");
-
-    let arg0 = match &args[0] {
-        Value::Object(_) => &args[0],
-        _ => return Err(other_error("Expected JSON object"))
-    };
-
-    let data_clone = arg0.clone();
-    let payload_result: Result<CreateObjectPayload, _> =
-        serde_json::from_value(data_clone);
-
-    let payload = match payload_result {
-        Ok(o) => o,
-        Err(_) => return Err(other_error("Failed to parse JSON data as payload for createobject function"))
-    };
-
-    debug!(log, "parsed CreateObjectPayload, req_id: {}", payload.request_id);
-    // Make db request and form response
-    create(payload, pool)
-        .and_then(|resp| {
-            let method = String::from("createobject");
-            let value = array_wrap(serde_json::to_value(resp).unwrap());
-            let msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
-            response.push(msg);
-            Ok(response)
+pub(crate) fn handler(
+    msg_id: u32,
+    data: &Value,
+    mut conn: &mut PostgresConnection,
+    log: &Logger
+) -> Result<HandlerResponse, HandlerError>
+{
+    debug!(log, "handling {} function request", &METHOD);
+
+    serde_json::from_value::<Vec<CreateObjectPayload>>(data.clone())
+        .map_err(|e| e.to_string())
+        .and_then(|mut arr| {
+            // Remove outer JSON array required by Fast
+            if !arr.is_empty() {
+                Ok(arr.remove(0))
+            } else {
+                let err_msg = "Failed to parse JSON data as payload for \
+                               createobject function";
+                warn!(log, "{}: {}", err_msg, data);
+                Err(err_msg.to_string())
+            }
+        })
+        .and_then(|payload| {
+            // Make database request
+            let req_id = payload.request_id;
+            debug!(log, "parsed CreateObjectPayload, req_id: {}", &req_id);
+
+            create(payload, &mut conn)
+                .and_then(|maybe_resp| {
+                    // Handle the successful database response
+                    debug!(log, "{} operation was successful, req_id: {}", &METHOD, &req_id);
+                    // The `None` branch of the following match statement should
+                    // never be reached. If `maybe_resp` was `None` this would
+                    // mean that the SQL INSERT for the object was successful
+                    // and the transaction committed, but no results were
+                    // returned from the RETURNING clause. This should not be
+                    // possible, but for completeleness we include a check for
+                    // the condition.
+                    let value =
+                        match maybe_resp {
+                            Some(resp) => to_json(resp),
+                            None => object_create_failed()
+                        };
+                    let msg_data =
+                        FastMessageData::new(METHOD.into(), array_wrap(value));
+                    let msg: HandlerResponse =
+                        FastMessage::data(msg_id, msg_data).into();
+                    Ok(msg)
+                })
+                .or_else(|e| {
+                    // Handle database error response
+                    error!(log, "{} operation failed: {}, req_id: {}", &METHOD, &e, &req_id);
+
+                    // Database errors are returned to as regular Fast messages
+                    // to be handled by the calling application
+                    let value = array_wrap(json!({
+                        "name": "PostgresError",
+                        "message": e
+                    }));
+
+                    let msg_data = FastMessageData::new(METHOD.into(), value);
+                    let msg: HandlerResponse =
+                        FastMessage::data(msg_id, msg_data).into();
+                    Ok(msg)
+                })
         })
-        //TODO: Proper error handling
-        .map_err(|_e| other_error("postgres error"))
+        .map_err(|e| HandlerError::IO(other_error(&e)))
 }
 
-fn create(payload: CreateObjectPayload,
-       pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>)
-       -> Result<Option<ObjectResponse>, IOError>
+fn create(
+    payload: CreateObjectPayload,
+    conn: &mut PostgresConnection
+) -> Result<Option<ObjectResponse>, String>
 {
-    let mut conn = pool.claim().unwrap();
-    let mut txn = (*conn).transaction().unwrap();
+    let mut txn = (*conn).transaction().map_err(|e| e.to_string())?;
     let create_sql = create_sql(payload.vnode);
     let move_sql = insert_delete_table_sql(payload.vnode);
-    let content_md5_bytes = base64::decode(&payload.content_md5).unwrap();
+    let content_md5_bytes =
+        base64::decode(&payload.content_md5)
+        .map_err(|e| format!("content_md5 is not valid base64 encoded data: {}",
+                             e.to_string()))?;
 
     sql::txn_execute(sql::Method::ObjectCreateMove, &mut txn, move_sql.as_str(),
                      &[&payload.owner,
-                     &payload.bucket_id,
-                     &payload.name])
+                       &payload.bucket_id,
+                       &payload.name])
         .and_then(|_moved_rows| {
             sql::txn_query(sql::Method::ObjectCreate, &mut txn, create_sql.as_str(),
                            &[&payload.id,
@@ -109,18 +144,20 @@ fn create(payload: CreateObjectPayload,
                            &payload.sharks,
                            &payload.properties])
         })
-        .map_err(|e| {
-            let pg_err = format!("{}", e);
-            IOError::new(IOErrorKind::Other, pg_err)
+        .and_then(|rows| {
+            txn.commit()?;
+            Ok(rows)
         })
-        .and_then(response)
-        .and_then(|response| {
-            txn.commit().unwrap();
-            Ok(response)
+        .map_err(|e| e.to_string())
+        .and_then(|rows| {
+            response(METHOD, rows)
         })
 }
 
-fn create_sql(vnode: u64) -> String {
+fn create_sql(
+    vnode: u64
+) -> String
+{
     ["INSERT INTO manta_bucket_",
      &vnode.to_string(),
      &".manta_bucket_object ( \
@@ -141,3 +178,167 @@ fn create_sql(vnode: u64) -> String {
        content_length, content_md5, content_type, headers, \
        sharks, properties"].concat()
 }
+
+// This error is only here for completeness. In practice it should never
+// actually be called. See the invocation in this module for more information.
+fn object_create_failed() -> Value {
+    json!({
+        "name": "PostgresError",
+        "message": "Create statement failed to return any results"
+    })
+}
+
+
+#[cfg(test)]
+mod test {
+    use super::*;
+
+    use std::collections::HashMap;
+
+    use quickcheck::{quickcheck, Arbitrary, Gen};
+    use quickcheck_helpers::random;
+    use serde_json;
+    use serde_json::Map;
+
+    use crate::object;
+
+    #[derive(Clone, Debug)]
+    struct CreateObjectJson(Value);
+
+    impl Arbitrary for CreateObjectJson {
+        fn arbitrary<G: Gen>(g: &mut G) -> Self {
+            let owner = serde_json::to_value(Uuid::new_v4())
+                .expect("failed to convert owner field to Value");
+            let name = serde_json::to_value(random::string(g, 63))
+                .expect("failed to convert name field to Value");
+            let bucket_id = serde_json::to_value(Uuid::new_v4())
+                .expect("failed to convert bucket_id field to Value");
+            let id = serde_json::to_value(Uuid::new_v4())
+                .expect("failed to convert id field to Value");
+            let vnode = serde_json::to_value(u64::arbitrary(g))
+                .expect("failed to convert vnode field to Value");
+            let content_length = serde_json::to_value(i64::arbitrary(g))
+                .expect("failed to convert content_length field to Value");
+            let content_md5 = serde_json::to_value(random::string(g, 20))
+                .expect("failed to convert content_md5 field to Value");
+            let content_type = serde_json::to_value(random::string(g, 32))
+                .expect("failed to convert content_type field to Value");
+            let mut headers = HashMap::new();
+            let _ = headers.insert(
+                random::string(g, 32),
+                Some(random::string(g, 32))
+            );
+            let _ = headers.insert(
+                random::string(g, 32),
+                Some(random::string(g, 32))
+            );
+            let headers = serde_json::to_value(headers)
+                .expect("failed to convert headers field to Value");
+            let shark1 = object::StorageNodeIdentifier {
+                datacenter: random::string(g, 32),
+                manta_storage_id: random::string(g, 32)
+            };
+            let shark2 = object::StorageNodeIdentifier {
+                datacenter: random::string(g, 32),
+                manta_storage_id: random::string(g, 32)
+            };
+            let sharks = serde_json::to_value(vec![shark1, shark2])
+                .expect("failed to convert sharks field to Value");
+            let request_id = serde_json::to_value(Uuid::new_v4())
+                .expect("failed to convert request_id field to Value");
+
+            let mut obj = Map::new();
+            obj.insert("owner".into(), owner);
+            obj.insert("name".into(), name);
+            obj.insert("bucket_id".into(), bucket_id);
+            obj.insert("id".into(), id);
+            obj.insert("vnode".into(), vnode);
+            obj.insert("content_length".into(), content_length);
+            obj.insert("content_md5".into(), content_md5);
+            obj.insert("content_type".into(), content_type);
+            obj.insert("headers".into(), headers);
+            obj.insert("sharks".into(), sharks);
+            obj.insert("request_id".into(), request_id);
+            CreateObjectJson(Value::Object(obj))
+        }
+    }
+
+    impl Arbitrary for CreateObjectPayload {
+        fn arbitrary<G: Gen>(g: &mut G) -> Self {
+            let owner = Uuid::new_v4();
+            let bucket_id = Uuid::new_v4();
+            let name = random::string(g, 32);
+            let id = Uuid::new_v4();
+            let vnode = u64::arbitrary(g);
+            let content_length = i64::arbitrary(g);
+            let content_type = random::string(g, 32);
+            let content_md5 = random::string(g, 32);
+            let mut headers = HashMap::new();
+            let _ = headers.insert(
+                random::string(g, 32),
+                Some(random::string(g, 32))
+            );
+            let _ = headers.insert(
+                random::string(g, 32),
+                Some(random::string(g, 32))
+            );
+
+            let shark1 = StorageNodeIdentifier {
+                datacenter: random::string(g, 32),
+                manta_storage_id: random::string(g, 32)
+            };
+            let shark2 = StorageNodeIdentifier {
+                datacenter: random::string(g, 32),
+                manta_storage_id: random::string(g, 32)
+            };
+            let sharks = vec![shark1, shark2];
+            let properties = None;
+            let request_id = Uuid::new_v4();
+
+            CreateObjectPayload {
+                owner,
+                bucket_id,
+                name,
+                id,
+                vnode,
+                content_length,
+                content_md5,
+                content_type,
+                headers,
+                sharks,
+                properties,
+                request_id
+            }
+        }
+    }
+
+    quickcheck! {
+        fn prop_create_object_payload_roundtrip(msg: CreateObjectPayload) -> bool {
+            match serde_json::to_string(&msg) {
+                Ok(create_str) => {
+                    let decode_result: Result<CreateObjectPayload, _> =
+                        serde_json::from_str(&create_str);
+                    match decode_result {
+                        Ok(decoded_msg) => decoded_msg == msg,
+                        Err(_) => false
+                    }
+                },
+                Err(_) => false
+            }
+        }
+    }
+
+    quickcheck! {
+        fn prop_createobject_payload_from_json(json: CreateObjectJson) -> bool {
+            let decode_result1: Result<CreateObjectPayload, _> =
+                serde_json::from_value(json.0.clone());
+            let res1 = decode_result1.is_ok();
+
+            let decode_result2: Result<Vec<CreateObjectPayload>, _> =
+                serde_json::from_value(Value::Array(vec![json.0]));
+            let res2 = decode_result2.is_ok();
+
+            res1 && res2
+        }
+    }
+}
diff --git a/src/object/delete.rs b/src/object/delete.rs
index e08a7f7..8e1fe9d 100644
--- a/src/object/delete.rs
+++ b/src/object/delete.rs
@@ -1,17 +1,10 @@
-/*
- * Copyright 2019 Joyent, Inc.
- */
+// Copyright 2019 Joyent, Inc.
 
-use std::io::Error as IOError;
-use std::io::ErrorKind as IOErrorKind;
 use std::vec::Vec;
 
 use serde_json::{Value, json};
-use slog::{Logger, debug};
+use slog::{Logger, debug, error, warn};
 
-use cueball::connection_pool::ConnectionPool;
-use cueball::backend::Backend;
-use cueball_static_resolver::StaticIpResolver;
 use cueball_postgres_connection::PostgresConnection;
 use rust_fast::protocol::{FastMessage, FastMessageData};
 
@@ -22,76 +15,90 @@ use crate::object::{
 };
 use crate::sql;
 use crate::util::{
+    HandlerError,
+    HandlerResponse,
     array_wrap,
     other_error
 };
 
-pub fn handler(
+const METHOD: &str = "deleteobject";
+
+pub(crate) fn handler(
     msg_id: u32,
-    args: &[Value],
-    mut response: Vec<FastMessage>,
-    pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>,
+    data: &Value,
+    mut conn: &mut PostgresConnection,
     log: &Logger
-) -> Result<Vec<FastMessage>, IOError> {
-    debug!(log, "handling deleteobject function request");
+) -> Result<HandlerResponse, HandlerError>
+{
+    debug!(log, "handling {} function request", &METHOD);
 
-    let arg0 = match &args[0] {
-        Value::Object(_) => &args[0],
-        _ => return Err(other_error("Expected JSON object"))
-    };
+    serde_json::from_value::<Vec<DeleteObjectPayload>>(data.clone())
+        .map_err(|e| e.to_string())
+        .and_then(|mut arr| {
+            // Remove outer JSON array required by Fast
+            if !arr.is_empty() {
+                Ok(arr.remove(0))
+            } else {
+                let err_msg = "Failed to parse JSON data as payload for \
+                               deleteobject function";
+                warn!(log, "{}: {}", err_msg, data);
+                Err(err_msg.to_string())
+            }
+        })
+        .and_then(|payload| {
+            // Make database request
+            let req_id = payload.request_id;
+            debug!(log, "parsed DeleteObjectPayload, req_id: {}", &req_id);
 
-    let data_clone = arg0.clone();
-    let payload_result: Result<DeleteObjectPayload, _> =
-        serde_json::from_value(data_clone);
+            delete(payload, &mut conn)
+                .and_then(|affected_rows| {
+                    // Handle the successful database response
+                    debug!(log, "{} operation was successful, req_id: {}", &METHOD, &req_id);
+                    let value =
+                        if affected_rows > 0 {
+                            // This conversion can fail if the implementation of
+                            // Serialize decides to fail, or if the type
+                            // contains a map with non-string keys. There is no
+                            // reason for the former to occur and the latter
+                            // reason for failure is not a concern here since
+                            // the type of `affected_rows` is u64.
+                            serde_json::to_value(affected_rows).unwrap()
+                        } else {
+                            object_not_found()
+                        };
 
-    let payload = match payload_result {
-        Ok(o) => o,
-        Err(_) => return Err(other_error("Failed to parse JSON data as payload \
-                                          for deleteobject function"))
-    };
+                    let msg_data =
+                        FastMessageData::new(METHOD.into(), array_wrap(value));
+                    let msg: HandlerResponse =
+                        FastMessage::data(msg_id, msg_data).into();
+                    Ok(msg)
+                })
+                .or_else(|e| {
+                    // Handle database error response
+                    error!(log, "{} operation failed: {}, req_id: {}", &METHOD, &e, &req_id);
 
-    debug!(log, "parsed DeleteObjectPayload, req_id: {}", payload.request_id);
+                    // Database errors are returned to as regular Fast messages
+                    // to be handled by the calling application
+                    let value = array_wrap(json!({
+                        "name": "PostgresError",
+                        "message": e
+                    }));
 
-    // Make db request and form response
-    let response_msg: Result<FastMessage, IOError> =
-        delete(payload, pool)
-        .and_then(|affected_rows| {
-            let method = String::from("deleteobject");
-            if affected_rows > 0 {
-                let value = array_wrap(serde_json::to_value(affected_rows).unwrap());
-                let msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
-                Ok(msg)
-            } else {
-                let value = array_wrap(object_not_found());
-                let err_msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
-                Ok(err_msg)
-            }
+                    let msg_data = FastMessageData::new(METHOD.into(), value);
+                    let msg: HandlerResponse =
+                        FastMessage::data(msg_id, msg_data).into();
+                    Ok(msg)
+                })
         })
-        .or_else(|e| {
-            // TODO: Write a helper function to deconstruct the postgres::Error
-            // and populate meaningful name and message fields for the error
-            // dependent on the details of the postgres error.
-            let err_str = format!("{}", e);
-            let value = array_wrap(json!({
-                "name": "PostgresError",
-                "message": err_str
-            }));
-            let method = String::from("deleteobject");
-            let err_msg_data = FastMessageData::new(method, value);
-            let err_msg = FastMessage::error(msg_id, err_msg_data);
-            Ok(err_msg)
-        });
-
-    response.push(response_msg.unwrap());
-    Ok(response)
+        .map_err(|e| HandlerError::IO(other_error(&e)))
 }
 
-fn delete(payload: DeleteObjectPayload,
-          pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>)
-          -> Result<u64, IOError>
+fn delete(
+    payload: DeleteObjectPayload,
+    conn: &mut PostgresConnection
+) -> Result<u64, String>
 {
-    let mut conn = pool.claim().unwrap();
-    let mut txn = (*conn).transaction().unwrap();
+    let mut txn = (*conn).transaction().map_err(|e| e.to_string())?;
     let move_sql = insert_delete_table_sql(payload.vnode);
     let delete_sql = delete_sql(payload.vnode);
 
@@ -106,17 +113,17 @@ fn delete(payload: DeleteObjectPayload,
                              &payload.name])
         })
         .and_then(|row_count| {
-            txn.commit().unwrap();
+            txn.commit()?;
             Ok(row_count)
         })
-        .map_err(|e| {
-            let pg_err = format!("{}", e);
-            IOError::new(IOErrorKind::Other, pg_err)
-        })
+        .map_err(|e| e.to_string())
 }
 
 
-fn delete_sql(vnode: u64) -> String {
+fn delete_sql(
+    vnode: u64
+) -> String
+{
     ["DELETE FROM manta_bucket_",
      &vnode.to_string(),
      &".manta_bucket_object \
diff --git a/src/object/get.rs b/src/object/get.rs
index e2dc64c..37c654a 100644
--- a/src/object/get.rs
+++ b/src/object/get.rs
@@ -1,17 +1,10 @@
-/*
- * Copyright 2019 Joyent, Inc.
- */
+// Copyright 2019 Joyent, Inc.
 
-use std::io::Error as IOError;
-use std::io::ErrorKind as IOErrorKind;
 use std::vec::Vec;
 
-use serde_json::Value;
-use slog::{Logger, debug};
+use serde_json::{Value, json};
+use slog::{Logger, debug, error, warn};
 
-use cueball::connection_pool::ConnectionPool;
-use cueball::backend::Backend;
-use cueball_static_resolver::StaticIpResolver;
 use cueball_postgres_connection::PostgresConnection;
 use rust_fast::protocol::{FastMessage, FastMessageData};
 
@@ -19,80 +12,100 @@ use crate::object::{
     GetObjectPayload,
     ObjectResponse,
     object_not_found,
-    response
+    response,
+    to_json
 };
 use crate::sql;
 use crate::util::{
+    HandlerError,
+    HandlerResponse,
     array_wrap,
     other_error
 };
 
-pub fn handler(msg_id: u32,
-               args: &[Value],
-               mut response: Vec<FastMessage>,
-               pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>,
-               log: &Logger) -> Result<Vec<FastMessage>, IOError> {
+const METHOD: &str = "getobject";
+
+pub(crate) fn handler(
+    msg_id: u32,
+    data: &Value,
+    mut conn: &mut PostgresConnection,
+    log: &Logger
+) -> Result<HandlerResponse, HandlerError>
+{
     debug!(log, "handling getobject function request");
 
-    let arg0 = match &args[0] {
-        Value::Object(_) => &args[0],
-        _ => return Err(other_error("Expected JSON object"))
-    };
+    serde_json::from_value::<Vec<GetObjectPayload>>(data.clone())
+        .map_err(|e| e.to_string())
+        .and_then(|mut arr| {
+            // Remove outer JSON array required by Fast
+            if !arr.is_empty() {
+                Ok(arr.remove(0))
+            } else {
+                let err_msg = "Failed to parse JSON data as payload for \
+                               getobject function";
+                warn!(log, "{}: {}", err_msg, data);
+                Err(err_msg.to_string())
+            }
+        })
+        .and_then(|payload| {
+            // Make database request
+            let req_id = payload.request_id;
+            debug!(log, "parsed GetObjectPayload, req_id: {}", &req_id);
 
-    let data_clone = arg0.clone();
-    let payload_result: Result<GetObjectPayload, _> =
-        serde_json::from_value(data_clone);
+            get(payload, &mut conn)
+                .and_then(|maybe_resp| {
+                    // Handle the successful database response
+                    debug!(log, "getobject operation was successful, req_id: {}", &req_id);
+                    let value =
+                        match maybe_resp {
+                            Some(resp) => array_wrap(to_json(resp)),
+                            None => array_wrap(object_not_found())
+                        };
+                    let msg_data = FastMessageData::new(METHOD.into(), value);
+                    let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
+                    Ok(msg)
+                })
+                .or_else(|e| {
+                    // Handle database error response
+                    error!(log, "getobject operation failed: {}, req_id: {}", &e, &req_id);
 
-    let payload = match payload_result {
-        Ok(o) => o,
-        Err(_) => return Err(other_error("Failed to parse JSON data as payload for getobject function"))
-    };
+                    // Database errors are returned to as regular Fast messages
+                    // to be handled by the calling application
+                    let value = array_wrap(json!({
+                        "name": "PostgresError",
+                        "message": e
+                    }));
 
-    debug!(log, "parsed GetObjectPayload, req_id: {}", payload.request_id);
-    get(payload, pool)
-        .and_then(|maybe_resp| {
-            let method = String::from("getobject");
-            match maybe_resp {
-                Some(resp) => {
-                    let value = array_wrap(serde_json::to_value(resp).unwrap());
-                    let msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
-                    response.push(msg);
-                    Ok(response)
-                },
-                None => {
-                    let value = array_wrap(object_not_found());
-                    let err_msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
-                    response.push(err_msg);
-                    Ok(response)
-                }
-            }
-        })
-        //TODO: Proper error handling
-        .map_err(|e| {
-            println!("Error: {}", e);
-            other_error("postgres error")
+                    let msg_data = FastMessageData::new(METHOD.into(), value);
+                    let msg: HandlerResponse =
+                        FastMessage::data(msg_id, msg_data).into();
+                    Ok(msg)
+                })
         })
+        .map_err(|e| HandlerError::IO(other_error(&e)))
 }
 
-fn get(payload: GetObjectPayload,
-       pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>)
-       -> Result<Option<ObjectResponse>, IOError>
+fn get(
+    payload: GetObjectPayload,
+    mut conn: &mut PostgresConnection
+) -> Result<Option<ObjectResponse>, String>
 {
-    let mut conn = pool.claim().unwrap();
     let sql = get_sql(payload.vnode);
 
     sql::query(sql::Method::ObjectGet, &mut conn, sql.as_str(),
                &[&payload.owner,
                &payload.bucket_id,
-               &payload.name])
-        .map_err(|e| {
-            let pg_err = format!("{}", e);
-            IOError::new(IOErrorKind::Other, pg_err)
+                 &payload.name])
+        .map_err(|e| e.to_string())
+        .and_then(|rows| {
+            response(METHOD, rows)
         })
-        .and_then(response)
 }
 
-fn get_sql(vnode: u64) -> String {
+fn get_sql(
+    vnode: u64
+) -> String
+{
     ["SELECT id, owner, bucket_id, name, created, modified, content_length, \
       content_md5, content_type, headers, sharks, properties \
       FROM manta_bucket_",
diff --git a/src/object/list.rs b/src/object/list.rs
index 838bb2f..412b016 100644
--- a/src/object/list.rs
+++ b/src/object/list.rs
@@ -1,35 +1,31 @@
-/*
- * Copyright 2019 Joyent, Inc.
- */
+// Copyright 2019 Joyent, Inc.
 
-use std::io::Error as IOError;
 use std::vec::Vec;
 
 use base64;
 use serde_derive::{Deserialize, Serialize};
-use serde_json::Value;
-use slog::{Logger, debug};
+use serde_json::{Value, json};
+use slog::{Logger, debug, error, warn};
 use uuid::Uuid;
 
-use cueball::connection_pool::ConnectionPool;
-use cueball::backend::Backend;
-use cueball_static_resolver::StaticIpResolver;
 use cueball_postgres_connection::PostgresConnection;
 use rust_fast::protocol::{FastMessage, FastMessageData};
 
-use tokio_postgres::Error as PGError;
-use tokio_postgres::Row as PGRow;
-
 use crate::object::{
-    ObjectResponse
+    ObjectResponse,
+    to_json
 };
 use crate::sql;
 use crate::util::{
+    HandlerError,
+    HandlerResponse,
     array_wrap,
     other_error
 };
 
-#[derive(Debug, Serialize, Deserialize)]
+const METHOD: &str = "listobjects";
+
+#[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
 pub struct ListObjectsPayload {
     pub owner      : Uuid,
     pub bucket_id  : Uuid,
@@ -40,88 +36,138 @@ pub struct ListObjectsPayload {
     pub request_id : Uuid
 }
 
-pub fn handler(msg_id: u32,
-               args: &[Value],
-               mut response: Vec<FastMessage>,
-               pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>,
-               log: &Logger) -> Result<Vec<FastMessage>, IOError> {
-    debug!(log, "handling listobjects function request");
-
-    let arg0 = match &args[0] {
-        Value::Object(_) => &args[0],
-        _ => return Err(other_error("Expected JSON object"))
-    };
-
-    let data_clone = arg0.clone();
-    let payload_result: Result<ListObjectsPayload, _> =
-        serde_json::from_value(data_clone);
-
-    let payload = match payload_result {
-        Ok(o) => o,
-        Err(_) => return Err(other_error("Failed to parse JSON data as payload for listobjects function"))
-    };
-
-    debug!(log, "parsed ListObjectPayload, req_id: {}", payload.request_id);
-
-    // TODO catch these as errors and return to the caller
-    assert!(payload.limit > 0);
-    assert!(payload.limit <= 1000);
-
-    // Make db request and form response
-    // TODO: make this call safe
-    let mut conn = pool.claim().unwrap();
-    let mut txn = (*conn).transaction().unwrap();
-    let query: Result<Vec<PGRow>, PGError>;
-
-    match (payload.marker, payload.prefix) {
-        (Some(marker), Some(prefix)) => {
-            let sql = list_sql_prefix_marker(payload.vnode, payload.limit);
-            let prefix = format!("{}%", prefix);
-            query = sql::txn_query(sql::Method::ObjectList, &mut txn, sql.as_str(),
-                &[&payload.owner, &payload.bucket_id, &prefix, &marker]);
-        }
-        (Some(marker), None) => {
-            let sql = list_sql_marker(payload.vnode, payload.limit);
-            query = sql::txn_query(sql::Method::ObjectList, &mut txn, sql.as_str(),
-                &[&payload.owner, &payload.bucket_id, &marker]);
-        }
-        (None, Some(prefix)) => {
-            let sql = list_sql_prefix(payload.vnode, payload.limit);
-            let prefix = format!("{}%", prefix);
-            query = sql::txn_query(sql::Method::ObjectList, &mut txn, sql.as_str(),
-                &[&payload.owner, &payload.bucket_id, &prefix]);
-        }
-        (None, None) => {
-            let sql = list_sql(payload.vnode, payload.limit);
-            query = sql::txn_query(sql::Method::ObjectList, &mut txn, sql.as_str(),
-                &[&payload.owner, &payload.bucket_id]);
-        }
-    }
+pub(crate) fn handler(
+    msg_id: u32,
+    data: &Value,
+    mut conn: &mut PostgresConnection,
+    log: &Logger
+) -> Result<HandlerResponse, HandlerError>
+{
+    debug!(log, "handling {} function request", &METHOD);
+
+    serde_json::from_value::<Vec<ListObjectsPayload>>(data.clone())
+        .map_err(|e| e.to_string())
+        .and_then(|mut arr| {
+            // Remove outer JSON array required by Fast
+            if !arr.is_empty() {
+                Ok(arr.remove(0))
+            } else {
+                let err_msg = "Failed to parse JSON data as payload for \
+                               getobject function";
+                warn!(log, "{}: {}", err_msg, data);
+                Err(err_msg.to_string())
+            }
+        })
+        .and_then(|payload| {
+            // Make database request
+            let req_id = payload.request_id;
+            debug!(log, "parsed ListObjectsPayload, req_id: {}", &req_id);
+
+            if payload.limit > 0 && payload.limit <= 1024 {
+                list(msg_id, payload, &mut conn)
+                    .and_then(|resp| {
+                        // Handle the successful database response
+                        debug!(log, "{} operation was successful, req_id: {}", &METHOD, &req_id);
+                        Ok(HandlerResponse::from(resp))
+                    })
+                    .or_else(|e| {
+                        // Handle database error response
+                        error!(log, "{} operation failed: {}, req_id: {}", &METHOD, &e, &req_id);
 
-    for row in query.unwrap().iter() {
-        let content_md5_bytes: Vec<u8> = row.get(7);
-        let content_md5 = base64::encode(&content_md5_bytes);
-        let resp = ObjectResponse {
-            id             : row.get(0),
-            owner          : row.get(1),
-            bucket_id      : row.get(2),
-            name           : row.get(3),
-            created        : row.get(4),
-            modified       : row.get(5),
-            content_length : row.get(6),
-            content_md5,
-            content_type   : row.get(8),
-            headers        : row.get(9),
-            sharks         : row.get(10),
-            properties     : row.get(11),
+                        // Database errors are returned to as regular Fast messages
+                        // to be handled by the calling application
+                        let value = array_wrap(json!({
+                            "name": "PostgresError",
+                            "message": e
+                        }));
+                        let msg_data = FastMessageData::new(METHOD.into(), value);
+                        let msg: HandlerResponse =
+                            FastMessage::data(msg_id, msg_data).into();
+                        Ok(msg)
+                    })
+            } else {
+                // Limit constraint violations are returned to as regular
+                // Fast messages to be handled by the calling application
+                let e = format!("the {} limit option must be a value between 1 \
+                                 and 1024. the requested limit was {}, req_id: \
+                                 {}", &METHOD, &payload.limit, &req_id);
+                let value = array_wrap(json!({
+                    "name": "LimitConstraintError",
+                    "message": e
+                }));
+                let msg_data = FastMessageData::new(METHOD.into(), value);
+                let msg: HandlerResponse =
+                    FastMessage::data(msg_id, msg_data).into();
+                Ok(msg)
+            }
+        })
+        .map_err(|e| HandlerError::IO(other_error(&e)))
+}
+
+fn list(
+    msg_id: u32,
+    payload: ListObjectsPayload,
+    mut conn: &mut PostgresConnection
+) -> Result<Vec<FastMessage>, String>
+{
+    let query_result =
+        match (payload.marker, payload.prefix) {
+            (Some(marker), Some(prefix)) => {
+                let sql = list_sql_prefix_marker(payload.vnode, payload.limit);
+                let prefix = format!("{}%", prefix);
+                sql::query(sql::Method::ObjectList, &mut conn, sql.as_str(),
+                           &[&payload.owner, &payload.bucket_id, &prefix, &marker])
+            }
+            (Some(marker), None) => {
+                let sql = list_sql_marker(payload.vnode, payload.limit);
+                sql::query(sql::Method::ObjectList, &mut conn, sql.as_str(),
+                           &[&payload.owner, &payload.bucket_id, &marker])
+            }
+            (None, Some(prefix)) => {
+                let sql = list_sql_prefix(payload.vnode, payload.limit);
+                let prefix = format!("{}%", prefix);
+                sql::query(sql::Method::ObjectList, &mut conn, sql.as_str(),
+                           &[&payload.owner, &payload.bucket_id, &prefix])
+            }
+            (None, None) => {
+                let sql = list_sql(payload.vnode, payload.limit);
+                sql::query(sql::Method::ObjectList, &mut conn, sql.as_str(),
+                           &[&payload.owner, &payload.bucket_id])
+            }
         };
 
-        let value = array_wrap(serde_json::to_value(resp).unwrap());
-        let msg = FastMessage::data(msg_id, FastMessageData::new(String::from("listobjects"), value));
-        response.push(msg);
-    }
+    let mut msgs: Vec<FastMessage> = Vec::with_capacity(1024);
+
+    query_result
+        .map_err(|e| e.to_string())
+        .and_then(|rows| {
+            for row in rows.iter() {
+                let content_md5_bytes: Vec<u8> = row.get(7);
+                let content_md5 = base64::encode(&content_md5_bytes);
+                let resp = ObjectResponse {
+                    id             : row.get("id"),
+                    owner          : row.get("owner"),
+                    bucket_id      : row.get("bucket_id"),
+                    name           : row.get("name"),
+                    created        : row.get("created"),
+                    modified       : row.get("modified"),
+                    content_length : row.get("content_length"),
+                    content_md5,
+                    content_type   : row.get("content_type"),
+                    headers        : row.get("headers"),
+                    sharks         : row.get("sharks"),
+                    properties     : row.get("properties")
+                };
+
+                let value = to_json(resp);
+                let msg_data =
+                    FastMessageData::new(METHOD.into(), array_wrap(value));
+                let msg = FastMessage::data(msg_id, msg_data);
 
-    Ok(response)
+                msgs.push(msg);
+            }
+            Ok(msgs)
+        })
 }
 
 fn list_sql_prefix_marker(vnode: u64, limit: u64) -> String {
@@ -167,3 +213,98 @@ fn list_sql(vnode: u64, limit: u64) -> String {
         LIMIT {}",
         vnode, limit)
 }
+
+
+#[cfg(test)]
+mod test {
+    use super::*;
+
+    use quickcheck::{quickcheck, Arbitrary, Gen};
+    use quickcheck_helpers::random;
+    use serde_json;
+    use serde_json::Map;
+
+    #[derive(Clone, Debug)]
+    struct ListObjectsJson(Value);
+
+    impl Arbitrary for ListObjectsJson {
+        fn arbitrary<G: Gen>(g: &mut G) -> Self {
+            let owner = serde_json::to_value(Uuid::new_v4())
+                .expect("failed to convert owner field to Value");
+            let bucket_id = serde_json::to_value(Uuid::new_v4())
+                .expect("failed to convert bucket_id field to Value");
+            let vnode = serde_json::to_value(u64::arbitrary(g))
+                .expect("failed to convert vnode field to Value");
+            let prefix = serde_json::to_value(random::string(g, 32))
+                .expect("failed to convert prefix field to Value");
+            let limit = serde_json::to_value(u64::arbitrary(g))
+                .expect("failed to convert limit field to Value");
+            let marker = serde_json::to_value(random::string(g, 32))
+                .expect("failed to convert marker field to Value");
+            let request_id = serde_json::to_value(Uuid::new_v4())
+                .expect("failed to convert request_id field to Value");
+
+            let mut obj = Map::new();
+            obj.insert("owner".into(), owner);
+            obj.insert("bucket_id".into(), bucket_id);
+            obj.insert("vnode".into(), vnode);
+            obj.insert("prefix".into(), prefix);
+            obj.insert("limit".into(), limit);
+            obj.insert("marker".into(), marker);
+            obj.insert("request_id".into(), request_id);
+            ListObjectsJson(Value::Object(obj))
+        }
+    }
+
+    impl Arbitrary for ListObjectsPayload {
+        fn arbitrary<G: Gen>(g: &mut G) -> Self {
+            let owner = Uuid::new_v4();
+            let bucket_id = Uuid::new_v4();
+            let vnode = u64::arbitrary(g);
+            let prefix = Some(random::string(g, 32));
+            let limit = u64::arbitrary(g);
+            let marker = Some(random::string(g, 32));
+            let request_id = Uuid::new_v4();
+
+            ListObjectsPayload {
+                owner,
+                bucket_id,
+                vnode,
+                prefix,
+                limit,
+                marker,
+                request_id
+            }
+        }
+    }
+
+    quickcheck! {
+        fn prop_list_object_payload_roundtrip(msg: ListObjectsPayload) -> bool {
+            match serde_json::to_string(&msg) {
+                Ok(list_str) => {
+                    let decode_result: Result<ListObjectsPayload, _> =
+                        serde_json::from_str(&list_str);
+                    match decode_result {
+                        Ok(decoded_msg) => decoded_msg == msg,
+                        Err(_) => false
+                    }
+                },
+                Err(_) => false
+            }
+        }
+    }
+
+    quickcheck! {
+        fn prop_listobject_payload_from_json(json: ListObjectsJson) -> bool {
+            let decode_result1: Result<ListObjectsPayload, _> =
+                serde_json::from_value(json.0.clone());
+            let res1 = decode_result1.is_ok();
+
+            let decode_result2: Result<Vec<ListObjectsPayload>, _> =
+                serde_json::from_value(Value::Array(vec![json.0]));
+            let res2 = decode_result2.is_ok();
+
+            res1 && res2
+        }
+    }
+}
diff --git a/src/object/update.rs b/src/object/update.rs
index 573958d..ead30db 100644
--- a/src/object/update.rs
+++ b/src/object/update.rs
@@ -1,35 +1,33 @@
-/*
- * Copyright 2019 Joyent, Inc.
- */
+// Copyright 2019 Joyent, Inc.
 
-use std::io::Error as IOError;
-use std::io::ErrorKind as IOErrorKind;
 use std::vec::Vec;
 
 use serde_derive::{Deserialize, Serialize};
-use serde_json::Value;
-use slog::{Logger, debug};
+use serde_json::{Value, json};
+use slog::{Logger, debug, error, warn};
 use uuid::Uuid;
 
-use cueball::connection_pool::ConnectionPool;
-use cueball::backend::Backend;
-use cueball_static_resolver::StaticIpResolver;
 use cueball_postgres_connection::PostgresConnection;
 use rust_fast::protocol::{FastMessage, FastMessageData};
 
 use crate::object::{
     ObjectResponse,
     object_not_found,
-    response
+    response,
+    to_json
 };
 use crate::sql;
 use crate::util::{
+    HandlerError,
+    HandlerResponse,
     Hstore,
     array_wrap,
     other_error
 };
 
-#[derive(Debug, Serialize, Deserialize)]
+const METHOD: &str = "updateobject";
+
+#[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
 pub struct UpdateObjectPayload {
     pub owner          : Uuid,
     pub bucket_id      : Uuid,
@@ -42,62 +40,74 @@ pub struct UpdateObjectPayload {
     pub request_id     : Uuid
 }
 
-pub fn handler(msg_id: u32,
-                      args: &[Value],
-                      mut response: Vec<FastMessage>,
-                      pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>,
-                      log: &Logger) -> Result<Vec<FastMessage>, IOError> {
-    debug!(log, "handling updateobject function request");
-
-    let arg0 = match &args[0] {
-        Value::Object(_) => &args[0],
-        _ => return Err(other_error("Expected JSON object"))
-    };
-
-    let data_clone = arg0.clone();
-    let payload_result: Result<UpdateObjectPayload, _> =
-        serde_json::from_value(data_clone);
-
-    let payload = match payload_result {
-        Ok(o) => o,
-        Err(_) => return Err(other_error("Failed to parse JSON data as payload for updateobject function"))
-    };
-
-    debug!(log, "parsed UpdateObjectPayload, req_id: {}", payload.request_id);
-
-    // Make db request and form response
-    // let response_msg: Result<FastMessage, IOError> =
-    update(payload, pool)
-        .and_then(|maybe_resp| {
-            let method = String::from("updateobject");
-            match maybe_resp {
-                Some(resp) => {
-                    let value = array_wrap(serde_json::to_value(resp).unwrap());
-                    let msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
-                    response.push(msg);
-                    Ok(response)
-                },
-                None => {
-                    let value = array_wrap(object_not_found());
-                    let err_msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
-                    response.push(err_msg);
-                    Ok(response)
-                }
+pub(crate) fn handler(
+    msg_id: u32,
+    data: &Value,
+    mut conn: &mut PostgresConnection,
+    log: &Logger
+) -> Result<HandlerResponse, HandlerError>
+{
+    debug!(log, "handling {} function request", &METHOD);
+
+    serde_json::from_value::<Vec<UpdateObjectPayload>>(data.clone())
+        .map_err(|e| e.to_string())
+        .and_then(|mut arr| {
+            // Remove outer JSON array required by Fast
+            if !arr.is_empty() {
+                Ok(arr.remove(0))
+            } else {
+                let err_msg = "Failed to parse JSON data as payload for \
+                               updateobject function";
+                warn!(log, "{}: {}", err_msg, data);
+                Err(err_msg.to_string())
             }
         })
-        //TODO: Proper error handling
-        .map_err(|e| {
-            println!("Error: {}", e);
-            other_error("postgres error")
+        .and_then(|payload| {
+            // Make database request
+            let req_id = payload.request_id;
+            debug!(log, "parsed UpdateObjectPayload, req_id: {}", &req_id);
+
+            update(payload, &mut conn)
+                .and_then(|maybe_resp| {
+                    // Handle the successful database response
+                    debug!(log, "{} operation was successful, req_id: {}", &METHOD, &req_id);
+                    let value =
+                        match maybe_resp {
+                            Some(resp) => to_json(resp),
+                            None => object_not_found()
+                        };
+                    let msg_data =
+                        FastMessageData::new(METHOD.into(), array_wrap(value));
+                    let msg: HandlerResponse =
+                        FastMessage::data(msg_id, msg_data).into();
+                    Ok(msg)
+                })
+                .or_else(|e| {
+                    // Handle database error response
+                    error!(log, "{} operation failed: {}, req_id: {}", &METHOD, &e, &req_id);
+
+                    // Database errors are returned to as regular Fast messages
+                    // to be handled by the calling application
+                    let value = array_wrap(json!({
+                        "name": "PostgresError",
+                        "message": e
+                    }));
+
+                    let msg_data = FastMessageData::new(METHOD.into(), value);
+                    let msg: HandlerResponse =
+                        FastMessage::data(msg_id, msg_data).into();
+                    Ok(msg)
+                })
         })
+        .map_err(|e| HandlerError::IO(other_error(&e)))
 }
 
-fn update(payload: UpdateObjectPayload,
-          pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>)
-          -> Result<Option<ObjectResponse>, IOError>
+fn update(
+    payload: UpdateObjectPayload,
+    conn: &mut PostgresConnection
+)  -> Result<Option<ObjectResponse>, String>
 {
-    let mut conn = pool.claim().unwrap();
-    let mut txn = (*conn).transaction().unwrap();
+    let mut txn = (*conn).transaction().map_err(|e| e.to_string())?;
     let update_sql = update_sql(payload.vnode);
 
     sql::txn_query(sql::Method::ObjectUpdate, &mut txn, update_sql.as_str(),
@@ -107,19 +117,20 @@ fn update(payload: UpdateObjectPayload,
                        &payload.owner,
                        &payload.bucket_id,
                        &payload.name])
-
-        .map_err(|e| {
-            let pg_err = format!("{}", e);
-            IOError::new(IOErrorKind::Other, pg_err)
+        .and_then(|rows| {
+            txn.commit()?;
+            Ok(rows)
         })
-        .and_then(response)
-        .and_then(|response| {
-            txn.commit().unwrap();
-            Ok(response)
+        .map_err(|e| e.to_string())
+        .and_then(|rows| {
+            response(METHOD, rows)
         })
 }
 
-fn update_sql(vnode: u64) -> String {
+fn update_sql(
+    vnode: u64
+) -> String
+{
     ["UPDATE manta_bucket_",
      &vnode.to_string(),
      &".manta_bucket_object \
@@ -134,3 +145,124 @@ fn update_sql(vnode: u64) -> String {
        content_length, content_md5, content_type, headers, \
        sharks, properties"].concat()
 }
+
+#[cfg(test)]
+mod test {
+    use super::*;
+
+    use std::collections::HashMap;
+
+    use quickcheck::{quickcheck, Arbitrary, Gen};
+    use quickcheck_helpers::random;
+    use serde_json;
+    use serde_json::Map;
+
+    #[derive(Clone, Debug)]
+    struct UpdateObjectJson(Value);
+
+    impl Arbitrary for UpdateObjectJson {
+        fn arbitrary<G: Gen>(g: &mut G) -> Self {
+            let owner = serde_json::to_value(Uuid::new_v4())
+                .expect("failed to convert owner field to Value");
+            let name = serde_json::to_value(random::string(g, 63))
+                .expect("failed to convert name field to Value");
+            let bucket_id = serde_json::to_value(Uuid::new_v4())
+                .expect("failed to convert bucket_id field to Value");
+            let id = serde_json::to_value(Uuid::new_v4())
+                .expect("failed to convert id field to Value");
+            let vnode = serde_json::to_value(u64::arbitrary(g))
+                .expect("failed to convert vnode field to Value");
+            let content_type = serde_json::to_value(random::string(g, 32))
+                .expect("failed to convert content_type field to Value");
+            let mut headers = HashMap::new();
+            let _ = headers.insert(
+                random::string(g, 32),
+                Some(random::string(g, 32))
+            );
+            let _ = headers.insert(
+                random::string(g, 32),
+                Some(random::string(g, 32))
+            );
+            let headers = serde_json::to_value(headers)
+                .expect("failed to convert headers field to Value");
+            let request_id = serde_json::to_value(Uuid::new_v4())
+                .expect("failed to convert request_id field to Value");
+
+            let mut obj = Map::new();
+            obj.insert("owner".into(), owner);
+            obj.insert("name".into(), name);
+            obj.insert("bucket_id".into(), bucket_id);
+            obj.insert("id".into(), id);
+            obj.insert("vnode".into(), vnode);
+            obj.insert("content_type".into(), content_type);
+            obj.insert("headers".into(), headers);
+            obj.insert("request_id".into(), request_id);
+            UpdateObjectJson(Value::Object(obj))
+        }
+    }
+
+    impl Arbitrary for UpdateObjectPayload {
+        fn arbitrary<G: Gen>(g: &mut G) -> Self {
+            let owner = Uuid::new_v4();
+            let bucket_id = Uuid::new_v4();
+            let name = random::string(g, 32);
+            let id = Uuid::new_v4();
+            let vnode = u64::arbitrary(g);
+            let content_type = random::string(g, 32);
+            let mut headers = HashMap::new();
+            let _ = headers.insert(
+                random::string(g, 32),
+                Some(random::string(g, 32))
+            );
+            let _ = headers.insert(
+                random::string(g, 32),
+                Some(random::string(g, 32))
+            );
+
+            let properties = None;
+            let request_id = Uuid::new_v4();
+
+            UpdateObjectPayload {
+                owner,
+                bucket_id,
+                name,
+                id,
+                vnode,
+                content_type,
+                headers,
+                properties,
+                request_id
+            }
+        }
+    }
+
+    quickcheck! {
+        fn prop_update_object_payload_roundtrip(msg: UpdateObjectPayload) -> bool {
+            match serde_json::to_string(&msg) {
+                Ok(update_str) => {
+                    let decode_result: Result<UpdateObjectPayload, _> =
+                        serde_json::from_str(&update_str);
+                    match decode_result {
+                        Ok(decoded_msg) => decoded_msg == msg,
+                        Err(_) => false
+                    }
+                },
+                Err(_) => false
+            }
+        }
+    }
+
+    quickcheck! {
+        fn prop_updateobject_payload_from_json(json: UpdateObjectJson) -> bool {
+            let decode_result1: Result<UpdateObjectPayload, _> =
+                serde_json::from_value(json.0.clone());
+            let res1 = decode_result1.is_ok();
+
+            let decode_result2: Result<Vec<UpdateObjectPayload>, _> =
+                serde_json::from_value(Value::Array(vec![json.0]));
+            let res2 = decode_result2.is_ok();
+
+            res1 && res2
+        }
+    }
+}
diff --git a/tests/rpc_handlers.rs b/tests/rpc_handlers.rs
index 1ca77b7..3bf3e45 100644
--- a/tests/rpc_handlers.rs
+++ b/tests/rpc_handlers.rs
@@ -1,6 +1,4 @@
-/*
- * Copyright 2019 Joyent, Inc.
- */
+// Copyright 2019 Joyent, Inc.
 
 use std::collections::HashMap;
 use std::net::{IpAddr, Ipv4Addr};
@@ -19,8 +17,10 @@ use cueball_postgres_connection::{
     PostgresConnectionConfig,
     TlsConfig
 };
+use rust_fast::protocol::{FastMessage, FastMessageData};
 
 use boray::bucket;
+use boray::util;
 use boray::error::{BorayError, BorayErrorType};
 use boray::object;
 
@@ -117,10 +117,13 @@ fn verify_rpc_handlers() {
         request_id
     };
 
-    let get_bucket_json = serde_json::to_value(get_bucket_payload).unwrap();
-    let get_bucket_args = vec![get_bucket_json];
+    let get_bucket_json = serde_json::to_value(vec![get_bucket_payload]).unwrap();
+    let get_bucket_fast_msg_data =
+        FastMessageData::new("getbucket".into(), get_bucket_json);
+    let get_bucket_fast_msg =
+        FastMessage::data(msg_id, get_bucket_fast_msg_data);
     let mut get_bucket_result =
-        bucket::get::handler(msg_id, &get_bucket_args, vec![], &pool, &log);
+        util::msg_handler(&get_bucket_fast_msg, &pool, &log);
 
     assert!(get_bucket_result.is_ok());
     let get_bucket_response = get_bucket_result.unwrap();
@@ -140,10 +143,13 @@ fn verify_rpc_handlers() {
         request_id
     };
 
-    let create_bucket_json = serde_json::to_value(create_bucket_payload).unwrap();
-    let create_bucket_args = vec![create_bucket_json];
+    let create_bucket_json = serde_json::to_value(vec![create_bucket_payload]).unwrap();
+    let create_bucket_fast_msg_data =
+        FastMessageData::new("createbucket".into(), create_bucket_json);
+    let create_bucket_fast_msg =
+        FastMessage::data(msg_id, create_bucket_fast_msg_data);
     let mut create_bucket_result =
-        bucket::create::handler(msg_id, &create_bucket_args, vec![], &pool, &log);
+        util::msg_handler(&create_bucket_fast_msg, &pool, &log);
 
     assert!(create_bucket_result.is_ok());
     let create_bucket_response = create_bucket_result.unwrap();
@@ -157,7 +163,7 @@ fn verify_rpc_handlers() {
 
     // Read bucket again and make sure the resonse is returned successfully
     get_bucket_result =
-        bucket::get::handler(msg_id, &get_bucket_args, vec![], &pool, &log);
+        util::msg_handler(&get_bucket_fast_msg, &pool, &log);
 
     assert!(get_bucket_result.is_ok());
     let get_bucket_response = get_bucket_result.unwrap();
@@ -172,7 +178,7 @@ fn verify_rpc_handlers() {
     // Try to create same bucket again and verify a BucketAlreadyExists error is
     // returned
     create_bucket_result =
-        bucket::create::handler(msg_id, &create_bucket_args, vec![], &pool, &log);
+        util::msg_handler(&create_bucket_fast_msg, &pool, &log);
 
     assert!(create_bucket_result.is_ok());
     let create_bucket_response = create_bucket_result.unwrap();
@@ -186,10 +192,19 @@ fn verify_rpc_handlers() {
 
     // Delete bucket
 
-    // The get and delete bucket args are the same so we can reuse
-    // get_bucket_args here.
+    let delete_bucket_payload = bucket::DeleteBucketPayload {
+        owner: owner_id,
+        name: bucket.clone(),
+        vnode: 0,
+        request_id
+    };
+    let delete_bucket_json = serde_json::to_value(vec![delete_bucket_payload]).unwrap();
+    let delete_bucket_fast_msg_data =
+        FastMessageData::new("deletebucket".into(), delete_bucket_json);
+    let delete_bucket_fast_msg =
+        FastMessage::data(msg_id, delete_bucket_fast_msg_data);
     let mut delete_bucket_result =
-        bucket::delete::handler(msg_id, &get_bucket_args, vec![], &pool, &log);
+        util::msg_handler(&delete_bucket_fast_msg, &pool, &log);
 
     assert!(delete_bucket_result.is_ok());
     let delete_bucket_response = delete_bucket_result.unwrap();
@@ -202,7 +217,7 @@ fn verify_rpc_handlers() {
 
     // Read bucket again and verify it's gone
     get_bucket_result =
-        bucket::get::handler(msg_id, &get_bucket_args, vec![], &pool, &log);
+        util::msg_handler(&get_bucket_fast_msg, &pool, &log);
 
     assert!(get_bucket_result.is_ok());
     let get_bucket_response = get_bucket_result.unwrap();
@@ -216,7 +231,7 @@ fn verify_rpc_handlers() {
 
     // Attempt to delete a nonexistent bucket and verify an error is returned
     delete_bucket_result =
-        bucket::delete::handler(msg_id, &get_bucket_args, vec![], &pool, &log);
+        util::msg_handler(&delete_bucket_fast_msg, &pool, &log);
 
     assert!(delete_bucket_result.is_ok());
     let delete_bucket_response = delete_bucket_result.unwrap();
@@ -240,10 +255,13 @@ fn verify_rpc_handlers() {
         request_id
     };
 
-    let get_object_json = serde_json::to_value(get_object_payload).unwrap();
-    let get_object_args = vec![get_object_json];
+    let get_object_json = serde_json::to_value(vec![&get_object_payload]).unwrap();
+    let get_object_fast_msg_data =
+        FastMessageData::new("getobject".into(), get_object_json);
+    let get_object_fast_msg =
+        FastMessage::data(msg_id, get_object_fast_msg_data);
     let mut get_object_result =
-        object::get::handler(msg_id, &get_object_args, vec![], &pool, &log);
+        util::msg_handler(&get_object_fast_msg, &pool, &log);
 
     assert!(get_object_result.is_ok());
     let get_object_response = get_object_result.unwrap();
@@ -280,10 +298,13 @@ fn verify_rpc_handlers() {
         request_id
     };
 
-    let update_object_json = serde_json::to_value(update_object_payload).unwrap();
-    let update_object_args = vec![update_object_json];
+    let update_object_json = serde_json::to_value(vec![update_object_payload]).unwrap();
+    let update_object_fast_msg_data =
+        FastMessageData::new("updateobject".into(), update_object_json);
+    let update_object_fast_msg =
+        FastMessage::data(msg_id, update_object_fast_msg_data);
     let mut update_object_result =
-        object::update::handler(msg_id, &update_object_args, vec![], &pool, &log);
+        util::msg_handler(&update_object_fast_msg, &pool, &log);
 
     assert!(update_object_result.is_ok());
     let mut update_object_response = update_object_result.unwrap();
@@ -321,10 +342,13 @@ fn verify_rpc_handlers() {
         request_id
     };
 
-    let create_object_json = serde_json::to_value(create_object_payload).unwrap();
-    let create_object_args = vec![create_object_json];
+    let create_object_json = serde_json::to_value(vec![create_object_payload]).unwrap();
+    let create_object_fast_msg_data =
+        FastMessageData::new("createobject".into(), create_object_json);
+    let create_object_fast_msg =
+        FastMessage::data(msg_id, create_object_fast_msg_data);
     let mut create_object_result =
-        object::create::handler(msg_id, &create_object_args, vec![], &pool, &log);
+        util::msg_handler(&create_object_fast_msg, &pool, &log);
 
     assert!(create_object_result.is_ok());
     let create_object_response = create_object_result.unwrap();
@@ -338,7 +362,7 @@ fn verify_rpc_handlers() {
 
     // Read object again and verify a successful response is returned
     get_object_result =
-        object::get::handler(msg_id, &get_object_args, vec![], &pool, &log);
+        util::msg_handler(&get_object_fast_msg, &pool, &log);
 
     assert!(get_object_result.is_ok());
     let get_object_response = get_object_result.unwrap();
@@ -354,7 +378,7 @@ fn verify_rpc_handlers() {
 
     // Update the object's metadata and verify it is successful
     update_object_result =
-        object::update::handler(msg_id, &update_object_args, vec![], &pool, &log);
+        util::msg_handler(&update_object_fast_msg, &pool, &log);
 
     assert!(update_object_result.is_ok());
     update_object_response = update_object_result.unwrap();
@@ -370,8 +394,7 @@ fn verify_rpc_handlers() {
 
     // Read object again and verify the metadata update
     get_object_result =
-        object::get::handler(msg_id, &get_object_args, vec![], &pool, &log);
-
+        util::msg_handler(&get_object_fast_msg, &pool, &log);
     assert!(get_object_result.is_ok());
     let get_object_response = get_object_result.unwrap();
     assert_eq!(get_object_response.len(), 1);
@@ -387,9 +410,14 @@ fn verify_rpc_handlers() {
     // Delete object
 
     // The get and delete object args are the same so we can reuse
-    // get_object_args here.
+    // get_object_json here.
+    let delete_object_json = serde_json::to_value(vec![get_object_payload]).unwrap();
+    let delete_object_fast_msg_data =
+        FastMessageData::new("deleteobject".into(), delete_object_json);
+    let delete_object_fast_msg =
+        FastMessage::data(msg_id, delete_object_fast_msg_data);
     let mut delete_object_result =
-        object::delete::handler(msg_id, &get_object_args, vec![], &pool, &log);
+        util::msg_handler(&delete_object_fast_msg, &pool, &log);
 
     assert!(delete_object_result.is_ok());
     let delete_object_response = delete_object_result.unwrap();
@@ -403,7 +431,7 @@ fn verify_rpc_handlers() {
 
     // Read object again and verify it is not found
     get_object_result =
-        object::get::handler(msg_id, &get_object_args, vec![], &pool, &log);
+        util::msg_handler(&get_object_fast_msg, &pool, &log);
 
     assert!(get_object_result.is_ok());
     let get_object_response = get_object_result.unwrap();
@@ -417,7 +445,7 @@ fn verify_rpc_handlers() {
 
     // Delete the object again and verify it is not found
     delete_object_result =
-        object::delete::handler(msg_id, &get_object_args, vec![], &pool, &log);
+        util::msg_handler(&delete_object_fast_msg, &pool, &log);
 
     assert!(delete_object_result.is_ok());
     let delete_object_response = delete_object_result.unwrap();
@@ -434,17 +462,19 @@ fn verify_rpc_handlers() {
     let list_buckets_payload = bucket::list::ListBucketsPayload {
         owner: owner_id,
         vnode: 0,
-        prefix: "testbucket".into(),
-        order_by: "created".into(),
+        prefix: Some("testbucket".into()),
         limit: 1000,
-        offset: 0,
+        marker: None,
         request_id
     };
 
-    let list_buckets_json = serde_json::to_value(list_buckets_payload).unwrap();
-    let list_buckets_args = vec![list_buckets_json];
+    let list_buckets_json = serde_json::to_value(vec![list_buckets_payload]).unwrap();
+    let list_buckets_fast_msg_data =
+        FastMessageData::new("listbuckets".into(), list_buckets_json);
+    let list_buckets_fast_msg =
+        FastMessage::data(msg_id, list_buckets_fast_msg_data);
     let mut list_buckets_result =
-        bucket::list::handler(msg_id, &list_buckets_args, vec![], &pool, &log);
+        util::msg_handler(&list_buckets_fast_msg, &pool, &log);
 
     assert!(list_buckets_result.is_ok());
     let list_buckets_response = list_buckets_result.unwrap();
@@ -452,7 +482,7 @@ fn verify_rpc_handlers() {
 
     // Create a bucket and list buckets again
     create_bucket_result =
-        bucket::create::handler(msg_id, &create_bucket_args, vec![], &pool, &log);
+        util::msg_handler(&create_bucket_fast_msg, &pool, &log);
 
     assert!(create_bucket_result.is_ok());
     let create_bucket_response = create_bucket_result.unwrap();
@@ -464,7 +494,7 @@ fn verify_rpc_handlers() {
     assert_eq!(create_bucket_response_result.unwrap().name, bucket);
 
     list_buckets_result =
-        bucket::list::handler(msg_id, &list_buckets_args, vec![], &pool, &log);
+        util::msg_handler(&list_buckets_fast_msg, &pool, &log);
 
     assert!(list_buckets_result.is_ok());
     let list_buckets_response = list_buckets_result.unwrap();
@@ -477,17 +507,19 @@ fn verify_rpc_handlers() {
         owner: owner_id,
         bucket_id,
         vnode: 1,
-        prefix: "testobject".into(),
-        order_by: "created".into(),
+        prefix: Some("testobject".into()),
         limit: 1000,
-        offset: 0,
+        marker: None,
         request_id
     };
 
-    let list_objects_json = serde_json::to_value(list_objects_payload).unwrap();
-    let list_objects_args = vec![list_objects_json];
+    let list_objects_json = serde_json::to_value(vec![list_objects_payload]).unwrap();
+    let list_objects_fast_msg_data =
+        FastMessageData::new("listobjects".into(), list_objects_json);
+    let list_objects_fast_msg =
+        FastMessage::data(msg_id, list_objects_fast_msg_data);
     let mut list_objects_result =
-        object::list::handler(msg_id, &list_objects_args, vec![], &pool, &log);
+        util::msg_handler(&list_objects_fast_msg, &pool, &log);
 
     assert!(list_objects_result.is_ok());
     let list_objects_response = list_objects_result.unwrap();
@@ -495,7 +527,7 @@ fn verify_rpc_handlers() {
 
     // Create an object and list objects again
     create_object_result =
-        object::create::handler(msg_id, &create_object_args, vec![], &pool, &log);
+        util::msg_handler(&create_object_fast_msg, &pool, &log);
 
     assert!(create_object_result.is_ok());
     let create_object_response = create_object_result.unwrap();
@@ -507,10 +539,9 @@ fn verify_rpc_handlers() {
     assert_eq!(create_object_response_result.unwrap().name, object);
 
     list_objects_result =
-        object::list::handler(msg_id, &list_objects_args, vec![], &pool, &log);
+        util::msg_handler(&list_objects_fast_msg, &pool, &log);
 
     assert!(list_objects_result.is_ok());
     let list_objects_response = list_objects_result.unwrap();
     assert_eq!(list_objects_response.len(), 1);
-
 }
