commit 34b26197b0eee07e54108b3753fe0ee8b2a4e3fb (refs/changes/71/2471/2)
Author: Alex Wilson <alex.wilson@joyent.com>
Date:   2017-08-28T14:07:31-07:00 (2 years, 1 month ago)
    
    joyent/node-cueball#80 want getLastError() for connection pools & sets

diff --git a/CHANGES.adoc b/CHANGES.adoc
index d436f2f..254611c 100644
--- a/CHANGES.adoc
+++ b/CHANGES.adoc
@@ -6,6 +6,22 @@ toc::[]
 
 ## v2.x
 
+### v2.3.0
+
+New minor release, due to addition of new API.
+
+API changes:
+
+ - The `Agent` class now has methods `getPool()` and `createPool()`, which
+   enables inspection of its internal state, as well as injection of a custom
+   Resolver (#122, #124)
+ - Pools and Sets now have a new method `getLastError()` (#80)
+
+Bugs fixed:
+
+ - #123 ConnectionSet memory leak during failure
+ - #120 Documentation improvements
+
 ### v2.2.9
 
 Maintenance release.
diff --git a/docs/api.adoc b/docs/api.adoc
index ee925ab..8ac663f 100644
--- a/docs/api.adoc
+++ b/docs/api.adoc
@@ -226,6 +226,15 @@ emit `'error'`. If you do not register a handler for this event immediately
 at the start of your claim, and it emits, this will be treated as an uncaught
 error and cause the program to crash.
 
+### `#getLastError()`
+
+When the pool has entered state "failed", this method may be used to retrieve
+the last Error object emitted by a connection attempt in the pool. Note that
+while this is very likely to be a proximate cause of the pool failure,
+determining the root cause may require further analysis.
+
+Returns an Error object.
+
 ## Resolver
 
 ### About the interface
@@ -757,7 +766,14 @@ Parameters
 
 Returns all the currently open connections in the Set, as an Array.
 
+### `#getLastError()`
+
+When the set has entered state "failed", this method may be used to retrieve
+the last Error object emitted by a connection attempt for the set. Note that
+while this is very likely to be a proximate cause of the failure,
+determining the root cause may require further analysis.
 
+Returns an Error object.
 
 # Tools
 
diff --git a/lib/pool.js b/lib/pool.js
index 12c9be3..84cab63 100644
--- a/lib/pool.js
+++ b/lib/pool.js
@@ -178,6 +178,8 @@ function CueBallConnectionPool(options) {
 	this.p_initq = new Queue();
 	this.p_waiters = new Queue();
 
+	this.p_lastError = undefined;
+
 	this.p_counters = {};
 
 	var self = this;
@@ -291,6 +293,7 @@ CueBallConnectionPool.prototype.state_starting = function (S) {
 	if (this.p_resolver.isInState('failed')) {
 		this.p_log.warn('pre-provided resolver has already failed, ' +
 		    'pool will start up in "failed" state');
+		this.p_lastError = this.p_resolver.getLastError();
 		S.gotoState('failed');
 		return;
 	}
@@ -299,6 +302,7 @@ CueBallConnectionPool.prototype.state_starting = function (S) {
 		if (state === 'failed') {
 			self.p_log.warn('underlying resolver failed, moving ' +
 			    'pool to "failed" state');
+			self.p_lastError = self.p_resolver.getLastError();
 			S.gotoState('failed');
 		}
 	});
@@ -453,6 +457,10 @@ CueBallConnectionPool.prototype.isDeclaredDead = function (backend) {
 	return (this.p_dead[backend] === true);
 };
 
+CueBallConnectionPool.prototype.getLastError = function () {
+	return (this.p_lastError);
+};
+
 CueBallConnectionPool.prototype.reshuffle = function () {
 	if (this.p_keys.length <= 1)
 		return;
@@ -665,6 +673,10 @@ CueBallConnectionPool.prototype.addConnection = function (key) {
 
 		if (newState === 'failed') {
 			self.p_dead[key] = true;
+
+			var err = fsm.getSocketMgr().getLastError();
+			if (err !== undefined)
+				self.p_lastError = err;
 		}
 
 		if (newState === 'stopped' || newState === 'failed') {
diff --git a/lib/set.js b/lib/set.js
index 62c8332..473a427 100644
--- a/lib/set.js
+++ b/lib/set.js
@@ -110,6 +110,7 @@ function CueBallConnectionSet(options) {
 
 	/* Debugging counters. */
 	this.cs_counters = {};
+	this.cs_lastError = undefined;
 
 	var self = this;
 
@@ -181,6 +182,7 @@ CueBallConnectionSet.prototype.state_starting = function (S) {
 	if (this.cs_resolver.isInState('failed')) {
 		this.cs_log.warn('resolver has already failed, cset will ' +
 		    'start up in "failed" state');
+		this.cs_lastError = this.cs_resolver.getLastError();
 		S.gotoState('failed');
 		return;
 	}
@@ -189,6 +191,7 @@ CueBallConnectionSet.prototype.state_starting = function (S) {
 		if (st === 'failed') {
 			self.cs_log.warn('underlying resolver failed, moving ' +
 			    'cset to "failed" state');
+			self.cs_lastError = self.cs_resolver.getLastError();
 			S.gotoState('failed');
 		}
 	});
@@ -571,6 +574,9 @@ CueBallConnectionSet.prototype.addConnection = function (key) {
 			 */
 			if (self.cs_backends[key] !== undefined) {
 				self.cs_dead[key] = true;
+				var err = fsm.getSocketMgr().getLastError();
+				if (err !== undefined)
+					self.cs_lastError = err;
 			}
 		}
 
@@ -584,6 +590,10 @@ CueBallConnectionSet.prototype.addConnection = function (key) {
 	fsm.start();
 };
 
+CueBallConnectionSet.prototype.getLastError = function () {
+	return (this.cs_lastError);
+};
+
 CueBallConnectionSet.prototype.getConnections = function () {
 	var self = this;
 	var conns = [];
diff --git a/package.json b/package.json
index ced0d14..1aa09f7 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "cueball",
-  "version": "2.2.9",
+  "version": "2.3.0",
   "description": "manage a pool of connections to a multi-node service where nodes are listed in DNS",
   "main": "lib/index.js",
   "dependencies": {
diff --git a/test/cset.test.js b/test/cset.test.js
index d76e896..7815b76 100644
--- a/test/cset.test.js
+++ b/test/cset.test.js
@@ -515,11 +515,17 @@ mod_tape.test('cset connect-reject (#92)', function (t) {
 	});
 
 	cset.on('stateChanged', function (st) {
-		if (st === 'failed')
+		if (st === 'failed') {
+			var e = cset.getLastError();
+			t.notStrictEqual(e, undefined);
+			t.notStrictEqual(
+			    e.message.indexOf('Connection timed out'), -1);
 			cset.stop();
-		if (st === 'stopped') {
+		} else if (st === 'stopped') {
 			t.deepEqual(inset, []);
 			t.end();
+		} else if (st !== 'stopping') {
+			t.strictEqual(cset.getLastError(), undefined);
 		}
 	});
 
diff --git a/test/pool.test.js b/test/pool.test.js
index 67d8c24..d2ecaaa 100644
--- a/test/pool.test.js
+++ b/test/pool.test.js
@@ -497,8 +497,8 @@ mod_tape.test('pool failure', function (t) {
 
 				t.equal(connections.length, 2);
 				summarize();
-				index.b1[0].emit('error', new Error());
-				index.b1[1].emit('error', new Error());
+				index.b1[0].emit('error', new Error('test'));
+				index.b1[1].emit('error', new Error('test'));
 
 				var sawErr = false;
 				pool.claim(function (err) {
@@ -511,6 +511,11 @@ mod_tape.test('pool failure', function (t) {
 				setTimeout(function () {
 					t.ok(pool.isInState('failed'));
 					t.ok(sawErr);
+					t.notStrictEqual(pool.getLastError(),
+					    undefined);
+					t.strictEqual(
+					    pool.getLastError().message,
+					    'test');
 
 					t.equal(connections.length, 1);
 					summarize();
@@ -565,9 +570,9 @@ mod_tape.test('pool failure / retry race', function (t) {
 		t.deepEqual(counts, { 'b1': 2 });
 
 		index.b1[0].connect();
-		index.b1[0].emit('error', new Error());
+		index.b1[0].emit('error', new Error('test'));
 		index.b1[1].connect();
-		index.b1[1].emit('error', new Error());
+		index.b1[1].emit('error', new Error('test'));
 
 		setTimeout(function () {
 			t.ok(pool.isInState('running'));
@@ -575,16 +580,17 @@ mod_tape.test('pool failure / retry race', function (t) {
 			t.equal(connections.length, 2);
 			summarize();
 			index.b1[1].connect();
-			index.b1[1].emit('error', new Error());
+			index.b1[1].emit('error', new Error('test'));
 			index.b1[0].connect();
-			index.b1[0].emit('error', new Error());
+			index.b1[0].emit('error', new Error('test'));
 
 			setTimeout(function () {
 				t.ok(pool.isInState('running'));
+				t.strictEqual(pool.getLastError(), undefined);
 
 				t.equal(connections.length, 2);
 				summarize();
-				index.b1[1].emit('error', new Error());
+				index.b1[1].emit('error', new Error('test2'));
 				index.b1[0].connect();
 
 				setTimeout(function () {
