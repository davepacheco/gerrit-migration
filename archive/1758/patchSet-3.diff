From 3d55008fcd2b9eb83970bc4093dcbc08c7828e2c Mon Sep 17 00:00:00 2001
From: Jerry Jelinek <jerry.jelinek@joyent.com>
Date: Fri, 7 Apr 2017 16:04:38 +0000
Subject: [PATCH] OS-5250 lxbrand populate d_type in sysfs

---
 .../uts/common/brand/lx/syscall/lx_getdents.c |  76 +++++++++-
 usr/src/uts/common/brand/lx/sysfs/lx_sysfs.h  |   4 +-
 .../uts/common/brand/lx/sysfs/lx_sysvfsops.c  |  21 ++-
 .../uts/common/brand/lx/sysfs/lx_sysvnops.c   | 142 +++++++++++++++++-
 4 files changed, 231 insertions(+), 12 deletions(-)

diff --git a/usr/src/uts/common/brand/lx/syscall/lx_getdents.c b/usr/src/uts/common/brand/lx/syscall/lx_getdents.c
index 101d8b2911..5bde892aea 100644
--- a/usr/src/uts/common/brand/lx/syscall/lx_getdents.c
+++ b/usr/src/uts/common/brand/lx/syscall/lx_getdents.c
@@ -20,7 +20,7 @@
  */
 
 /*
- * Copyright 2016 Joyent, Inc.
+ * Copyright 2017 Joyent, Inc.
  */
 
 #include <sys/systm.h>
@@ -43,6 +43,27 @@
 
 #define	LX_GETDENTS_MAX_BUFSZ	65536
 
+/*
+ * See the comment in our lx_sysfs VFS code for a detailed explanation around
+ * the handling of 'd_type' here.
+ */
+#define	LX_DT_UNKNOWN	0
+#define	LX_DT_FIFO	1
+#define	LX_DT_CHR	2
+#define	LX_DT_DIR	4
+#define	LX_DT_BLK	6
+#define	LX_DT_REG	8
+#define	LX_DT_LNK	10
+#define	LX_DT_SOCK	12
+
+/*
+ * Set by lx_sysfs when it loads. lx_sysfs depends on the lx_brand module,
+ * so our module has to load first and define the variables that lx_sysfs will
+ * set when it loads.
+ */
+int lx_sysfs_vfs_type;
+int (*lx_sysfs_vtype)(ino_t);
+
 /*
  * Because the Linux dirent has an extra field (d_type), it's possible that
  * each entry will be 8 bytes larger (and aligned to 8 bytes) due to padding.
@@ -52,6 +73,12 @@
 #define	LTOS_GETDENTS_BUFSZ(bufsz, datasz)	\
 	(((bufsz) / (((datasz) + 15) & ~7)) * sizeof (struct dirent))
 
+/*
+ * Linux d_type offset is at (d_reclen - 1). See the Linux getdents(2) man page.
+ * This macro assumes d_reclen is already set correctly.
+ */
+#define	LX_DTYPE(l) *(((char *)l) + (l->d_reclen - 1))
+
 /*
  * Record must be long enough to house d_name string, null terminator and
  * d_type field.  It's then padded to nearest 8-byte boundary
@@ -86,9 +113,10 @@ struct lx_dirent_64 {
 
 static long
 lx_getdents_common(int fd, caddr_t uptr, size_t count,
-    unsigned int lx_size, int (*outcb)(caddr_t, caddr_t, int))
+    unsigned int lx_size, int (*outcb)(caddr_t, caddr_t, int, boolean_t))
 {
 	vnode_t *vp;
+	boolean_t is_sysfs = B_FALSE;
 	file_t *fp;
 	struct uio auio;
 	struct iovec aiov;
@@ -113,6 +141,10 @@ lx_getdents_common(int fd, caddr_t uptr, size_t count,
 		return (set_errno(EBADF));
 	}
 
+	if (vp->v_vfsp->vfs_fstype == lx_sysfs_vfs_type) {
+		is_sysfs = B_TRUE;
+	}
+
 	if (count > LX_GETDENTS_MAX_BUFSZ) {
 		/*
 		 * If the target buffer passed to us is huge, keep the
@@ -167,7 +199,7 @@ lx_getdents_common(int fd, caddr_t uptr, size_t count,
 		if (error != 0 || auio.uio_resid == sbufsz) {
 			break;
 		}
-		res = outcb(sbuf, lbuf, bufsz - auio.uio_resid);
+		res = outcb(sbuf, lbuf, bufsz - auio.uio_resid, is_sysfs);
 		VERIFY(res <= lbufsz);
 		if (res == 0) {
 			/* no records to copyout from this batch */
@@ -217,9 +249,27 @@ lx_getdents_common(int fd, caddr_t uptr, size_t count,
 	return (outb);
 }
 
+static int
+lx_get_sysfs_dtype(ino_t ino)
+{
+	vtype_t vt;
+
+	vt = lx_sysfs_vtype(ino);
+
+	switch (vt) {
+	case VREG:	return (LX_DT_REG);
+	case VDIR:	return (LX_DT_DIR);
+	case VBLK:	return (LX_DT_BLK);
+	case VCHR:	return (LX_DT_CHR);
+	case VLNK:	return (LX_DT_LNK);
+	case VFIFO:	return (LX_DT_FIFO);
+	case VSOCK:	return (LX_DT_SOCK);
+	default:	return (LX_DT_UNKNOWN);
+	}
+}
 
 static int
-lx_getdents_format32(caddr_t sbuf, caddr_t lbuf, int len)
+lx_getdents_format32(caddr_t sbuf, caddr_t lbuf, int len, boolean_t is_sysfs)
 {
 	struct dirent *sd;
 	struct lx_dirent_32 *ld;
@@ -243,6 +293,10 @@ lx_getdents_format32(caddr_t sbuf, caddr_t lbuf, int len)
 		bzero(ld->d_name + namelen,
 		    LX_ZEROLEN(namelen, struct lx_dirent_32));
 
+		if (is_sysfs) {
+			LX_DTYPE(ld) = lx_get_sysfs_dtype(ld->d_ino);
+		}
+
 		len -= sd->d_reclen;
 		size += ld->d_reclen;
 		sbuf += sd->d_reclen;
@@ -252,7 +306,7 @@ lx_getdents_format32(caddr_t sbuf, caddr_t lbuf, int len)
 }
 
 static int
-lx_getdents_format64(caddr_t sbuf, caddr_t lbuf, int len)
+lx_getdents_format64(caddr_t sbuf, caddr_t lbuf, int len, boolean_t is_sysfs)
 {
 	struct dirent *sd;
 	struct lx_dirent_64 *ld;
@@ -276,6 +330,10 @@ lx_getdents_format64(caddr_t sbuf, caddr_t lbuf, int len)
 		bzero(ld->d_name + namelen,
 		    LX_ZEROLEN(namelen, struct lx_dirent_64));
 
+		if (is_sysfs) {
+			LX_DTYPE(ld) = lx_get_sysfs_dtype(ld->d_ino);
+		}
+
 		len -= sd->d_reclen;
 		size += ld->d_reclen;
 		sbuf += sd->d_reclen;
@@ -314,7 +372,7 @@ struct lx_dirent64 {
 	((offsetof(struct lx_dirent64, d_name) + (namelen))))
 
 static int
-lx_getdents64_format(caddr_t sbuf, caddr_t lbuf, int len)
+lx_getdents64_format(caddr_t sbuf, caddr_t lbuf, int len, boolean_t is_sysfs)
 {
 	struct dirent *sd;
 	struct lx_dirent64 *ld;
@@ -330,13 +388,17 @@ lx_getdents64_format(caddr_t sbuf, caddr_t lbuf, int len)
 
 		ld->d_ino = sd->d_ino;
 		ld->d_off = sd->d_off;
-		ld->d_type = 0;
+		ld->d_type = LX_DT_UNKNOWN;
 		(void) strncpy(ld->d_name, sd->d_name, namelen);
 		ld->d_name[namelen] = 0;
 		ld->d_reclen = (ushort_t)LX_RECLEN64(namelen);
 		/* Zero out any alignment padding */
 		bzero(ld->d_name + namelen, LX_ZEROLEN64(namelen));
 
+		if (is_sysfs) {
+			ld->d_type = lx_get_sysfs_dtype(ld->d_ino);
+		}
+
 		len -= sd->d_reclen;
 		size += ld->d_reclen;
 		sbuf += sd->d_reclen;
diff --git a/usr/src/uts/common/brand/lx/sysfs/lx_sysfs.h b/usr/src/uts/common/brand/lx/sysfs/lx_sysfs.h
index 93dc316c1e..f34ed31dcb 100644
--- a/usr/src/uts/common/brand/lx/sysfs/lx_sysfs.h
+++ b/usr/src/uts/common/brand/lx/sysfs/lx_sysfs.h
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright 2016 Joyent, Inc.
+ * Copyright 2017 Joyent, Inc.
  */
 
 #ifndef	_LXSYSFS_H
@@ -166,6 +166,8 @@ extern void lxsys_freenode(lxsys_node_t *);
 extern netstack_t *lxsys_netstack(lxsys_node_t *);
 extern ill_t *lxsys_find_ill(ip_stack_t *, uint_t);
 
+extern int lxsys_ino_get_type(ino_t);
+
 typedef struct lxpr_uiobuf {
 	uio_t *uiop;
 	char *buffer;
diff --git a/usr/src/uts/common/brand/lx/sysfs/lx_sysvfsops.c b/usr/src/uts/common/brand/lx/sysfs/lx_sysvfsops.c
index 9bb1d70527..fddc1e0234 100644
--- a/usr/src/uts/common/brand/lx/sysfs/lx_sysvfsops.c
+++ b/usr/src/uts/common/brand/lx/sysfs/lx_sysvfsops.c
@@ -10,11 +10,21 @@
  */
 
 /*
- * Copyright 2016 Joyent, Inc.
+ * Copyright 2017 Joyent, Inc.
  */
 
 /*
  * lxsysvfsops.c: vfs operations for lx sysfs.
+ *
+ * sysfs has a close relationship with the lx getdents(2) syscall. This is
+ * necessary so that the getdents code can populate the 'd_type' entries
+ * during a sysfs readdir operation. The glibc code which accesses sysfs
+ * (specifically the 'cpu' subtree) expects dirents to have the d_type field
+ * populated. One problematic consumer is java, which becomes unstable if it
+ * gets the incorrect data from glibc. When sysfs loads, it populates the
+ * lx_sysfs_vfs_type and lx_sysfs_vtype variables defined in lx_getdents.c.
+ * The getdents code can then call into sysfs to determine the d_type for any
+ * given inode directory entry.
  */
 
 #include <sys/types.h>
@@ -51,6 +61,9 @@ static int	lxsysfstype;
 static dev_t	lxsysdev;
 static kmutex_t	lxsys_mount_lock;
 
+extern int	lx_sysfs_vfs_type;
+extern int	(*lx_sysfs_vtype)(ino_t);
+
 static int lxsys_mount(vfs_t *, vnode_t *, mounta_t *, cred_t *);
 static int lxsys_unmount(vfs_t *, int, cred_t *);
 static int lxsys_root(vfs_t *, vnode_t **);
@@ -101,6 +114,9 @@ _fini(void)
 	if ((retval = mod_remove(&modlinkage)) != 0)
 		goto done;
 
+	lx_sysfs_vfs_type = 0;
+	lx_sysfs_vtype = NULL;
+
 	/*
 	 * destroy lxsys_node cache
 	 */
@@ -131,7 +147,8 @@ lxsys_init(int fstype, char *name)
 	int error;
 	major_t dev;
 
-	lxsysfstype = fstype;
+	lx_sysfs_vtype = lxsys_ino_get_type;
+	lx_sysfs_vfs_type = lxsysfstype = fstype;
 	ASSERT(lxsysfstype != 0);
 
 	mutex_init(&lxsys_mount_lock, NULL, MUTEX_DEFAULT, NULL);
diff --git a/usr/src/uts/common/brand/lx/sysfs/lx_sysvnops.c b/usr/src/uts/common/brand/lx/sysfs/lx_sysvnops.c
index 7278a0fd92..3d545c7c28 100644
--- a/usr/src/uts/common/brand/lx/sysfs/lx_sysvnops.c
+++ b/usr/src/uts/common/brand/lx/sysfs/lx_sysvnops.c
@@ -169,6 +169,9 @@ const fs_operation_def_t lxsys_vnodeops_template[] = {
  * symlinks, and perhaps other static files. By only providing 'node0' we
  * pretend that there is only a single NUMA node available to a zone (trying to
  * be NUMA-aware inside a zone is generally not going to work anyway).
+ *
+ * The dyn_ino_type table must be updated whenever a new static instance is
+ * defined.
  */
 
 #define	LXSYS_INST_CLASSDIR			0x1
@@ -185,6 +188,31 @@ const fs_operation_def_t lxsys_vnodeops_template[] = {
 #define	LXSYS_INST_DEV_SYSCPU_KMAX		0xc
 #define	LXSYS_INST_DEVICES_SYSNODE		0xd
 #define	LXSYS_INST_BUSDIR			0xe
+#define	LXSYS_INST_MAX				LXSYS_INST_BUSDIR /* limit */
+
+/*
+ * This array is used for directory inode correction in lxsys_readdir_common
+ * when a directory's static-type entry is actually a dynamic-type.
+ */
+static int dyn_ino_type [] = {
+	0,				/* invalid */
+	0,				/* LXSYS_INST_CLASSDIR */
+	0,				/* LXSYS_INST_DEVICESDIR */
+	0,				/* LXSYS_INST_FSDIR */
+	LXSYS_CLASS_NET,		/* LXSYS_INST_CLASS_NETDIR */
+	0,				/* LXSYS_INST_DEVICES_VIRTUALDIR */
+	0,				/* LXSYS_INST_DEVICES_SYSTEMDIR */
+	0,				/* LXSYS_INST_FS_CGROUPDIR */
+	LXSYS_DEV_NET,			/* LXSYS_INST_DEV_VIRTUAL_NETDIR */
+	LXSYS_BLOCK,			/* LXSYS_INST_BLOCKDIR */
+	LXSYS_DEV_ZFS,			/* LXSYS_INST_DEVICES_ZFSDIR */
+	LXSYS_DEV_SYS_CPU,		/* LXSYS_INST_DEVICES_SYSCPU */
+	0,				/* LXSYS_INST_DEV_SYSCPU_KMAX */
+	LXSYS_DEV_SYS_NODE,		/* LXSYS_INST_DEV_SYSNODE */
+	0,				/* LXSYS_INST_BUSDIR */
+};
+#define	DYN_INO_LEN \
+	(sizeof (dyn_ino_type) / sizeof ((dyn_ino_type)[0]))
 
 /*
  * file contents of an lx /sys directory.
@@ -334,6 +362,99 @@ typedef struct lxsys_cpu_info {
 	processorid_t	cpu_seqid;
 } lxsys_cpu_info_t;
 
+/*
+ * Given one of our inodes, return the vnode type.
+ *
+ * lxsys_getnode will always set the vnode type to VDIR. It expects the
+ * caller (normally the lookup functions) to fix the type. Those same rules are
+ * encoded here for our inode-to-type translation.
+ */
+int
+lxsys_ino_get_type(ino_t ino)
+{
+	lxsys_nodetype_t type;
+	unsigned int instance;
+	unsigned int endpoint;
+
+	type = (ino & 0xff000000) >> 24;
+	instance = (ino & 0xffff00) >> 8;
+	endpoint = (ino & 0xff);
+
+	if (instance > LXSYS_INST_MAX)
+		return (VNON);
+
+	/* Validate non-static node types */
+	if (type != LXSYS_STATIC &&
+	    (type <= LXSYS_STATIC || type >= LXSYS_MAXTYPE)) {
+		return (VNON);
+	}
+
+	if (type == LXSYS_STATIC) {
+		switch (instance) {
+		case LXSYS_INST_DEV_SYSCPU_KMAX:
+			return (VREG);
+		}
+	} else {
+		/* Non-static node types */
+		switch (type) {
+		case LXSYS_CLASS_NET:
+			if (instance != 0) {
+				return (VLNK);
+			}
+			break;
+		case LXSYS_DEV_NET:
+			/*
+			 * /sys/devices/virtual/net usually has the eth0 and
+			 * lo directories. Each network device directory is an
+			 * instances with a 0 endpoint. The files within
+			 * that directory have a non-0 endpoint.
+			 */
+			if (endpoint != 0) {
+				return (VREG);
+			}
+			break;
+		case LXSYS_BLOCK:
+			if (instance != 0) {
+				return (VLNK);
+			}
+			break;
+		case LXSYS_DEV_ZFS:
+			/*
+			 * /sys/devices/zfs usually has the zfsds0 directory
+			 * instance with a 0 endpoint. The device file within
+			 * that directory has a non-0 endpoint.
+			 */
+			if (endpoint != 0) {
+				return (VREG);
+			}
+			break;
+		case LXSYS_DEV_SYS_CPU:
+			if (instance != 0) {
+				return (VREG);
+			}
+			break;
+		case LXSYS_DEV_SYS_CPUINFO:
+			if (instance != 0) {
+				return (VREG);
+			}
+			break;
+		case LXSYS_DEV_SYS_NODE:
+			/*
+			 * /sys/devices/system/node has the node0 directory
+			 * instance with a 0 endpoint. The cpulist file within
+			 * that directory has a non-0 endpoint.
+			 */
+			if (endpoint != 0) {
+				return (VREG);
+			}
+			break;
+		default:
+			break;
+		}
+	}
+	return (VDIR);
+}
+
 /*
  * lxsys_open(): Vnode operation for VOP_OPEN()
  */
@@ -1094,9 +1215,26 @@ lxsys_readdir_common(lxsys_node_t *lxsnp, uio_t *uiop, int *eofp,
 		} else if (dirindex >= 0 && dirindex < dirtablen) {
 
 			int slen = strlen(dirtab[dirindex].d_name);
+			int idnum, ino_type = 0;
+
+			idnum = dirtab[dirindex].d_idnum;
+			if (idnum > 0 && idnum < DYN_INO_LEN)
+				ino_type = dyn_ino_type[idnum];
+
+			if (ino_type != 0) {
+				/*
+				 * Correct the inode for static directories
+				 * which contain non-static lxsys_nodetype_t's.
+				 */
+				dirent->d_ino = lxsys_inode(ino_type, 0, 0);
+				DTRACE_PROBE3(lxsys__fix__inode,
+				    char *, dirtab[dirindex].d_name,
+				    int, ino_type, int, dirent->d_ino);
+			} else {
+				dirent->d_ino = lxsys_inode(LXSYS_STATIC,
+				    idnum, 0);
+			}
 
-			dirent->d_ino = lxsys_inode(LXSYS_STATIC,
-			    dirtab[dirindex].d_idnum, 0);
 			(void) strcpy(dirent->d_name, dirtab[dirindex].d_name);
 			reclen = DIRENT64_RECLEN(slen);
 
-- 
2.21.0

