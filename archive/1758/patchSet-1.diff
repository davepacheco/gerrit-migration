From 15903caa2f3bee93c930df628be91d471e1d9739 Mon Sep 17 00:00:00 2001
From: Jerry Jelinek <jerry.jelinek@joyent.com>
Date: Thu, 6 Apr 2017 15:47:50 +0000
Subject: [PATCH] OS-5250 lxbrand populate d_type in sysfs

---
 usr/src/uts/common/brand/lx/sys/lx_types.h    |  11 +-
 .../uts/common/brand/lx/syscall/lx_getdents.c |  78 +++++-
 usr/src/uts/common/brand/lx/sysfs/lx_sysfs.h  |   9 +-
 .../uts/common/brand/lx/sysfs/lx_sysvfsops.c  |  27 +-
 .../uts/common/brand/lx/sysfs/lx_sysvnops.c   | 264 +++++++++++++++++-
 5 files changed, 376 insertions(+), 13 deletions(-)

diff --git a/usr/src/uts/common/brand/lx/sys/lx_types.h b/usr/src/uts/common/brand/lx/sys/lx_types.h
index 90363c8939..511e2028ca 100644
--- a/usr/src/uts/common/brand/lx/sys/lx_types.h
+++ b/usr/src/uts/common/brand/lx/sys/lx_types.h
@@ -21,7 +21,7 @@
 /*
  * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
- * Copyright 2016 Joyent, Inc.  All rights reserved.
+ * Copyright 2017 Joyent, Inc.  All rights reserved.
  */
 
 #ifndef _SYS_LX_TYPES_H
@@ -71,6 +71,15 @@ typedef	uint64_t	lx_blkcnt64_t;
 typedef	uint32_t	lx_mode_t;
 typedef	uint16_t	lx_mode16_t;
 
+/*
+ * lx_fid overlays the fid structure (for VFS_VGET)
+ */
+typedef struct lx_fid {
+	uint16_t lxfid_len;
+	ino32_t lxfid_ino;
+	int32_t lxfid_gen;
+} lx_fid_t;
+
 /*
  * Linux mangles major/minor numbers into dev_t differently than SunOS.
  */
diff --git a/usr/src/uts/common/brand/lx/syscall/lx_getdents.c b/usr/src/uts/common/brand/lx/syscall/lx_getdents.c
index 101d8b2911..5f3bcb2a4b 100644
--- a/usr/src/uts/common/brand/lx/syscall/lx_getdents.c
+++ b/usr/src/uts/common/brand/lx/syscall/lx_getdents.c
@@ -20,7 +20,7 @@
  */
 
 /*
- * Copyright 2016 Joyent, Inc.
+ * Copyright 2017 Joyent, Inc.
  */
 
 #include <sys/systm.h>
@@ -43,6 +43,13 @@
 
 #define	LX_GETDENTS_MAX_BUFSZ	65536
 
+/*
+ * Set by lx_sysfs when it loads. lx_sysfs depends on the lx_brand module,
+ * so our module has to load first and define the variable that lx_sysfs will
+ * set when it loads.
+ */
+int lx_sysfs_type;
+
 /*
  * Because the Linux dirent has an extra field (d_type), it's possible that
  * each entry will be 8 bytes larger (and aligned to 8 bytes) due to padding.
@@ -52,6 +59,12 @@
 #define	LTOS_GETDENTS_BUFSZ(bufsz, datasz)	\
 	(((bufsz) / (((datasz) + 15) & ~7)) * sizeof (struct dirent))
 
+/*
+ * Linux d_type offset is at (d_reclen - 1). See the Linix getdents(2) man page.
+ * This macro assumes d_reclen is already set correctly.
+ */
+#define	LX_DTYPE(l) *(((char *)l) + (l->d_reclen - 1))
+
 /*
  * Record must be long enough to house d_name string, null terminator and
  * d_type field.  It's then padded to nearest 8-byte boundary
@@ -84,11 +97,21 @@ struct lx_dirent_64 {
 	uchar_t		d_type;
 };
 
+#define	LX_DT_UNKNOWN	0
+#define	LX_DT_FIFO	1
+#define	LX_DT_CHR	2
+#define	LX_DT_DIR	4
+#define	LX_DT_BLK	6
+#define	LX_DT_REG	8
+#define	LX_DT_LNK	10
+#define	LX_DT_SOCK	12
+
 static long
 lx_getdents_common(int fd, caddr_t uptr, size_t count,
-    unsigned int lx_size, int (*outcb)(caddr_t, caddr_t, int))
+    unsigned int lx_size, int (*outcb)(caddr_t, caddr_t, int, vfs_t *))
 {
 	vnode_t *vp;
+	vfs_t *vfsp = NULL;
 	file_t *fp;
 	struct uio auio;
 	struct iovec aiov;
@@ -113,6 +136,10 @@ lx_getdents_common(int fd, caddr_t uptr, size_t count,
 		return (set_errno(EBADF));
 	}
 
+	if (vp->v_vfsp->vfs_fstype == lx_sysfs_type) {
+		vfsp = vp->v_vfsp;
+	}
+
 	if (count > LX_GETDENTS_MAX_BUFSZ) {
 		/*
 		 * If the target buffer passed to us is huge, keep the
@@ -167,7 +194,7 @@ lx_getdents_common(int fd, caddr_t uptr, size_t count,
 		if (error != 0 || auio.uio_resid == sbufsz) {
 			break;
 		}
-		res = outcb(sbuf, lbuf, bufsz - auio.uio_resid);
+		res = outcb(sbuf, lbuf, bufsz - auio.uio_resid, vfsp);
 		VERIFY(res <= lbufsz);
 		if (res == 0) {
 			/* no records to copyout from this batch */
@@ -217,9 +244,34 @@ lx_getdents_common(int fd, caddr_t uptr, size_t count,
 	return (outb);
 }
 
+static int
+lx_get_dtype(vfs_t *vfsp, int ino)
+{
+	vnode_t *vp;
+	lx_fid_t fid;
+	int dtype = VNON;
+
+	fid.lxfid_ino = ino;
+	if (VFS_VGET(vfsp, &vp, (fid_t *)&fid) == 0 && vp != NULL) {
+		dtype = vp->v_type;
+		VN_RELE(vp);
+	}
+
+	switch (dtype) {
+	case VREG:	return (LX_DT_REG);
+	case VDIR:	return (LX_DT_DIR);
+	case VBLK:	return (LX_DT_BLK);
+	case VCHR:	return (LX_DT_CHR);
+	case VLNK:	return (LX_DT_LNK);
+	case VFIFO:	return (LX_DT_FIFO);
+	case VSOCK:	return (LX_DT_SOCK);
+	}
+
+	return (LX_DT_UNKNOWN);
+}
 
 static int
-lx_getdents_format32(caddr_t sbuf, caddr_t lbuf, int len)
+lx_getdents_format32(caddr_t sbuf, caddr_t lbuf, int len, vfs_t *vfsp)
 {
 	struct dirent *sd;
 	struct lx_dirent_32 *ld;
@@ -243,6 +295,10 @@ lx_getdents_format32(caddr_t sbuf, caddr_t lbuf, int len)
 		bzero(ld->d_name + namelen,
 		    LX_ZEROLEN(namelen, struct lx_dirent_32));
 
+		if (vfsp != NULL) {
+			LX_DTYPE(ld) = lx_get_dtype(vfsp, ld->d_ino);
+		}
+
 		len -= sd->d_reclen;
 		size += ld->d_reclen;
 		sbuf += sd->d_reclen;
@@ -252,7 +308,7 @@ lx_getdents_format32(caddr_t sbuf, caddr_t lbuf, int len)
 }
 
 static int
-lx_getdents_format64(caddr_t sbuf, caddr_t lbuf, int len)
+lx_getdents_format64(caddr_t sbuf, caddr_t lbuf, int len, vfs_t *vfsp)
 {
 	struct dirent *sd;
 	struct lx_dirent_64 *ld;
@@ -276,6 +332,10 @@ lx_getdents_format64(caddr_t sbuf, caddr_t lbuf, int len)
 		bzero(ld->d_name + namelen,
 		    LX_ZEROLEN(namelen, struct lx_dirent_64));
 
+		if (vfsp != NULL) {
+			LX_DTYPE(ld) = lx_get_dtype(vfsp, ld->d_ino);
+		}
+
 		len -= sd->d_reclen;
 		size += ld->d_reclen;
 		sbuf += sd->d_reclen;
@@ -314,7 +374,7 @@ struct lx_dirent64 {
 	((offsetof(struct lx_dirent64, d_name) + (namelen))))
 
 static int
-lx_getdents64_format(caddr_t sbuf, caddr_t lbuf, int len)
+lx_getdents64_format(caddr_t sbuf, caddr_t lbuf, int len, vfs_t *vfsp)
 {
 	struct dirent *sd;
 	struct lx_dirent64 *ld;
@@ -330,13 +390,17 @@ lx_getdents64_format(caddr_t sbuf, caddr_t lbuf, int len)
 
 		ld->d_ino = sd->d_ino;
 		ld->d_off = sd->d_off;
-		ld->d_type = 0;
+		ld->d_type = LX_DT_UNKNOWN;
 		(void) strncpy(ld->d_name, sd->d_name, namelen);
 		ld->d_name[namelen] = 0;
 		ld->d_reclen = (ushort_t)LX_RECLEN64(namelen);
 		/* Zero out any alignment padding */
 		bzero(ld->d_name + namelen, LX_ZEROLEN64(namelen));
 
+		if (vfsp != NULL) {
+			ld->d_type = lx_get_dtype(vfsp, ld->d_ino);
+		}
+
 		len -= sd->d_reclen;
 		size += ld->d_reclen;
 		sbuf += sd->d_reclen;
diff --git a/usr/src/uts/common/brand/lx/sysfs/lx_sysfs.h b/usr/src/uts/common/brand/lx/sysfs/lx_sysfs.h
index 93dc316c1e..7775193782 100644
--- a/usr/src/uts/common/brand/lx/sysfs/lx_sysfs.h
+++ b/usr/src/uts/common/brand/lx/sysfs/lx_sysfs.h
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright 2016 Joyent, Inc.
+ * Copyright 2017 Joyent, Inc.
  */
 
 #ifndef	_LXSYSFS_H
@@ -58,6 +58,11 @@ extern "C" {
 #include <inet/ip.h>
 #include <inet/ip_if.h>
 
+/*
+ * Convert a vfsp into an lxsys_mnt_t
+ */
+#define	VFSTOLXSM(vp)	((lxsys_mnt_t *)(vp)->vfs_data)
+
 /*
  * Convert a vnode into an lxsys_mnt_t
  */
@@ -166,6 +171,8 @@ extern void lxsys_freenode(lxsys_node_t *);
 extern netstack_t *lxsys_netstack(lxsys_node_t *);
 extern ill_t *lxsys_find_ill(ip_stack_t *, uint_t);
 
+extern lxsys_node_t *lxsys_ino_get_node(vfs_t *, ino_t);
+
 typedef struct lxpr_uiobuf {
 	uio_t *uiop;
 	char *buffer;
diff --git a/usr/src/uts/common/brand/lx/sysfs/lx_sysvfsops.c b/usr/src/uts/common/brand/lx/sysfs/lx_sysvfsops.c
index 9bb1d70527..cb15c75968 100644
--- a/usr/src/uts/common/brand/lx/sysfs/lx_sysvfsops.c
+++ b/usr/src/uts/common/brand/lx/sysfs/lx_sysvfsops.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright 2016 Joyent, Inc.
+ * Copyright 2017 Joyent, Inc.
  */
 
 /*
@@ -43,6 +43,7 @@
 #include <sys/sunddi.h>
 #include <sys/sunldi.h>
 #include <sys/lx_impl.h>
+#include <sys/lx_types.h>
 
 #include "lx_sysfs.h"
 
@@ -51,10 +52,13 @@ static int	lxsysfstype;
 static dev_t	lxsysdev;
 static kmutex_t	lxsys_mount_lock;
 
+extern int	lx_sysfs_type;
+
 static int lxsys_mount(vfs_t *, vnode_t *, mounta_t *, cred_t *);
 static int lxsys_unmount(vfs_t *, int, cred_t *);
 static int lxsys_root(vfs_t *, vnode_t **);
 static int lxsys_statvfs(vfs_t *, statvfs64_t *);
+static int lxsys_vget(vfs_t *, vnode_t **, fid_t *);
 static int lxsys_init(int, char *);
 
 static vfsdef_t vfw = {
@@ -101,6 +105,8 @@ _fini(void)
 	if ((retval = mod_remove(&modlinkage)) != 0)
 		goto done;
 
+	lx_sysfs_type = 0;
+
 	/*
 	 * destroy lxsys_node cache
 	 */
@@ -125,13 +131,14 @@ lxsys_init(int fstype, char *name)
 		VFSNAME_UNMOUNT,	{ .vfs_unmount = lxsys_unmount },
 		VFSNAME_ROOT,		{ .vfs_root = lxsys_root },
 		VFSNAME_STATVFS,	{ .vfs_statvfs = lxsys_statvfs },
+		VFSNAME_VGET,		{ .vfs_vget = lxsys_vget },
 		NULL,			NULL
 	};
 	extern const fs_operation_def_t lxsys_vnodeops_template[];
 	int error;
 	major_t dev;
 
-	lxsysfstype = fstype;
+	lx_sysfs_type = lxsysfstype = fstype;
 	ASSERT(lxsysfstype != 0);
 
 	mutex_init(&lxsys_mount_lock, NULL, MUTEX_DEFAULT, NULL);
@@ -346,3 +353,19 @@ lxsys_statvfs(vfs_t *vfsp, statvfs64_t *sp)
 
 	return (0);
 }
+
+static int
+lxsys_vget(vfs_t *vfsp, vnode_t **vpp, fid_t *fidp)
+{
+	lx_fid_t *lfid;
+	lxsys_node_t *lnp;
+
+	lfid = (lx_fid_t *)fidp;
+	*vpp = NULL;
+
+	if ((lnp = lxsys_ino_get_node(vfsp, lfid->lxfid_ino)) == NULL)
+		return (EINVAL);
+
+	*vpp = (struct vnode *)LXSTOV(lnp);
+	return (0);
+}
diff --git a/usr/src/uts/common/brand/lx/sysfs/lx_sysvnops.c b/usr/src/uts/common/brand/lx/sysfs/lx_sysvnops.c
index 7278a0fd92..d5ad2cc0f4 100644
--- a/usr/src/uts/common/brand/lx/sysfs/lx_sysvnops.c
+++ b/usr/src/uts/common/brand/lx/sysfs/lx_sysvnops.c
@@ -169,6 +169,10 @@ const fs_operation_def_t lxsys_vnodeops_template[] = {
  * symlinks, and perhaps other static files. By only providing 'node0' we
  * pretend that there is only a single NUMA node available to a zone (trying to
  * be NUMA-aware inside a zone is generally not going to work anyway).
+ *
+ * The pinst_static table must be updated whenever a new static instance is
+ * defined. The pinst_dynamic table must be updated whenever a new dynamic
+ * type is defined.
  */
 
 #define	LXSYS_INST_CLASSDIR			0x1
@@ -186,6 +190,56 @@ const fs_operation_def_t lxsys_vnodeops_template[] = {
 #define	LXSYS_INST_DEVICES_SYSNODE		0xd
 #define	LXSYS_INST_BUSDIR			0xe
 
+/*
+ * The parent instance for each static LXSYS_INST_
+ * The ps_ino_type is used for directory inode correction in
+ * lxsys_readdir_common when we have a dynamic node under a static node.
+ */
+typedef struct {
+	int		ps_inst;
+	int		ps_ino_type;
+} pinst_static_t;
+
+static pinst_static_t pinst_static [] = {
+	{0, 0},					/* invalid */
+	{LXSYS_INST_ROOT, 0},			/* CLASSDIR */
+	{LXSYS_INST_ROOT, 0},			/* DEVICESDIR */
+	{LXSYS_INST_ROOT, 0},			/* FSDIR */
+	{LXSYS_INST_CLASSDIR, LXSYS_CLASS_NET},	/* CLASS_NETDIR */
+	{LXSYS_INST_DEVICESDIR, 0},		/* DEVICES_VIRTUALDIR */
+	{LXSYS_INST_DEVICESDIR, 0},		/* DEVICES_SYSTEMDIR */
+	{LXSYS_INST_FSDIR, 0},			/* FS_CGROUPDIR */
+	{LXSYS_INST_DEVICES_VIRTUALDIR, LXSYS_DEV_NET}, /* DEV_VIRTUAL_NETDIR */
+	{LXSYS_INST_ROOT, LXSYS_BLOCK},		/* BLOCKDIR */
+	{LXSYS_INST_DEVICESDIR, LXSYS_DEV_ZFS},	/* DEVICES_ZFSDIR */
+	{LXSYS_INST_DEVICES_SYSTEMDIR, LXSYS_DEV_SYS_CPU}, /* DEVICES_SYSCPU */
+	{LXSYS_INST_DEVICESDIR, 0},		/* DEV_SYSCPU_KMAX */
+	{LXSYS_INST_DEVICES_SYSTEMDIR, LXSYS_DEV_SYS_NODE}, /* DEV_SYSNODE */
+	{LXSYS_INST_ROOT, 0},			/* BUSDIR */
+};
+#define	PINST_ST_LEN	(sizeof (pinst_static) / sizeof ((pinst_static)[0]))
+
+/*
+ * The parent type and instance for each dynamic lxsys_nodetype_t.
+ */
+typedef struct {
+	lxsys_nodetype_t	pd_type;
+	int			pd_inst;
+} pinst_dynamic_t;
+
+static pinst_dynamic_t pinst_dynamic [] = {
+	{0, 0},						/* invalid */
+	{0, 0},						/* STATIC - invalid */
+	{LXSYS_STATIC, LXSYS_INST_CLASS_NETDIR},	/* CLASS_NET */
+	{LXSYS_STATIC, LXSYS_INST_DEVICES_VIRTUAL_NETDIR}, /* DEV_NET */
+	{LXSYS_STATIC, LXSYS_INST_ROOT},		/* BLOCK */
+	{LXSYS_STATIC, LXSYS_INST_DEVICES_ZFSDIR},	/* DEV_ZFS */
+	{LXSYS_STATIC, LXSYS_INST_DEVICES_SYSCPU},	/* DEV_SYS_CPU */
+	{LXSYS_DEV_SYS_CPU, 0},				/* DEV_SYS_CPUINFO */
+	{LXSYS_STATIC, LXSYS_INST_DEVICES_SYSNODE},	/* DEV_SYS_NODE */
+};
+#define	PINST_DY_LEN	(sizeof (pinst_dynamic) / sizeof ((pinst_dynamic)[0]))
+
 /*
  * file contents of an lx /sys directory.
  */
@@ -334,6 +388,195 @@ typedef struct lxsys_cpu_info {
 	processorid_t	cpu_seqid;
 } lxsys_cpu_info_t;
 
+/*
+ * Nodes default to a directory. Normally we correct the type in the
+ * appropriate lookup function but if we get a node via another path then
+ * we must correct the type using this function.
+ */
+static vtype_t
+lxsys_get_vtype(lxsys_nodetype_t type, uint_t instance, uint_t endpoint)
+{
+	if (type == LXSYS_STATIC) {
+		switch (instance) {
+		case LXSYS_INST_DEV_SYSCPU_KMAX:
+			return (VREG);
+		}
+	} else {
+		/* Non-static node types */
+		switch (type) {
+		case LXSYS_CLASS_NET:
+			if (instance != 0) {
+				return (VLNK);
+			}
+			break;
+		case LXSYS_DEV_NET:
+			/*
+			 * /sys/devices/virtual/net usually has the eth0 and
+			 * lo directories. Each network device directory is an
+			 * instances with a 0 endpoint. The files within
+			 * that directory have a non-0 endpoint.
+			 */
+			if (endpoint != 0) {
+				return (VREG);
+			}
+			break;
+		case LXSYS_BLOCK:
+			if (instance != 0) {
+				return (VLNK);
+			}
+			break;
+		case LXSYS_DEV_ZFS:
+			/*
+			 * /sys/devices/zfs usually has the zfsds0 directory
+			 * instance with a 0 endpoint. The device file within
+			 * that directory has a non-0 endpoint.
+			 */
+			if (endpoint != 0) {
+				return (VREG);
+			}
+			break;
+		case LXSYS_DEV_SYS_CPU:
+			if (instance != 0) {
+				return (VREG);
+			}
+			break;
+		case LXSYS_DEV_SYS_CPUINFO:
+			if (instance != 0) {
+				return (VREG);
+			}
+			break;
+		case LXSYS_DEV_SYS_NODE:
+			/*
+			 * /sys/devices/system/node has the node0 directory
+			 * instance with a 0 endpoint. The cpulist file within
+			 * that directory has a non-0 endpoint.
+			 */
+			if (endpoint != 0) {
+				return (VREG);
+			}
+			break;
+		default:
+			break;
+		}
+	}
+	return (VDIR);
+}
+
+/*
+ * Given type/instance/endpoint, get the parent lxsys_node_t
+ */
+static lxsys_node_t *
+lxsys_get_pnode(vfs_t *vfsp, lxsys_nodetype_t type, uint_t instance,
+    uint_t endpoint)
+{
+	/* Start by assuming we don't change types */
+	lxsys_nodetype_t ptype = type;
+	uint_t pinst = 0;
+	ino_t ino;
+
+	if (type == LXSYS_STATIC) {
+		if (instance <= 0 || instance > PINST_ST_LEN)
+			return (NULL);
+		pinst = pinst_static[instance].ps_inst;
+	} else {
+		/* Non-static node types */
+		if (type <= 1 || instance > PINST_DY_LEN)
+			return (NULL);
+
+		/*
+		 * A non-zero instance simply implies that this is an entry in
+		 * a directory of the same type. If the endpoint is also
+		 * non-zero then this is an entry in that dyanmic instance
+		 * directory.
+		 */
+		if (instance != 0) {
+			if (endpoint == 0) {
+				pinst = 0;
+			} else {
+				pinst = instance;
+			}
+		} else {
+			pinst_dynamic_t pd = pinst_dynamic[type];
+
+			ptype = pd.pd_type;
+			pinst = pd.pd_inst;
+		}
+	}
+
+	ino = lxsys_inode(ptype, pinst, 0);
+	return (lxsys_ino_get_node(vfsp, ino));
+}
+
+/*
+ * Given one of our inodes, get the node, creating it if necessary.
+ * Note: this can call lxsys_get_pnode() to get the parent node. That in turn
+ * will recursively call back to this function as it traverses up the tree.
+ */
+lxsys_node_t *
+lxsys_ino_get_node(vfs_t *vfsp, ino_t ino)
+{
+	lxsys_mnt_t *lxsm = VFSTOLXSM(vfsp);
+	lxsys_node_t *lnp, *plnp;
+	vnode_t *pvp;
+	lxsys_nodetype_t type;
+	unsigned int instance;
+	unsigned int endpoint;
+	vtype_t vt;
+
+	/*
+	 * Check if it already exists in the static list.
+	 */
+	mutex_enter(&lxsm->lxsysm_lock);
+	for (lnp = lxsm->lxsysm_node; lnp != NULL; lnp = lnp->lxsys_next) {
+		if (lnp->lxsys_ino == ino) {
+			VN_HOLD(lnp->lxsys_vnode);
+			mutex_exit(&lxsm->lxsysm_lock);
+			return (lnp);
+		}
+	}
+	mutex_exit(&lxsm->lxsysm_lock);
+
+	type = (ino & 0xff000000) >> 24;
+	instance = (ino & 0xffff00) >> 8;
+	endpoint = (ino & 0xff);
+
+	/*
+	 * The node was not found in the static list. Call pnode to get the
+	 * parent, then create our node. The type and instance are validated in
+	 * that function.
+	 */
+	if ((plnp = lxsys_get_pnode(vfsp, type, instance, endpoint)) == NULL)
+		return (NULL);
+
+	pvp = (struct vnode *)LXSTOV(plnp);
+	if (type == LXSYS_STATIC) {
+		lnp = lxsys_getnode_static(pvp, instance);
+	} else {
+		lnp = lxsys_getnode(pvp, type, instance, endpoint);
+	}
+	/*
+	 * The lxsys_getnode functions add a hold on pvp. We must do a rele on
+	 * that now so the eventual rele of lnp's vnode will cleanup correctly.
+	 */
+	ASSERT(pvp->v_count > 1);
+	VN_RELE(pvp);
+
+	/*
+	 * lxsys_getnode will always set the vnode type to VDIR and the mode to
+	 * 0555. It expects the caller to fix these.
+	 */
+	if ((vt = lxsys_get_vtype(type, instance, endpoint)) != VDIR) {
+		lnp->lxsys_vnode->v_type = vt;
+		if (vt == VREG) {
+			lnp->lxsys_mode = 0444;
+		} else if (vt == VLNK) {
+			lnp->lxsys_mode = 0777;
+		}
+	}
+
+	return (lnp);
+}
+
 /*
  * lxsys_open(): Vnode operation for VOP_OPEN()
  */
@@ -1094,9 +1337,26 @@ lxsys_readdir_common(lxsys_node_t *lxsnp, uio_t *uiop, int *eofp,
 		} else if (dirindex >= 0 && dirindex < dirtablen) {
 
 			int slen = strlen(dirtab[dirindex].d_name);
+			int idnum, ino_type = 0;
+
+			idnum = dirtab[dirindex].d_idnum;
+			if (idnum > 0 && idnum < PINST_ST_LEN)
+				ino_type = pinst_static[idnum].ps_ino_type;
+
+			if (ino_type != 0) {
+				/*
+				 * Correct the inode for static directories
+				 * which contain non-static lxsys_nodetype_t's.
+				 */
+				dirent->d_ino = lxsys_inode(ino_type, 0, 0);
+				DTRACE_PROBE3(lxsys__fix__inode,
+				    char *, dirtab[dirindex].d_name,
+				    int, ino_type, int, dirent->d_ino);
+			} else {
+				dirent->d_ino = lxsys_inode(LXSYS_STATIC,
+				    idnum, 0);
+			}
 
-			dirent->d_ino = lxsys_inode(LXSYS_STATIC,
-			    dirtab[dirindex].d_idnum, 0);
 			(void) strcpy(dirent->d_name, dirtab[dirindex].d_name);
 			reclen = DIRENT64_RECLEN(slen);
 
-- 
2.21.0

