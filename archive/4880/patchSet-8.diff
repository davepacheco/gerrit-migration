commit 85d2b8be85a8edd829255d47412f4e8620867d56 (refs/changes/80/4880/8)
Author: Robert Bogart <Robert.bogart@joyent.com>
Date:   2018-10-15T22:42:01+00:00 (12 months ago)
    
    MANTA-3854 Mako sometimes fails to create manifests due to limitations in 'find'

diff --git a/Makefile b/Makefile
index 400083a..bf72b65 100644
--- a/Makefile
+++ b/Makefile
@@ -45,10 +45,10 @@ JSSTYLE_FLAGS	= -f tools/jsstyle.conf
 # Variables
 #
 NAME			= mako
-NODE_PREBUILT_VERSION	= v0.10.48
+NODE_PREBUILT_VERSION	= v6.14.3
 NODE_PREBUILT_TAG	= zone
-# sdc-minimal-multiarch-lts 15.4.1
-NODE_PREBUILT_IMAGE	= 18b094b0-eb01-11e5-80c1-175dac7ddf02
+# minimal-multiarch 18.1.0
+NODE_PREBUILT_IMAGE	= 1ad363ec-3b83-11e8-8521-2f68a4a34d5d
 
 include ./tools/mk/Makefile.defs
 ifeq ($(shell uname -s),SunOS)
diff --git a/bin/upload_mako_ls.sh b/bin/upload_mako_ls.sh
index 658150f..0d9b667 100755
--- a/bin/upload_mako_ls.sh
+++ b/bin/upload_mako_ls.sh
@@ -6,7 +6,7 @@
 #
 
 #
-# Copyright (c) 2017, Joyent, Inc.
+# Copyright (c) 2018, Joyent, Inc.
 #
 
 ###############################################################################
@@ -23,11 +23,12 @@ export PATH=/opt/local/bin:$PATH
 # Immutables
 
 [ -z $SSH_KEY ] && SSH_KEY=/root/.ssh/id_rsa
-[ -z $MANTA_KEY_ID ] && MANTA_KEY_ID=$(ssh-keygen -l -f $SSH_KEY.pub | awk '{print $2}')
+[ -z $MANTA_KEY_ID ] && MANTA_KEY_ID=$(ssh-keygen -l -f $SSH_KEY.pub | gawk '{print $2}')
 [ -z $MANTA_URL ] && MANTA_URL=$(cat /opt/smartdc/mako/etc/gc_config.json | json -ga manta_url)
 [ -z $MANTA_USER ] && MANTA_USER=$(json -f /opt/smartdc/common/etc/config.json manta.user)
 [ -z $MANTA_STORAGE_ID ] && MANTA_STORAGE_ID=$(cat /opt/smartdc/mako/etc/gc_config.json | json -ga manta_storage_id)
 
+MAKO_PROCESS_MANIFEST=$(json -f /opt/smartdc/mako/etc/upload_config.json process_manifest)
 AUTHZ_HEADER="keyId=\"/$MANTA_USER/keys/$MANTA_KEY_ID\",algorithm=\"rsa-sha256\""
 DIR_TYPE='application/json; type=directory'
 LOG_TYPE='application/x-bzip2'
@@ -35,7 +36,12 @@ PID=$$
 PID_FILE=/tmp/upload_mako_ls.pid
 TMP_DIR=/var/tmp/mako_dir
 LISTING_FILE=$TMP_DIR/$MANTA_STORAGE_ID
-MANTA_DIR=/mako
+LISTING_FILE_PARTIAL=${LISTING_FILE}.${PID}
+MANTA_DIR=mako
+SUMMARY_FILE="$TMP_DIR/${MANTA_STORAGE_ID}.summary"
+SUMMARY_DIR="$MANTA_DIR/summary"
+MAKO_DIR=/opt/smartdc/mako
+TARGET_DIR=/manta
 START_TIME=`date -u +"%Y-%m-%dT%H:%M:%SZ"` # Time that this script started.
 
 
@@ -79,7 +85,7 @@ function manta_put_directory() {
         -H "Date: $NOW" \
         -H "Authorization: Signature $AUTHZ_HEADER,signature=\"$SIGNATURE\"" \
         -H "Connection: close" \
-        $MANTA_URL/$MANTA_USER/stor$1 2>&1
+        $MANTA_URL/$MANTA_USER/stor/${1} 2>&1
 }
 
 
@@ -91,12 +97,95 @@ function manta_put() {
         -H "Authorization: Signature $AUTHZ_HEADER,signature=\"$SIGNATURE\"" \
         -H "Connection: close" \
         -H "m-mako-dump-time: $START_TIME" \
-        $MANTA_URL/$MANTA_USER/stor$1 \
+        $MANTA_URL/$MANTA_USER/stor/${1} \
         -T $2 \
         || fatal "unable to put $1"
 }
 
+#
+# This function performs the heavy lifting when processing a mako manifest.  It
+# builds out several associative arrays, each indexed by account id:
+#
+# bytes[acct] contains a running sum of the number of bytes that account `acct'
+# currently consumed.  This value is obtained from the %s parameter in the call
+# to gfind.
+#
+# objects[acct] contains a running count of the number of files that belong to
+# account `acct'.
+#
+# kilobytes[acct] contains a sum of one- kilobyte blocks that account `acct'
+# consumes.  This value is the actual amount of data on disk consumed by the
+# account.
+#
+# At the completion of the call to gawk, the contents of each array are printed
+# to give per-account information along with a global summary.
+#
+function process_manifest() {
+        file="$1"
+
+	if [ ! -f $file ]; then
+		fatal "File $file does not exist."
+	fi
+
+        cat $file | gawk -M -v PREC="quad" '{
+		split($1, x, "/")
+		acct=x[3]
+		bytes[acct] += $2
+		objects[acct]++
+		kilobytes[acct] += $4
+		total_bytes += $2
+		total_objects++
+		total_kilobytes += $4
+	} END {
+		printf("%s\t%s\t%s\t%s\t%s\n", "account", "bytes",
+		    "objects", "average size kb", "kilobytes");
+
+		for (acct in bytes) {
+			printf("%s\t%f\t%f\t%f\t%f\n",
+			    acct, bytes[acct], objects[acct],
+			    kilobytes[acct] / objects[acct], kilobytes[acct]);
+		}
+
+		printf("%s\t%f\t%f\t%f\t%f\n", "totals", total_bytes,
+		    total_objects, total_kilobytes / total_objects,
+		    total_kilobytes);
+	}' > "$SUMMARY_FILE"
+
+	if [[ $? -ne 0 ]]; then
+		rm "$SUMMARY_FILE"
+		fatal "Unable to completely process mako manifest file $file."
+	fi
+}
 
+function generate_manifest() {
+	file=$1
+	#
+	# %p is the filename, %s is the logical size in bytes, %T@ is the
+	# timestamp of the last modification and %k is the physical size (i.e.
+	# size on disk) in kilobytes.  It is worth mentioning that in later
+	# versions of GNU find (> 4.2.33), the timestamp includes both, the
+	# number of seconds and the fractional part.  In order to maintain the
+	# same format as earlier versions of the mako manifest, we perform some
+	# onerous sequence of operations using gawk (below) to first separate
+	# each parameter in the line with the assumption that each argument is
+	# delimited by a tab.  We know that the third field (i.e. $3) will
+	# contain the timestamp.  We perform a split on $3, further dividing
+	# the field in to two smaller pieces, each delimited by a '.'.  This
+	# is stored in array `y' where y[1] is the whole part of the timestamp
+	# and y[2] is the fractional part.  No one is denying that this is not
+	# elegant, but the change in the way that GNU find prints timestamps
+	# permits few (if any) alternatives.
+	#
+	find "$TARGET_DIR" -type f -printf '%p\t%s\t%T@\t%k\n' |\
+	    gawk -M -v PREC="quad" -v FS="\t" -v OFS="\t" '{
+		split($3, y, ".");
+		print $1,$2,y[1],$4
+	}'> "$file"
+
+	if [[ $? -ne 0 ]]; then
+		fatal "Error: find failed to obtain a complete listing"
+	fi
+}
 
 ## Main
 
@@ -119,13 +208,25 @@ log "starting directory listing upload"
 
 mkdir -p $TMP_DIR
 
-# %p is filename, %s is *logical* size in *bytes*, %T@ is last modified time,
-# %unix time, %k is the *physical* size in *kilobytes*
-find /manta -type f -printf '%p\t%s\t%T@\t%k\n' >$LISTING_FILE
+generate_manifest "$LISTING_FILE_PARTIAL"
+
+# Rename the file to reflect that find completed successfully
+mv "$LISTING_FILE_PARTIAL" "$LISTING_FILE"
 
 log "Going to upload $LISTING_FILE to $MANTA_DIR/$MANTA_STORAGE_ID"
-manta_put_directory $MANTA_DIR
-manta_put $MANTA_DIR/$MANTA_STORAGE_ID $LISTING_FILE
+manta_put_directory "$MANTA_DIR"
+manta_put "$MANTA_DIR/$MANTA_STORAGE_ID" "$LISTING_FILE"
+
+if [[ -z $MAKO_PROCESS_MANIFEST ]]; then
+	fatal "Error: MAKO_PROCESS_MANIFEST not set.  Please check /opt/smartdc/mako/etc/upload_config.json"
+fi
+
+if [[ $MAKO_PROCESS_MANIFEST == true ]]; then
+	log "Going to upload $SUMMARY_FILE to $SUMMARY_DIR/$MANTA_STORAGE_ID"
+	process_manifest "$LISTING_FILE"
+	manta_put_directory "$SUMMARY_DIR"
+	manta_put "$SUMMARY_DIR/$MANTA_STORAGE_ID" "$SUMMARY_FILE"
+fi
 
 log "Cleaning up..."
 rm -rf $TMP_DIR
diff --git a/sapi_manifests/upload/manifest.json b/sapi_manifests/upload/manifest.json
new file mode 100644
index 0000000..1956777
--- /dev/null
+++ b/sapi_manifests/upload/manifest.json
@@ -0,0 +1,5 @@
+{
+    "name": "upload",
+    "path": "/opt/smartdc/mako/etc/upload_config.json",
+    "master": true
+}
diff --git a/sapi_manifests/upload/template b/sapi_manifests/upload/template
new file mode 100644
index 0000000..efad2cf
--- /dev/null
+++ b/sapi_manifests/upload/template
@@ -0,0 +1,3 @@
+{
+	"process_manifest": {{#MAKO_PROCESS_MANIFEST}}{{MAKO_PROCESS_MANIFEST}}{{/MAKO_PROCESS_MANIFEST}}{{^MAKO_PROCESS_MANIFEST}}false{{/MAKO_PROCESS_MANIFEST}}
+}
