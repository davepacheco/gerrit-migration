From a1e47391d2e8ab76550161ae96de245dddc8f00b Mon Sep 17 00:00:00 2001
From: Jerry Jelinek <jerry.jelinek@joyent.com>
Date: Wed, 11 Apr 2018 20:17:17 +0000
Subject: [PATCH] OS-6878 mac_fix_cksum is incomplete

---
 usr/src/uts/common/inet/ip/ip6_output.c |  18 +-
 usr/src/uts/common/io/mac/mac_util.c    | 351 ++++++++++++++++++------
 usr/src/uts/common/sys/stream.h         |   5 +-
 usr/src/uts/common/sys/strsubr.h        |   1 +
 4 files changed, 293 insertions(+), 82 deletions(-)

diff --git a/usr/src/uts/common/inet/ip/ip6_output.c b/usr/src/uts/common/inet/ip/ip6_output.c
index dc074454e3..0e6a9bb011 100644
--- a/usr/src/uts/common/inet/ip/ip6_output.c
+++ b/usr/src/uts/common/inet/ip/ip6_output.c
@@ -725,6 +725,7 @@ ip_output_sw_cksum_v6(mblk_t *mp, ip6_t *ip6h, ip_xmit_attr_t *ixa)
 	uint32_t	cksum;
 	uint8_t		protocol = ixa->ixa_protocol;
 	uint16_t	ip_hdr_length = ixa->ixa_ip_hdr_length;
+	uint16_t	orig;
 
 #define	iphs    ((uint16_t *)ip6h)
 
@@ -773,6 +774,9 @@ ip_output_sw_cksum_v6(mblk_t *mp, ip6_t *ip6h, ip_xmit_attr_t *ixa)
 	/* ULP puts the checksum field is in the first mblk */
 	ASSERT(((uchar_t *)cksump) + sizeof (uint16_t) <= mp->b_wptr);
 
+	orig = *cksump;
+	DB_CKSUMOCSUM(mp) = orig;
+
 	/*
 	 * We accumulate the pseudo header checksum in cksum.
 	 * This is pretty hairy code, so watch close.  One
@@ -804,7 +808,11 @@ ip_output_sw_cksum_v6(mblk_t *mp, ip6_t *ip6h, ip_xmit_attr_t *ixa)
 #undef	iphs
 }
 
-/* There are drivers that can't do partial checksum for ICMPv6 */
+/*
+ * Sadly, removing this unused global variable will actually break the build.
+ * Compiling the "ip" module explicitly checks that no global variables
+ * are added or removed.
+ */
 int nxge_cksum_workaround = 1;
 
 /*
@@ -825,6 +833,7 @@ ip_output_cksum_v6(iaflags_t ixaflags, mblk_t *mp, ip6_t *ip6h,
 	uint32_t	cksum;
 	uint8_t		protocol = ixa->ixa_protocol;
 	uint16_t	ip_hdr_length = ixa->ixa_ip_hdr_length;
+	uint16_t	orig;
 
 #define	iphs    ((uint16_t *)ip6h)
 
@@ -886,6 +895,10 @@ ip_output_cksum_v6(iaflags_t ixaflags, mblk_t *mp, ip6_t *ip6h,
 	/* ULP puts the checksum field is in the first mblk */
 	ASSERT(((uchar_t *)cksump) + sizeof (uint16_t) <= mp->b_wptr);
 
+	/* Record original checksum field in case needed within MAC */
+	orig = *cksump;
+	DB_CKSUMOCSUM(mp) = orig;
+
 	/*
 	 * Underlying interface supports hardware checksum offload for
 	 * the payload; leave the payload checksum for the hardware to
@@ -905,8 +918,7 @@ ip_output_cksum_v6(iaflags_t ixaflags, mblk_t *mp, ip6_t *ip6h,
 		DB_CKSUMFLAGS(mp) |= HCK_FULLCKSUM;
 		return (B_TRUE);
 	}
-	if (((hck_flags) & HCKSUM_INET_PARTIAL) &&
-	    (protocol != IPPROTO_ICMPV6 || !nxge_cksum_workaround)) {
+	if (hck_flags & HCKSUM_INET_PARTIAL) {
 		/*
 		 * Partial checksum offload has been enabled.  Fill
 		 * the checksum field in the protocol header with the
diff --git a/usr/src/uts/common/io/mac/mac_util.c b/usr/src/uts/common/io/mac/mac_util.c
index a877ca258c..24430b0afb 100644
--- a/usr/src/uts/common/io/mac/mac_util.c
+++ b/usr/src/uts/common/io/mac/mac_util.c
@@ -48,6 +48,7 @@
 #include <inet/sadb.h>
 #include <inet/ipsecesp.h>
 #include <inet/ipsecah.h>
+#include <inet/sctp_ip.h>
 
 /*
  * Copy an mblk, preserving its hardware checksum flags.
@@ -88,10 +89,230 @@ mac_copymsgchain_cksum(mblk_t *mp)
 	return (nmp);
 }
 
+static void
+mac_ipv4_chksum(mblk_t *mp, uint32_t offset, ipha_t *ipha)
+{
+	uint8_t proto;
+	ipaddr_t src, dst;
+	uint16_t len;
+	uint32_t cksum;
+	uint16_t *up;
+
+	/*
+	 * Pointer to checksum field in ULP header.
+	 */
+	proto = ipha->ipha_protocol;
+	ASSERT(ipha->ipha_version_and_hdr_length == IP_SIMPLE_HDR_VERSION);
+
+	switch (proto) {
+	case IPPROTO_TCP:
+		/* LINTED: improper alignment cast */
+		up = IPH_TCPH_CHECKSUMP(ipha, IP_SIMPLE_HDR_LENGTH);
+		cksum = IP_TCP_CSUM_COMP;
+		break;
+	case IPPROTO_UDP:
+		/* LINTED: improper alignment cast */
+		up = IPH_UDPH_CHECKSUMP(ipha, IP_SIMPLE_HDR_LENGTH);
+		cksum = IP_UDP_CSUM_COMP;
+		break;
+	case IPPROTO_SCTP: {
+		sctp_hdr_t *sctph;
+
+		ASSERT(MBLKL(mp) >= (IP_SIMPLE_HDR_LENGTH + sizeof (*sctph)));
+		sctph = (sctp_hdr_t *)(mp->b_rptr + IP_SIMPLE_HDR_LENGTH);
+		/*
+		 * Zero out the checksum field to ensure proper checksum
+		 * calculation.
+		 */
+		sctph->sh_chksum = 0;
+		sctph->sh_chksum = sctp_cksum(mp, IP_SIMPLE_HDR_LENGTH);
+		return;
+	}
+	default:
+		return;
+	}
+
+	/*
+	 * Pseudo-header checksum.
+	 */
+	src = ipha->ipha_src;
+	dst = ipha->ipha_dst;
+	len = ntohs(ipha->ipha_length) - IP_SIMPLE_HDR_LENGTH;
+
+	cksum += (dst >> 16) + (dst & 0xFFFF) + (src >> 16) + (src & 0xFFFF);
+	cksum += htons(len);
+
+	/*
+	 * The checksum value stored in the packet needs to be correct. Compute
+	 * it here.
+	 */
+	*up = 0;
+	cksum = IP_CSUM(mp, IP_SIMPLE_HDR_LENGTH + offset, cksum);
+	*up = (uint16_t)(cksum ? cksum : ~cksum);
+}
+
+/*
+ * Return the length of the IPv6 related headers (including extension headers)
+ * Returns a length even if the packet is malformed.
+ * Derived from ip_hdr_length_v6(), but implemented here so that MAC does not
+ * depend on the IPv6 module.
+ */
+static int
+mac_ip6_hdr_len(mblk_t *mp, ip6_t *ip6h)
+{
+	uint16_t length;
+	uint_t	ehdrlen;
+	uint8_t	*nexthdrp;
+	uint8_t *whereptr;
+	uint8_t *endptr;
+	ip6_dest_t *desthdr;
+	ip6_rthdr_t *rthdr;
+	ip6_frag_t *fraghdr;
+
+	ASSERT(IPH_HDR_VERSION(ip6h) == IPV6_VERSION);
+	length = IPV6_HDR_LEN;
+	whereptr = ((uint8_t *)&ip6h[1]); /* point to next hdr */
+	endptr = mp->b_wptr;
+
+	nexthdrp = &ip6h->ip6_nxt;
+	while (whereptr < endptr) {
+		/* Is there enough left for len + nexthdr? */
+		if (whereptr + MIN_EHDR_LEN > endptr)
+			break;
+
+		switch (*nexthdrp) {
+		case IPPROTO_HOPOPTS:
+		case IPPROTO_DSTOPTS:
+			/* Assumes the headers are identical for hbh and dst */
+			desthdr = (ip6_dest_t *)whereptr;
+			ehdrlen = 8 * (desthdr->ip6d_len + 1);
+			if ((uchar_t *)desthdr +  ehdrlen > endptr)
+				return (length);
+			nexthdrp = &desthdr->ip6d_nxt;
+			break;
+		case IPPROTO_ROUTING:
+			rthdr = (ip6_rthdr_t *)whereptr;
+			ehdrlen =  8 * (rthdr->ip6r_len + 1);
+			if ((uchar_t *)rthdr +  ehdrlen > endptr)
+				return (length);
+			nexthdrp = &rthdr->ip6r_nxt;
+			break;
+		case IPPROTO_FRAGMENT:
+			fraghdr = (ip6_frag_t *)whereptr;
+			ehdrlen = sizeof (ip6_frag_t);
+			if ((uchar_t *)&fraghdr[1] > endptr)
+				return (length);
+			nexthdrp = &fraghdr->ip6f_nxt;
+			break;
+		case IPPROTO_NONE:
+			/* No next header means we're finished */
+		default:
+			return (length);
+		}
+		length += ehdrlen;
+		whereptr += ehdrlen;
+	}
+
+	return (length);
+}
+
+static void
+mac_ipv6_chksum(mblk_t *mp, uint32_t offset, ip6_t *ip6h)
+{
+	uint8_t proto;
+	ipaddr_t src, dst;
+	uint32_t cksum;
+	uint16_t *up;
+	uint16_t ip_hdr_length = mac_ip6_hdr_len(mp, ip6h);
+
+#define	iphs	((uint16_t *)ip6h)
+
+	/*
+	 * Pointer to checksum field in ULP header.
+	 */
+	proto = ip6h->ip6_nxt;
+
+	/*
+	 * The IPv6 SW checksum code calculation (ip_output_cksum_v6) handles
+	 * IXAF_SET_RAW_CKSUM, but that is never a factor when full HW checksum
+	 * offload is in use, so we can't worry about it here either. We have
+	 * to calculate the noraml ICMPv6 checksum.
+	 */
+
+	switch (proto) {
+	case IPPROTO_TCP:
+		/* LINTED: improper alignment cast */
+		up = IPH_TCPH_CHECKSUMP(ip6h, ip_hdr_length);
+		cksum = IP_TCP_CSUM_COMP;
+		break;
+
+	case IPPROTO_UDP:
+		/* LINTED: improper alignment cast */
+		up = IPH_UDPH_CHECKSUMP(ip6h, ip_hdr_length);
+		cksum = IP_UDP_CSUM_COMP;
+		break;
+
+	case IPPROTO_SCTP: {
+		sctp_hdr_t *sctph;
+
+		ASSERT(MBLKL(mp) >= (ip_hdr_length + sizeof (*sctph)));
+		sctph = (sctp_hdr_t *)(mp->b_rptr + ip_hdr_length);
+		/*
+		 * Zero out the checksum field to ensure proper
+		 * checksum calculation.
+		 */
+		sctph->sh_chksum = 0;
+		sctph->sh_chksum = sctp_cksum(mp, ip_hdr_length);
+		return;
+	}
+
+	case IPPROTO_ICMPV6:
+		up = IPH_ICMPV6_CHECKSUMP(ip6h, ip_hdr_length);
+		cksum = IP_ICMPV6_CSUM_COMP;    /* Pseudo-header cksum */
+		break;
+
+	default:
+		return;
+	}
+
+	/* ULP assumes the checksum field is in the first mblk */
+	ASSERT(((uchar_t *)up) + sizeof (uint16_t) <= mp->b_wptr);
+
+	/*
+	 * Restore the original entry in the checksum field so that we can
+	 * properly calculate the checksum.
+	 */
+	*up = DB_CKSUMOCSUM(mp);
+
+	/*
+	 * We accumulate the pseudo header checksum in cksum. This is pretty
+	 * hairy code, so watch close. One thing to keep in mind is that UDP
+	 * and TCP have stored their respective datagram lengths in their
+	 * checksum fields. This lines things up real nice.
+	 */
+	cksum += iphs[4] + iphs[5] + iphs[6] + iphs[7] + iphs[8] + iphs[9] +
+	    iphs[10] + iphs[11] + iphs[12] + iphs[13] + iphs[14] + iphs[15] +
+	    iphs[16] + iphs[17] + iphs[18] + iphs[19];
+	cksum = IP_CSUM(mp, ip_hdr_length + offset, cksum);
+
+	/* For UDP/IPv6 a zero UDP checksum is not allowed. Change to 0xffff */
+	if (proto == IPPROTO_UDP && cksum == 0)
+		cksum = ~cksum;
+	*up = cksum;
+
+#undef	iphs
+	/* No IP header checksum for IPv6 */
+}
+
 /*
  * Process the specified mblk chain for proper handling of hardware
  * checksum offload. This routine is invoked for loopback traffic
- * between MAC clients.
+ * between MAC clients. The specific issue is that the upstack code (IP) may
+ * not calculate any checksums, or perhaps a partial checksum, based on the
+ * advertised HW checksum offload features of the underlying NIC below the
+ * netstack, but since we're looping back the packet without ever hitting the
+ * NIC, we may have to calculate the checksums ourselves at this point.
+ *
  * The function handles a NULL mblk chain passed as argument.
  */
 mblk_t *
@@ -122,6 +343,7 @@ mac_fix_cksum(mblk_t *mp_chain)
 				continue;
 			mp1->b_next = mp->b_next;
 			mp->b_next = NULL;
+			DB_CKSUMOCSUM(mp1) = DB_CKSUMOCSUM(mp);
 			freemsg(mp);
 			if (prev != NULL)
 				prev->b_next = mp1;
@@ -173,98 +395,66 @@ mac_fix_cksum(mblk_t *mp_chain)
 		}
 
 		if (flags & (HCK_FULLCKSUM | HCK_IPV4_HDRCKSUM)) {
-			ipha_t *ipha = NULL;
-
 			/*
 			 * In order to compute the full and header
 			 * checksums, we need to find and parse
-			 * the IP and/or ULP headers.
+			 * the IP/IPv6 and/or ULP headers.
 			 */
 
 			sap = (sap < ETHERTYPE_802_MIN) ? 0 : sap;
 
-			/*
-			 * IP header.
-			 */
-			if (sap != ETHERTYPE_IP)
-				continue;
-
-			ASSERT(MBLKL(mp) >= offset + sizeof (ipha_t));
-			/* LINTED: improper alignment cast */
-			ipha = (ipha_t *)(mp->b_rptr + offset);
-
-			if (flags & HCK_FULLCKSUM) {
-				ipaddr_t src, dst;
-				uint32_t cksum;
-				uint16_t *up;
-				uint8_t proto;
-
-				/*
-				 * Pointer to checksum field in ULP header.
-				 */
-				proto = ipha->ipha_protocol;
-				ASSERT(ipha->ipha_version_and_hdr_length ==
-				    IP_SIMPLE_HDR_VERSION);
-
-				switch (proto) {
-				case IPPROTO_TCP:
-					/* LINTED: improper alignment cast */
-					up = IPH_TCPH_CHECKSUMP(ipha,
-					    IP_SIMPLE_HDR_LENGTH);
-					break;
-
-				case IPPROTO_UDP:
-					/* LINTED: improper alignment cast */
-					up = IPH_UDPH_CHECKSUMP(ipha,
-					    IP_SIMPLE_HDR_LENGTH);
-					break;
-
-				default:
-					cmn_err(CE_WARN, "mac_fix_cksum: "
-					    "unexpected protocol: %d", proto);
-					continue;
-				}
-
+			if (sap == ETHERTYPE_IP) {
 				/*
-				 * Pseudo-header checksum.
+				 * IP header.
 				 */
-				src = ipha->ipha_src;
-				dst = ipha->ipha_dst;
-				len = ntohs(ipha->ipha_length) -
-				    IP_SIMPLE_HDR_LENGTH;
+				ipha_t *ipha;
 
-				cksum = (dst >> 16) + (dst & 0xFFFF) +
-				    (src >> 16) + (src & 0xFFFF);
-				cksum += htons(len);
+				ASSERT(MBLKL(mp) >= offset + sizeof (ipha_t));
+				/* LINTED: improper alignment cast */
+				ipha = (ipha_t *)(mp->b_rptr + offset);
 
-				/*
-				 * The checksum value stored in the packet needs
-				 * to be correct. Compute it here.
-				 */
-				*up = 0;
-				cksum += (((proto) == IPPROTO_UDP) ?
-				    IP_UDP_CSUM_COMP : IP_TCP_CSUM_COMP);
-				cksum = IP_CSUM(mp, IP_SIMPLE_HDR_LENGTH +
-				    offset, cksum);
-				*(up) = (uint16_t)(cksum ? cksum : ~cksum);
+				if (flags & HCK_FULLCKSUM) {
+					mac_ipv4_chksum(mp, offset, ipha);
+					/*
+					 * Flag the packet so that it appears
+					 * that the checksum has already been
+					 * verified by the hardware.
+					 */
+					flags &= ~HCK_FULLCKSUM;
+					flags |= HCK_FULLCKSUM_OK;
+					value = 0;
+				}
 
+				if (flags & HCK_IPV4_HDRCKSUM) {
+					ASSERT(ipha != NULL);
+					ipha->ipha_hdr_checksum =
+					    (uint16_t)ip_csum_hdr(ipha);
+					flags &= ~HCK_IPV4_HDRCKSUM;
+					flags |= HCK_IPV4_HDRCKSUM_OK;
+				}
+			} else if (sap == ETHERTYPE_IPV6) {
 				/*
-				 * Flag the packet so that it appears
-				 * that the checksum has already been
-				 * verified by the hardware.
+				 * IPv6 header.
 				 */
-				flags &= ~HCK_FULLCKSUM;
-				flags |= HCK_FULLCKSUM_OK;
-				value = 0;
-			}
+				ip6_t *ip6ha;
 
-			if (flags & HCK_IPV4_HDRCKSUM) {
-				ASSERT(ipha != NULL);
-				ipha->ipha_hdr_checksum =
-				    (uint16_t)ip_csum_hdr(ipha);
-				flags &= ~HCK_IPV4_HDRCKSUM;
-				flags |= HCK_IPV4_HDRCKSUM_OK;
+				ASSERT(MBLKL(mp) >= offset + sizeof (ip6_t));
+				/* LINTED: improper alignment cast */
+				ip6ha = (ip6_t *)(mp->b_rptr + offset);
 
+				if (flags & HCK_FULLCKSUM) {
+					mac_ipv6_chksum(mp, offset, ip6ha);
+					/*
+					 * Flag the packet so that it appears
+					 * that the checksum has already been
+					 * verified by the hardware.
+					 */
+					flags &= ~HCK_FULLCKSUM;
+					flags |= HCK_FULLCKSUM_OK;
+					value = 0;
+				}
+			} else {
+				continue;
 			}
 		}
 
@@ -284,6 +474,13 @@ mac_fix_cksum(mblk_t *mp_chain)
 				mp = new_mp;
 			}
 
+			/*
+			 * Note: this code properly handles a partial checksum
+			 * for either IPv4 or IPv6. The "stuff", "start" and
+			 * "end" returned from mac_hcksum_get() is correct for
+			 * both protocols.
+			 */
+
 			ipp = mp->b_rptr + offset;
 			/* LINTED: cast may result in improper alignment */
 			up = (uint16_t *)((uchar_t *)ipp + stuff);
diff --git a/usr/src/uts/common/sys/stream.h b/usr/src/uts/common/sys/stream.h
index a45030ff7e..72c561a8f9 100644
--- a/usr/src/uts/common/sys/stream.h
+++ b/usr/src/uts/common/sys/stream.h
@@ -21,7 +21,7 @@
 /*
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
- * Copyright 2015 Joyent, Inc.  All rights reserved.
+ * Copyright 2018 Joyent, Inc.  All rights reserved.
  */
 
 /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
@@ -338,7 +338,8 @@ typedef struct datab {
 				uint16_t u16;
 			} cksum_val;    /* used to store calculated cksum */
 			uint16_t flags;
-			uint16_t pad;
+			uint16_t pad;	/* not padding, see DB_LSOMSS, DB_TCI */
+			uint32_t ocsum;	/* original cksum field value */
 		} cksum;
 		/*
 		 * Union used for future extensions (pointer to data ?).
diff --git a/usr/src/uts/common/sys/strsubr.h b/usr/src/uts/common/sys/strsubr.h
index 0f29dd3675..6e1baa9ef2 100644
--- a/usr/src/uts/common/sys/strsubr.h
+++ b/usr/src/uts/common/sys/strsubr.h
@@ -1341,6 +1341,7 @@ extern int SAMESTR(queue_t *);
 #define	DB_CKSUMEND(mp)		((mp)->b_datap->db_cksumend)
 #define	DB_CKSUMSTUFF(mp)	((mp)->b_datap->db_cksumstuff)
 #define	DB_CKSUMFLAGS(mp)	((mp)->b_datap->db_struioun.cksum.flags)
+#define	DB_CKSUMOCSUM(mp)	((mp)->b_datap->db_struioun.cksum.ocsum)
 #define	DB_CKSUM16(mp)		((mp)->b_datap->db_cksum16)
 #define	DB_CKSUM32(mp)		((mp)->b_datap->db_cksum32)
 #define	DB_LSOFLAGS(mp)		((mp)->b_datap->db_struioun.cksum.flags)
-- 
2.21.0

