From 05f00b97a613e26dc065b9a6efb3c1d760f4cb68 Mon Sep 17 00:00:00 2001
From: Pedro Palazon Candel <pedro@joyent.com>
Date: Tue, 30 Jan 2018 18:36:26 +0100
Subject: [PATCH] TOOLS-1579 sdcadm post-setup ha-binder should update core
 zones resolvers

---
 .gitmodules                         |   8 +-
 lib/cli/do_fix_core_vm_resolvers.js | 101 +++++++
 lib/cli/experimental.js             |  12 +-
 lib/post-setup/ha-binder.js         | 414 ++++++++++++++++++++++------
 lib/procedures/shared.js            | 108 +++++++-
 lib/steps/binder.js                 | 350 +++++++++++++++++++++++
 lib/steps/index.js                  |   7 +-
 7 files changed, 888 insertions(+), 112 deletions(-)
 create mode 100644 lib/cli/do_fix_core_vm_resolvers.js
 create mode 100644 lib/steps/binder.js

diff --git a/.gitmodules b/.gitmodules
index fb2d1cd..8bfbc59 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -1,12 +1,12 @@
 [submodule "deps/javascriptlint"]
 	path = deps/javascriptlint
-	url = git://github.com/davepacheco/javascriptlint.git
+	url = https://github.com/davepacheco/javascriptlint.git
 [submodule "deps/jsstyle"]
 	path = deps/jsstyle
-	url = git://github.com/davepacheco/jsstyle.git
+	url = https://github.com/davepacheco/jsstyle.git
 [submodule "deps/restdown"]
 	path = deps/restdown
-	url = git://github.com/trentm/restdown.git
+	url = https://github.com/trentm/restdown.git
 [submodule "deps/restdown-brand-remora"]
 	path = deps/restdown-brand-remora
-	url = git@github.com:joyent/restdown-brand-remora.git
+	url = https://github.com/joyent/restdown-brand-remora.git
diff --git a/lib/cli/do_fix_core_vm_resolvers.js b/lib/cli/do_fix_core_vm_resolvers.js
new file mode 100644
index 0000000..f5113e5
--- /dev/null
+++ b/lib/cli/do_fix_core_vm_resolvers.js
@@ -0,0 +1,101 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2018 Joyent, Inc.
+ */
+
+var util = require('util');
+var format = util.format;
+
+var common = require('../common');
+var errors = require('../errors');
+var steps = require('../steps');
+
+function do_fix_core_vm_resolvers(subcmd, opts, args, cb) {
+    var self = this;
+    var progress = self.progress;
+    var log = self.log;
+
+    if (opts.help) {
+        this.do_help('help', {}, [subcmd], cb);
+        return;
+    } else if (args.length > 0) {
+        cb(new errors.UsageError('too many args: ' + args));
+        return;
+    }
+
+    steps.checkCoreVmInstancesResolvers({
+        sdcadm: self.sdcadm,
+        progress: progress,
+        log: log,
+        adminOnly: opts.admin_only
+    }, function (err, resolvers) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        Object.keys(resolvers).forEach(function (r) {
+            progress(
+                format('VM %s (%s) resolvers need to be updated\n', r,
+                    resolvers[r].alias) +
+                common.indent(format('from [%s] to [%s]',
+                    resolvers[r].current.join(', '),
+                    resolvers[r].expected.join(', '))));
+        });
+
+        if (opts.dry_run) {
+            cb();
+            return;
+        }
+
+        steps.updateCoreVmsResolvers({
+            sdcadm: self.sdcadm,
+            progress: progress,
+            log: log,
+            fixableResolvers: resolvers
+        }, function (updateError) {
+            cb(updateError);
+        });
+    });
+}
+
+
+do_fix_core_vm_resolvers.options = [
+    {
+        names: ['help', 'h'],
+        type: 'bool',
+        help: 'Show this help.'
+    },
+    {
+        names: ['dry-run', 'n'],
+        type: 'bool',
+        help: 'Go through the motions without actually updating.'
+    },
+    {
+        names: ['admin-only', 'o'],
+        type: 'bool',
+        help: 'Only update resolvers for VMs with a NIC on the admin network.'
+    }
+];
+do_fix_core_vm_resolvers.help = (
+    'Temporary subcommand for fixing resolvers for core resources VMs.\n' +
+    'This will be integrated into "sdcadm post-setup ha-binder".\n' +
+    '\n' +
+    'Usage:\n' +
+    '     {{name}} fix-core-vm-resolvers\n' +
+    '\n' +
+    '{{options}}'
+);
+
+// --- exports
+
+module.exports = {
+    do_fix_core_vm_resolvers: do_fix_core_vm_resolvers
+};
+
+// vim: set softtabstop=4 shiftwidth=4:
diff --git a/lib/cli/experimental.js b/lib/cli/experimental.js
index 4d1d73c..e541e56 100644
--- a/lib/cli/experimental.js
+++ b/lib/cli/experimental.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2017 Joyent, Inc.
+ * Copyright 2018 Joyent, Inc.
  */
 
 /*
@@ -23,7 +23,7 @@ var Cmdln = cmdln.Cmdln;
 var DCMaintCLI = require('../dc-maint').DCMaintCLI;
 
 
-//---- Experimental CLI class
+// --- Experimental CLI class
 
 function ExperimentalCLI(top) {
     this.top = top;
@@ -36,7 +36,7 @@ function ExperimentalCLI(top) {
               'general upgrade process will not include any commands under\n' +
               '"sdcadm experimental".',
         helpOpts: {
-            minHelpCol: 24 /* line up with option help */
+            minHelpCol: 27 /* line up with option help */
         }
     });
 }
@@ -77,14 +77,18 @@ require('./do_update_docker').do_update_docker;
 ExperimentalCLI.prototype.do_install_docker_cert =
 require('./do_install_docker_cert').do_install_docker_cert;
 
+ExperimentalCLI.prototype.do_fix_core_vm_resolvers =
+require('./do_fix_core_vm_resolvers').do_fix_core_vm_resolvers;
+
 // Deprecated: TOOLS-1667
 ExperimentalCLI.prototype.do_cns = require('../post-setup/cns').do_cns;
 
 ExperimentalCLI.prototype.do_nfs_volumes =
 require('./do_nfs_volumes').do_nfs_volumes;
 
-//---- exports
+// --- exports
 
 module.exports = {
     ExperimentalCLI: ExperimentalCLI
 };
+// vim: set softtabstop=4 shiftwidth=4:
diff --git a/lib/post-setup/ha-binder.js b/lib/post-setup/ha-binder.js
index 8443b17..c6b2ee0 100644
--- a/lib/post-setup/ha-binder.js
+++ b/lib/post-setup/ha-binder.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2016, Joyent, Inc.
+ * Copyright 2018 Joyent, Inc.
  */
 
 /*
@@ -24,6 +24,7 @@ var common = require('../common');
 var errors = require('../errors');
 var shared = require('../procedures/shared');
 var svcadm = require('../svcadm');
+var steps = require('../steps');
 
 
 
@@ -62,7 +63,8 @@ function do_ha_binder(subcmd, opts, args, cb) {
         this.do_help('help', {}, [subcmd], cb);
         return;
     } else if (args.length > 0) {
-        return cb(new errors.UsageError('too many args: ' + args));
+        cb(new errors.UsageError('too many args: ' + args));
+        return;
     }
 
     if (subcmd === 'zookeeper') {
@@ -73,21 +75,21 @@ function do_ha_binder(subcmd, opts, args, cb) {
     }
 
     if (opts.members !== 2 && opts.members !== 4) {
-        return cb(new errors.UsageError(
-                    'Invalid number of binder cluster members: ' +
-                    opts.members));
+        cb(new errors.UsageError('Invalid number of binder cluster members: ' +
+            opts.members));
+        return;
     }
 
     if (!opts.servers || !opts.servers.length ||
             opts.servers.length < (opts.members - 1)) {
-        return cb(new errors.UsageError(
-                    'Must specify ' +
-                    (opts.members - 1) + ' servers'));
+        cb(new errors.UsageError('Must specify ' +
+            (opts.members - 1) + ' servers'));
+        return;
 
     }
 
     var app = self.sdcadm.sdc;
-    var img, svc, instances, history;
+    var img, instances, history;
     var vms;
     var oldVms;
     var newVms = [];
@@ -105,9 +107,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
     var wrkDir;
     var stamp;
     var hasManatee21 = false;
+    var willCreateInsts = true;
 
     vasync.pipeline({arg: arg, funcs: [
-        function getBinderSvc(_, next) {
+        function getBinderSvc(ctx, next) {
             self.progress('Getting SDC\'s binder details from SAPI');
             self.sdcadm.sapi.listServices({
                 name: 'binder',
@@ -117,7 +120,7 @@ function do_ha_binder(subcmd, opts, args, cb) {
                     return next(svcErr);
                 }
                 if (svcs.length) {
-                    svc = svcs[0];
+                    ctx.binderSvc = svcs[0];
                 }
                 return next();
             });
@@ -126,19 +129,21 @@ function do_ha_binder(subcmd, opts, args, cb) {
         // XXX vestigial?
         shared.getUserScript, // sets `arg.userScript`.
 
-        function getBinderInstances(_, next) {
-            if (!svc) {
-                return next();
+        function getBinderInstances(ctx, next) {
+            if (!ctx.binderSvc) {
+                next();
+                return;
             }
             self.progress('Getting SDC\'s binder instances from SAPI');
             self.sdcadm.sapi.listInstances({
-                service_uuid: svc.uuid
+                service_uuid: ctx.binderSvc.uuid
             }, function (instErr, insts) {
                 if (instErr) {
-                    return next(instErr);
+                    next(instErr);
+                    return;
                 }
                 instances = insts;
-                return next();
+                next();
             });
         },
 
@@ -161,7 +166,9 @@ function do_ha_binder(subcmd, opts, args, cb) {
 
         function checkTargetServers(_, next) {
             if (instances && instances.length === (opts.members + 1)) {
-                return next();
+                willCreateInsts = false;
+                next();
+                return;
             }
             self.progress('Verifying target severs "%j" exist', opts.servers);
             self.sdcadm.cnapi.listServers(function (sErr, servers_) {
@@ -202,20 +209,25 @@ function do_ha_binder(subcmd, opts, args, cb) {
         },
 
         function getNextInstanceId(_, next) {
-            if (!instances || instances.length === (opts.members + 1)) {
-                return next();
+            if (!willCreateInsts) {
+                next();
+                return;
             }
             self.progress('Calculating next binder instance alias');
             nextId = instances.map(function (inst) {
                 return Number(inst.params.alias.replace('binder', ''));
             }).sort().pop();
             nextId = nextId + 1;
-            return next();
+            next();
         },
 
         // This is for merely informative purposes and in order to add our
         // changes to history:
         function getImage(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.sdcadm.imgapi.getImage(vms[0].image_uuid, {
             }, function (err, im) {
                 if (err) {
@@ -227,9 +239,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
             });
         },
 
-        function instancesToBeCreated(_, next) {
-            if (instances && instances.length === (opts.members + 1)) {
-                return next();
+        function instancesToBeCreated(ctx, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
             }
             self.progress('Determining binder instances to be created');
             var i;
@@ -237,7 +250,7 @@ function do_ha_binder(subcmd, opts, args, cb) {
                 var change = {
                     image: img,
                     type: 'add-instance',
-                    service: svc,
+                    service: ctx.binderSvc,
                     inst: {
                         type: 'vm',
                         alias: 'binder' + i,
@@ -252,10 +265,14 @@ function do_ha_binder(subcmd, opts, args, cb) {
                 change.inst.server = opts.servers[(i - 1)];
                 changes.push(change);
             }
-            return next();
+            next();
         },
 
         function getMorayService(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Getting SDC\'s moray details from SAPI');
             self.sdcadm.sapi.listServices({
                 name: 'moray',
@@ -274,6 +291,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
         },
 
         function getMorayVms(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Getting SDC\'s moray vms from VMAPI');
             self.sdcadm.vmapi.listVms({
                 'tag.smartdc_role': 'moray',
@@ -288,6 +309,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
         },
 
         function getManateeService(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Getting SDC\'s manatee details from SAPI');
             self.sdcadm.sapi.listServices({
                 name: 'manatee',
@@ -306,6 +331,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
         },
 
         function getManateeVms(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Getting SDC\'s manatees vms from VMAPI');
             self.sdcadm.vmapi.listVms({
                 'tag.smartdc_role': 'manatee',
@@ -320,6 +349,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
         },
 
         function getShard(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Getting manatee shard status');
             var vm = manateeVms[0];
 
@@ -356,6 +389,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
         // Check manatee-adm version in order to take advantage of latest
         // available sub-commands if possible:
         function getManateeVersion(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.sdcadm.imgapi.getImage(manateeVms[0].image_uuid, {
             }, function (err, image) {
                 if (err) {
@@ -366,14 +403,15 @@ function do_ha_binder(subcmd, opts, args, cb) {
                     if (curVer >= '20150320T174220Z') {
                         hasManatee21 = true;
                     }
-                    return next();
+                    next();
                 }
             });
         },
 
         function confirm(_, next) {
             if (changes.length === 0) {
-                return next();
+                next();
+                return;
             }
             p('');
             p('This command will make the following changes:');
@@ -384,16 +422,21 @@ function do_ha_binder(subcmd, opts, args, cb) {
                 out.push(sprintf('Add instance "%s" in server %s',
                     c.inst.alias, c.inst.server));
             });
+
+            out.push('Update core VMs resolvers.');
+
             p(out.join('\n'));
             p('');
             if (opts.yes) {
-                return next();
+                next();
+                return;
             }
             var msg = 'Would you like to continue? [y/N] ';
             common.promptYesNo({msg: msg, default: 'n'}, function (answer) {
                 if (answer !== 'y') {
                     p('Aborting ha-binder setup');
-                    return cb();
+                    cb();
+                    return;
                 }
                 p('');
                 next();
@@ -402,7 +445,8 @@ function do_ha_binder(subcmd, opts, args, cb) {
 
         function confirmDuplicatedServers(_, next) {
             if (!duplicatedServers || opts.yes) {
-                return next();
+                next();
+                return;
             }
             p('');
             p('You\'ve provided duplicated servers: %j.', opts.servers);
@@ -412,7 +456,8 @@ function do_ha_binder(subcmd, opts, args, cb) {
             common.promptYesNo({msg: msg, default: 'n'}, function (answer) {
                 if (answer !== 'y') {
                     p('Aborting ha-binder setup');
-                    return cb();
+                    cb();
+                    return;
                 }
                 p('');
                 next();
@@ -456,6 +501,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
         },
 
         function freezeManatee(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Freezing manatee shard');
             common.manateeFreeze({
                 vm: manateeVms[0].uuid,
@@ -466,6 +515,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
         },
 
         function disableZkForBakup(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Disabling zookeeper for data backup');
             shared.disableRemoteSvc({
                 server: vms[0].server_uuid,
@@ -476,6 +529,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
         },
 
         function backupZookeeperData(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Creating backup of zookeeper data directory ' +
                     '(this may take some time)');
             common.execRemote({
@@ -485,20 +542,26 @@ function do_ha_binder(subcmd, opts, args, cb) {
                 vm: vms[0].uuid,
                 server: vms[0].server_uuid,
                 log: self.log
-            }, function (err, stdout, stderr) {
+            }, function (err, __, stderr) {
                 if (err) {
-                    return next(err);
+                    next(err);
+                    return;
                 }
                 if (stderr) {
-                    return next(new errors.InternalError({
+                    next(new errors.InternalError({
                         message: util.format('Backup failed: %s', stderr)
                     }));
+                    return;
                 }
-                return next();
+                next();
             });
         },
 
         function enableZkAfterBakup(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Enabling zookeeper after data backup');
             shared.enableRemoteSvc({
                 server: vms[0].server_uuid,
@@ -509,6 +572,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
         },
 
         function copyZkBackupToWorkDir(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Copying backup of zookeeper data to: %s', wrkDir);
             var argv = [
                 '/opt/smartdc/bin/sdc-oneachnode',
@@ -518,8 +585,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
                 '-n',
                 vms[0].server_uuid,
                 '-p',
-                /* JSSTYLED */
-                util.format('/zones/%s/root/zookeeper/zookeeper/zookeeper-%s.tgz', vms[0].uuid, stamp),
+                util.format(
+                    '/zones/%s/root/zookeeper/zookeeper/zookeeper-%s.tgz',
+                    vms[0].uuid, stamp
+                ),
                 '--clobber',
                 '-d',
                 wrkDir
@@ -554,15 +623,20 @@ function do_ha_binder(subcmd, opts, args, cb) {
         },
 
         function renameZkBackup(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             var fname = path.join(wrkDir,
                     util.format('zookeeper-%s.tgz', stamp));
             self.progress('Moving backup of zookeeper data to: %s', fname);
             fs.rename(path.join(wrkDir, vms[0].server_uuid), fname, next);
         },
 
-        function createBinderInstances(_, next) {
-            if (instances && instances.length === (opts.members + 1)) {
-                return next();
+        function createBinderInstances(ctx, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
             }
 
             vasync.forEachPipeline({
@@ -582,8 +656,8 @@ function do_ha_binder(subcmd, opts, args, cb) {
                         instOpts.params.server_uuid = change.inst.server;
                     }
 
-                    self.sdcadm.sapi.createInstance(svc.uuid, instOpts,
-                            function (err, inst_) {
+                    self.sdcadm.sapi.createInstance(ctx.binderSvc.uuid,
+                        instOpts, function (err, inst_) {
                         if (err) {
                             return next_(
                                 new errors.SDCClientError(err, 'sapi'));
@@ -602,6 +676,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
         },
 
         function hupHermes(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             svcadm.restartHermes({
                 sdcadm: self.sdcadm,
                 log: self.log,
@@ -609,24 +687,19 @@ function do_ha_binder(subcmd, opts, args, cb) {
             }, next);
         },
 
-        function getBinderInstancesAfterCreation(_, next) {
-            if (instances && instances.length === opts.members) {
-                return next();
-            }
-            self.progress('Getting SDC\'s binder instances from SAPI');
+        function getBinderInstancesAfterCreation(ctx, next) {
             self.sdcadm.sapi.listInstances({
-                service_uuid: svc.uuid
+                service_uuid: ctx.binderSvc.uuid
             }, function (instErr, insts) {
                 if (instErr) {
                     return next(instErr);
                 }
-                instances = insts;
+                ctx.binderInsts = instances = insts;
                 return next();
             });
         },
 
-        function getBinderVmsAfterCreation(_, next) {
-            self.progress('Getting SDC\'s binder vms from VMAPI');
+        function getBinderVmsAfterCreation(ctx, next) {
             self.sdcadm.vmapi.listVms({
                 'tag.smartdc_role': 'binder',
                 state: 'running'
@@ -639,12 +712,16 @@ function do_ha_binder(subcmd, opts, args, cb) {
                         newVms.push(vm);
                     }
                 });
-                vms = vms_;
+                ctx.binderVms = vms = vms_;
                 return next();
             });
         },
 
         function disableZkIntoNewInsts(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Disabling zookeeper into new instances');
             vasync.forEachParallel({
                 inputs: newVms,
@@ -660,6 +737,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
         },
         // rm -Rf /zookeeper/zookeeper/version-2 into the new binders
         function removeZkDataFromNewInsts(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Clearing zookeeper data into new instances');
             vasync.forEachParallel({
                 inputs: newVms,
@@ -669,22 +750,28 @@ function do_ha_binder(subcmd, opts, args, cb) {
                         vm: vm.uuid,
                         server: vm.server_uuid,
                         log: self.log
-                    }, function (err, stdout, stderr) {
+                    }, function (err, __, stderr) {
                         if (err) {
-                            return nextVm(err);
+                            nextVm(err);
+                            return;
                         }
                         if (stderr) {
-                            return nextVm(new errors.InternalError({
+                            nextVm(new errors.InternalError({
                                 message: stderr
                             }));
+                            return;
                         }
-                        return nextVm();
+                        nextVm();
                     });
                 }
             }, next);
         },
         // Copy data from binder0 backup into the binder instances
         function copyZkDataIntoNewInsts(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Copying zookeeper data into new instances');
             var fname = path.join(wrkDir,
                     util.format('zookeeper-%s.tgz', stamp));
@@ -738,6 +825,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
         },
         // Untar data from binder0 into the new binder instances
         function untarZkDataIntoNewInsts(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Extracting zookeeper data into new instances ' +
                     '(may take some time)');
             vasync.forEachParallel({
@@ -750,22 +841,28 @@ function do_ha_binder(subcmd, opts, args, cb) {
                         vm: vm.uuid,
                         server: vm.server_uuid,
                         log: self.log
-                    }, function (err, stdout, stderr) {
+                    }, function (err, __, stderr) {
                         if (err) {
-                            return nextVm(err);
+                            nextVm(err);
+                            return;
                         }
                         if (stderr) {
-                            return nextVm(new errors.InternalError({
+                            nextVm(new errors.InternalError({
                                 message: stderr
                             }));
+                            return;
                         }
-                        return nextVm();
+                        nextVm();
                     });
                 }
             }, next);
         },
         // enable zookeeper into the new binder instances
         function enableZkIntoNewInsts(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Enabling zookeeper into new instances');
             vasync.forEachParallel({
                 inputs: newVms,
@@ -785,6 +882,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
         // to make these instances to join the same zookeeper ensemble.
 
         function prepareClusterPayload(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             vms.forEach(function (vm) {
                 var instance = instances.filter(function (i) {
                     return (i.uuid === vm.uuid);
@@ -800,10 +901,14 @@ function do_ha_binder(subcmd, opts, args, cb) {
             // Set a value for special property "last" for just the final
             // element of the collection
             HA_ZK_JSON[HA_ZK_JSON.length - 1].last = true;
-            return next();
+            next();
         },
 
         function cfgBinderService(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Updating Binder service config in SAPI');
             self.sdcadm.sapi.updateApplication(app.uuid, {
                 metadata: {
@@ -819,6 +924,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
 
         // Set ZK_SERVERS, not ZK_HA_SERVERS
         function cfgMoraySvc(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Updating Moray service config in SAPI');
             self.sdcadm.sapi.updateService(moraySvc.uuid, {
                 metadata: {
@@ -834,6 +943,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
 
         // Set ZK_SERVERS, not ZK_HA_SERVERS
         function cfgManateeSvc(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Updating Manatee service config in SAPI');
             self.sdcadm.sapi.updateService(manateeSvc.uuid, {
                 metadata: {
@@ -849,6 +962,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
 
         // Call config-agent sync for all the binder VMs
         function callConfigAgentSyncForAllBinders(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Reloading config for all the binder VMs');
             vasync.forEachParallel({
                 inputs: vms,
@@ -862,39 +979,48 @@ function do_ha_binder(subcmd, opts, args, cb) {
             }, next);
         },
 
-        function waitForZkClusterOk(_, next) {
-            self.progress('Waiting for ZK cluster to reach a steady state');
-            var ips = vms.map(function (vm) {
+        function waitForZkClusterOk(ctx, next) {
+            ctx.ips = vms.map(function (vm) {
                 return (vm.nics[0].ip);
             });
 
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
+
+            self.progress('Waiting for ZK cluster to reach a steady state');
+
+
             shared.wait4ZkOk({
-                ips: ips,
+                ips: ctx.ips,
                 log: self.sdcadm.log
             }, next);
         },
 
-        function checkAllInstancesJoinedZkCluster(_, next) {
+        function checkAllInstancesJoinedZkCluster(ctx, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Waiting for binder instances to join ZK cluster');
-            var ips = vms.map(function (vm) {
-                return (vm.nics[0].ip);
-            });
 
             shared.wait4ZkCluster({
-                ips: ips,
+                ips: ctx.ips,
                 log: self.sdcadm.log
             }, next);
         },
 
         // Now that we've added the binder, wouldn't it be the leader always?:
-        function getZkLeaderIP(_, next) {
+        function getZkLeaderIP(ctx, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Getting ZK leader IP');
-            var ips = vms.map(function (vm) {
-                return (vm.nics[0].ip);
-            });
 
             shared.getZkLeaderIP({
-                ips: ips,
+                ips: ctx.ips,
                 log: self.sdcadm.log
             }, function (err, ip) {
                 if (err) {
@@ -907,6 +1033,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
 
         // Call config-agent sync for all the manatee VMs
         function callConfigAgentSyncForAllManatees(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Reloading config for all the manatee VMs');
             vasync.forEachParallel({
                 inputs: manateeVms,
@@ -923,6 +1053,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
         // HUP Manatee (Already waits for manatee shard to
         // reach the desired status):
         function disableManatee(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             shared.disableManateeSitter({
                 progress: self.progress,
                 log: self.sdcadm.log,
@@ -933,6 +1067,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
         },
 
         function enableManatee(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             shared.enableManateeSitter({
                 progress: self.progress,
                 log: self.sdcadm.log,
@@ -944,6 +1082,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
 
         // Call config-agent sync for all the moray VMs
         function callConfigAgentSyncForAllMorays(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Reloading config for all the moray VMs');
             vasync.forEachParallel({
                 inputs: morayVms,
@@ -959,6 +1101,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
 
         // HUP morays:
         function restartMorays(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Restarting moray services');
             vasync.forEachParallel({
                 inputs: morayVms,
@@ -979,6 +1125,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
         },
 
         function wait4Morays(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Waiting for moray services to be up into' +
                     ' every moray instance');
             shared.wait4Morays({
@@ -988,25 +1138,35 @@ function do_ha_binder(subcmd, opts, args, cb) {
         },
 
         function unfreezeManatee(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Unfreezing manatee shard');
             common.manateeAdmRemote({
                 server: manateeVms[0].server_uuid,
                 vm: manateeVms[0].uuid,
                 cmd: 'unfreeze',
                 log: self.log
-            }, function (err, stdou, stder) {
+            }, function (err, __, stder) {
                 if (err) {
-                    return next(err);
+                    next(err);
+                    return;
                 } else if (stder) {
-                    return next(new errors.InternalError({
+                    next(new errors.InternalError({
                         message: stder
                     }));
+                    return;
                 }
-                return next();
+                next();
             });
         },
 
         function clearDataBackupFromBinderVm(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Removing zookeeper data backup from %s',
                     vms[0].uuid);
 
@@ -1016,24 +1176,101 @@ function do_ha_binder(subcmd, opts, args, cb) {
                 vm: vms[0].uuid,
                 server: vms[0].server_uuid,
                 log: self.log
-            }, function (err, stdout, stderr) {
+            }, function (err, __, stderr) {
                 if (err) {
-                    return next(err);
+                    next(err);
+                    return;
                 }
                 if (stderr) {
-                    return next(new errors.InternalError({
+                    next(new errors.InternalError({
                         message: stderr
                     }));
+                    return;
                 }
-                return next();
+                next();
+            });
+        },
+
+        function ensureAdminNetworkHasCorrectResolvers(ctx, next) {
+            self.sdcadm.napi.listNetworks({
+                name: 'admin',
+                owner_uuid: self.sdcadm.config.ufds_admin_uuid
+            }, function (err, nets) {
+                if (err) {
+                    next(new errors.SDCClientError(err, 'napi'));
+                    return;
+                }
+
+                if (!nets.length) {
+                    next(new errors.InternalError(
+                        'Cannot find Admin network in NAPI'));
+                    return;
+                }
+
+                ctx.admin_network_uuid = nets[0].uuid;
+                var changed = (ctx.ips.length !== nets[0].resolvers.length ||
+                                !ctx.ips.every(function checkIp(ip, pos) {
+                                    return (ip === nets[0].resolvers[pos]);
+                                }));
+
+                if (!changed) {
+                    next();
+                    return;
+                }
+
+                self.progress(
+                    'Adding new binder IPs to admin network resolvers');
+                self.sdcadm.napi.updateNetwork(ctx.admin_network_uuid, {
+                    resolvers: ctx.ips
+                }, function (err2) {
+                    if (err2) {
+                        next(new errors.SDCClientError(err2, 'napi'));
+                        return;
+                    }
+                    next();
+                });
+            });
+        },
+
+        function updateCoreVmsResolvers(ctx, next) {
+            self.progress('Updating core SDC VMs resolvers');
+            ctx.binderIps = ctx.ips;
+            steps.checkCoreVmInstancesResolvers({
+                sdcadm: self.sdcadm,
+                progress: self.progress,
+                log: self.log,
+                ctx: ctx
+            }, function (err, resolvers) {
+                if (err) {
+                    next(err);
+                    return;
+                }
+
+                Object.keys(resolvers).forEach(function (r) {
+                    self.progress(
+                        'VM %s resolvers need to be updated from [%s] to [%s]',
+                        r, resolvers[r].current.join(', '),
+                        resolvers[r].expected.join(', '));
+                });
+
+                steps.updateCoreVmsResolvers({
+                    sdcadm: self.sdcadm,
+                    progress: self.progress,
+                    log: self.log,
+                    fixableResolvers: resolvers
+                }, function (updateError) {
+                    next(updateError);
+                });
             });
         }
+
     ]}, function (err) {
         // Add error to history in case the update execution failed:
         if (err) {
             if (!history) {
                 self.log.warn('History not set for post-setup ha-binder');
-                return cb(err);
+                cb(err);
+                return;
             }
             history.error = err;
         } else {
@@ -1041,11 +1278,12 @@ function do_ha_binder(subcmd, opts, args, cb) {
         }
         if (!history) {
             self.log.warn('History not set for post-setup ha-binder');
-            return cb();
+            cb();
+            return;
         }
         history.changes = changes;
         // No need to add `history.finished` here, History instance will handle
-        self.sdcadm.history.updateHistory(history, function (err2, hist2) {
+        self.sdcadm.history.updateHistory(history, function (err2) {
             if (err) {
                 cb(err);
             } else if (err2) {
@@ -1103,7 +1341,7 @@ do_ha_binder.help = (
 
 
 
-//---- exports
+// --- exports
 
 module.exports = {
     do_ha_binder: do_ha_binder
diff --git a/lib/procedures/shared.js b/lib/procedures/shared.js
index 000b9a6..5322640 100644
--- a/lib/procedures/shared.js
+++ b/lib/procedures/shared.js
@@ -1659,7 +1659,8 @@ function wait4ZkOk(opts, callback) {
             }
         }, function (waitErr, results) {
             if (waitErr) {
-                return callback(waitErr);
+                callback(waitErr);
+                return;
             }
             counter += 1;
             var notOk = results.successes.filter(function (r) {
@@ -1668,14 +1669,15 @@ function wait4ZkOk(opts, callback) {
 
             if (notOk.length) {
                 if (counter < limit) {
-                    return setTimeout(_wait4Zk, 5000);
+                    setTimeout(_wait4Zk, 5000);
                 } else {
-                    return callback('Timeout (5min) waiting ' +
-                            'for ZK cluster');
+                    callback(new errors.UpdateError('Timeout (5min) waiting ' +
+                            'for ZK cluster'));
                 }
+                return;
             }
 
-            return callback();
+            callback();
         });
     }
 
@@ -1719,7 +1721,8 @@ function wait4ZkCluster(opts, callback) {
             }
         }, function (waitErr, results) {
             if (waitErr) {
-                return callback(waitErr);
+                callback(waitErr);
+                return;
             }
             counter += 1;
             var notOk = results.successes.filter(function (r) {
@@ -1728,13 +1731,14 @@ function wait4ZkCluster(opts, callback) {
 
             if (notOk.length && counter < limit) {
                 if (counter < limit) {
-                    return setTimeout(_wait4ZkMode, 5000);
+                    setTimeout(_wait4ZkMode, 5000);
                 } else {
-                    return callback('Timeout (5min) waiting ' +
-                            'for ZK cluster');
+                    callback(new errors.UpdateError('Timeout (5min) waiting ' +
+                            'for ZK cluster'));
                 }
+                return;
             }
-            return callback();
+            callback();
         });
     }
 
@@ -1774,7 +1778,8 @@ function getZkLeaderIP(opts, callback) {
         }
     }, function (waitErr, results) {
         if (waitErr) {
-            return callback(waitErr);
+            callback(waitErr);
+            return;
         }
 
         var leader = results.successes.filter(function (r) {
@@ -1782,7 +1787,7 @@ function getZkLeaderIP(opts, callback) {
         });
 
         var IP = leader.length ? leader[0].ip : null;
-        return callback(null, IP);
+        callback(null, IP);
     });
 
 }
@@ -1915,6 +1920,82 @@ function wait4Morays(opts, cb) {
     });
 }
 
+
+/**
+ * Wait for the given job_uuid to be finished.
+ *
+ * In case of failure this function will return an error
+ *
+ * @param {Object} opts: All the following options are required:
+ *      @param {Object} opts.job_uuid: Job UUID
+ *      @param {Object} opts.sdcadm: sdcadm object instance
+ *      @param {Integer} opts.timeout: timeout in seconds, default
+ *          to 2 hours if none specified.
+ *
+ * @param {Function} cb: Callback of the form f(err);
+ */
+function waitForJob(opts, cb) {
+    assert.object(opts, 'opts');
+    assert.string(opts.job_uuid, 'opts.job_uuid');
+    assert.object(opts.sdcadm, 'opts.sdcadm');
+    assert.optionalNumber(opts.timeout, 'opts.timeout');
+    assert.func(cb, 'cb');
+
+    function pollJob(job_uuid, _cb) {
+        var attempts = 0;
+        var errs = 0;
+
+        var interval = 5000;  // 5 seconds
+        var limit = opts.timeout || 720; // 1 hour
+
+        var poll = function () {
+            opts.sdcadm.wfapi.getJob(job_uuid, function (err, job) {
+                attempts++;
+
+                if (err) {
+                    errs++;
+                    if (errs >= 5) {
+                        _cb(err);
+                        return;
+                    } else {
+                        setTimeout(poll, interval);
+                        return;
+                    }
+                }
+
+                if (job && (job.execution === 'succeeded' ||
+                    job.execution === 'failed')) {
+                    _cb(null, job);
+                    return;
+                } else if (attempts > limit) {
+                    _cb(new Error('polling for import job timed out'), job);
+                    return;
+                }
+
+                setTimeout(poll, interval);
+                return;
+            });
+        };
+
+        poll();
+    }
+
+    pollJob(opts.job_uuid, function (err, job) {
+        if (err) {
+            cb(err);
+            return;
+        }
+        var result = job.chain_results.pop();
+        if (result.error) {
+            var errmsg = result.error.message || JSON.stringify(result.error);
+            cb(new Error(errmsg));
+            return;
+        } else {
+            cb();
+        }
+    });
+}
+
 // --- exports
 
 module.exports = {
@@ -1955,6 +2036,7 @@ module.exports = {
     getShardState: getShardState,
     wait4Morays: wait4Morays,
     manateeSitterSvcStatus: manateeSitterSvcStatus,
-    waitForManatee: waitForManatee
+    waitForManatee: waitForManatee,
+    waitForJob: waitForJob
 };
 // vim: set softtabstop=4 shiftwidth=4:
diff --git a/lib/steps/binder.js b/lib/steps/binder.js
new file mode 100644
index 0000000..ab2304f
--- /dev/null
+++ b/lib/steps/binder.js
@@ -0,0 +1,350 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2018 Joyent, Inc.
+ */
+
+/*
+ * Steps for checking all the "core" VMs for the correct resolvers.
+ */
+
+var assert = require('assert-plus');
+var vasync = require('vasync');
+
+var errors = require('../errors');
+var shared = require('../procedures/shared');
+
+/**
+ * Compare current resolvers value for 'core' VMs with expected value
+ * from 'binder' instances, and return an object containing only those
+ * VMs which need an update.
+ *
+ * Callback function will be called with the aforementioned object as
+ * its second argument, (the first argument will be any error which could
+ * happen during the process).
+ *
+ * Format for this object is:
+ *
+ * {
+ *      VM_UUID: {
+ *          expected: [resolvers],
+ *          current: [resolvers]
+ *      },
+ *      VM_UUID_2: ...
+ * }
+ *
+ */
+function checkCoreVmInstancesResolvers(arg, cb) {
+    assert.object(arg, 'arg');
+    assert.func(arg.progress, 'arg.progress');
+    assert.object(arg.log, 'arg.log');
+    assert.object(arg.sdcadm, 'arg.sdcadm');
+    assert.optionalObject(arg.ctx, 'arg.ctx');
+    assert.optionalBool(arg.adminOnly, 'arg.adminOnly');
+    assert.func(cb, 'cb');
+
+    var sdcadm = arg.sdcadm;
+    var context = arg.ctx || {};
+    var app = sdcadm.sdc;
+    context.adminOnly = arg.adminOnly || false;
+
+    vasync.pipeline({
+        arg: context,
+        funcs: [
+            function getBinderSvc(ctx, next) {
+                if (ctx.binderSvc) {
+                    next();
+                    return;
+                }
+                sdcadm.sapi.listServices({
+                    name: 'binder',
+                    application_uuid: app.uuid
+                }, function (svcErr, svcs) {
+                    if (svcErr) {
+                        next(svcErr);
+                        return;
+                    }
+                    if (svcs.length) {
+                        ctx.binderSvc = svcs[0];
+                    }
+                    next();
+                });
+            },
+
+            function getBinderInsts(ctx, next) {
+                if (ctx.binderInsts) {
+                    next();
+                    return;
+                }
+                sdcadm.sapi.listInstances({
+                    service_uuid: ctx.binderSvc.uuid
+                }, function (instErr, insts) {
+                    if (instErr) {
+                        next(instErr);
+                        return;
+                    }
+                    ctx.binderInsts = insts;
+                    next();
+                });
+            },
+
+            function getBinderVms(ctx, next) {
+                if (ctx.binderVms && ctx.binderIps) {
+                    next();
+                    return;
+                }
+                sdcadm.vmapi.listVms({
+                    'tag.smartdc_role': 'binder',
+                    state: 'running'
+                }, function (vmsErr, vms) {
+                    if (vmsErr) {
+                        next(vmsErr);
+                        return;
+                    }
+                    ctx.binderVms = vms;
+                    // Binder instances have only admin Ips:
+                    ctx.binderIps = vms.map(function (vm) {
+                        return (vm.nics[0].ip);
+                    });
+                    next();
+                });
+            },
+
+            function getExternalNetworkResolvers(ctx, next) {
+                if (ctx.externalNetworkResolvers) {
+                    next();
+                    return;
+                }
+                sdcadm.napi.listNetworks({
+                    name: 'external'
+                }, function (err, nets) {
+                    if (err) {
+                        next(new errors.SDCClientError(
+                            err, 'napi'));
+                        return;
+                    }
+
+                    if (!nets.length) {
+                        next(new errors.InternalError(new Error(
+                            'Cannot find external network in NAPI')));
+                        return;
+                    }
+
+                    ctx.externalNetworkResolvers = nets[0].resolvers;
+                    next();
+                });
+            },
+
+            function getSdcVmServices(ctx, next) {
+                if (ctx.coreSvcs) {
+                    next();
+                    return;
+                }
+                sdcadm.getServices({
+                    type: 'vm'
+                }, function (svcsErr, svcs) {
+                    if (svcsErr) {
+                        next(svcsErr);
+                        return;
+                    }
+                    ctx.coreSvcs = svcs.map(function (s) {
+                        return s.uuid;
+                    }).filter(function (x) {
+                        return (x !== undefined && x !== null);
+                    });
+                    next();
+                });
+            },
+
+            function getSdcSapiVmInstances(ctx, next) {
+                if (ctx.coreInstances) {
+                    next();
+                    return;
+                }
+                vasync.forEachPipeline({
+                    inputs: ctx.coreSvcs,
+                    func: function getSvcInstances(service, nextSvc) {
+                        if (!ctx.coreInstances) {
+                            ctx.coreInstances = [];
+                        }
+
+                        sdcadm.sapi.listInstances({
+                            service_uuid: service
+                        }, function (sapiErr, insts) {
+                            if (sapiErr) {
+                                nextSvc(new errors.SDCClientError(
+                                    sapiErr, 'sapi'));
+                                return;
+                            }
+                            ctx.coreInstances = ctx.coreInstances.concat(
+                                insts.map(function (ins) {
+                                    return ins.uuid;
+                                })
+                            );
+                            nextSvc();
+                        });
+                    }
+                }, next);
+            },
+
+            function getSdcCoreVms(ctx, next) {
+                if (ctx.coreVms) {
+                    next();
+                    return;
+                }
+
+                vasync.forEachPipeline({
+                    inputs: ctx.coreInstances,
+                    func: function getInstanceVm(inst, nextInst) {
+                        if (!ctx.coreVms) {
+                            ctx.coreVms = [];
+                        }
+
+                        sdcadm.vmapi.getVm({
+                            uuid: inst
+                        }, function (vmapiErr, vm) {
+                            if (vmapiErr) {
+                                nextInst(new errors.SDCClientError(
+                                    vmapiErr, 'vmapi'));
+                                return;
+                            }
+                            ctx.coreVms.push(vm);
+                            nextInst();
+                        });
+                    }
+                }, next);
+
+            },
+
+            function checkVmResolvers(ctx, next) {
+                ctx.fixableResolvers = {};
+
+                vasync.forEachParallel({
+                    inputs: ctx.coreVms,
+                    func: function checkResolvers(vm, nextVm) {
+                        // Binder VMs and eventually, anything we want to
+                        // avoid resolvers:
+                        if (vm.resolvers.length === 0 &&
+                            vm.internal_metadata &&
+                            (vm.internal_metadata.set_resolvers === false)) {
+                            nextVm();
+                            return;
+                        }
+
+                        var hasAdminNic = false;
+                        var unknownNicTag = false;
+                        var resolvers = [];
+                        vm.nics.forEach(function (nic) {
+                            if (nic.nic_tag === 'admin') {
+                                resolvers = resolvers.concat(
+                                    ctx.binderIps);
+                                hasAdminNic = true;
+                            } else if (nic.nic_tag === 'external') {
+                                resolvers = resolvers.concat(
+                                    ctx.externalNetworkResolvers);
+                            } else {
+                                unknownNicTag = nic.nic_tag;
+                            }
+                        });
+
+                        if (unknownNicTag) {
+                            arg.progress('Skip VM %s (%s): unknown NIC tag %s',
+                                vm.uuid, vm.alias, unknownNicTag);
+                            nextVm();
+                            return;
+                        }
+
+                        if (ctx.adminOnly && !hasAdminNic) {
+                            nextVm();
+                            return;
+                        }
+
+                        // Resolvers must match exactly on the same order:
+                        var fixResolvers = false;
+                        fixResolvers = resolvers.some(function (el, id) {
+                            return (vm.resolvers[id] !== el);
+                        });
+                        if (!fixResolvers) {
+                            fixResolvers = vm.resolvers.some(function (el, id) {
+                                return (resolvers[id] !== el);
+                            });
+                        }
+                        if (fixResolvers) {
+                            ctx.fixableResolvers[vm.uuid] = {
+                                current: vm.resolvers,
+                                expected: resolvers,
+                                alias: vm.alias
+                            };
+                        }
+                        nextVm();
+                    }
+                }, next);
+            }
+        ]
+    }, function (pipeErr) {
+        cb(pipeErr, context.fixableResolvers);
+    });
+}
+
+/**
+ * The expected format for 'arg.fixableResolvers' is the value
+ * returnted by checkCoreVmInstancesResolvers.
+ */
+function updateCoreVmsResolvers(arg, cb) {
+    assert.object(arg, 'arg');
+    assert.func(arg.progress, 'arg.progress');
+    assert.object(arg.log, 'arg.log');
+    assert.object(arg.sdcadm, 'arg.sdcadm');
+    assert.object(arg.fixableResolvers, 'arg.fixableResolvers');
+    assert.func(cb, 'cb');
+
+    var sdcadm = arg.sdcadm;
+    var log = arg.log.child({ component: 'updateCoreVmsResolvers'}, true);
+
+    vasync.forEachPipeline({
+        inputs: Object.keys(arg.fixableResolvers),
+        func: function updateVmResolvers(vm, nextVm) {
+            log.debug({
+                vm: vm,
+                resolvers: arg.fixableResolvers[vm].expected
+            }, 'Updating VM resolvers');
+
+            sdcadm.vmapi.updateVm({
+                uuid: vm,
+                payload: {
+                    resolvers: arg.fixableResolvers[vm].expected
+                }
+            }, function (vmapiErr, vmapiRes) {
+                if (vmapiErr) {
+                    nextVm(new errors.SDCClientError(vmapiErr, 'vmapi'));
+                    return;
+                }
+
+                log.debug(vmapiRes, 'waiting for VM job');
+
+                shared.waitForJob({
+                    sdcadm: sdcadm,
+                    job_uuid: vmapiRes.job_uuid
+                }, function (jobErr) {
+                    if (jobErr) {
+                        nextVm(new errors.SDCClientError(jobErr, 'wfapi'));
+                        return;
+                    }
+                    nextVm();
+                });
+            });
+        }
+    }, cb);
+}
+// --- exports
+
+module.exports = {
+    checkCoreVmInstancesResolvers: checkCoreVmInstancesResolvers,
+    updateCoreVmsResolvers: updateCoreVmsResolvers
+};
+
+// vim: set softtabstop=4 shiftwidth=4:
diff --git a/lib/steps/index.js b/lib/steps/index.js
index 801697d..a8f3472 100644
--- a/lib/steps/index.js
+++ b/lib/steps/index.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2017 Joyent, Inc.
+ * Copyright 2018 Joyent, Inc.
  */
 
 /*
@@ -17,7 +17,7 @@ var format = require('util').format;
 
 
 
-//---- exports
+// --- exports
 
 module.exports = {};
 
@@ -25,7 +25,8 @@ module.exports = {};
     'no-rabbit',
     'update_vm_size',
     'sapi',
-    'servers'
+    'servers',
+    'binder'
 ].forEach(function (modName) {
     var mod = require('./' + modName);
     Object.keys(mod).forEach(function (symbol) {
-- 
2.21.0

