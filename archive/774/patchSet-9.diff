From b6492d293940bc0ec23613e04b20c319c8797881 Mon Sep 17 00:00:00 2001
From: Pedro Palazon Candel <pedro@joyent.com>
Date: Tue, 15 Aug 2017 12:12:10 +0200
Subject: [PATCH] TOOLS-1579 sdcadm post-setup ha-binder should update core
 zones resolvers

---
 lib/cli/do_fix_core_vm_resolvers.js | 100 ++++++++
 lib/cli/experimental.js             |   4 +
 lib/post-setup/ha-binder.js         | 276 +++++++++++++++++++---
 lib/procedures/shared.js            |  76 ++++++-
 lib/steps/binder.js                 | 341 ++++++++++++++++++++++++++++
 lib/steps/index.js                  |   4 +-
 6 files changed, 766 insertions(+), 35 deletions(-)
 create mode 100644 lib/cli/do_fix_core_vm_resolvers.js
 create mode 100644 lib/steps/binder.js

diff --git a/lib/cli/do_fix_core_vm_resolvers.js b/lib/cli/do_fix_core_vm_resolvers.js
new file mode 100644
index 0000000..f5afcec
--- /dev/null
+++ b/lib/cli/do_fix_core_vm_resolvers.js
@@ -0,0 +1,100 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2017 Joyent, Inc.
+ */
+
+var util = require('util');
+var format = util.format;
+var fs = require('fs');
+
+var common = require('../common');
+var errors = require('../errors');
+var steps = require('../steps');
+
+function do_fix_core_vm_resolvers(subcmd, opts, args, cb) {
+    var self = this;
+    var progress = self.progress;
+    var log = self.log;
+
+    if (opts.help) {
+        this.do_help('help', {}, [subcmd], cb);
+        return;
+    } else if (args.length > 0) {
+        return cb(new errors.UsageError('too many args: ' + args));
+    }
+
+    steps.checkCoreVmInstancesResolvers({
+        sdcadm: self.sdcadm,
+        progress: progress,
+        log: log,
+        adminOnly: opts.admin_only
+    }, function (err, resolvers) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        Object.keys(resolvers).forEach(function (r) {
+            progress(
+                format('VM %s resolvers need to be updated\n', r) +
+                common.indent(format('from [%s] to [%s]',
+                    resolvers[r].current.join(', '),
+                    resolvers[r].expected.join(', '))));
+        });
+
+        if (opts.dry_run) {
+            cb();
+            return;
+        }
+
+        steps.updateCoreVmsResolvers({
+            sdcadm: self.sdcadm,
+            progress: progress,
+            log: log,
+            fixableResolvers: resolvers
+        }, function (updateError) {
+            cb(updateError);
+        });
+    });
+}
+
+
+do_fix_core_vm_resolvers.options = [
+    {
+        names: ['help', 'h'],
+        type: 'bool',
+        help: 'Show this help.'
+    },
+    {
+        names: ['dry-run', 'n'],
+        type: 'bool',
+        help: 'Go through the motions without actually updating.'
+    },
+    {
+        names: ['admin-only', 'o'],
+        type: 'bool',
+        help: 'Only update resolvers for VMs with a NIC on the admin network.'
+    }
+];
+do_fix_core_vm_resolvers.help = (
+    'Temporary grabbag for fixing resolvers for core resources VMs.\n' +
+    'This will be integrated into "sdcadm post-setup ha-binder".\n' +
+    '\n' +
+    'Usage:\n' +
+    '     {{name}} core-vm-resolvers\n' +
+    '\n' +
+    '{{options}}'
+);
+
+// --- exports
+
+module.exports = {
+    do_fix_core_vm_resolvers: do_fix_core_vm_resolvers
+};
+
+// vim: set softtabstop=4 shiftwidth=4:
diff --git a/lib/cli/experimental.js b/lib/cli/experimental.js
index acdb5f8..e421b08 100644
--- a/lib/cli/experimental.js
+++ b/lib/cli/experimental.js
@@ -77,6 +77,9 @@ require('./do_update_docker').do_update_docker;
 ExperimentalCLI.prototype.do_install_docker_cert =
 require('./do_install_docker_cert').do_install_docker_cert;
 
+ExperimentalCLI.prototype.do_fix_core_vm_resolvers =
+require('./do_fix_core_vm_resolvers').do_fix_core_vm_resolvers;
+
 // Deprecated: TOOLS-1667
 ExperimentalCLI.prototype.do_cns = require('../post-setup/cns').do_cns;
 
@@ -87,3 +90,4 @@ ExperimentalCLI.prototype.do_cns = require('../post-setup/cns').do_cns;
 module.exports = {
     ExperimentalCLI: ExperimentalCLI
 };
+// vim: set softtabstop=4 shiftwidth=4:
diff --git a/lib/post-setup/ha-binder.js b/lib/post-setup/ha-binder.js
index 8443b17..d55da42 100644
--- a/lib/post-setup/ha-binder.js
+++ b/lib/post-setup/ha-binder.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2016, Joyent, Inc.
+ * Copyright 2017 Joyent, Inc.
  */
 
 /*
@@ -24,6 +24,7 @@ var common = require('../common');
 var errors = require('../errors');
 var shared = require('../procedures/shared');
 var svcadm = require('../svcadm');
+var steps = require('../steps');
 
 
 
@@ -105,9 +106,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
     var wrkDir;
     var stamp;
     var hasManatee21 = false;
+    var willCreateInsts = true;
 
     vasync.pipeline({arg: arg, funcs: [
-        function getBinderSvc(_, next) {
+        function getBinderSvc(ctx, next) {
             self.progress('Getting SDC\'s binder details from SAPI');
             self.sdcadm.sapi.listServices({
                 name: 'binder',
@@ -117,7 +119,7 @@ function do_ha_binder(subcmd, opts, args, cb) {
                     return next(svcErr);
                 }
                 if (svcs.length) {
-                    svc = svcs[0];
+                    ctx.binderSvc = svc = svcs[0];
                 }
                 return next();
             });
@@ -161,7 +163,9 @@ function do_ha_binder(subcmd, opts, args, cb) {
 
         function checkTargetServers(_, next) {
             if (instances && instances.length === (opts.members + 1)) {
-                return next();
+                willCreateInsts = false;
+                next();
+                return;
             }
             self.progress('Verifying target severs "%j" exist', opts.servers);
             self.sdcadm.cnapi.listServers(function (sErr, servers_) {
@@ -202,8 +206,9 @@ function do_ha_binder(subcmd, opts, args, cb) {
         },
 
         function getNextInstanceId(_, next) {
-            if (!instances || instances.length === (opts.members + 1)) {
-                return next();
+            if (!willCreateInsts) {
+                next();
+                return;
             }
             self.progress('Calculating next binder instance alias');
             nextId = instances.map(function (inst) {
@@ -216,6 +221,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
         // This is for merely informative purposes and in order to add our
         // changes to history:
         function getImage(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.sdcadm.imgapi.getImage(vms[0].image_uuid, {
             }, function (err, im) {
                 if (err) {
@@ -228,8 +237,9 @@ function do_ha_binder(subcmd, opts, args, cb) {
         },
 
         function instancesToBeCreated(_, next) {
-            if (instances && instances.length === (opts.members + 1)) {
-                return next();
+            if (!willCreateInsts) {
+                next();
+                return;
             }
             self.progress('Determining binder instances to be created');
             var i;
@@ -256,6 +266,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
         },
 
         function getMorayService(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Getting SDC\'s moray details from SAPI');
             self.sdcadm.sapi.listServices({
                 name: 'moray',
@@ -274,6 +288,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
         },
 
         function getMorayVms(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Getting SDC\'s moray vms from VMAPI');
             self.sdcadm.vmapi.listVms({
                 'tag.smartdc_role': 'moray',
@@ -288,6 +306,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
         },
 
         function getManateeService(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Getting SDC\'s manatee details from SAPI');
             self.sdcadm.sapi.listServices({
                 name: 'manatee',
@@ -306,6 +328,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
         },
 
         function getManateeVms(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Getting SDC\'s manatees vms from VMAPI');
             self.sdcadm.vmapi.listVms({
                 'tag.smartdc_role': 'manatee',
@@ -320,6 +346,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
         },
 
         function getShard(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Getting manatee shard status');
             var vm = manateeVms[0];
 
@@ -356,6 +386,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
         // Check manatee-adm version in order to take advantage of latest
         // available sub-commands if possible:
         function getManateeVersion(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.sdcadm.imgapi.getImage(manateeVms[0].image_uuid, {
             }, function (err, image) {
                 if (err) {
@@ -384,6 +418,9 @@ function do_ha_binder(subcmd, opts, args, cb) {
                 out.push(sprintf('Add instance "%s" in server %s',
                     c.inst.alias, c.inst.server));
             });
+
+            out.push('Update core VMs resolvers.');
+
             p(out.join('\n'));
             p('');
             if (opts.yes) {
@@ -456,6 +493,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
         },
 
         function freezeManatee(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Freezing manatee shard');
             common.manateeFreeze({
                 vm: manateeVms[0].uuid,
@@ -466,6 +507,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
         },
 
         function disableZkForBakup(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Disabling zookeeper for data backup');
             shared.disableRemoteSvc({
                 server: vms[0].server_uuid,
@@ -476,6 +521,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
         },
 
         function backupZookeeperData(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Creating backup of zookeeper data directory ' +
                     '(this may take some time)');
             common.execRemote({
@@ -499,6 +548,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
         },
 
         function enableZkAfterBakup(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Enabling zookeeper after data backup');
             shared.enableRemoteSvc({
                 server: vms[0].server_uuid,
@@ -509,6 +562,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
         },
 
         function copyZkBackupToWorkDir(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Copying backup of zookeeper data to: %s', wrkDir);
             var argv = [
                 '/opt/smartdc/bin/sdc-oneachnode',
@@ -554,6 +611,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
         },
 
         function renameZkBackup(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             var fname = path.join(wrkDir,
                     util.format('zookeeper-%s.tgz', stamp));
             self.progress('Moving backup of zookeeper data to: %s', fname);
@@ -561,8 +622,9 @@ function do_ha_binder(subcmd, opts, args, cb) {
         },
 
         function createBinderInstances(_, next) {
-            if (instances && instances.length === (opts.members + 1)) {
-                return next();
+            if (!willCreateInsts) {
+                next();
+                return;
             }
 
             vasync.forEachPipeline({
@@ -602,6 +664,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
         },
 
         function hupHermes(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             svcadm.restartHermes({
                 sdcadm: self.sdcadm,
                 log: self.log,
@@ -609,24 +675,19 @@ function do_ha_binder(subcmd, opts, args, cb) {
             }, next);
         },
 
-        function getBinderInstancesAfterCreation(_, next) {
-            if (instances && instances.length === opts.members) {
-                return next();
-            }
-            self.progress('Getting SDC\'s binder instances from SAPI');
+        function getBinderInstancesAfterCreation(ctx, next) {
             self.sdcadm.sapi.listInstances({
                 service_uuid: svc.uuid
             }, function (instErr, insts) {
                 if (instErr) {
                     return next(instErr);
                 }
-                instances = insts;
+                ctx.binderInsts = instances = insts;
                 return next();
             });
         },
 
-        function getBinderVmsAfterCreation(_, next) {
-            self.progress('Getting SDC\'s binder vms from VMAPI');
+        function getBinderVmsAfterCreation(ctx, next) {
             self.sdcadm.vmapi.listVms({
                 'tag.smartdc_role': 'binder',
                 state: 'running'
@@ -639,12 +700,16 @@ function do_ha_binder(subcmd, opts, args, cb) {
                         newVms.push(vm);
                     }
                 });
-                vms = vms_;
+                ctx.binderVms = vms = vms_;
                 return next();
             });
         },
 
         function disableZkIntoNewInsts(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Disabling zookeeper into new instances');
             vasync.forEachParallel({
                 inputs: newVms,
@@ -660,6 +725,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
         },
         // rm -Rf /zookeeper/zookeeper/version-2 into the new binders
         function removeZkDataFromNewInsts(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Clearing zookeeper data into new instances');
             vasync.forEachParallel({
                 inputs: newVms,
@@ -685,6 +754,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
         },
         // Copy data from binder0 backup into the binder instances
         function copyZkDataIntoNewInsts(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Copying zookeeper data into new instances');
             var fname = path.join(wrkDir,
                     util.format('zookeeper-%s.tgz', stamp));
@@ -738,6 +811,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
         },
         // Untar data from binder0 into the new binder instances
         function untarZkDataIntoNewInsts(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Extracting zookeeper data into new instances ' +
                     '(may take some time)');
             vasync.forEachParallel({
@@ -766,6 +843,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
         },
         // enable zookeeper into the new binder instances
         function enableZkIntoNewInsts(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Enabling zookeeper into new instances');
             vasync.forEachParallel({
                 inputs: newVms,
@@ -785,6 +866,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
         // to make these instances to join the same zookeeper ensemble.
 
         function prepareClusterPayload(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             vms.forEach(function (vm) {
                 var instance = instances.filter(function (i) {
                     return (i.uuid === vm.uuid);
@@ -804,6 +889,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
         },
 
         function cfgBinderService(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Updating Binder service config in SAPI');
             self.sdcadm.sapi.updateApplication(app.uuid, {
                 metadata: {
@@ -819,6 +908,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
 
         // Set ZK_SERVERS, not ZK_HA_SERVERS
         function cfgMoraySvc(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Updating Moray service config in SAPI');
             self.sdcadm.sapi.updateService(moraySvc.uuid, {
                 metadata: {
@@ -834,6 +927,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
 
         // Set ZK_SERVERS, not ZK_HA_SERVERS
         function cfgManateeSvc(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Updating Manatee service config in SAPI');
             self.sdcadm.sapi.updateService(manateeSvc.uuid, {
                 metadata: {
@@ -849,6 +946,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
 
         // Call config-agent sync for all the binder VMs
         function callConfigAgentSyncForAllBinders(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Reloading config for all the binder VMs');
             vasync.forEachParallel({
                 inputs: vms,
@@ -862,39 +963,48 @@ function do_ha_binder(subcmd, opts, args, cb) {
             }, next);
         },
 
-        function waitForZkClusterOk(_, next) {
-            self.progress('Waiting for ZK cluster to reach a steady state');
-            var ips = vms.map(function (vm) {
+        function waitForZkClusterOk(ctx, next) {
+            ctx.ips = vms.map(function (vm) {
                 return (vm.nics[0].ip);
             });
 
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
+
+            self.progress('Waiting for ZK cluster to reach a steady state');
+
+
             shared.wait4ZkOk({
-                ips: ips,
+                ips: ctx.ips,
                 log: self.sdcadm.log
             }, next);
         },
 
-        function checkAllInstancesJoinedZkCluster(_, next) {
+        function checkAllInstancesJoinedZkCluster(ctx, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Waiting for binder instances to join ZK cluster');
-            var ips = vms.map(function (vm) {
-                return (vm.nics[0].ip);
-            });
 
             shared.wait4ZkCluster({
-                ips: ips,
+                ips: ctx.ips,
                 log: self.sdcadm.log
             }, next);
         },
 
         // Now that we've added the binder, wouldn't it be the leader always?:
-        function getZkLeaderIP(_, next) {
+        function getZkLeaderIP(ctx, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Getting ZK leader IP');
-            var ips = vms.map(function (vm) {
-                return (vm.nics[0].ip);
-            });
 
             shared.getZkLeaderIP({
-                ips: ips,
+                ips: ctx.ips,
                 log: self.sdcadm.log
             }, function (err, ip) {
                 if (err) {
@@ -907,6 +1017,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
 
         // Call config-agent sync for all the manatee VMs
         function callConfigAgentSyncForAllManatees(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Reloading config for all the manatee VMs');
             vasync.forEachParallel({
                 inputs: manateeVms,
@@ -923,6 +1037,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
         // HUP Manatee (Already waits for manatee shard to
         // reach the desired status):
         function disableManatee(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             shared.disableManateeSitter({
                 progress: self.progress,
                 log: self.sdcadm.log,
@@ -933,6 +1051,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
         },
 
         function enableManatee(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             shared.enableManateeSitter({
                 progress: self.progress,
                 log: self.sdcadm.log,
@@ -944,6 +1066,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
 
         // Call config-agent sync for all the moray VMs
         function callConfigAgentSyncForAllMorays(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Reloading config for all the moray VMs');
             vasync.forEachParallel({
                 inputs: morayVms,
@@ -959,6 +1085,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
 
         // HUP morays:
         function restartMorays(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Restarting moray services');
             vasync.forEachParallel({
                 inputs: morayVms,
@@ -979,6 +1109,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
         },
 
         function wait4Morays(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Waiting for moray services to be up into' +
                     ' every moray instance');
             shared.wait4Morays({
@@ -988,6 +1122,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
         },
 
         function unfreezeManatee(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Unfreezing manatee shard');
             common.manateeAdmRemote({
                 server: manateeVms[0].server_uuid,
@@ -1007,6 +1145,10 @@ function do_ha_binder(subcmd, opts, args, cb) {
         },
 
         function clearDataBackupFromBinderVm(_, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
             self.progress('Removing zookeeper data backup from %s',
                     vms[0].uuid);
 
@@ -1027,7 +1169,75 @@ function do_ha_binder(subcmd, opts, args, cb) {
                 }
                 return next();
             });
+        },
+
+        function addNewBinderIPsToAdminNetworkResolvers(ctx, next) {
+            if (!willCreateInsts) {
+                next();
+                return;
+            }
+            self.progress('Adding new binder IPs to admin network resolvers');
+            self.sdcadm.napi.listNetworks({
+                name: 'admin',
+                owner_uuid: self.sdcadm.config.ufds_admin_uuid
+            }, function (err, nets) {
+                if (err) {
+                    next(new errors.SDCClientError(err, 'napi'));
+                    return;
+                }
+
+                if (!nets.length) {
+                    next(new errors.InternalError(
+                        'Cannot find Admin network in NAPI'));
+                    return;
+                }
+
+                ctx.admin_network_uuid = nets[0].uuid;
+
+                self.sdcadm.napi.updateNetwork(ctx.admin_network_uuid, {
+                    resolvers: ctx.ips
+                }, function (err2) {
+                    if (err2) {
+                        next(new errors.SDCClientError(err2, 'napi'));
+                        return;
+                    }
+                    next();
+                });
+            });
+        },
+
+        function updateCoreVmsResolvers(ctx, next) {
+            self.progress('Updating core SDC VMs resolvers');
+            ctx.binderIps = ctx.ips;
+            steps.checkCoreVmInstancesResolvers({
+                sdcadm: self.sdcadm,
+                progress: self.progress,
+                log: self.log,
+                ctx: ctx
+            }, function (err, resolvers) {
+                if (err) {
+                    next(err);
+                    return;
+                }
+
+                Object.keys(resolvers).forEach(function (r) {
+                    self.progress(
+                        'VM %s resolvers need to be updated from [%s] to [%s]',
+                        r, resolvers[r].current.join(', '),
+                        resolvers[r].expected.join(', '));
+                });
+
+                steps.updateCoreVmsResolvers({
+                    sdcadm: self.sdcadm,
+                    progress: self.progress,
+                    log: self.log,
+                    fixableResolvers: resolvers
+                }, function (updateError) {
+                    next(updateError);
+                });
+            });
         }
+
     ]}, function (err) {
         // Add error to history in case the update execution failed:
         if (err) {
diff --git a/lib/procedures/shared.js b/lib/procedures/shared.js
index bc4f2a7..ffe4b71 100644
--- a/lib/procedures/shared.js
+++ b/lib/procedures/shared.js
@@ -1856,6 +1856,79 @@ function wait4Morays(opts, cb) {
     });
 }
 
+
+/**
+ * Wait for the given job_uuid to be finished.
+ *
+ * In case of failure this function will return an error
+ *
+ * @param {Object} opts: All the following options are required:
+ *      @param {Object} opts.job_uuid: Job UUID
+ *      @param {Object} opts.sdcadm: sdcadm object instance
+ *
+ * @param {Function} cb: Callback of the form f(err);
+ */
+function waitForJob(opts, cb) {
+    assert.object(opts, 'opts');
+    assert.string(opts.job_uuid, 'opts.job_uuid');
+    assert.object(opts.sdcadm, 'opts.sdcadm');
+    assert.func(cb, 'cb');
+
+    function pollJob(job_uuid, _cb) {
+        var attempts = 0;
+        var errs = 0;
+
+        var timeout = 5000;  // 5 seconds
+        var limit = 720;     // 1 hour
+
+        var poll = function () {
+            opts.sdcadm.wfapi.getJob(job_uuid, function (err, job) {
+                attempts++;
+
+                if (err) {
+                    errs++;
+                    if (errs >= 5) {
+                        _cb(err);
+                        return;
+                    } else {
+                        setTimeout(poll, timeout);
+                        return;
+                    }
+                }
+
+                if (job && (job.execution === 'succeeded' ||
+                    job.execution === 'failed')) {
+                    _cb(null, job);
+                    return;
+                } else if (attempts > limit) {
+                    _cb(new Error('polling for import job timed out'), job);
+                    return;
+                }
+
+                setTimeout(poll, timeout);
+                return;
+            });
+        };
+
+        poll();
+    }
+
+    pollJob(opts.job_uuid, function (err, job) {
+        if (err) {
+            cb(err);
+            return;
+        }
+        var result = job.chain_results.pop();
+        if (result.error) {
+            var errmsg = result.error.message || JSON.stringify(result.error);
+            cb(new Error(errmsg));
+            return;
+        } else {
+            cb();
+        }
+    });
+}
+
 // --- exports
 
 module.exports = {
@@ -1896,6 +1969,7 @@ module.exports = {
     getShardState: getShardState,
     wait4Morays: wait4Morays,
     manateeSitterSvcStatus: manateeSitterSvcStatus,
-    waitForManatee: waitForManatee
+    waitForManatee: waitForManatee,
+    waitForJob: waitForJob
 };
 // vim: set softtabstop=4 shiftwidth=4:
diff --git a/lib/steps/binder.js b/lib/steps/binder.js
new file mode 100644
index 0000000..1c7bcf9
--- /dev/null
+++ b/lib/steps/binder.js
@@ -0,0 +1,341 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2017 Joyent, Inc.
+ */
+
+/*
+ * Steps for checking all the "core" VMs for the correct resolvers.
+ */
+
+var util = require('util');
+
+var assert = require('assert-plus');
+var vasync = require('vasync');
+
+var errors = require('../errors');
+var shared = require('../procedures/shared');
+
+/**
+ * Compare current resolvers value for 'core' VMs with expected value
+ * from 'binder' instances, and return an object containing only those
+ * VMs which need an update.
+ *
+ * Callback function will be called with the aforementioned object as
+ * its second argument, (the first argument will be any error which could
+ * happen during the process).
+ *
+ * Format for this object is:
+ *
+ * {
+ *      VM_UUID: {
+ *          expected: [resolvers],
+ *          current: [resolvers]
+ *      },
+ *      VM_UUID_2: ...
+ * }
+ *
+ */
+function checkCoreVmInstancesResolvers(arg, cb) {
+    assert.object(arg, 'arg');
+    assert.func(arg.progress, 'arg.progress');
+    assert.object(arg.log, 'arg.log');
+    assert.object(arg.sdcadm, 'arg.sdcadm');
+    assert.optionalObject(arg.ctx, 'arg.ctx');
+    assert.optionalBool(arg.adminOnly, 'arg.adminOnly');
+    assert.func(cb, 'cb');
+
+    var sdcadm = arg.sdcadm;
+    var context = arg.ctx || {};
+    var app = sdcadm.sdc;
+    context.adminOnly = arg.adminOnly || false;
+
+    vasync.pipeline({
+        arg: context,
+        funcs: [
+            function getBinderSvc(ctx, next) {
+                if (ctx.binderSvc) {
+                    next();
+                    return;
+                }
+                sdcadm.sapi.listServices({
+                    name: 'binder',
+                    application_uuid: app.uuid
+                }, function (svcErr, svcs) {
+                    if (svcErr) {
+                        next(svcErr);
+                        return;
+                    }
+                    if (svcs.length) {
+                        ctx.binderSvc = svcs[0];
+                    }
+                    next();
+                });
+            },
+
+            function getBinderInsts(ctx, next) {
+                if (ctx.binderInsts) {
+                    next();
+                    return;
+                }
+                sdcadm.sapi.listInstances({
+                    service_uuid: ctx.binderSvc.uuid
+                }, function (instErr, insts) {
+                    if (instErr) {
+                        next(instErr);
+                        return;
+                    }
+                    ctx.binderInsts = insts;
+                    next();
+                });
+            },
+
+            function getBinderVms(ctx, next) {
+                if (ctx.binderVms && ctx.binderIps) {
+                    next();
+                    return;
+                }
+                sdcadm.vmapi.listVms({
+                    'tag.smartdc_role': 'binder',
+                    state: 'running'
+                }, function (vmsErr, vms) {
+                    if (vmsErr) {
+                        next(vmsErr);
+                        return;
+                    }
+                    ctx.binderVms = vms;
+                    // Binder instances have only admin Ips:
+                    ctx.binderIps = vms.map(function (vm) {
+                        return (vm.nics[0].ip);
+                    });
+                    next();
+                });
+            },
+
+            function getExternalNetworkResolvers(ctx, next) {
+                if (ctx.externalNetworkResolvers || ctx.adminOnly) {
+                    next();
+                    return;
+                }
+                sdcadm.napi.listNetworks({
+                    name: 'external'
+                }, function (err, nets) {
+                    if (err) {
+                        next(new errors.SDCClientError(
+                            err, 'napi'));
+                        return;
+                    }
+
+                    if (!nets.length) {
+                        next(new errors.InternalError(new Error(
+                            'Cannot find external network in NAPI')));
+                        return;
+                    }
+
+                    ctx.externalNetworkResolvers = nets[0].resolvers;
+                    next();
+                });
+            },
+
+            function getSdcVmServices(ctx, next) {
+                if (ctx.coreSvcs) {
+                    next();
+                    return;
+                }
+                sdcadm.getServices({
+                    type: 'vm'
+                }, function (svcsErr, svcs) {
+                    if (svcsErr) {
+                        next(svcsErr);
+                        return;
+                    }
+                    ctx.coreSvcs = svcs.map(function (s) {
+                        return s.uuid;
+                    }).filter(function (x) {
+                        return (x !== undefined && x !== null);
+                    });
+                    next();
+                });
+            },
+
+            function getSdcSapiVmInstances(ctx, next) {
+                if (ctx.coreInstances) {
+                    next();
+                    return;
+                }
+                vasync.forEachPipeline({
+                    inputs: ctx.coreSvcs,
+                    func: function getSvcInstances(service, nextSvc) {
+                        if (!ctx.coreInstances) {
+                            ctx.coreInstances = [];
+                        }
+
+                        sdcadm.sapi.listInstances({
+                            service_uuid: service
+                        }, function (sapiErr, insts) {
+                            if (sapiErr) {
+                                nextSvc(new errors.SDCClientError(
+                                    sapiErr, 'sapi'));
+                                return;
+                            }
+                            ctx.coreInstances = ctx.coreInstances.concat(
+                                insts.map(function (ins) {
+                                    return ins.uuid;
+                                })
+                            );
+                            nextSvc();
+                        });
+                    }
+                }, next);
+            },
+
+            function getSdcCoreVms(ctx, next) {
+                if (ctx.coreVms) {
+                    next();
+                    return;
+                }
+
+                vasync.forEachPipeline({
+                    inputs: ctx.coreInstances,
+                    func: function getInstanceVm(inst, nextInst) {
+                        if (!ctx.coreVms) {
+                            ctx.coreVms = [];
+                        }
+
+                        sdcadm.vmapi.getVm({
+                            uuid: inst
+                        }, function (vmapiErr, vm) {
+                            if (vmapiErr) {
+                                nextInst(new errors.SDCClientError(
+                                    vmapiErr, 'vmapi'));
+                                return;
+                            }
+                            ctx.coreVms.push(vm);
+                            nextInst();
+                        });
+                    }
+                }, next);
+
+            },
+
+            function checkVmResolvers(ctx, next) {
+                ctx.fixableResolvers = {};
+
+                vasync.forEachParallel({
+                    inputs: ctx.coreVms,
+                    func: function checkResolvers(vm, nextVm) {
+                        // Binder VMs and eventually, anything we want to
+                        // avoid resolvers:
+                        if (vm.resolvers.length === 0 &&
+                            vm.internal_metadata &&
+                            (vm.internal_metadata.set_resolvers === false)) {
+                            nextVm();
+                            return;
+                        }
+
+                        var hasAdminNic = false;
+                        var resolvers = [];
+                        vm.nics.forEach(function (nic) {
+                            if (nic.nic_tag === 'admin') {
+                                resolvers = resolvers.concat(
+                                    ctx.binderIps);
+                                hasAdminNic = true;
+                            } else if (nic.nic_tag === 'external') {
+                                resolvers = resolvers.concat(
+                                    ctx.externalNetworkResolvers);
+                            }
+                        });
+
+                        if (ctx.adminOnly && !hasAdminNic) {
+                            nextVm();
+                            return;
+                        }
+
+                        // Resolvers must match exactly on the same order:
+                        var fixResolvers = false;
+                        fixResolvers = resolvers.some(function (el, id) {
+                            return (vm.resolvers[id] !== el);
+                        });
+                        if (!fixResolvers) {
+                            fixResolvers = vm.resolvers.some(function (el, id) {
+                                return (resolvers[id] !== el);
+                            });
+                        }
+                        if (fixResolvers) {
+                            ctx.fixableResolvers[vm.uuid] = {
+                                current: vm.resolvers,
+                                expected: resolvers
+                            };
+                        }
+                        nextVm();
+                    }
+                }, next);
+            }
+        ]
+    }, function (pipeErr, pipeRes) {
+        cb(pipeErr, context.fixableResolvers);
+    });
+}
+
+/**
+ * The expected format for 'arg.fixableResolvers' is the value
+ * returnted by checkCoreVmInstancesResolvers.
+ */
+function updateCoreVmsResolvers(arg, cb) {
+    assert.object(arg, 'arg');
+    assert.func(arg.progress, 'arg.progress');
+    assert.object(arg.log, 'arg.log');
+    assert.object(arg.sdcadm, 'arg.sdcadm');
+    assert.object(arg.fixableResolvers, 'arg.fixableResolvers');
+    assert.func(cb, 'cb');
+
+    var sdcadm = arg.sdcadm;
+    var log = arg.log.child({ component: 'updateCoreVmsResolvers'}, true);
+
+    vasync.forEachPipeline({
+        inputs: Object.keys(arg.fixableResolvers),
+        func: function updateVmResolvers(vm, nextVm) {
+            log.debug({
+                vm: vm,
+                resolvers: arg.fixableResolvers[vm].expected
+            }, 'Updating VM resolvers');
+
+            sdcadm.vmapi.updateVm({
+                uuid: vm,
+                payload: {
+                    resolvers: arg.fixableResolvers[vm].expected
+                }
+            }, function (vmapiErr, vmapiRes) {
+                if (vmapiErr) {
+                    nextVm(new errors.SDCClientError(vmapiErr, 'vmapi'));
+                    return;
+                }
+
+                log.debug(vmapiRes, 'waiting for VM job');
+
+                shared.waitForJob({
+                    sdcadm: sdcadm,
+                    job_uuid: vmapiRes.job_uuid
+                }, function (jobErr) {
+                    if (jobErr) {
+                        nextVm(new errors.SDCClientError(jobErr, 'wfapi'));
+                        return;
+                    }
+                    nextVm();
+                });
+            });
+        }
+    }, cb);
+}
+//---- exports
+
+module.exports = {
+    checkCoreVmInstancesResolvers: checkCoreVmInstancesResolvers,
+    updateCoreVmsResolvers: updateCoreVmsResolvers
+};
+
+// vim: set softtabstop=4 shiftwidth=4:
diff --git a/lib/steps/index.js b/lib/steps/index.js
index 801697d..7fef6a5 100644
--- a/lib/steps/index.js
+++ b/lib/steps/index.js
@@ -25,7 +25,9 @@ module.exports = {};
     'no-rabbit',
     'update_vm_size',
     'sapi',
-    'servers'
+    'servers',
+    'agent-services',
+    'binder'
 ].forEach(function (modName) {
     var mod = require('./' + modName);
     Object.keys(mod).forEach(function (symbol) {
-- 
2.21.0

