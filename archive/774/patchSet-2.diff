From ad394e668823ee5324a7528e6a92494717047b43 Mon Sep 17 00:00:00 2001
From: Pedro Palazon Candel <pedro@joyent.com>
Date: Tue, 25 Oct 2016 12:08:33 +0200
Subject: [PATCH] TOOLS-1579 sdcadm post-setup ha-binder should update core
 zones resolvers

---
 lib/post-setup/ha-binder.js | 194 +++++++++++++++++++++++++++++++++---
 lib/procedures/shared.js    |  76 +++++++++++++-
 2 files changed, 256 insertions(+), 14 deletions(-)

diff --git a/lib/post-setup/ha-binder.js b/lib/post-setup/ha-binder.js
index 8443b17..7a260b6 100644
--- a/lib/post-setup/ha-binder.js
+++ b/lib/post-setup/ha-binder.js
@@ -862,39 +862,33 @@ function do_ha_binder(subcmd, opts, args, cb) {
             }, next);
         },
 
-        function waitForZkClusterOk(_, next) {
+        function waitForZkClusterOk(ctx, next) {
             self.progress('Waiting for ZK cluster to reach a steady state');
-            var ips = vms.map(function (vm) {
+            ctx.ips = vms.map(function (vm) {
                 return (vm.nics[0].ip);
             });
 
             shared.wait4ZkOk({
-                ips: ips,
+                ips: ctx.ips,
                 log: self.sdcadm.log
             }, next);
         },
 
-        function checkAllInstancesJoinedZkCluster(_, next) {
+        function checkAllInstancesJoinedZkCluster(ctx, next) {
             self.progress('Waiting for binder instances to join ZK cluster');
-            var ips = vms.map(function (vm) {
-                return (vm.nics[0].ip);
-            });
 
             shared.wait4ZkCluster({
-                ips: ips,
+                ips: ctx.ips,
                 log: self.sdcadm.log
             }, next);
         },
 
         // Now that we've added the binder, wouldn't it be the leader always?:
-        function getZkLeaderIP(_, next) {
+        function getZkLeaderIP(ctx, next) {
             self.progress('Getting ZK leader IP');
-            var ips = vms.map(function (vm) {
-                return (vm.nics[0].ip);
-            });
 
             shared.getZkLeaderIP({
-                ips: ips,
+                ips: ctx.ips,
                 log: self.sdcadm.log
             }, function (err, ip) {
                 if (err) {
@@ -1027,7 +1021,181 @@ function do_ha_binder(subcmd, opts, args, cb) {
                 }
                 return next();
             });
+        },
+
+        function addNewBinderIPsToAdminNetworkResolvers(ctx, next) {
+            self.progress('Adding new binder IPs to admin network resolvers');
+            self.sdcadm.napi.listNetworks({
+                name: 'admin',
+                owner_uuid: self.sdcadm.config.ufds_admin_uuid
+            }, function (err, nets) {
+                if (err) {
+                    next(new errors.SDCClientError(err, 'napi'));
+                    return;
+                }
+
+                if (!nets.length) {
+                    next(new errors.InternalError(
+                        'Cannot find Admin network in NAPI'));
+                    return;
+                }
+
+                ctx.admin_network_uuid = nets[0].uuid;
+
+                self.sdcadm.napi.updateNetwork(ctx.admin_network_uuid, {
+                    resolvers: ctx.ips
+                }, function (err2) {
+                    if (err2) {
+                        next(new errors.SDCClientError(err2, 'napi'));
+                        return;
+                    }
+                    next();
+                });
+            });
+        },
+
+        function updateCoreVmsResolvers(ctx, next) {
+            self.progress('Updating core SDC VMs resolvers');
+            vasync.pipeline({
+                arg: {
+                    ips: ctx.ips
+                },
+                funcs: [
+                    function getExternalNetwork(context, nextFun) {
+                        self.sdcadm.napi.listNetworks({
+                            name: 'external'
+                        }, function (err, nets) {
+                            if (err) {
+                                nextFun(new errors.SDCClientError(
+                                    err, 'napi'));
+                                return;
+                            }
+
+                            if (!nets.length) {
+                                nextFun(new errors.InternalError(new Error(
+                                    'Cannot find external network in NAPI')));
+                                return;
+                            }
+
+                            context.external_net_resolvers = nets[0].resolvers;
+                            nextFun();
+                        });
+                    },
+
+                    function getSdcVmServices(context, nextFun) {
+                        self.sdcadm.getServices({
+                            type: 'vm'
+                        }, function (svcsErr, svcs) {
+                            if (svcsErr) {
+                                nextFun(svcsErr);
+                                return;
+                            }
+                            context.svcUuids = svcs.map(function (s) {
+                                return s.uuid;
+                            }).filter(function (x) {
+                                return (x !== undefined && x !== null);
+                            });
+                            nextFun();
+                        });
+                    },
+
+                    function getSdcSapiVmInstances(context, nextFun) {
+                        vasync.forEachPipeline({
+                            inputs: context.svcUuids,
+                            func: function getSvcInstances(service, nextSvc) {
+                                if (!context.coreInstances) {
+                                    context.coreInstances = [];
+                                }
+
+                                self.sdcadm.sapi.listInstances({
+                                    service_uuid: service
+                                }, function (sapiErr, insts) {
+                                    if (sapiErr) {
+                                        nextSvc(new errors.SDCClientError(
+                                            sapiErr, 'sapi'));
+                                        return;
+                                    }
+                                    context.coreInstances =
+                                        context.coreInstances.concat(insts.map(
+                                        function (ins) {
+                                        return ins.uuid;
+                                    }));
+                                    nextSvc();
+                                });
+                            }
+                        }, nextFun);
+                    },
+
+                    function getSdcCoreVms(context, nextFun) {
+                        vasync.forEachPipeline({
+                            inputs: context.coreInstances,
+                            func: function getInstanceVm(inst, nextInst) {
+                                if (!context.coreVms) {
+                                    context.coreVms = [];
+                                }
+
+                                self.sdcadm.vmapi.getVm({
+                                    uuid: inst
+                                }, function (vmapiErr, vm) {
+                                    if (vmapiErr) {
+                                        nextInst(new errors.SDCClientError(
+                                            vmapiErr, 'vmapi'));
+                                        return;
+                                    }
+                                    context.coreVms.push(vm);
+                                    nextInst();
+                                });
+                            }
+                        }, nextFun);
+                    },
+
+                    function updateSdcCoreVmsResolvers(context, nextFun) {
+                        vasync.forEachPipeline({
+                            inputs: context.coreVms,
+                            func: function updateVmResolvers(vm, nextVm) {
+                                var resolvers = [];
+                                vm.nics.forEach(function (nic) {
+                                    if (nic.nic_tag === 'admin') {
+                                        resolvers = resolvers.concat(
+                                            context.ips);
+                                    } else if (nic.nic_tag === 'external') {
+                                        resolvers = resolvers.concat(
+                                            context.external_net_resolvers);
+                                    }
+                                });
+
+                                self.sdcadm.vmapi.updateVm({
+                                    uuid: vm.uuid,
+                                    payload: {
+                                        resolvers: resolvers
+                                    }
+                                }, function (vmapiErr, vmapiRes) {
+                                    if (vmapiErr) {
+                                        nextVm(new errors.SDCClientError(
+                                            vmapiErr, 'vmapi'));
+                                        return;
+                                    }
+                                    self.log.debug(vmapiRes,
+                                        'waiting for VM job');
+                                    shared.waitForJob({
+                                        sdcadm: self.sdcadm,
+                                        job_uuid: vmapiRes.job_uuid
+                                    }, function (jobErr) {
+                                        if (jobErr) {
+                                            nextVm(new errors.SDCClientError(
+                                                jobErr, 'wfapi'));
+                                            return;
+                                        }
+                                        nextVm();
+                                    });
+                                });
+                            }
+                        }, nextFun);
+                    }
+                ]
+            }, next);
         }
+
     ]}, function (err) {
         // Add error to history in case the update execution failed:
         if (err) {
diff --git a/lib/procedures/shared.js b/lib/procedures/shared.js
index e4c34d0..c07c42e 100644
--- a/lib/procedures/shared.js
+++ b/lib/procedures/shared.js
@@ -1873,6 +1873,79 @@ function wait4Morays(opts, cb) {
     });
 }
 
+
+/**
+ * Wait for the given job_uuid to be finished.
+ *
+ * In case of failure this function will return an error
+ *
+ * @param {Object} opts: All the following options are required:
+ *      @param {Object} opts.job_uuid: Job UUID
+ *      @param {Object} opts.sdcadm: sdcadm object instance
+ *
+ * @param {Function} cb: Callback of the form f(err);
+ */
+function waitForJob(opts, cb) {
+    assert.object(opts, 'opts');
+    assert.string(opts.job_uuid, 'opts.job_uuid');
+    assert.object(opts.sdcadm, 'opts.sdcadm');
+    assert.func(cb, 'cb');
+
+    function pollJob(job_uuid, _cb) {
+        var attempts = 0;
+        var errs = 0;
+
+        var timeout = 5000;  // 5 seconds
+        var limit = 720;     // 1 hour
+
+        var poll = function () {
+            opts.sdcadm.wfapi.getJob(job_uuid, function (err, job) {
+                attempts++;
+
+                if (err) {
+                    errs++;
+                    if (errs >= 5) {
+                        _cb(err);
+                        return;
+                    } else {
+                        setTimeout(poll, timeout);
+                        return;
+                    }
+                }
+
+                if (job && (job.execution === 'succeeded' ||
+                    job.execution === 'failed')) {
+                    _cb(null, job);
+                    return;
+                } else if (attempts > limit) {
+                    _cb(new Error('polling for import job timed out'), job);
+                    return;
+                }
+
+                setTimeout(poll, timeout);
+                return;
+            });
+        };
+
+        poll();
+    }
+
+    pollJob(opts.job_uuid, function (err, job) {
+        if (err) {
+            cb(err);
+            return;
+        }
+        var result = job.chain_results.pop();
+        if (result.error) {
+            var errmsg = result.error.message || JSON.stringify(result.error);
+            cb(new Error(errmsg));
+            return;
+        } else {
+            cb();
+        }
+    });
+}
+
 // --- exports
 
 module.exports = {
@@ -1913,6 +1986,7 @@ module.exports = {
     getShardState: getShardState,
     wait4Morays: wait4Morays,
     manateeSitterSvcStatus: manateeSitterSvcStatus,
-    waitForManatee: waitForManatee
+    waitForManatee: waitForManatee,
+    waitForJob: waitForJob
 };
 // vim: set softtabstop=4 shiftwidth=4:
-- 
2.21.0

