From 26398ea6b09d04cc2e72b4d7444096bf1d8da0e8 Mon Sep 17 00:00:00 2001
From: Jerry Jelinek <jerry.jelinek@joyent.com>
Date: Wed, 18 Jan 2017 14:01:44 +0000
Subject: [PATCH] OS-5900 io_getevents doesn't block when it should

---
 usr/src/lib/brand/lx/lx_brand/common/aio.c | 18 ++++++++++++++++--
 1 file changed, 16 insertions(+), 2 deletions(-)

diff --git a/usr/src/lib/brand/lx/lx_brand/common/aio.c b/usr/src/lib/brand/lx/lx_brand/common/aio.c
index 1945d0004b..e757c5426b 100644
--- a/usr/src/lib/brand/lx/lx_brand/common/aio.c
+++ b/usr/src/lib/brand/lx/lx_brand/common/aio.c
@@ -294,13 +294,14 @@ lx_io_submit(lx_aio_context_t cid, long nr, uintptr_t **bpp)
 
 long
 lx_io_getevents(lx_aio_context_t cid, long min_nr, long nr,
-    lx_io_event_t *events, struct timespec *timeout)
+    lx_io_event_t *events, struct timespec *timeoutp)
 {
 	port_event_t *list;
 	lx_io_event_t *out;
 	uint_t nget, max;
 	int rval, i, err;
 	lx_aio_ctxt_t *ctx = (lx_aio_ctxt_t *)cid;
+	struct timespec timeout, *tp;
 
 	if (INVALID_CTX(ctx))
 		return (-EINVAL);
@@ -312,6 +313,19 @@ lx_io_getevents(lx_aio_context_t cid, long min_nr, long nr,
 	if (events == NULL)
 		return (-EFAULT);
 
+	if (timeoutp == NULL) {
+		tp = NULL;
+	} else if (uucopy(timeoutp, &timeout, sizeof (struct timespec)) != 0) {
+		return (-EFAULT);
+	} else {
+		/* A timeout of 0:0 should behave like a NULL timeout */
+		if (timeout.tv_sec == 0 && timeout.tv_nsec == 0) {
+			tp = NULL;
+		} else {
+			tp = &timeout;
+		}
+	}
+
 	/*
 	 * We can't return ENOMEM from this syscall so EINTR is the closest
 	 * we can come.
@@ -347,7 +361,7 @@ lx_io_getevents(lx_aio_context_t cid, long min_nr, long nr,
 	ctx->lxaio_waiters++;
 	mutex_exit(&ctx->lxaio_lock);
 
-	rval = port_getn(ctx->lxaio_port, list, max, &nget, timeout);
+	rval = port_getn(ctx->lxaio_port, list, max, &nget, tp);
 	err = errno;
 
 	mutex_enter(&ctx->lxaio_lock);
-- 
2.21.0

