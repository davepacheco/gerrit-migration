commit db0d12450c3f31b86e93791c057f073362595388 (refs/changes/34/934/3)
Author: Richard Bradley <richard.bradley@joyent.com>
Date:   2016-12-05T16:19:23+00:00 (2 years, 10 months ago)
    
    MANATEE-260 `manatee-adm rebuild` loops without feedback when postgres fails to start
    MANATEE-261 `manatee-adm rebuild` claims it was successful when it was not
    MANATEE-262 manatee-adm hangs at spinner even after it appears to have been successful

diff --git a/lib/adm.js b/lib/adm.js
index 2056497..e16c7f9 100644
--- a/lib/adm.js
+++ b/lib/adm.js
@@ -1460,7 +1460,12 @@ function rebuild(opts, cb) {
             checkZkActive();
         },
         function _deleteDataDir(_, _cb) {
-            console.error('removing zfs dataset');
+            console.error('Attempting to remove ZFS dataset\'s contents');
+            /*
+             * If sitter hasn't been started since uptime, this directory
+             * will not be the dataset we expect. This isn't fatal, though,
+             * as sitter is able to cope with this scenario.
+             */
             var cmd = 'rm -rf ' + _.config.postgresMgrCfg.dataDir + '/*';
             exec(cmd, _cb);
         },
@@ -1472,11 +1477,16 @@ function rebuild(opts, cb) {
             _putState(_, _cb);
         },
         //This just lets the node recover "naturally"
-        function _restartSitter(_, _cb) {
-            console.error('enabling sitter');
-            exec('svcadm enable manatee-sitter', _cb);
+        function _enableSitter(_, _cb) {
+            console.error('Enabling sitter');
+            /*
+             * '-s' is used here so we'll block on starting the sitter
+             * service. This also means we'll catch the error and report
+             * it if for some reason it doesn't start
+             */
+            exec('svcadm enable -s manatee-sitter', _cb);
         },
-        function _checkZfsRecv(_, _cb) {
+        function _watchSitter(_, _cb) {
             _cb = once(_cb);
             var client = restify.createJsonClient({
                 url: 'http://' + _.config.ip + ':' +
@@ -1484,52 +1494,116 @@ function rebuild(opts, cb) {
                 version: '*'
             });
 
-            var bar;
-            var lastByte = 0;
             var waitCount = 0;
+            var lastByte = 0;
+            var restoreTry = 1;
+            var bar, restore, lastRestore;
 
-            process.stderr.write('Waiting for zfs recv  ');
-            function checkZfsStatus() {
-                client.get('/restore', function (err, req, res, obj) {
-                    if (err) {
-                        LOG.warn({err: err}, 'unable to query zfs status');
-                        // give the sitter 30s to start
-                        if (++waitCount > 30) {
-                            client.close();
-                            return _cb(err, 'unable to query zfs status');
-                        }
-                        setTimeout(checkZfsStatus, 1000);
-                        return;
-                    } else if (obj.restore && obj.restore.size) {
-                        if (obj.restore.done) {
-                            LOG.info('zfs receive is done');
+            process.stderr.write('Watching postgres startup  ');
+            function checkPostgresStatus() {
+                vasync.pipeline({ funcs: [
+                    _getClusterStates,
+                    _addPostgresStatus,
+                    function _getCurrentPeer(_cpCtx, _cpCb) {
+                        var thisPeer = null;
+                        _cpCtx.state[_.shard].async.forEach(function (peer) {
+                            if (peer.zoneId == _.config.zoneId) {
+                                thisPeer = peer;
+                            }
+                        });
+                        _.peer = thisPeer;
+                        _cpCb();
+                    },
+                    function _getRestoreStatus(_rsCtx, _rsCb) {
+                        client.get('/restore', function (err, req, res, obj) {
+                            if (err) {
+                                LOG.warn({err: err},
+                                    'unable to query zfs status');
+                                return _rsCb(err);
+                            }
+                            if (obj && obj.restore) {
+                                restore = obj.restore;
+                            }
+                            _rsCb();
+                        });
+                    }
+                ], arg: opts}, function (err) {
+                    if (restore) {
+                        /*
+                         * If the sitter SMF service starts but postgres
+                         * subsequently doesn't we'll see multiple restore
+                         * attempts. Here we check if we're in this kind of
+                         * loop and only retry a small number of times.
+                         */
+                        if (lastRestore && ('uuid' in lastRestore) &&
+                            lastRestore.uuid != restore.uuid) {
                             process.stderr.write('\n');
-                            client.close();
-                            return _cb();
+                            if (++restoreTry > 5) {
+                                return _cb(new Error('Postgres failed to ' +
+                                    'start after 5 tries. Check sitter logs.'));
+                            }
+                            process.stderr.write('Postgres failed to ' +
+                                'start; trying again (attempt ' + restoreTry +
+                                '/5)  ');
                         }
-                        if (!bar) {
-                            bar = new progbar.ProgressBar({
-                                filename: obj.restore.dataset,
-                                size: parseInt(obj.restore.size, 10)
-                            });
+
+                        if (!bar && !restore.done) {
+                            var barOpts = {
+                                filename: restore.dataset
+                            };
+                            if (restore.size) {
+                                barOpts.size = parseInt(restore.size, 10);
+                            } else {
+                                barOpts.nosize = true;
+                            }
+                            process.stderr.write('\n');
+                            bar = new progbar.ProgressBar(barOpts);
                         }
-                        if (obj.restore.completed) {
-                            var completed = parseInt(obj.restore.completed, 10);
+
+                        if (bar && restore.completed) {
+                            var completed = parseInt(restore.completed, 10);
                             var advance = completed - lastByte;
                             lastByte = completed;
                             bar.advance(advance);
                         }
-                        setTimeout(checkZfsStatus, 1000);
-                        return;
-                    } else {
+
+                        if (bar && restore.done) {
+                            bar.end();
+                            bar = lastByte = null;
+                            process.stderr.write('Restore done. Waiting ' +
+                                'for postgres to start  ');
+                        }
+
+                        lastRestore = restore;
+
+                    } else if (waitCount > 60) {
+                        /*
+                         * At this point no restore has taken place and
+                         * postgres hasn't started after roughly 60 seconds.
+                         * Something is likely wrong with postgres, so we error
+                         * here to prevent an unlimited spinner.
+                         */
+                        process.stderr.write('\n');
+                        return _cb(new Error('Postgres failed to start after ' +
+                            '60 seconds. Check sitter logs.'));
+                    }
+
+                    /*
+                     * Only move the spinner if there is no bar on the screen
+                     */
+                    if (!bar)
                         process.stderr.write('\b' + SPINNER[waitCount++ %
-                                             SPINNER.length]);
-                        setTimeout(checkZfsStatus, 1000);
-                        return;
+                            SPINNER.length]);
+
+                    if (_.peer && _.peer.online) {
+                        process.stderr.write('\n');
+                        return _cb();
+                    } else {
+                        return setTimeout(checkPostgresStatus, 1000);
                     }
                 });
             }
-            checkZfsStatus();
+            checkPostgresStatus();
         }
     ], arg: opts}, function (err, results) {
         _closeZkClient(opts);
