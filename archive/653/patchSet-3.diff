From 42b2165932794e4f975361a729820b6489103724 Mon Sep 17 00:00:00 2001
From: Alex Wilson <alex.wilson@joyent.com>
Date: Tue, 11 Oct 2016 16:51:18 -0700
Subject: [PATCH] joyent/node-cueball#36 want option to pre-seed Agent
 instances with domains Reviewed by: David Pacheco <dap@joyent.com>

---
 README.md    |   2 +
 lib/agent.js | 148 ++++++++++++++++++++++++++++-----------------------
 package.json |   2 +-
 3 files changed, 84 insertions(+), 68 deletions(-)

diff --git a/README.md b/README.md
index c52a596..059e582 100644
--- a/README.md
+++ b/README.md
@@ -75,6 +75,8 @@ Parameters
   - `log` -- optional Object, a `bunyan`-style logger to use
   - `spares` -- optional Number, number of spares wanted in the pool per host
   - `maximum` -- optional Number, maximum number of connections per host
+  - `initialDomains` -- optional Array of String, initial domains to create
+    connections to at startup (to pre-seed the Agent for quick user later)
   - `tcpKeepAliveInitialDelay` -- optional Number, if supplied, enable TCP
     level keep-alives with the given initial delay (in milliseconds)
   - `ping` -- optional String, URL path to use for health checking. Connection
diff --git a/lib/agent.js b/lib/agent.js
index a7ef997..65a8535 100644
--- a/lib/agent.js
+++ b/lib/agent.js
@@ -30,6 +30,8 @@ function CueBallAgent(options) {
 	mod_assert.string(options.protocol, 'options.protocol');
 	mod_assert.optionalArrayOfString(options.resolvers,
 	    'options.resolvers');
+	mod_assert.optionalArrayOfString(options.initialDomains,
+	    'options.initialDomains');
 	mod_assert.optionalNumber(options.tcpKeepAliveInitialDelay,
 	    'options.tcpKeepAliveInitialDelay');
 	mod_assert.optionalObject(options.log, 'options.log');
@@ -67,6 +69,13 @@ function CueBallAgent(options) {
 
 	mod_assert.optionalBool(options.errorOnEmpty, 'options.errorOnEmpty');
 	this.cba_errOnEmpty = options.errorOnEmpty;
+
+	if (options.initialDomains !== undefined) {
+		var self = this;
+		options.initialDomains.forEach(function (host) {
+			self.addPool(host, {});
+		});
+	}
 }
 mod_util.inherits(CueBallAgent, EventEmitter);
 
@@ -79,6 +88,77 @@ if (/^v0\.[0-9]\./.test(process.version) ||
 	USE_SECURECONNECT = true;
 }
 
+CueBallAgent.prototype.addPool = function (host, options) {
+	var self = this;
+	mod_assert.string(host, 'hostname');
+	var poolOpts = {
+		defaultPort: this.defaultPort,
+		resolvers: this.resolvers,
+		service: this.service,
+		domain: host,
+		constructor: constructSocket,
+		maximum: this.maximum,
+		spares: this.spares,
+		log: this.log,
+		recovery: this.cba_recovery
+	};
+	function constructSocket(backend) {
+		var opts = {
+			host: backend.address || backend.name,
+			port: backend.port || self.defaultPort,
+			servername: backend.name || host
+		};
+		PASS_FIELDS.forEach(function (k) {
+			if (options.hasOwnProperty(k))
+				opts[k] = options[k];
+		});
+		var nsock;
+		if (self.protocol === 'https:') {
+			nsock = mod_tls.connect(opts);
+			/*
+			 * In older versions of node, TLS sockets don't
+			 * quite obey the socket interface -- they emit
+			 * the event 'secureConnect' instead of
+			 * 'connect' and they don't support ref/unref.
+			 *
+			 * We polyfill these here.
+			 */
+			if (USE_SECURECONNECT) {
+				nsock.on('secureConnect',
+				    nsock.emit.bind(nsock, 'connect'));
+			}
+			if (nsock.unref === undefined) {
+				nsock.unref = function () {
+					nsock.socket.unref();
+				};
+				nsock.ref = function () {
+					nsock.socket.ref();
+				};
+			}
+		} else {
+			nsock = mod_net.createConnection(opts);
+		}
+		if (self.tcpKAID !== undefined) {
+			nsock.on('connect', function () {
+				if (USE_SECURECONNECT &&
+				    self.protocol === 'https:') {
+					nsock.socket.setKeepAlive(true,
+					    self.tcpKAID);
+				} else {
+					nsock.setKeepAlive(true,
+					    self.tcpKAID);
+				}
+			});
+		}
+		return (nsock);
+	}
+	if (this.cba_ping !== undefined) {
+		poolOpts.checkTimeout = this.cba_pingInterval || 30000;
+		poolOpts.checker = this.checkSocket.bind(this, host);
+	}
+	this.pools[host] = new Pool(poolOpts);
+};
+
 /*
  * Sets up a duplex stream to be used for the given HTTP request.
  * Calls req.onSocket(sock) with said stream once it is ready.
@@ -88,7 +168,6 @@ if (/^v0\.[0-9]\./.test(process.version) ||
  * believes the socket to be reuseable or not.
  */
 CueBallAgent.prototype.addRequest = function (req, optionsOrHost, port) {
-	var self = this;
 	var options;
 	mod_assert.object(req, 'req');
 	if (typeof (optionsOrHost) === 'string') {
@@ -102,72 +181,7 @@ CueBallAgent.prototype.addRequest = function (req, optionsOrHost, port) {
 	var host = options.host || options.hostname;
 	mod_assert.string(host, 'hostname');
 	if (this.pools[host] === undefined) {
-		var poolOpts = {
-			defaultPort: this.defaultPort,
-			resolvers: this.resolvers,
-			service: this.service,
-			domain: host,
-			constructor: constructSocket,
-			maximum: this.maximum,
-			spares: this.spares,
-			log: this.log,
-			recovery: this.cba_recovery
-		};
-		function constructSocket(backend) {
-			var opts = {
-				host: backend.address || backend.name,
-				port: backend.port || self.defaultPort,
-				servername: backend.name || host
-			};
-			PASS_FIELDS.forEach(function (k) {
-				if (options.hasOwnProperty(k))
-					opts[k] = options[k];
-			});
-			var nsock;
-			if (self.protocol === 'https:') {
-				nsock = mod_tls.connect(opts);
-				/*
-				 * In older versions of node, TLS sockets don't
-				 * quite obey the socket interface -- they emit
-				 * the event 'secureConnect' instead of
-				 * 'connect' and they don't support ref/unref.
-				 *
-				 * We polyfill these here.
-				 */
-				if (USE_SECURECONNECT) {
-					nsock.on('secureConnect',
-					    nsock.emit.bind(nsock, 'connect'));
-				}
-				if (nsock.unref === undefined) {
-					nsock.unref = function () {
-						nsock.socket.unref();
-					};
-					nsock.ref = function () {
-						nsock.socket.ref();
-					};
-				}
-			} else {
-				nsock = mod_net.createConnection(opts);
-			}
-			if (self.tcpKAID !== undefined) {
-				nsock.on('connect', function () {
-					if (USE_SECURECONNECT &&
-					    self.protocol === 'https:') {
-						nsock.socket.setKeepAlive(true,
-						    self.tcpKAID);
-					} else {
-						nsock.setKeepAlive(true,
-						    self.tcpKAID);
-					}
-				});
-			}
-			return (nsock);
-		}
-		if (this.cba_ping !== undefined) {
-			poolOpts.checkTimeout = this.cba_pingInterval || 30000;
-			poolOpts.checker = this.checkSocket.bind(this, host);
-		}
-		this.pools[host] = new Pool(poolOpts);
+		this.addPool(host, options);
 	}
 	var pool = this.pools[host];
 	var waiter, sock, conn;
diff --git a/package.json b/package.json
index f4bd49d..dde76ba 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "cueball",
-  "version": "1.0.3",
+  "version": "1.1.0",
   "description": "",
   "main": "lib/index.js",
   "dependencies": {
-- 
2.21.0

